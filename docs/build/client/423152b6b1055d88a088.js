var InkAPI = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // ../../node_modules/@stackpress/ink/dist/dom/Node.js
  var require_Node = __commonJS({
    "../../node_modules/@stackpress/ink/dist/dom/Node.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var Node2 = class {
        constructor() {
          this._parent = null;
        }
        get parent() {
          return this._parent;
        }
        get parentElement() {
          return this._parent;
        }
        set parent(parent) {
          this._parent = parent;
        }
      };
      exports.default = Node2;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/dom/Comment.js
  var require_Comment = __commonJS({
    "../../node_modules/@stackpress/ink/dist/dom/Comment.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Node_1 = __importDefault(require_Node());
      var Comment = class extends Node_1.default {
        get nodeName() {
          return this.name;
        }
        get nodeType() {
          return this.type;
        }
        constructor(value) {
          super();
          this.name = "#comment";
          this.type = 8;
          this.value = value;
        }
        export() {
          return {
            type: this.type,
            name: this.name,
            value: this.value
          };
        }
        toString() {
          return `<!--${this.value}-->`;
        }
      };
      exports.default = Comment;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/dom/Doctype.js
  var require_Doctype = __commonJS({
    "../../node_modules/@stackpress/ink/dist/dom/Doctype.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Node_1 = __importDefault(require_Node());
      var Doctype = class extends Node_1.default {
        get nodeName() {
          return this.name;
        }
        get nodeType() {
          return this.type;
        }
        constructor(value) {
          super();
          this.name = "#doctype";
          this.type = 10;
          this.value = value;
        }
        export() {
          return {
            type: this.type,
            name: this.name,
            value: this.value
          };
        }
        toString() {
          return `<!DOCTYPE ${this.value}>`;
        }
      };
      exports.default = Doctype;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/dom/Element.js
  var require_Element = __commonJS({
    "../../node_modules/@stackpress/ink/dist/dom/Element.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Node_1 = __importDefault(require_Node());
      var selfClosingTags = [
        "area",
        "base",
        "br",
        "col",
        "embed",
        "hr",
        "img",
        "input",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ];
      var Element2 = class _Element extends Node_1.default {
        get attributes() {
          return Object.fromEntries(this._attributes);
        }
        get childList() {
          return Array.from(this.children);
        }
        get elements() {
          return this.nodes.filter((node) => node instanceof _Element);
        }
        get nodeName() {
          return this.name.toUpperCase();
        }
        get nodes() {
          const nodes = [this];
          this._flatten(Array.from(this.children), nodes);
          return nodes;
        }
        get nodeType() {
          return this.type;
        }
        get parent() {
          return this._parent;
        }
        set parent(parent) {
          this._parent = parent;
        }
        constructor(name2, attributes = {}, children4 = []) {
          super();
          this.type = 1;
          this._parent = null;
          this.name = name2;
          this._attributes = new Map(Object.entries(attributes));
          this.children = new Set(children4.filter(Boolean));
        }
        appendChild(child) {
          this.children.add(child);
          child.parent = this;
          return this;
        }
        export() {
          return {
            type: this.type,
            name: this.name,
            attributes: Object.fromEntries(this._attributes.entries()),
            children: Array.from(this.children).map((child) => child.export())
          };
        }
        getAttribute(name2) {
          return this._attributes.get(name2);
        }
        hasAttribute(name2) {
          return this._attributes.has(name2);
        }
        removeAttribute(name2) {
          this._attributes.delete(name2);
          return this;
        }
        removeChild(child) {
          this.children.delete(child);
          child.parent = null;
          return;
        }
        setAttribute(name2, value) {
          this._attributes.set(name2, value);
          return this;
        }
        toString() {
          const entries = Array.from(this._attributes.entries());
          const attributes = entries.length > 0 ? " " + entries.map(([key, value]) => {
            if (typeof value === "string" && !/["<>\n]/.test(value)) {
              return `${key}="${value}"`;
            } else if (typeof value === "boolean") {
              return value ? key : "";
            }
          }).join(" ") : "";
          if (selfClosingTags.includes(this.name)) {
            return `<${this.name}${attributes} />`;
          }
          const children4 = Array.from(this.children.values()).map((child) => child.toString()).join("");
          return `<${this.name}${attributes}>${children4}</${this.name}>`;
        }
        _flatten(markup, nodes) {
          markup.forEach((node) => {
            nodes.push(node);
            if (node instanceof _Element) {
              this._flatten(Array.from(node.children), nodes);
            }
          });
        }
      };
      exports.default = Element2;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/dom/Text.js
  var require_Text = __commonJS({
    "../../node_modules/@stackpress/ink/dist/dom/Text.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Node_1 = __importDefault(require_Node());
      var Text = class extends Node_1.default {
        get nodeName() {
          return "#text";
        }
        get nodeType() {
          return this.type;
        }
        get value() {
          return this._escape ? this._value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") : this._value;
        }
        constructor(value, escape = false) {
          super();
          this.name = "#text";
          this.type = 3;
          this._escape = escape;
          this._value = value;
        }
        export() {
          return {
            type: this.type,
            name: this.name,
            value: this.value
          };
        }
        toString() {
          return this.value;
        }
      };
      exports.default = Text;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/dom/Document.js
  var require_Document = __commonJS({
    "../../node_modules/@stackpress/ink/dist/dom/Document.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Comment_1 = __importDefault(require_Comment());
      var Doctype_1 = __importDefault(require_Doctype());
      var Element_1 = __importDefault(require_Element());
      var Text_1 = __importDefault(require_Text());
      var Document = class _Document {
        static createComment(value, parent) {
          const node = new Comment_1.default(value);
          if (parent) {
            node.parent = parent;
          }
          return node;
        }
        static createDoctype(value = "html", parent) {
          const node = new Doctype_1.default(value);
          if (parent) {
            node.parent = parent;
          }
          return node;
        }
        static createElement(name2, attributes = {}, children4 = [], parent) {
          const element = new Element_1.default(name2, attributes, children4);
          if (parent) {
            element.parent = parent;
          }
          return element;
        }
        static createText(value, escape = false, parent) {
          const node = new Text_1.default(value, escape);
          if (parent) {
            node.parent = parent;
          }
          return node;
        }
        static import(data2, parent) {
          return data2.map((node) => {
            const { value } = node;
            const { name: name2, attributes, children: children4 } = node;
            switch (node.type) {
              case 1:
                const element = this.createElement(name2, attributes, [], parent);
                _Document.import(children4, element).forEach((child) => element.appendChild(child));
                return element;
              case 3:
                return this.createText(value, true, parent);
              case 8:
                return this.createComment(value, parent);
              case 10:
                return this.createDoctype(value, parent);
            }
            return null;
          }).filter(Boolean);
        }
        static load(children4) {
          return new _Document(children4);
        }
        get childList() {
          return Array.from(this.children);
        }
        get elements() {
          return this.nodes.filter((node) => node instanceof Element_1.default);
        }
        get nodes() {
          return Array.from(this.children).map((child) => child instanceof Element_1.default ? child.nodes : [child]).flat();
        }
        constructor(children4) {
          this.children = new Set(children4.filter(Boolean));
        }
        export() {
          return this.childList.map((child) => child.export());
        }
        toString() {
          return Array.from(this.children).map((child) => child.toString()).join("");
        }
      };
      exports.default = Document;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/data.js
  var require_data = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/data.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TemplateData = void 0;
      var TemplateData = class {
        constructor() {
          if (!window.__TEMPLATE_DATA__) {
            window.__TEMPLATE_DATA__ = {};
          }
        }
        clear() {
          window.__TEMPLATE_DATA__ = {};
          return this;
        }
        delete(key) {
          if (this.has(key)) {
            delete window.__TEMPLATE_DATA__[key];
            return true;
          }
          return false;
        }
        entries() {
          return Object.entries(window.__TEMPLATE_DATA__);
        }
        has(key) {
          return key in window.__TEMPLATE_DATA__;
        }
        get(key) {
          return window.__TEMPLATE_DATA__[key];
        }
        keys() {
          return Object.keys(window.__TEMPLATE_DATA__);
        }
        set(key, value) {
          window.__TEMPLATE_DATA__[key] = value;
          return this;
        }
        values() {
          return Object.values(window.__TEMPLATE_DATA__);
        }
      };
      exports.TemplateData = TemplateData;
      var data2 = new TemplateData();
      exports.default = data2;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/Emitter.js
  var require_Emitter = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/Emitter.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.match = exports.ClientEmitter = exports.events = void 0;
      exports.bindAttribute = bindAttribute;
      exports.unbindAttribute = unbindAttribute;
      var Registry_1 = __importDefault(require_Registry());
      exports.events = [
        "click",
        "dblclick",
        "mousedown",
        "mouseup",
        "mousemove",
        "mouseover",
        "mouseout",
        "wheel",
        "keydown",
        "keypress",
        "keyup",
        "blur",
        "change",
        "contextmenu",
        "focus",
        "input",
        "submit",
        "invalid",
        "reset",
        "search",
        "select",
        "copy",
        "cut",
        "paste",
        "drag",
        "dragstart",
        "dragend",
        "dragover",
        "dragenter",
        "dragleave",
        "drop",
        "scroll",
        "durationchange",
        "ended",
        "error",
        "loadeddata",
        "loadedmetadata",
        "loadstart",
        "pause",
        "play",
        "playing",
        "progress",
        "ratechange",
        "seeked",
        "seeking",
        "stalled",
        "suspend",
        "timeupdate",
        "volumechange",
        "waiting",
        "animationstart",
        "animationend",
        "animationiteration",
        "transitionend",
        "toggle"
      ];
      var ClientEmitter = class extends EventTarget {
        emit(event, target) {
          this.dispatchEvent(new CustomEvent(event, { detail: target }));
          return this;
        }
        on(event, callback) {
          if (event === "ready") {
            if (document.readyState !== "loading") {
              const event2 = new CustomEvent("ready");
              setTimeout(() => callback(event2), 1);
              return this;
            }
          }
          this.addEventListener(event, callback);
          return this;
        }
        once(event, callback) {
          const unbinder = (e) => {
            this.unbind(event, unbinder);
            callback(e);
          };
          this.on(event, unbinder);
          return this;
        }
        unbind(event, callback) {
          this.removeEventListener(event, callback);
          return this;
        }
      };
      exports.ClientEmitter = ClientEmitter;
      var match = (element, attribute, bind = true) => {
        return Array.from(element.querySelectorAll("*")).filter((element2) => {
          const node = Registry_1.default.get(element2);
          const matched = node && node.hasAttribute(attribute) && (!bind || !node.hasEvent(attribute));
          if (matched) {
            node.addEvent(attribute);
          }
          return matched;
        }).map((element2) => Registry_1.default.get(element2));
      };
      exports.match = match;
      function bindAttribute(name2, bind) {
        emitter2.on("mounted", (e) => {
          if (!e.detail)
            return;
          const element = e.detail;
          (0, exports.match)(element.shadowRoot || element, name2).forEach(bind);
        });
      }
      function unbindAttribute(name2, bind) {
        emitter2.on("unmounted", (e) => {
          if (!e.detail)
            return;
          const element = e.detail;
          (0, exports.match)(element.shadowRoot || element, name2, false).forEach(bind);
        });
      }
      var emitter2 = new ClientEmitter();
      exports.default = (() => {
        document.onreadystatechange = () => {
          if (document.readyState !== "loading") {
            emitter2.emit("ready");
          }
        };
        bindAttribute("mount", (element) => {
          const callback = element.getAttribute("mount");
          if (typeof callback === "function") {
            const event = new CustomEvent("mount", {
              detail: {
                node: element,
                target: element.element
              }
            });
            callback(event);
          }
        });
        unbindAttribute("unmount", (element) => {
          const callback = element.getAttribute("unmount");
          if (typeof callback === "function") {
            const event = new CustomEvent("unmount", {
              detail: {
                node: element,
                target: element.element
              }
            });
            callback(event);
          }
        });
        bindAttribute("if", (element) => {
          const condition = element.getAttribute("if");
          if (condition === false || condition === "false") {
            element.element.remove();
          } else if (typeof condition === "function" && !condition()) {
            element.element.remove();
          }
        });
        exports.events.forEach((event) => {
          bindAttribute(event, (element) => {
            const callback = element.getAttribute(event);
            if (typeof callback === "function") {
              element.element.removeEventListener(event, callback);
              element.element.addEventListener(event, callback);
            }
          });
          unbindAttribute(event, (element) => {
            const callback = element.getAttribute(event);
            if (typeof callback === "function") {
              element.element.removeEventListener(event, callback);
            }
          });
        });
        return emitter2;
      })();
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/Element.js
  var require_Element2 = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/Element.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Emitter_1 = __importDefault(require_Emitter());
      var ClientElement = class {
        get attributes() {
          return Object.assign({}, this._attributes);
        }
        get element() {
          return this._element;
        }
        get events() {
          return this._events;
        }
        constructor(element, attributes) {
          this._events = /* @__PURE__ */ new Set();
          this._element = element;
          this._attributes = attributes;
        }
        addEvent(event) {
          this._events.add(event);
          return this;
        }
        camel() {
          return Object.fromEntries(Object.entries(this._attributes).map(([key, value]) => {
            if (key === "class") {
              return ["className", value];
            }
            const camel = key.replace(/-([a-z])/g, (_2, letter) => letter.toUpperCase()).replaceAll("-", "");
            return [camel, value];
          }));
        }
        getAttribute(key) {
          return this._attributes[key];
        }
        hasAttribute(key) {
          return key in this._attributes;
        }
        hasEvent(event) {
          return this._events.has(event);
        }
        removeAttribute(key, silent = false) {
          const current = this.getAttribute(key);
          if (typeof current === "undefined") {
            return this;
          }
          delete this._attributes[key];
          if (!silent) {
            Emitter_1.default.emit("attribute-remove", {
              element: this,
              key,
              previous: current
            });
          }
          return this;
        }
        setAttribute(key, value, silent = false) {
          if (typeof value === "undefined") {
            return this.removeAttribute(key, silent);
          }
          const current = this.getAttribute(key);
          if (current === value) {
            return this;
          }
          this._attributes[key] = value;
          if (!silent) {
            if (typeof current === "undefined") {
              Emitter_1.default.emit("attribute-create", { element: this, key, value });
            } else {
              Emitter_1.default.emit("attribute-update", {
                element: this,
                key,
                value,
                previous: current
              });
            }
          }
          return this;
        }
        setAttributes(attributes, silent = false) {
          for (const [key, value] of Object.entries(attributes)) {
            this.setAttribute(key, value, silent);
          }
          const names = Object.keys(attributes);
          for (const key of Object.keys(this._attributes)) {
            if (!names.includes(key)) {
              this.removeAttribute(key, silent);
            }
          }
          return this;
        }
        tree(attributes, name2, value) {
          if (!attributes) {
            attributes = Object.assign({}, this._attributes);
          }
          if (name2) {
            const path = name2.split("-");
            if (path.length > 0) {
              const key = path.shift();
              if (path.length > 0) {
                if (!attributes[key])
                  attributes[key] = {};
                this.tree(attributes[key], path.join("-"), value);
              } else {
                attributes[key] = value;
              }
            }
            return attributes;
          }
          const branch = {};
          for (const [name3, value2] of Object.entries(attributes)) {
            this.tree(branch, name3, value2);
          }
          return branch;
        }
      };
      exports.default = ClientElement;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/client.js
  var require_client = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/client.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = () => window.InkAPI;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/Registry.js
  var require_Registry = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/Registry.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Element_1 = __importDefault(require_Element2());
      var client_1 = __importDefault(require_client());
      var decoder = document.createElement("textarea");
      var decode = (value) => {
        decoder.innerHTML = value;
        return decoder.value;
      };
      var ClientRegistry18 = class _ClientRegistry {
        static get elements() {
          return this._elements;
        }
        static createComponent(tagname, definition, attributes = {}, children4 = []) {
          var _a;
          const { registered } = definition;
          if (!registered && !((_a = (0, client_1.default)()) === null || _a === void 0 ? void 0 : _a.elements[tagname])) {
            return this.createVirtualComponent(tagname, definition, attributes, children4);
          }
          const name2 = registered || tagname;
          const component4 = document.createElement(name2);
          customElements.whenDefined(name2).then(() => {
            customElements.upgrade(component4);
            if (!component4.initiated) {
              component4.connectedCallback();
            }
          });
          const element = _ClientRegistry.register(component4, attributes);
          element.setAttributes(attributes, true);
          for (const [name3, value] of Object.entries(attributes)) {
            if (typeof value === "string") {
              component4.setAttribute(name3, value);
            } else if (value === true) {
              component4.setAttribute(name3, "");
            }
          }
          this._cleanChildren(children4).forEach((child) => component4.appendChild(child));
          return element;
        }
        static createElement(name2, attributes = {}, children4 = []) {
          const element = document.createElement(name2);
          for (const [name3, value] of Object.entries(attributes)) {
            if (typeof value === "string") {
              element.setAttribute(name3, value);
            } else if (value === true) {
              element.setAttribute(name3, "");
            }
          }
          this._cleanChildren(children4).forEach((child) => element.appendChild(child));
          return this.register(element, attributes);
        }
        static createText(value, escape = true) {
          return document.createTextNode(decode(value));
        }
        static createVirtualComponent(tagname, definition, attributes = {}, children4 = []) {
          const component4 = document.createElement(tagname);
          component4.definition = definition;
          Object.setPrototypeOf(component4, definition.prototype);
          component4.constructor = definition.constructor;
          component4.constructor.id = definition.id;
          component4.constructor.tagname = definition.tagname;
          component4.constructor.classname = definition.classname;
          if (definition.observedAttributes) {
            component4.constructor.observedAttributes = definition.observedAttributes;
          }
          component4.register(attributes, children4);
          return component4.element;
        }
        static cloneElement(node, andChildren = false) {
          var _a;
          const component4 = node;
          if (component4.definition) {
            const children4 = component4.originalChildren || [];
            return this.createComponent(component4.nodeName.toLowerCase(), component4.definition, component4.props || {}, andChildren ? children4.map((element) => this.cloneElement(element, andChildren)) : []).element;
          } else if (node instanceof HTMLElement) {
            const children4 = Array.from(node.childNodes);
            return this.createElement(node.nodeName.toLowerCase(), this.has(node) ? (_a = this.get(node)) === null || _a === void 0 ? void 0 : _a.attributes : Object.fromEntries(Array.from(node.attributes).map((attribute) => [attribute.name, attribute.value])), andChildren ? children4.map((element) => this.cloneElement(element, andChildren)) : []).element;
          }
          return node.cloneNode(andChildren);
        }
        static filter(callback) {
          const elements2 = [];
          this._elements.forEach((ink, html) => {
            if (callback(ink, html)) {
              elements2.push(ink);
            }
          });
          return elements2;
        }
        static get(element) {
          return this._elements.get(element) || null;
        }
        static has(element) {
          return this._elements.has(element);
        }
        static map(callback) {
          const elements2 = [];
          this._elements.forEach((ink, html) => {
            elements2.push(callback(ink, html));
          });
          return elements2;
        }
        static register(element, attributes, andChildren = false) {
          if (this.has(element)) {
            return this.get(element);
          }
          if (!attributes) {
            Array.from(element.attributes).forEach((attribute) => {
              attributes = attributes || {};
              attributes[attribute.name] = attribute.value !== "" ? attribute.value : true;
            });
          }
          const node = new Element_1.default(element, attributes || {});
          this._elements.set(element, node);
          if (andChildren) {
            Array.from(element.children).forEach((child) => {
              if (child instanceof Element) {
                this.register(child, void 0, true);
              }
            });
          }
          return node;
        }
        static _cleanChildren(children4) {
          return Array.from(children4).filter((child) => typeof child !== "undefined").map((child) => typeof child === "string" ? this.createText(child) : child instanceof Element_1.default ? child.element : child);
        }
      };
      ClientRegistry18._elements = /* @__PURE__ */ new Map();
      exports.default = ClientRegistry18;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/Document.js
  var require_Document2 = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/Document.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Document_1 = __importDefault(require_Document());
      var data_1 = __importDefault(require_data());
      var Registry_1 = __importDefault(require_Registry());
      var ClientDocument2 = class {
        constructor() {
          const template = document.querySelector("script[data-template]");
          if (!template) {
            throw new Error("TEMPLATE_DATA not found");
          }
          try {
            window.__TEMPLATE_DATA__ = JSON.parse(template.innerText.trim());
            Object.entries(window.__TEMPLATE_DATA__).forEach(([key, value]) => {
              data_1.default.set(key, value);
            });
          } catch (error) {
            throw new Error("TEMPLATE_DATA is not a valid JSON");
          }
        }
        bindings() {
          data_1.default.set("current", "document");
          const markup = this.template();
          data_1.default.delete("current");
          const sequence = Document_1.default.load(markup).elements;
          const entries = Array.from(sequence).map((el, id) => [String(id), el.attributes]).filter((entry) => Object.keys(entry[1]).length);
          return Object.fromEntries(entries);
        }
        sync() {
          const bindings = this.bindings();
          const map = Array.from(document.querySelectorAll("*"));
          for (const element of map) {
            const attributes = Object.fromEntries(Array.from(element.attributes).map((attribute) => [
              attribute.nodeName,
              attribute.nodeValue && attribute.nodeValue.length > 0 ? attribute.nodeValue : true
            ]));
            const id = String(Registry_1.default.elements.size);
            if (bindings[id]) {
              Object.assign(attributes, bindings[id]);
            }
            Registry_1.default.register(element, attributes);
          }
          return bindings;
        }
        _toNodeList(value) {
          if (typeof value === "object" && typeof value.nodeType === "number") {
            return [value];
          }
          if (Array.isArray(value)) {
            if (value.every((item) => typeof item === "object" && typeof item.nodeType === "number")) {
              return value;
            }
          }
          return [Registry_1.default.createText(String(value))];
        }
      };
      exports.default = ClientDocument2;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/Component.js
  var require_Component = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/Component.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Element_1 = __importDefault(require_Element2());
      var Registry_1 = __importDefault(require_Registry());
      var Emitter_1 = __importDefault(require_Emitter());
      var data_1 = __importDefault(require_data());
      var ClientComponent17 = class _ClientComponent extends HTMLElement {
        static get registered() {
          return customElements.getName(this);
        }
        static register() {
          customElements.define(this.tagname, this);
        }
        get attr() {
          return Object.fromEntries(Array.from(this.attributes).map((attr) => [attr.name, attr.value]));
        }
        get definition() {
          return this._definition || this.constructor;
        }
        get element() {
          if (!Registry_1.default.has(this)) {
            throw new Error(`Component ${this.metadata.classname} not mapped.`);
          }
          return Registry_1.default.get(this);
        }
        get initiated() {
          return this._initiated;
        }
        get metadata() {
          const { id, classname, tagname, registered, observedAttributes: observed = [] } = this.definition;
          return {
            id,
            tagname,
            classname,
            registered,
            observed
          };
        }
        get originalChildren() {
          return this._children;
        }
        get props() {
          return this.getAttributes();
        }
        get propsCamel() {
          return this.element.camel();
        }
        get propsTree() {
          return this.element.tree();
        }
        get virtual() {
          return this._virtual;
        }
        set props(props3) {
          this.setAttributes(props3);
        }
        set definition(definition) {
          this._definition = definition;
        }
        set originalChildren(children4) {
          if (typeof this._children === "undefined") {
            this._children = this._cleanChildren(children4 || []);
          }
        }
        constructor() {
          super();
          this._children = void 0;
          this._definition = null;
          this._initiated = false;
          this._observer = null;
          this._rendering = false;
          this._template = null;
          this._virtual = false;
          if (!Registry_1.default.has(this)) {
            const { registered } = this.metadata;
            if (!registered) {
              throw new Error(`Component ${this.metadata.classname} not registered in customElements.`);
            }
            const attributes = Object.fromEntries(Array.from(this.attributes).map((attr) => [attr.name, attr.value !== "" ? attr.value : true]));
            Registry_1.default.register(this, attributes);
          }
        }
        adoptedCallback() {
          this.render();
          this.emit("adopt", this);
        }
        attributeChangedCallback(name2, prev, next) {
          if (this._rendering) {
            return;
          }
          const action = prev === null ? "add" : next === null ? "remove" : "update";
          if (next === null && this.hasAttribute(name2)) {
            this.element.removeAttribute(name2);
          } else if (next === "") {
            this.element.setAttribute(name2, true);
          } else {
            this.element.setAttribute(name2, next);
          }
          this.emit("attributechange", { action, name: name2, prev, value: next, target: this });
        }
        clone(andChildren = false) {
          return this.cloneElement(this, andChildren);
        }
        cloneElement(element, andChildren = false) {
          return Registry_1.default.cloneElement(element, andChildren);
        }
        connectedCallback() {
          this.wait();
          this.emit("connect", this);
        }
        createComponent(tagname, definition, attributes = {}, children4 = []) {
          return Registry_1.default.createComponent(tagname, definition, attributes, children4);
        }
        createElement(name2, attributes = {}, children4 = []) {
          return Registry_1.default.createElement(name2, attributes, children4);
        }
        disconnectedCallback() {
          this.emit("disconnect", this);
        }
        emit(event, detail) {
          this.dispatchEvent(new CustomEvent(event, { detail }));
          return this;
        }
        getAttribute(name2) {
          return this.element.getAttribute(name2);
        }
        getAttributes() {
          return Object.assign({}, this.element.attributes);
        }
        getChildren(type = true) {
          if (type === true) {
            return Array.from(this.childNodes);
          } else if (type === false) {
            return this._children;
          } else if (type === null && this.shadowRoot) {
            return Array.from(this.shadowRoot.childNodes);
          }
          return [];
        }
        getElement(element) {
          return Registry_1.default.get(element);
        }
        getParentComponent() {
          let parent = this.parentElement;
          while (parent) {
            if (parent instanceof _ClientComponent) {
              return parent;
            }
            parent = parent.parentElement;
          }
          return null;
        }
        hasAttribute(name2) {
          return this.element.hasAttribute(name2);
        }
        on(event, callback) {
          this.removeEventListener(event, callback);
          this.addEventListener(event, callback);
          return this;
        }
        once(event, callback) {
          const unbinder = (e) => {
            this.removeEventListener(event, callback);
            callback(e);
          };
          this.on(event, unbinder);
          return this;
        }
        register(attributes = {}, children4 = []) {
          if (Registry_1.default.has(this)) {
            const element = Registry_1.default.get(this);
            element.setAttributes(attributes);
          } else {
            Registry_1.default.register(this, attributes);
          }
          for (const [name2, value] of Object.entries(attributes)) {
            if (typeof value === "string" || value === true) {
              super.setAttribute(name2, value === "" || value === name2 || value === true ? true : value);
            }
          }
          this._children = this._cleanChildren(children4);
          this._children.forEach((child) => this.appendChild(child));
          this._virtual = true;
          this.connectedCallback();
        }
        removeAttribute(name2) {
          const prev = this.getAttribute(name2);
          if (this.hasAttribute(name2)) {
            this.element.removeAttribute(name2);
          }
          if (super.hasAttribute(name2)) {
            super.removeAttribute(name2);
          }
          if (this._virtual && this.metadata.observed.includes(name2)) {
            this.attributeChangedCallback(name2, prev, null);
          }
        }
        render() {
          const parent = this.getParentComponent();
          if (parent && !parent.initiated) {
            return;
          } else if (this._rendering) {
            return;
          }
          this._rendering = true;
          const prev = data_1.default.get("current");
          data_1.default.set("current", this);
          if (!this._template) {
            this._template = this.template();
          } else {
            Emitter_1.default.emit("unmounted", this);
          }
          const children4 = this._template().filter(Boolean);
          const styles = this.styles();
          const mode = styles.length === 0 ? "light" : "shadow";
          const { light, shadow } = this._getChildren(children4, mode);
          if (shadow.length === 0 && mode === "light") {
            this.textContent = "";
            light.forEach((child) => this.appendChild(child));
          } else {
            if (!this.shadowRoot) {
              this.attachShadow({ mode: "open", delegatesFocus: true });
            }
            const style = document.createElement("style");
            style.innerText = styles;
            const shadowRoot = this.shadowRoot;
            shadowRoot.textContent = "";
            shadowRoot.appendChild(style);
            shadow.forEach((child) => shadowRoot.appendChild(child));
            if (light.length) {
              this.textContent = "";
              light.forEach((child) => this.appendChild(child));
            }
          }
          if (prev) {
            data_1.default.set("current", prev);
          } else {
            data_1.default.delete("current");
          }
          this._initiated = true;
          this._rendering = false;
          Emitter_1.default.emit("mounted", this);
          return this.shadowRoot ? this.shadowRoot.innerHTML : this.innerHTML;
        }
        setAttribute(name2, value) {
          const prev = this.getAttribute(name2);
          if (value === "" || value === true) {
            this.element.setAttribute(name2, true);
            super.setAttribute(name2, "");
          } else if (value === false) {
            this.element.setAttribute(name2, value);
            super.removeAttribute(name2);
          } else if (typeof value === "string") {
            this.element.setAttribute(name2, value);
            super.setAttribute(name2, value);
          } else {
            this.element.setAttribute(name2, value);
          }
          if (this._virtual && this.metadata.observed.includes(name2) && typeof value === "string") {
            this.attributeChangedCallback(name2, prev, value);
          }
        }
        setAttributes(attributes) {
          Object.entries(attributes).forEach(([key, value]) => this.setAttribute(key, value));
        }
        unbind(event, callback) {
          this.removeEventListener(event, callback);
          return this;
        }
        wait() {
          if (document.readyState !== "loading") {
            this._update();
          } else {
            const next = () => {
              this._update();
              Emitter_1.default.unbind("ready", next);
            };
            Emitter_1.default.on("ready", next);
          }
        }
        _cleanChildren(children4) {
          return Array.from(children4).filter((child) => typeof child !== "undefined").map((child) => typeof child === "string" ? Registry_1.default.createText(child) : child instanceof Element_1.default ? child.element : child);
        }
        _getChildren(children4, mode) {
          const anyNodes = this._getTemplateNodes(children4);
          const lightNodes = this._getTemplateNodes(children4, "light");
          const shadowNodes = this._getTemplateNodes(children4, "shadow");
          const defaultNodes = anyNodes.length > 0 ? anyNodes : children4;
          return {
            light: lightNodes.length > 0 ? lightNodes : mode === "light" ? defaultNodes : [],
            shadow: shadowNodes.length > 0 ? shadowNodes : mode === "shadow" ? defaultNodes : []
          };
        }
        _getTemplateNodes(children4, type) {
          const template = children4.find((child) => this._isTemplate(child, type));
          if (!template)
            return [];
          return Array.from(template.childNodes || []);
        }
        _isTemplate(child, type) {
          if (child.nodeName !== "TEMPLATE")
            return false;
          const template = child;
          if (!type)
            return !template.hasAttribute("type");
          return type === template.getAttribute("type");
        }
        _toNodeList(value) {
          if (value instanceof Node) {
            return [value];
          }
          if (Array.isArray(value)) {
            if (value.every((item) => item instanceof Node)) {
              return value;
            }
          }
          return [Registry_1.default.createText(String(value))];
        }
        _update() {
          if (typeof this._children === "undefined") {
            this._children = this._cleanChildren(Array.from(this.childNodes || []));
          }
          if (!this._initiated) {
            this.render();
          }
        }
      };
      exports.default = ClientComponent17;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/Field.js
  var require_Field = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/Field.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Component_1 = __importDefault(require_Component());
      var ClientField = class extends Component_1.default {
        get field() {
          return this._field;
        }
        constructor() {
          super();
          this._field = this.attachInternals();
        }
        formAssociatedCallback(form) {
          this.emit("formassociate", this);
        }
        formDisabledCallback(disabled) {
          this.emit("formdisable", this);
        }
        formResetCallback() {
          this.emit("formreset", this);
        }
      };
      ClientField.formAssociated = true;
      exports.default = ClientField;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/component.js
  var require_component = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/component.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = component4;
      var data_1 = __importDefault(require_data());
      function component4(component5 = null, nullable = false) {
        if (!component5) {
          component5 = data_1.default.get("current");
          if (!component5) {
            if (!nullable) {
              throw new Error("Not called within a Ink component");
            }
            return null;
          }
        }
        return component5;
      }
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/env.js
  var require_env = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/env.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var data_1 = __importDefault(require_data());
      function env2(name2) {
        const env3 = data_1.default.get("env") || {};
        if (name2) {
          return env3[name2] || null;
        }
        return env3;
      }
      exports.default = env2;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/props.js
  var require_props = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/props.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = props3;
      var component_1 = __importDefault(require_component());
      var data_1 = __importDefault(require_data());
      function props3(pointer = null) {
        const component4 = (0, component_1.default)(pointer, true);
        if (typeof component4 === "string") {
          return data_1.default.get("props") || {};
        }
        return component4 ? component4.props : {};
      }
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/classnames.js
  var require_classnames = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/classnames.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.classlist = classlist2;
      exports.default = classnames;
      var component_1 = __importDefault(require_component());
      var props_1 = __importDefault(require_props());
      function classlist2(pointer = null) {
        var _a;
        if (pointer === "body") {
          return document.body.classList;
        } else if (pointer === "head") {
          return document.head.classList;
        } else if (pointer === "document") {
          return (_a = document.body.parentElement) === null || _a === void 0 ? void 0 : _a.classList;
        }
        const component4 = (0, component_1.default)(pointer);
        return component4 === null || component4 === void 0 ? void 0 : component4.classList;
      }
      function classnames(pointer = null) {
        return (0, props_1.default)(pointer)["class"] || "";
      }
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/children.js
  var require_children = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/children.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.innerHTML = innerHTML;
      exports.innerText = innerText;
      exports.default = children4;
      var component_1 = __importDefault(require_component());
      function innerHTML(pointer = null) {
        const inner = children4(pointer);
        const wrapper = document.createElement("template");
        wrapper.append(...inner.map((child) => child.cloneNode(true)));
        return wrapper.innerHTML;
      }
      function innerText(pointer = null) {
        const inner = children4(pointer);
        const wrapper = document.createElement("template");
        wrapper.append(...inner.map((child) => child.cloneNode(true)));
        return wrapper.innerText;
      }
      function children4(pointer = null) {
        const component4 = (0, component_1.default)(pointer, true);
        return typeof component4 !== "string" && component4 ? component4.originalChildren || [] : [];
      }
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/signal.js
  var require_signal = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/signal.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SignalRegistry = void 0;
      exports.default = signal;
      var component_1 = __importDefault(require_component());
      var SignalRegistry = class _SignalRegistry {
        static observe(component4, value) {
          const methods = {
            getter: () => property.raw,
            setter: (value2) => value2
          };
          const listeners = /* @__PURE__ */ new Set();
          const property = {
            raw: value,
            change(callback) {
              listeners.add(callback);
              return property;
            },
            getter(callback) {
              methods.getter = callback;
              return property;
            },
            setter(callback) {
              methods.setter = callback;
              return property;
            }
          };
          Object.defineProperty(property, "value", {
            get() {
              return methods.getter();
            },
            set(value2) {
              const formatted = methods.setter(value2);
              const rerender = _SignalRegistry.serialize(formatted) !== _SignalRegistry.serialize(property.raw);
              property.raw = formatted;
              if (rerender) {
                listeners.forEach((listener) => listener(formatted));
                component4.render();
              }
            }
          });
          const observer = this._observers.get(component4);
          if (!observer) {
            this._observers.set(component4, {
              observed: 1,
              values: [property]
            });
          } else {
            observer.observed++;
            observer.values.push(property);
          }
          return property;
        }
        static observer(component4) {
          return this._observers.get(component4) || null;
        }
        static serialize(value) {
          return JSON.stringify(value);
        }
      };
      exports.SignalRegistry = SignalRegistry;
      SignalRegistry._observers = /* @__PURE__ */ new Map();
      function signal(value, pointer = null) {
        const component4 = (0, component_1.default)(pointer);
        if (!component4.initiated) {
          return SignalRegistry.observe(component4, value);
        }
        const observer = SignalRegistry.observer(component4);
        if (!observer) {
          throw new Error("Signal state mismatch");
        }
        const values = observer.values;
        return values[observer.observed++ % observer.values.length];
      }
    }
  });

  // ../../node_modules/@stackpress/ink/dist/style/StyleMap.js
  var require_StyleMap = __commonJS({
    "../../node_modules/@stackpress/ink/dist/style/StyleMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stylemap = stylemap;
      function stylemap(styles = {}) {
        return new StyleMap(Object.entries(styles));
      }
      var StyleMap = class _StyleMap extends Map {
        add(property, values) {
          if (!this.has(property)) {
            this.set(property, []);
          }
          const styles = this.get(property);
          if (typeof values === "string" || typeof values === "number") {
            styles.push(values);
          } else if (Array.isArray(values)) {
            styles.push(...values);
          }
          return this;
        }
        clone() {
          const stylemap2 = new _StyleMap();
          for (const [key, values] of this.entries()) {
            stylemap2.set(key, values.slice());
          }
          return stylemap2;
        }
        replaceAll(search, replace) {
          for (const [key, values] of this.entries()) {
            this.set(key, values.map((value) => {
              if (typeof value === "string") {
                return value.replaceAll(search, replace);
              }
              return value;
            }));
          }
          return this;
        }
      };
      exports.default = StyleMap;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/style/StyleSet.js
  var require_StyleSet = __commonJS({
    "../../node_modules/@stackpress/ink/dist/style/StyleSet.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.styleset = styleset;
      var StyleMap_1 = __importDefault(require_StyleMap());
      function styleset(styles = {}) {
        return new StyleSet12(Object.entries(styles));
      }
      var StyleSet12 = class extends Map {
        add(selector, property, values) {
          if (!this.has(selector)) {
            this.set(selector, new StyleMap_1.default());
          }
          const styles = this.get(selector);
          if (typeof values === "string") {
            styles.set(property, values.split(" "));
          } else if (Array.isArray(values)) {
            styles.set(property, values);
          }
          return this;
        }
        map(selector, map) {
          this.set(selector, map);
          return this;
        }
        toString() {
          const styleset2 = [];
          for (const [selector, styles] of this.entries()) {
            const definitions = [];
            for (const [property, values] of styles.entries()) {
              if (property && (values === null || values === void 0 ? void 0 : values.length)) {
                definitions.push(`${property}:${values.join(" ")}`);
              }
            }
            if (definitions.length) {
              styleset2.push(`${selector}{${definitions.join(";")}}`);
            }
          }
          return styleset2.join("");
        }
      };
      exports.default = StyleSet12;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/style/StyleSheet.js
  var require_StyleSheet = __commonJS({
    "../../node_modules/@stackpress/ink/dist/style/StyleSheet.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.breakpoints = void 0;
      exports.stylesheet = stylesheet;
      var StyleSet_1 = __importDefault(require_StyleSet());
      exports.breakpoints = {
        all: 0,
        xl4: 1920,
        xl3: 1536,
        xl2: 1280,
        xl: 1024,
        lg: 992,
        md: 767,
        sm: 420,
        xs: 360
      };
      function stylesheet() {
        return new StyleSheet();
      }
      var StyleSheet = class extends Map {
        add(media, selector, property, values) {
          if (!this.has(media)) {
            this.set(media, new StyleSet_1.default());
          }
          const styleset = this.get(media);
          styleset.add(selector, property, values);
          return this;
        }
        map(media, selector, map) {
          if (!this.has(media)) {
            this.set(media, new StyleSet_1.default());
          }
          const styleset = this.get(media);
          styleset.map(selector, map);
          return this;
        }
        toString() {
          var _a;
          const stylesheet2 = [];
          for (const [media, breakpoint] of Object.entries(exports.breakpoints)) {
            const styles = (_a = this.get(media)) === null || _a === void 0 ? void 0 : _a.toString();
            if (!styles) {
              continue;
            }
            if (media === "all") {
              stylesheet2.push(styles);
              continue;
            }
            stylesheet2.push(`@media (max-width:${breakpoint}px){${styles}}`);
          }
          return stylesheet2.join("");
        }
      };
      exports.default = StyleSheet;
    }
  });

  // ../../node_modules/@stackpress/lib/dist/Status.js
  var require_Status = __commonJS({
    "../../node_modules/@stackpress/lib/dist/Status.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getStatus = getStatus;
      var statuses = {
        CONTINUE: { code: 100, status: "Continue" },
        PROCESSING: { code: 102, status: "Processing" },
        OK: { code: 200, status: "OK" },
        CREATED: { code: 201, status: "Created" },
        ACCEPTED: { code: 202, status: "Accepted" },
        EMPTY: { code: 204, status: "No Content" },
        RESET: { code: 205, status: "Reset Content" },
        PARTIAL: { code: 206, status: "Partial Content" },
        MOVED: { code: 301, status: "Moved Permanently" },
        FOUND: { code: 302, status: "Found" },
        REDIRECT: { code: 303, status: "See Other" },
        CACHE: { code: 304, status: "Not Modified" },
        TEMPORARY: { code: 307, status: "Temporary Redirect" },
        PERMANENT: { code: 308, status: "Permanent Redirect" },
        ABORT: { code: 309, status: "Aborted" },
        BAD_REQUEST: { code: 400, status: "Bad Request" },
        UNAUTHORIZED: { code: 401, status: "Unauthorized" },
        FORBIDDEN: { code: 403, status: "Forbidden" },
        NOT_FOUND: { code: 404, status: "Not Found" },
        BAD_METHOD: { code: 405, status: "Method Not Allowed" },
        NOT_ACCEPTABLE: { code: 406, status: "Not Acceptable" },
        REQUEST_TIMEOUT: { code: 408, status: "Request Timeout" },
        CONFLICT: { code: 409, status: "Conflict" },
        GONE: { code: 410, status: "Gone" },
        LENGTH_REQUIRED: { code: 411, status: "Length Required" },
        TOO_LARGE: { code: 413, status: "Payload Too Large" },
        TOO_LONG: { code: 414, status: "URI Too Long" },
        UNSUPPORTED_TYPE: { code: 415, status: "Unsupported Media Type" },
        BAD_RANGE: { code: 416, status: "Range Not Satisfiable" },
        BAD_EXPECTATION: { code: 417, status: "Expectation Failed" },
        MISDIRECTED: { code: 421, status: "Misdirected Request" },
        UNPROCESSABLE: { code: 422, status: "Unprocessable Content" },
        LOCKED: { code: 423, status: "Locked" },
        BAD_DEPENDENCY: { code: 424, status: "Failed Dependency" },
        UPGRADE_REQUIRED: { code: 426, status: "Upgrade Required" },
        BAD_PRECONDITION: { code: 428, status: "Precondition Required" },
        TOO_MANY: { code: 429, status: "Too Many Requests" },
        HEADER_TOO_LARGE: { code: 431, status: "Request Header Fields Too Large" },
        LEGAL_REASONS: { code: 451, status: "Unavailable For Legal Reasons" },
        ERROR: { code: 500, status: "Internal Server Error" },
        NOT_IMPLEMENTED: { code: 501, status: "Not Implemented" },
        BAD_GATEWAY: { code: 502, status: "Bad Gateway" },
        UNAVAILABLE: { code: 503, status: "Service Unavailable" },
        RESPONSE_TIMEOUT: { code: 504, status: "Gateway Timeout" },
        BAD_VERSION: { code: 505, status: "HTTP Version Not Supported" },
        INSUFFICIENT_STORAGE: { code: 507, status: "Insufficient Storage" },
        INFINITE_LOOP: { code: 508, status: "Loop Detected" },
        NETWORK_AUTHENTICATION_REQUIRED: { code: 511, status: "Network Authentication Required" }
      };
      exports.default = statuses;
      function getStatus(code) {
        return Object.values(statuses).find((status) => status.code === code);
      }
    }
  });

  // ../../node_modules/@stackpress/lib/dist/Exception.js
  var require_Exception = __commonJS({
    "../../node_modules/@stackpress/lib/dist/Exception.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var Status_1 = require_Status();
      var Exception = class _Exception extends Error {
        static for(message, ...values) {
          values.forEach(function(value) {
            message = message.replace("%s", String(value));
          });
          return new this(message);
        }
        static forErrors(errors) {
          const exception = new this("Invalid Parameters");
          exception.withErrors(errors);
          return exception;
        }
        static require(condition, message, ...values) {
          if (!condition) {
            for (const value of values) {
              message = message.replace("%s", value);
            }
            throw new this(message);
          }
        }
        static try(callback) {
          return {
            catch: (catcher) => {
              try {
                return callback();
              } catch (error) {
                if (error instanceof _Exception) {
                  return catcher(error, error.type);
                } else if (error instanceof Error) {
                  const e = _Exception.upgrade(error);
                  return catcher(e, e.type);
                } else if (typeof error === "string") {
                  const e = _Exception.for(error);
                  return catcher(e, e.type);
                }
                return catcher(error, "unknown");
              }
            }
          };
        }
        static upgrade(error, code = 500) {
          if (error instanceof _Exception) {
            return error;
          }
          const exception = new this(error.message, code);
          exception.name = error.name;
          exception.stack = error.stack;
          return exception;
        }
        get code() {
          return this._code;
        }
        get end() {
          return this._end;
        }
        get errors() {
          return Object.assign({}, this._errors);
        }
        get start() {
          return this._start;
        }
        get type() {
          return this._type;
        }
        constructor(message, code = 500) {
          var _a;
          super(message);
          this._errors = {};
          this._start = 0;
          this._end = 0;
          this.name = this.constructor.name;
          this._type = this.constructor.name;
          this._code = code;
          this._status = ((_a = (0, Status_1.getStatus)(code)) === null || _a === void 0 ? void 0 : _a.status) || "Unknown";
        }
        toJSON() {
          return JSON.stringify(this.toResponse(), null, 2);
        }
        toResponse(start = 0, end = 0) {
          const json = {
            code: this._code,
            status: this._status,
            error: this.message,
            start: this._start,
            end: this._end,
            stack: this.trace(start, end)
          };
          if (Object.keys(this._errors).length > 0) {
            json.errors = this._errors;
          }
          return json;
        }
        trace(start = 0, end = 0) {
          if (typeof this.stack !== "string") {
            return [];
          }
          const trace = this.stack.split("\n").slice(start, end || this.stack.length).map((line) => line.trim()).map((trace2) => {
            if (!trace2.startsWith("at")) {
              return false;
            }
            let [_2, method, location2] = trace2.split(" ");
            if (!location2) {
              location2 = `(${method})`;
              method = "<none>";
            }
            const [file, line, char] = location2.substring(1, location2.length - 1).split(":");
            return {
              method,
              file,
              line: parseInt(line) || 0,
              char: parseInt(char) || 0
            };
          }).filter(Boolean);
          return trace;
        }
        withCode(code) {
          this._code = code;
          return this;
        }
        withErrors(errors) {
          this._errors = errors;
          return this;
        }
        withPosition(start, end) {
          this._start = start;
          this._end = end;
          return this;
        }
      };
      exports.default = Exception;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/Exception.js
  var require_Exception2 = __commonJS({
    "../../node_modules/@stackpress/ink/dist/Exception.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Exception_1 = __importDefault(require_Exception());
      var InkException = class extends Exception_1.default {
      };
      exports.default = InkException;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client.js
  var require_client2 = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StyleSheet = exports.StyleSet = exports.StyleMap = exports.stylesheet = exports.styleset = exports.stylemap = exports.breakpoints = exports.emitter = exports.signal = exports.innerHTML = exports.innerText = exports.children = exports.classnames = exports.classlist = exports.props = exports.env = exports.data = exports.client = exports.component = exports.SignalRegistry = exports.ClientException = exports.ClientEmitter = exports.ClientElement = exports.ClientRegistry = exports.ClientComponent = exports.ClientField = exports.TemplateData = exports.DOMNode = exports.DOMText = exports.DOMElement = exports.DOMDocument = exports.DOMDoctype = exports.DOMComment = void 0;
      var Comment_1 = __importDefault(require_Comment());
      exports.DOMComment = Comment_1.default;
      var Doctype_1 = __importDefault(require_Doctype());
      exports.DOMDoctype = Doctype_1.default;
      var Document_1 = __importDefault(require_Document());
      exports.DOMDocument = Document_1.default;
      var Element_1 = __importDefault(require_Element());
      exports.DOMElement = Element_1.default;
      var Text_1 = __importDefault(require_Text());
      exports.DOMText = Text_1.default;
      var Node_1 = __importDefault(require_Node());
      exports.DOMNode = Node_1.default;
      var Field_1 = __importDefault(require_Field());
      exports.ClientField = Field_1.default;
      var Component_1 = __importDefault(require_Component());
      exports.ClientComponent = Component_1.default;
      var Registry_1 = __importDefault(require_Registry());
      exports.ClientRegistry = Registry_1.default;
      var Element_2 = __importDefault(require_Element2());
      exports.ClientElement = Element_2.default;
      var Emitter_1 = __importStar(require_Emitter());
      exports.emitter = Emitter_1.default;
      Object.defineProperty(exports, "ClientEmitter", { enumerable: true, get: function() {
        return Emitter_1.ClientEmitter;
      } });
      var client_1 = __importDefault(require_client());
      exports.client = client_1.default;
      var component_1 = __importDefault(require_component());
      exports.component = component_1.default;
      var data_1 = __importStar(require_data());
      exports.data = data_1.default;
      Object.defineProperty(exports, "TemplateData", { enumerable: true, get: function() {
        return data_1.TemplateData;
      } });
      var env_1 = __importDefault(require_env());
      exports.env = env_1.default;
      var props_1 = __importDefault(require_props());
      exports.props = props_1.default;
      var classnames_1 = __importStar(require_classnames());
      exports.classnames = classnames_1.default;
      Object.defineProperty(exports, "classlist", { enumerable: true, get: function() {
        return classnames_1.classlist;
      } });
      var children_1 = __importStar(require_children());
      exports.children = children_1.default;
      Object.defineProperty(exports, "innerHTML", { enumerable: true, get: function() {
        return children_1.innerHTML;
      } });
      Object.defineProperty(exports, "innerText", { enumerable: true, get: function() {
        return children_1.innerText;
      } });
      var signal_1 = __importStar(require_signal());
      exports.signal = signal_1.default;
      Object.defineProperty(exports, "SignalRegistry", { enumerable: true, get: function() {
        return signal_1.SignalRegistry;
      } });
      var StyleMap_1 = __importStar(require_StyleMap());
      exports.StyleMap = StyleMap_1.default;
      Object.defineProperty(exports, "stylemap", { enumerable: true, get: function() {
        return StyleMap_1.stylemap;
      } });
      var StyleSet_1 = __importStar(require_StyleSet());
      exports.StyleSet = StyleSet_1.default;
      Object.defineProperty(exports, "styleset", { enumerable: true, get: function() {
        return StyleSet_1.styleset;
      } });
      var StyleSheet_1 = __importStar(require_StyleSheet());
      exports.StyleSheet = StyleSheet_1.default;
      Object.defineProperty(exports, "stylesheet", { enumerable: true, get: function() {
        return StyleSheet_1.stylesheet;
      } });
      Object.defineProperty(exports, "breakpoints", { enumerable: true, get: function() {
        return StyleSheet_1.breakpoints;
      } });
      var Exception_1 = __importDefault(require_Exception2());
      exports.ClientException = Exception_1.default;
    }
  });

  // ../../node_modules/@stackpress/ink/index.js
  var require_ink = __commonJS({
    "../../node_modules/@stackpress/ink/index.js"(exports, module) {
      module.exports = { ...require_client2() };
    }
  });

  // ../../node_modules/prismjs/prism.js
  var require_prism = __commonJS({
    "../../node_modules/prismjs/prism.js"(exports, module) {
      var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
      var Prism2 = function(_self2) {
        var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
        var uniqueId = 0;
        var plainTextGrammar = {};
        var _2 = {
          /**
           * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
           * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
           * additional languages or plugins yourself.
           *
           * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
           *
           * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
           * empty Prism object into the global scope before loading the Prism script like this:
           *
           * ```js
           * window.Prism = window.Prism || {};
           * Prism.manual = true;
           * // add a new <script> to load Prism's script
           * ```
           *
           * @default false
           * @type {boolean}
           * @memberof Prism
           * @public
           */
          manual: _self2.Prism && _self2.Prism.manual,
          /**
           * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
           * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
           * own worker, you don't want it to do this.
           *
           * By setting this value to `true`, Prism will not add its own listeners to the worker.
           *
           * You obviously have to change this value before Prism executes. To do this, you can add an
           * empty Prism object into the global scope before loading the Prism script like this:
           *
           * ```js
           * window.Prism = window.Prism || {};
           * Prism.disableWorkerMessageHandler = true;
           * // Load Prism's script
           * ```
           *
           * @default false
           * @type {boolean}
           * @memberof Prism
           * @public
           */
          disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
          /**
           * A namespace for utility methods.
           *
           * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
           * change or disappear at any time.
           *
           * @namespace
           * @memberof Prism
           */
          util: {
            encode: function encode(tokens) {
              if (tokens instanceof Token) {
                return new Token(tokens.type, encode(tokens.content), tokens.alias);
              } else if (Array.isArray(tokens)) {
                return tokens.map(encode);
              } else {
                return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
              }
            },
            /**
             * Returns the name of the type of the given value.
             *
             * @param {any} o
             * @returns {string}
             * @example
             * type(null)      === 'Null'
             * type(undefined) === 'Undefined'
             * type(123)       === 'Number'
             * type('foo')     === 'String'
             * type(true)      === 'Boolean'
             * type([1, 2])    === 'Array'
             * type({})        === 'Object'
             * type(String)    === 'Function'
             * type(/abc+/)    === 'RegExp'
             */
            type: function(o) {
              return Object.prototype.toString.call(o).slice(8, -1);
            },
            /**
             * Returns a unique number for the given object. Later calls will still return the same number.
             *
             * @param {Object} obj
             * @returns {number}
             */
            objId: function(obj) {
              if (!obj["__id"]) {
                Object.defineProperty(obj, "__id", { value: ++uniqueId });
              }
              return obj["__id"];
            },
            /**
             * Creates a deep clone of the given object.
             *
             * The main intended use of this function is to clone language definitions.
             *
             * @param {T} o
             * @param {Record<number, any>} [visited]
             * @returns {T}
             * @template T
             */
            clone: function deepClone(o, visited) {
              visited = visited || {};
              var clone;
              var id;
              switch (_2.util.type(o)) {
                case "Object":
                  id = _2.util.objId(o);
                  if (visited[id]) {
                    return visited[id];
                  }
                  clone = /** @type {Record<string, any>} */
                  {};
                  visited[id] = clone;
                  for (var key in o) {
                    if (o.hasOwnProperty(key)) {
                      clone[key] = deepClone(o[key], visited);
                    }
                  }
                  return (
                    /** @type {any} */
                    clone
                  );
                case "Array":
                  id = _2.util.objId(o);
                  if (visited[id]) {
                    return visited[id];
                  }
                  clone = [];
                  visited[id] = clone;
                  /** @type {Array} */
                  /** @type {any} */
                  o.forEach(function(v, i) {
                    clone[i] = deepClone(v, visited);
                  });
                  return (
                    /** @type {any} */
                    clone
                  );
                default:
                  return o;
              }
            },
            /**
             * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
             *
             * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
             *
             * @param {Element} element
             * @returns {string}
             */
            getLanguage: function(element) {
              while (element) {
                var m = lang.exec(element.className);
                if (m) {
                  return m[1].toLowerCase();
                }
                element = element.parentElement;
              }
              return "none";
            },
            /**
             * Sets the Prism `language-xxxx` class of the given element.
             *
             * @param {Element} element
             * @param {string} language
             * @returns {void}
             */
            setLanguage: function(element, language) {
              element.className = element.className.replace(RegExp(lang, "gi"), "");
              element.classList.add("language-" + language);
            },
            /**
             * Returns the script element that is currently executing.
             *
             * This does __not__ work for line script element.
             *
             * @returns {HTMLScriptElement | null}
             */
            currentScript: function() {
              if (typeof document === "undefined") {
                return null;
              }
              if ("currentScript" in document && 1 < 2) {
                return (
                  /** @type {any} */
                  document.currentScript
                );
              }
              try {
                throw new Error();
              } catch (err) {
                var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
                if (src) {
                  var scripts = document.getElementsByTagName("script");
                  for (var i in scripts) {
                    if (scripts[i].src == src) {
                      return scripts[i];
                    }
                  }
                }
                return null;
              }
            },
            /**
             * Returns whether a given class is active for `element`.
             *
             * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
             * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
             * given class is just the given class with a `no-` prefix.
             *
             * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
             * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
             * ancestors have the given class or the negated version of it, then the default activation will be returned.
             *
             * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
             * version of it, the class is considered active.
             *
             * @param {Element} element
             * @param {string} className
             * @param {boolean} [defaultActivation=false]
             * @returns {boolean}
             */
            isActive: function(element, className, defaultActivation) {
              var no = "no-" + className;
              while (element) {
                var classList = element.classList;
                if (classList.contains(className)) {
                  return true;
                }
                if (classList.contains(no)) {
                  return false;
                }
                element = element.parentElement;
              }
              return !!defaultActivation;
            }
          },
          /**
           * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
           *
           * @namespace
           * @memberof Prism
           * @public
           */
          languages: {
            /**
             * The grammar for plain, unformatted text.
             */
            plain: plainTextGrammar,
            plaintext: plainTextGrammar,
            text: plainTextGrammar,
            txt: plainTextGrammar,
            /**
             * Creates a deep copy of the language with the given id and appends the given tokens.
             *
             * If a token in `redef` also appears in the copied language, then the existing token in the copied language
             * will be overwritten at its original position.
             *
             * ## Best practices
             *
             * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
             * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
             * understand the language definition because, normally, the order of tokens matters in Prism grammars.
             *
             * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
             * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
             *
             * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
             * @param {Grammar} redef The new tokens to append.
             * @returns {Grammar} The new language created.
             * @public
             * @example
             * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
             *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
             *     // at its original position
             *     'comment': { ... },
             *     // CSS doesn't have a 'color' token, so this token will be appended
             *     'color': /\b(?:red|green|blue)\b/
             * });
             */
            extend: function(id, redef) {
              var lang2 = _2.util.clone(_2.languages[id]);
              for (var key in redef) {
                lang2[key] = redef[key];
              }
              return lang2;
            },
            /**
             * Inserts tokens _before_ another token in a language definition or any other grammar.
             *
             * ## Usage
             *
             * This helper method makes it easy to modify existing languages. For example, the CSS language definition
             * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
             * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
             * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
             * this:
             *
             * ```js
             * Prism.languages.markup.style = {
             *     // token
             * };
             * ```
             *
             * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
             * before existing tokens. For the CSS example above, you would use it like this:
             *
             * ```js
             * Prism.languages.insertBefore('markup', 'cdata', {
             *     'style': {
             *         // token
             *     }
             * });
             * ```
             *
             * ## Special cases
             *
             * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
             * will be ignored.
             *
             * This behavior can be used to insert tokens after `before`:
             *
             * ```js
             * Prism.languages.insertBefore('markup', 'comment', {
             *     'comment': Prism.languages.markup.comment,
             *     // tokens after 'comment'
             * });
             * ```
             *
             * ## Limitations
             *
             * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
             * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
             * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
             * deleting properties which is necessary to insert at arbitrary positions.
             *
             * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
             * Instead, it will create a new object and replace all references to the target object with the new one. This
             * can be done without temporarily deleting properties, so the iteration order is well-defined.
             *
             * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
             * you hold the target object in a variable, then the value of the variable will not change.
             *
             * ```js
             * var oldMarkup = Prism.languages.markup;
             * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
             *
             * assert(oldMarkup !== Prism.languages.markup);
             * assert(newMarkup === Prism.languages.markup);
             * ```
             *
             * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
             * object to be modified.
             * @param {string} before The key to insert before.
             * @param {Grammar} insert An object containing the key-value pairs to be inserted.
             * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
             * object to be modified.
             *
             * Defaults to `Prism.languages`.
             * @returns {Grammar} The new grammar object.
             * @public
             */
            insertBefore: function(inside, before, insert, root) {
              root = root || /** @type {any} */
              _2.languages;
              var grammar = root[inside];
              var ret = {};
              for (var token in grammar) {
                if (grammar.hasOwnProperty(token)) {
                  if (token == before) {
                    for (var newToken in insert) {
                      if (insert.hasOwnProperty(newToken)) {
                        ret[newToken] = insert[newToken];
                      }
                    }
                  }
                  if (!insert.hasOwnProperty(token)) {
                    ret[token] = grammar[token];
                  }
                }
              }
              var old = root[inside];
              root[inside] = ret;
              _2.languages.DFS(_2.languages, function(key, value) {
                if (value === old && key != inside) {
                  this[key] = ret;
                }
              });
              return ret;
            },
            // Traverse a language definition with Depth First Search
            DFS: function DFS(o, callback, type, visited) {
              visited = visited || {};
              var objId = _2.util.objId;
              for (var i in o) {
                if (o.hasOwnProperty(i)) {
                  callback.call(o, i, o[i], type || i);
                  var property = o[i];
                  var propertyType = _2.util.type(property);
                  if (propertyType === "Object" && !visited[objId(property)]) {
                    visited[objId(property)] = true;
                    DFS(property, callback, null, visited);
                  } else if (propertyType === "Array" && !visited[objId(property)]) {
                    visited[objId(property)] = true;
                    DFS(property, callback, i, visited);
                  }
                }
              }
            }
          },
          plugins: {},
          /**
           * This is the most high-level function in Prisms API.
           * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
           * each one of them.
           *
           * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
           *
           * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
           * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
           * @memberof Prism
           * @public
           */
          highlightAll: function(async, callback) {
            _2.highlightAllUnder(document, async, callback);
          },
          /**
           * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
           * {@link Prism.highlightElement} on each one of them.
           *
           * The following hooks will be run:
           * 1. `before-highlightall`
           * 2. `before-all-elements-highlight`
           * 3. All hooks of {@link Prism.highlightElement} for each element.
           *
           * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
           * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
           * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
           * @memberof Prism
           * @public
           */
          highlightAllUnder: function(container, async, callback) {
            var env2 = {
              callback,
              container,
              selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
            };
            _2.hooks.run("before-highlightall", env2);
            env2.elements = Array.prototype.slice.apply(env2.container.querySelectorAll(env2.selector));
            _2.hooks.run("before-all-elements-highlight", env2);
            for (var i = 0, element; element = env2.elements[i++]; ) {
              _2.highlightElement(element, async === true, env2.callback);
            }
          },
          /**
           * Highlights the code inside a single element.
           *
           * The following hooks will be run:
           * 1. `before-sanity-check`
           * 2. `before-highlight`
           * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
           * 4. `before-insert`
           * 5. `after-highlight`
           * 6. `complete`
           *
           * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
           * the element's language.
           *
           * @param {Element} element The element containing the code.
           * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
           * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
           * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
           * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
           *
           * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
           * asynchronous highlighting to work. You can build your own bundle on the
           * [Download page](https://prismjs.com/download.html).
           * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
           * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
           * @memberof Prism
           * @public
           */
          highlightElement: function(element, async, callback) {
            var language = _2.util.getLanguage(element);
            var grammar = _2.languages[language];
            _2.util.setLanguage(element, language);
            var parent = element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre") {
              _2.util.setLanguage(parent, language);
            }
            var code = element.textContent;
            var env2 = {
              element,
              language,
              grammar,
              code
            };
            function insertHighlightedCode(highlightedCode) {
              env2.highlightedCode = highlightedCode;
              _2.hooks.run("before-insert", env2);
              env2.element.innerHTML = env2.highlightedCode;
              _2.hooks.run("after-highlight", env2);
              _2.hooks.run("complete", env2);
              callback && callback.call(env2.element);
            }
            _2.hooks.run("before-sanity-check", env2);
            parent = env2.element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
              parent.setAttribute("tabindex", "0");
            }
            if (!env2.code) {
              _2.hooks.run("complete", env2);
              callback && callback.call(env2.element);
              return;
            }
            _2.hooks.run("before-highlight", env2);
            if (!env2.grammar) {
              insertHighlightedCode(_2.util.encode(env2.code));
              return;
            }
            if (async && _self2.Worker) {
              var worker = new Worker(_2.filename);
              worker.onmessage = function(evt) {
                insertHighlightedCode(evt.data);
              };
              worker.postMessage(JSON.stringify({
                language: env2.language,
                code: env2.code,
                immediateClose: true
              }));
            } else {
              insertHighlightedCode(_2.highlight(env2.code, env2.grammar, env2.language));
            }
          },
          /**
           * Low-level function, only use if you know what youre doing. It accepts a string of text as input
           * and the language definitions to use, and returns a string with the HTML produced.
           *
           * The following hooks will be run:
           * 1. `before-tokenize`
           * 2. `after-tokenize`
           * 3. `wrap`: On each {@link Token}.
           *
           * @param {string} text A string with the code to be highlighted.
           * @param {Grammar} grammar An object containing the tokens to use.
           *
           * Usually a language definition like `Prism.languages.markup`.
           * @param {string} language The name of the language definition passed to `grammar`.
           * @returns {string} The highlighted HTML.
           * @memberof Prism
           * @public
           * @example
           * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
           */
          highlight: function(text, grammar, language) {
            var env2 = {
              code: text,
              grammar,
              language
            };
            _2.hooks.run("before-tokenize", env2);
            if (!env2.grammar) {
              throw new Error('The language "' + env2.language + '" has no grammar.');
            }
            env2.tokens = _2.tokenize(env2.code, env2.grammar);
            _2.hooks.run("after-tokenize", env2);
            return Token.stringify(_2.util.encode(env2.tokens), env2.language);
          },
          /**
           * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
           * and the language definitions to use, and returns an array with the tokenized code.
           *
           * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
           *
           * This method could be useful in other contexts as well, as a very crude parser.
           *
           * @param {string} text A string with the code to be highlighted.
           * @param {Grammar} grammar An object containing the tokens to use.
           *
           * Usually a language definition like `Prism.languages.markup`.
           * @returns {TokenStream} An array of strings and tokens, a token stream.
           * @memberof Prism
           * @public
           * @example
           * let code = `var foo = 0;`;
           * let tokens = Prism.tokenize(code, Prism.languages.javascript);
           * tokens.forEach(token => {
           *     if (token instanceof Prism.Token && token.type === 'number') {
           *         console.log(`Found numeric literal: ${token.content}`);
           *     }
           * });
           */
          tokenize: function(text, grammar) {
            var rest = grammar.rest;
            if (rest) {
              for (var token in rest) {
                grammar[token] = rest[token];
              }
              delete grammar.rest;
            }
            var tokenList = new LinkedList();
            addAfter(tokenList, tokenList.head, text);
            matchGrammar(text, tokenList, grammar, tokenList.head, 0);
            return toArray(tokenList);
          },
          /**
           * @namespace
           * @memberof Prism
           * @public
           */
          hooks: {
            all: {},
            /**
             * Adds the given callback to the list of callbacks for the given hook.
             *
             * The callback will be invoked when the hook it is registered for is run.
             * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
             *
             * One callback function can be registered to multiple hooks and the same hook multiple times.
             *
             * @param {string} name The name of the hook.
             * @param {HookCallback} callback The callback function which is given environment variables.
             * @public
             */
            add: function(name2, callback) {
              var hooks = _2.hooks.all;
              hooks[name2] = hooks[name2] || [];
              hooks[name2].push(callback);
            },
            /**
             * Runs a hook invoking all registered callbacks with the given environment variables.
             *
             * Callbacks will be invoked synchronously and in the order in which they were registered.
             *
             * @param {string} name The name of the hook.
             * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
             * @public
             */
            run: function(name2, env2) {
              var callbacks = _2.hooks.all[name2];
              if (!callbacks || !callbacks.length) {
                return;
              }
              for (var i = 0, callback; callback = callbacks[i++]; ) {
                callback(env2);
              }
            }
          },
          Token
        };
        _self2.Prism = _2;
        function Token(type, content, alias, matchedStr) {
          this.type = type;
          this.content = content;
          this.alias = alias;
          this.length = (matchedStr || "").length | 0;
        }
        Token.stringify = function stringify(o, language) {
          if (typeof o == "string") {
            return o;
          }
          if (Array.isArray(o)) {
            var s = "";
            o.forEach(function(e) {
              s += stringify(e, language);
            });
            return s;
          }
          var env2 = {
            type: o.type,
            content: stringify(o.content, language),
            tag: "span",
            classes: ["token", o.type],
            attributes: {},
            language
          };
          var aliases = o.alias;
          if (aliases) {
            if (Array.isArray(aliases)) {
              Array.prototype.push.apply(env2.classes, aliases);
            } else {
              env2.classes.push(aliases);
            }
          }
          _2.hooks.run("wrap", env2);
          var attributes = "";
          for (var name2 in env2.attributes) {
            attributes += " " + name2 + '="' + (env2.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
          }
          return "<" + env2.tag + ' class="' + env2.classes.join(" ") + '"' + attributes + ">" + env2.content + "</" + env2.tag + ">";
        };
        function matchPattern(pattern, pos, text, lookbehind) {
          pattern.lastIndex = pos;
          var match = pattern.exec(text);
          if (match && lookbehind && match[1]) {
            var lookbehindLength = match[1].length;
            match.index += lookbehindLength;
            match[0] = match[0].slice(lookbehindLength);
          }
          return match;
        }
        function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
          for (var token in grammar) {
            if (!grammar.hasOwnProperty(token) || !grammar[token]) {
              continue;
            }
            var patterns = grammar[token];
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            for (var j = 0; j < patterns.length; ++j) {
              if (rematch && rematch.cause == token + "," + j) {
                return;
              }
              var patternObj = patterns[j];
              var inside = patternObj.inside;
              var lookbehind = !!patternObj.lookbehind;
              var greedy = !!patternObj.greedy;
              var alias = patternObj.alias;
              if (greedy && !patternObj.pattern.global) {
                var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
              }
              var pattern = patternObj.pattern || patternObj;
              for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
                if (rematch && pos >= rematch.reach) {
                  break;
                }
                var str = currentNode.value;
                if (tokenList.length > text.length) {
                  return;
                }
                if (str instanceof Token) {
                  continue;
                }
                var removeCount = 1;
                var match;
                if (greedy) {
                  match = matchPattern(pattern, pos, text, lookbehind);
                  if (!match || match.index >= text.length) {
                    break;
                  }
                  var from = match.index;
                  var to = match.index + match[0].length;
                  var p = pos;
                  p += currentNode.value.length;
                  while (from >= p) {
                    currentNode = currentNode.next;
                    p += currentNode.value.length;
                  }
                  p -= currentNode.value.length;
                  pos = p;
                  if (currentNode.value instanceof Token) {
                    continue;
                  }
                  for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                    removeCount++;
                    p += k.value.length;
                  }
                  removeCount--;
                  str = text.slice(pos, p);
                  match.index -= pos;
                } else {
                  match = matchPattern(pattern, 0, str, lookbehind);
                  if (!match) {
                    continue;
                  }
                }
                var from = match.index;
                var matchStr = match[0];
                var before = str.slice(0, from);
                var after = str.slice(from + matchStr.length);
                var reach = pos + str.length;
                if (rematch && reach > rematch.reach) {
                  rematch.reach = reach;
                }
                var removeFrom = currentNode.prev;
                if (before) {
                  removeFrom = addAfter(tokenList, removeFrom, before);
                  pos += before.length;
                }
                removeRange(tokenList, removeFrom, removeCount);
                var wrapped = new Token(token, inside ? _2.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                currentNode = addAfter(tokenList, removeFrom, wrapped);
                if (after) {
                  addAfter(tokenList, currentNode, after);
                }
                if (removeCount > 1) {
                  var nestedRematch = {
                    cause: token + "," + j,
                    reach
                  };
                  matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                  if (rematch && nestedRematch.reach > rematch.reach) {
                    rematch.reach = nestedRematch.reach;
                  }
                }
              }
            }
          }
        }
        function LinkedList() {
          var head = { value: null, prev: null, next: null };
          var tail = { value: null, prev: head, next: null };
          head.next = tail;
          this.head = head;
          this.tail = tail;
          this.length = 0;
        }
        function addAfter(list, node, value) {
          var next = node.next;
          var newNode = { value, prev: node, next };
          node.next = newNode;
          next.prev = newNode;
          list.length++;
          return newNode;
        }
        function removeRange(list, node, count) {
          var next = node.next;
          for (var i = 0; i < count && next !== list.tail; i++) {
            next = next.next;
          }
          node.next = next;
          next.prev = node;
          list.length -= i;
        }
        function toArray(list) {
          var array = [];
          var node = list.head.next;
          while (node !== list.tail) {
            array.push(node.value);
            node = node.next;
          }
          return array;
        }
        if (!_self2.document) {
          if (!_self2.addEventListener) {
            return _2;
          }
          if (!_2.disableWorkerMessageHandler) {
            _self2.addEventListener("message", function(evt) {
              var message = JSON.parse(evt.data);
              var lang2 = message.language;
              var code = message.code;
              var immediateClose = message.immediateClose;
              _self2.postMessage(_2.highlight(code, _2.languages[lang2], lang2));
              if (immediateClose) {
                _self2.close();
              }
            }, false);
          }
          return _2;
        }
        var script = _2.util.currentScript();
        if (script) {
          _2.filename = script.src;
          if (script.hasAttribute("data-manual")) {
            _2.manual = true;
          }
        }
        function highlightAutomaticallyCallback() {
          if (!_2.manual) {
            _2.highlightAll();
          }
        }
        if (!_2.manual) {
          var readyState = document.readyState;
          if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
            document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
          } else {
            if (window.requestAnimationFrame) {
              window.requestAnimationFrame(highlightAutomaticallyCallback);
            } else {
              window.setTimeout(highlightAutomaticallyCallback, 16);
            }
          }
        }
        return _2;
      }(_self);
      if (typeof module !== "undefined" && module.exports) {
        module.exports = Prism2;
      }
      if (typeof global !== "undefined") {
        global.Prism = Prism2;
      }
      Prism2.languages.markup = {
        "comment": {
          pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
          greedy: true
        },
        "prolog": {
          pattern: /<\?[\s\S]+?\?>/,
          greedy: true
        },
        "doctype": {
          // https://www.w3.org/TR/xml/#NT-doctypedecl
          pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
          greedy: true,
          inside: {
            "internal-subset": {
              pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
              lookbehind: true,
              greedy: true,
              inside: null
              // see below
            },
            "string": {
              pattern: /"[^"]*"|'[^']*'/,
              greedy: true
            },
            "punctuation": /^<!|>$|[[\]]/,
            "doctype-tag": /^DOCTYPE/i,
            "name": /[^\s<>'"]+/
          }
        },
        "cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          greedy: true
        },
        "tag": {
          pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
          greedy: true,
          inside: {
            "tag": {
              pattern: /^<\/?[^\s>\/]+/,
              inside: {
                "punctuation": /^<\/?/,
                "namespace": /^[^\s>\/:]+:/
              }
            },
            "special-attr": [],
            "attr-value": {
              pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
              inside: {
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  {
                    pattern: /^(\s*)["']|["']$/,
                    lookbehind: true
                  }
                ]
              }
            },
            "punctuation": /\/?>/,
            "attr-name": {
              pattern: /[^\s>\/]+/,
              inside: {
                "namespace": /^[^\s>\/:]+:/
              }
            }
          }
        },
        "entity": [
          {
            pattern: /&[\da-z]{1,8};/i,
            alias: "named-entity"
          },
          /&#x?[\da-f]{1,8};/i
        ]
      };
      Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
      Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
      Prism2.hooks.add("wrap", function(env2) {
        if (env2.type === "entity") {
          env2.attributes["title"] = env2.content.replace(/&amp;/, "&");
        }
      });
      Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
        /**
         * Adds an inlined language to markup.
         *
         * An example of an inlined language is CSS with `<style>` tags.
         *
         * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
         * case insensitive.
         * @param {string} lang The language key.
         * @example
         * addInlined('style', 'css');
         */
        value: function addInlined(tagName, lang) {
          var includedCdataInside = {};
          includedCdataInside["language-" + lang] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: true,
            inside: Prism2.languages[lang]
          };
          includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
          var inside = {
            "included-cdata": {
              pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
              inside: includedCdataInside
            }
          };
          inside["language-" + lang] = {
            pattern: /[\s\S]+/,
            inside: Prism2.languages[lang]
          };
          var def = {};
          def[tagName] = {
            pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
              return tagName;
            }), "i"),
            lookbehind: true,
            greedy: true,
            inside
          };
          Prism2.languages.insertBefore("markup", "cdata", def);
        }
      });
      Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
        /**
         * Adds an pattern to highlight languages embedded in HTML attributes.
         *
         * An example of an inlined language is CSS with `style` attributes.
         *
         * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
         * case insensitive.
         * @param {string} lang The language key.
         * @example
         * addAttribute('style', 'css');
         */
        value: function(attrName, lang) {
          Prism2.languages.markup.tag.inside["special-attr"].push({
            pattern: RegExp(
              /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
              "i"
            ),
            lookbehind: true,
            inside: {
              "attr-name": /^[^\s=]+/,
              "attr-value": {
                pattern: /=[\s\S]+/,
                inside: {
                  "value": {
                    pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                    lookbehind: true,
                    alias: [lang, "language-" + lang],
                    inside: Prism2.languages[lang]
                  },
                  "punctuation": [
                    {
                      pattern: /^=/,
                      alias: "attr-equals"
                    },
                    /"|'/
                  ]
                }
              }
            }
          });
        }
      });
      Prism2.languages.html = Prism2.languages.markup;
      Prism2.languages.mathml = Prism2.languages.markup;
      Prism2.languages.svg = Prism2.languages.markup;
      Prism2.languages.xml = Prism2.languages.extend("markup", {});
      Prism2.languages.ssml = Prism2.languages.xml;
      Prism2.languages.atom = Prism2.languages.xml;
      Prism2.languages.rss = Prism2.languages.xml;
      (function(Prism3) {
        var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
        Prism3.languages.css = {
          "comment": /\/\*[\s\S]*?\*\//,
          "atrule": {
            pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
            inside: {
              "rule": /^@[\w-]+/,
              "selector-function-argument": {
                pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                lookbehind: true,
                alias: "selector"
              },
              "keyword": {
                pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                lookbehind: true
              }
              // See rest below
            }
          },
          "url": {
            // https://drafts.csswg.org/css-values-3/#urls
            pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
            greedy: true,
            inside: {
              "function": /^url/i,
              "punctuation": /^\(|\)$/,
              "string": {
                pattern: RegExp("^" + string.source + "$"),
                alias: "url"
              }
            }
          },
          "selector": {
            pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
            lookbehind: true
          },
          "string": {
            pattern: string,
            greedy: true
          },
          "property": {
            pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
            lookbehind: true
          },
          "important": /!important\b/i,
          "function": {
            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
            lookbehind: true
          },
          "punctuation": /[(){};:,]/
        };
        Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
        var markup = Prism3.languages.markup;
        if (markup) {
          markup.tag.addInlined("style", "css");
          markup.tag.addAttribute("style", "css");
        }
      })(Prism2);
      Prism2.languages.clike = {
        "comment": [
          {
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        "string": {
          pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          greedy: true
        },
        "class-name": {
          pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
          lookbehind: true,
          inside: {
            "punctuation": /[.\\]/
          }
        },
        "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
        "boolean": /\b(?:false|true)\b/,
        "function": /\b\w+(?=\()/,
        "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
        "punctuation": /[{}[\];(),.:]/
      };
      Prism2.languages.javascript = Prism2.languages.extend("clike", {
        "class-name": [
          Prism2.languages.clike["class-name"],
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
            lookbehind: true
          }
        ],
        "keyword": [
          {
            pattern: /((?:^|\})\s*)catch\b/,
            lookbehind: true
          },
          {
            pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
            lookbehind: true
          }
        ],
        // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
        "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
        "number": {
          pattern: RegExp(
            /(^|[^\w$])/.source + "(?:" + // constant
            (/NaN|Infinity/.source + "|" + // binary integer
            /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
            /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
            /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
            /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
            /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
          ),
          lookbehind: true
        },
        "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
      });
      Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
      Prism2.languages.insertBefore("javascript", "keyword", {
        "regex": {
          pattern: RegExp(
            // lookbehind
            // eslint-disable-next-line regexp/no-dupe-characters-character-class
            /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
            // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
            // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
            // with the only syntax, so we have to define 2 different regex patterns.
            /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
            /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
            /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            "regex-source": {
              pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
              lookbehind: true,
              alias: "language-regex",
              inside: Prism2.languages.regex
            },
            "regex-delimiter": /^\/|\/$/,
            "regex-flags": /^[a-z]+$/
          }
        },
        // This must be declared before keyword because we use "function" inside the look-forward
        "function-variable": {
          pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
          alias: "function"
        },
        "parameter": [
          {
            pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
            lookbehind: true,
            inside: Prism2.languages.javascript
          },
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
            lookbehind: true,
            inside: Prism2.languages.javascript
          },
          {
            pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
            lookbehind: true,
            inside: Prism2.languages.javascript
          },
          {
            pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
            lookbehind: true,
            inside: Prism2.languages.javascript
          }
        ],
        "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
      });
      Prism2.languages.insertBefore("javascript", "string", {
        "hashbang": {
          pattern: /^#!.*/,
          greedy: true,
          alias: "comment"
        },
        "template-string": {
          pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
          greedy: true,
          inside: {
            "template-punctuation": {
              pattern: /^`|`$/,
              alias: "string"
            },
            "interpolation": {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
              lookbehind: true,
              inside: {
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                },
                rest: Prism2.languages.javascript
              }
            },
            "string": /[\s\S]+/
          }
        },
        "string-property": {
          pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
          lookbehind: true,
          greedy: true,
          alias: "property"
        }
      });
      Prism2.languages.insertBefore("javascript", "operator", {
        "literal-property": {
          pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
          lookbehind: true,
          alias: "property"
        }
      });
      if (Prism2.languages.markup) {
        Prism2.languages.markup.tag.addInlined("script", "javascript");
        Prism2.languages.markup.tag.addAttribute(
          /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
          "javascript"
        );
      }
      Prism2.languages.js = Prism2.languages.javascript;
      (function() {
        if (typeof Prism2 === "undefined" || typeof document === "undefined") {
          return;
        }
        if (!Element.prototype.matches) {
          Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
        }
        var LOADING_MESSAGE = "Loading\u2026";
        var FAILURE_MESSAGE = function(status, message) {
          return "\u2716 Error " + status + " while fetching file: " + message;
        };
        var FAILURE_EMPTY_MESSAGE = "\u2716 Error: File does not exist or is empty";
        var EXTENSIONS = {
          "js": "javascript",
          "py": "python",
          "rb": "ruby",
          "ps1": "powershell",
          "psm1": "powershell",
          "sh": "bash",
          "bat": "batch",
          "h": "c",
          "tex": "latex"
        };
        var STATUS_ATTR = "data-src-status";
        var STATUS_LOADING = "loading";
        var STATUS_LOADED = "loaded";
        var STATUS_FAILED = "failed";
        var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
        function loadFile(src, success, error) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", src, true);
          xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
              if (xhr.status < 400 && xhr.responseText) {
                success(xhr.responseText);
              } else {
                if (xhr.status >= 400) {
                  error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
                } else {
                  error(FAILURE_EMPTY_MESSAGE);
                }
              }
            }
          };
          xhr.send(null);
        }
        function parseRange(range) {
          var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
          if (m) {
            var start = Number(m[1]);
            var comma = m[2];
            var end = m[3];
            if (!comma) {
              return [start, start];
            }
            if (!end) {
              return [start, void 0];
            }
            return [start, Number(end)];
          }
          return void 0;
        }
        Prism2.hooks.add("before-highlightall", function(env2) {
          env2.selector += ", " + SELECTOR;
        });
        Prism2.hooks.add("before-sanity-check", function(env2) {
          var pre = (
            /** @type {HTMLPreElement} */
            env2.element
          );
          if (pre.matches(SELECTOR)) {
            env2.code = "";
            pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
            var code = pre.appendChild(document.createElement("CODE"));
            code.textContent = LOADING_MESSAGE;
            var src = pre.getAttribute("data-src");
            var language = env2.language;
            if (language === "none") {
              var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
              language = EXTENSIONS[extension] || extension;
            }
            Prism2.util.setLanguage(code, language);
            Prism2.util.setLanguage(pre, language);
            var autoloader = Prism2.plugins.autoloader;
            if (autoloader) {
              autoloader.loadLanguages(language);
            }
            loadFile(
              src,
              function(text) {
                pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
                var range = parseRange(pre.getAttribute("data-range"));
                if (range) {
                  var lines = text.split(/\r\n?|\n/g);
                  var start = range[0];
                  var end = range[1] == null ? lines.length : range[1];
                  if (start < 0) {
                    start += lines.length;
                  }
                  start = Math.max(0, Math.min(start - 1, lines.length));
                  if (end < 0) {
                    end += lines.length;
                  }
                  end = Math.max(0, Math.min(end, lines.length));
                  text = lines.slice(start, end).join("\n");
                  if (!pre.hasAttribute("data-start")) {
                    pre.setAttribute("data-start", String(start + 1));
                  }
                }
                code.textContent = text;
                Prism2.highlightElement(code);
              },
              function(error) {
                pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
                code.textContent = error;
              }
            );
          }
        });
        Prism2.plugins.fileHighlight = {
          /**
           * Executes the File Highlight plugin for all matching `pre` elements under the given container.
           *
           * Note: Elements which are already loaded or currently loading will not be touched by this method.
           *
           * @param {ParentNode} [container=document]
           */
          highlight: function highlight(container) {
            var elements2 = (container || document).querySelectorAll(SELECTOR);
            for (var i = 0, element; element = elements2[i++]; ) {
              Prism2.highlightElement(element);
            }
          }
        };
        var logged = false;
        Prism2.fileHighlight = function() {
          if (!logged) {
            console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
            logged = true;
          }
          Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
        };
      })();
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/style/color.js
  var require_color = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/style/color.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = color;
      function color(props3, styles, initial = false, selector = ":host", property = "color") {
        const { color: color2, white, black, info, warning, success, error, muted, primary, secondary, theme } = props3;
        const style = color2 ? color2 : theme ? `var(--${theme})` : white ? "var(--white)" : black ? "var(--black)" : info ? "var(--info)" : warning ? "var(--warning)" : success ? "var(--success)" : error ? "var(--error)" : muted ? "var(--muted)" : primary ? "var(--primary)" : secondary ? "var(--secondary)" : initial;
        if (style) {
          styles.add(selector, property, style);
        }
        return color2 ? "color" : white ? "white" : black ? "black" : info ? "info" : warning ? "warning" : success ? "success" : error ? "error" : muted ? "muted" : primary ? "primary" : secondary ? "secondary" : "initial";
      }
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/style/display.js
  var require_display = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/style/display.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = display;
      function display(props3, styles, initial = false, selector = ":host") {
        const { flex, none, inline, block, "inline-block": iblock, "inline-flex": iflex } = props3;
        const style = flex ? "flex" : none ? "none" : block ? "block" : inline ? "inline" : iflex ? "inline-flex" : iblock ? "inline-block" : initial;
        if (style) {
          styles.add(selector, "display", style);
        }
        return style || "initial";
      }
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/style/size.js
  var require_size = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/style/size.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = size;
      function size(props3, styles, initial = false, selector = ":host", property = "font-size") {
        const { size: size2, xs, sm, md, lg, xl, xl2, xl3, xl4, xl5 } = props3;
        const style = size2 ? `${size2}px` : xs ? "8px" : sm ? "12px" : md ? "16px" : lg ? "20px" : xl ? "24px" : xl2 ? "28px" : xl3 ? "32px" : xl4 ? "36px" : xl5 ? "40px" : initial;
        if (style) {
          styles.add(selector, property, style);
        }
        return size2 ? "size" : xs ? "xs" : sm ? "sm" : md ? "md" : lg ? "lg" : xl ? "xl" : xl2 ? "xl2" : xl3 ? "xl3" : xl4 ? "xl4" : xl5 ? "xl5" : "initial";
      }
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/style/bold.js
  var require_bold = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/style/bold.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = bold;
      function bold(props3, styles, selector = ":host") {
        const { bold: bold2 } = props3;
        if (bold2) {
          styles.add(selector, "font-weight", "bold");
        }
        return bold2;
      }
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/style/underline.js
  var require_underline = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/style/underline.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = underline;
      function underline(props3, styles, selector = ":host") {
        const { underline: underline2 } = props3;
        if (underline2) {
          styles.add(selector, "text-decoration", "underline");
        } else {
          styles.add(selector, "text-decoration", "none");
        }
        return underline2;
      }
    }
  });

  // ../../node_modules/suneditor/src/lang/en.js
  var require_en = __commonJS({
    "../../node_modules/suneditor/src/lang/en.js"(exports, module) {
      "use strict";
      (function(global2, factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global2.document ? factory(global2, true) : function(w) {
            if (!w.document) {
              throw new Error("SUNEDITOR_LANG a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global2);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        const lang = {
          code: "en",
          toolbar: {
            default: "Default",
            save: "Save",
            font: "Font",
            formats: "Formats",
            fontSize: "Size",
            bold: "Bold",
            underline: "Underline",
            italic: "Italic",
            strike: "Strike",
            subscript: "Subscript",
            superscript: "Superscript",
            removeFormat: "Remove Format",
            fontColor: "Font Color",
            hiliteColor: "Highlight Color",
            indent: "Indent",
            outdent: "Outdent",
            align: "Align",
            alignLeft: "Align left",
            alignRight: "Align right",
            alignCenter: "Align center",
            alignJustify: "Align justify",
            list: "List",
            orderList: "Ordered list",
            unorderList: "Unordered list",
            horizontalRule: "Horizontal line",
            hr_solid: "Solid",
            hr_dotted: "Dotted",
            hr_dashed: "Dashed",
            table: "Table",
            link: "Link",
            math: "Math",
            image: "Image",
            video: "Video",
            audio: "Audio",
            fullScreen: "Full screen",
            showBlocks: "Show blocks",
            codeView: "Code view",
            undo: "Undo",
            redo: "Redo",
            preview: "Preview",
            print: "print",
            tag_p: "Paragraph",
            tag_div: "Normal (DIV)",
            tag_h: "Header",
            tag_blockquote: "Quote",
            tag_pre: "Code",
            template: "Template",
            lineHeight: "Line height",
            paragraphStyle: "Paragraph style",
            textStyle: "Text style",
            imageGallery: "Image gallery",
            dir_ltr: "Left to right",
            dir_rtl: "Right to left",
            mention: "Mention"
          },
          dialogBox: {
            linkBox: {
              title: "Insert Link",
              url: "URL to link",
              text: "Text to display",
              newWindowCheck: "Open in new window",
              downloadLinkCheck: "Download link",
              bookmark: "Bookmark"
            },
            mathBox: {
              title: "Math",
              inputLabel: "Mathematical Notation",
              fontSizeLabel: "Font Size",
              previewLabel: "Preview"
            },
            imageBox: {
              title: "Insert image",
              file: "Select from files",
              url: "Image URL",
              altText: "Alternative text"
            },
            videoBox: {
              title: "Insert Video",
              file: "Select from files",
              url: "Media embed URL, YouTube/Vimeo"
            },
            audioBox: {
              title: "Insert Audio",
              file: "Select from files",
              url: "Audio URL"
            },
            browser: {
              tags: "Tags",
              search: "Search"
            },
            caption: "Insert description",
            close: "Close",
            submitButton: "Submit",
            revertButton: "Revert",
            proportion: "Constrain proportions",
            basic: "Basic",
            left: "Left",
            right: "Right",
            center: "Center",
            width: "Width",
            height: "Height",
            size: "Size",
            ratio: "Ratio"
          },
          controller: {
            edit: "Edit",
            unlink: "Unlink",
            remove: "Remove",
            insertRowAbove: "Insert row above",
            insertRowBelow: "Insert row below",
            deleteRow: "Delete row",
            insertColumnBefore: "Insert column before",
            insertColumnAfter: "Insert column after",
            deleteColumn: "Delete column",
            fixedColumnWidth: "Fixed column width",
            resize100: "Resize 100%",
            resize75: "Resize 75%",
            resize50: "Resize 50%",
            resize25: "Resize 25%",
            autoSize: "Auto size",
            mirrorHorizontal: "Mirror, Horizontal",
            mirrorVertical: "Mirror, Vertical",
            rotateLeft: "Rotate left",
            rotateRight: "Rotate right",
            maxSize: "Max size",
            minSize: "Min size",
            tableHeader: "Table header",
            mergeCells: "Merge cells",
            splitCells: "Split Cells",
            HorizontalSplit: "Horizontal split",
            VerticalSplit: "Vertical split"
          },
          menu: {
            spaced: "Spaced",
            bordered: "Bordered",
            neon: "Neon",
            translucent: "Translucent",
            shadow: "Shadow",
            code: "Code"
          }
        };
        if (typeof noGlobal === "undefined") {
          if (!window2.SUNEDITOR_LANG) {
            Object.defineProperty(window2, "SUNEDITOR_LANG", {
              enumerable: true,
              writable: false,
              configurable: false,
              value: {}
            });
          }
          Object.defineProperty(window2.SUNEDITOR_LANG, "en", {
            enumerable: true,
            writable: true,
            configurable: true,
            value: lang
          });
        }
        return lang;
      });
    }
  });

  // ../../node_modules/suneditor/src/plugins/modules/dialog.js
  var require_dialog = __commonJS({
    "../../node_modules/suneditor/src/plugins/modules/dialog.js"(exports, module) {
      "use strict";
      (function(global2, factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global2.document ? factory(global2, true) : function(w) {
            if (!w.document) {
              throw new Error("SUNEDITOR_MODULES a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global2);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        const dialog6 = {
          name: "dialog",
          /**
           * @description Constructor
           * @param {Object} core Core object 
           */
          add: function(core) {
            const context = core.context;
            context.dialog = {
              kind: "",
              updateModal: false,
              _closeSignal: false
            };
            let dialog_div = core.util.createElement("DIV");
            dialog_div.className = "se-dialog sun-editor-common";
            let dialog_back = core.util.createElement("DIV");
            dialog_back.className = "se-dialog-back";
            dialog_back.style.display = "none";
            let dialog_area = core.util.createElement("DIV");
            dialog_area.className = "se-dialog-inner";
            dialog_area.style.display = "none";
            dialog_div.appendChild(dialog_back);
            dialog_div.appendChild(dialog_area);
            context.dialog.modalArea = dialog_div;
            context.dialog.back = dialog_back;
            context.dialog.modal = dialog_area;
            context.dialog.modal.addEventListener("mousedown", this._onMouseDown_dialog.bind(core));
            context.dialog.modal.addEventListener("click", this._onClick_dialog.bind(core));
            context.element.relative.appendChild(dialog_div);
            dialog_div = null, dialog_back = null, dialog_area = null;
          },
          /**
           * @description Event to control the behavior of closing the dialog
           * @param {MouseEvent} e Event object
           * @private
           */
          _onMouseDown_dialog: function(e) {
            if (/se-dialog-inner/.test(e.target.className)) {
              this.context.dialog._closeSignal = true;
            } else {
              this.context.dialog._closeSignal = false;
            }
          },
          /**
           * @description Event to close the window when the outside area of the dialog or close button is click
           * @param {MouseEvent} e Event object
           * @private
           */
          _onClick_dialog: function(e) {
            if (/close/.test(e.target.getAttribute("data-command")) || this.context.dialog._closeSignal) {
              this.plugins.dialog.close.call(this);
            }
          },
          /**
           * @description Open a Dialog plugin
           * @param {String} kind Dialog plugin name
           * @param {Boolean} update Whether it will open for update ('image' === this.currentControllerName)
           */
          open: function(kind, update) {
            if (this.modalForm) return false;
            if (this.plugins.dialog._bindClose) {
              this._d.removeEventListener("keydown", this.plugins.dialog._bindClose);
              this.plugins.dialog._bindClose = null;
            }
            this.plugins.dialog._bindClose = function(e) {
              if (!/27/.test(e.keyCode)) return;
              this.plugins.dialog.close.call(this);
            }.bind(this);
            this._d.addEventListener("keydown", this.plugins.dialog._bindClose);
            this.context.dialog.updateModal = update;
            if (this.options.popupDisplay === "full") {
              this.context.dialog.modalArea.style.position = "fixed";
            } else {
              this.context.dialog.modalArea.style.position = "absolute";
            }
            this.context.dialog.kind = kind;
            this.modalForm = this.context[kind].modal;
            const focusElement = this.context[kind].focusElement;
            if (typeof this.plugins[kind].on === "function") this.plugins[kind].on.call(this, update);
            this.context.dialog.modalArea.style.display = "block";
            this.context.dialog.back.style.display = "block";
            this.context.dialog.modal.style.display = "block";
            this.modalForm.style.display = "block";
            if (focusElement) focusElement.focus();
          },
          _bindClose: null,
          /**
           * @description Close a Dialog plugin
           * The plugin's "init" method is called.
           */
          close: function() {
            if (this.plugins.dialog._bindClose) {
              this._d.removeEventListener("keydown", this.plugins.dialog._bindClose);
              this.plugins.dialog._bindClose = null;
            }
            const kind = this.context.dialog.kind;
            this.modalForm.style.display = "none";
            this.context.dialog.back.style.display = "none";
            this.context.dialog.modalArea.style.display = "none";
            this.context.dialog.updateModal = false;
            if (typeof this.plugins[kind].init === "function") this.plugins[kind].init.call(this);
            this.context.dialog.kind = "";
            this.modalForm = null;
            this.focus();
          }
        };
        if (typeof noGlobal === "undefined") {
          if (!window2.SUNEDITOR_MODULES) {
            Object.defineProperty(window2, "SUNEDITOR_MODULES", {
              enumerable: true,
              writable: false,
              configurable: false,
              value: {}
            });
          }
          Object.defineProperty(window2.SUNEDITOR_MODULES, "dialog", {
            enumerable: true,
            writable: false,
            configurable: false,
            value: dialog6
          });
        }
        return dialog6;
      });
    }
  });

  // ../../node_modules/suneditor/src/plugins/modules/component.js
  var require_component2 = __commonJS({
    "../../node_modules/suneditor/src/plugins/modules/component.js"(exports, module) {
      "use strict";
      (function(global2, factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global2.document ? factory(global2, true) : function(w) {
            if (!w.document) {
              throw new Error("SUNEDITOR_MODULES a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global2);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        const component4 = {
          name: "component",
          /**
           * @description Create a container for the resizing component and insert the element.
           * @param {Element} cover Cover element (FIGURE)
           * @param {String} className Class name of container (fixed: se-component)
           * @returns {Element} Created container element
           */
          set_container: function(cover, className) {
            const container = this.util.createElement("DIV");
            container.className = "se-component " + className;
            container.appendChild(cover);
            return container;
          },
          /**
           * @description Cover the target element with a FIGURE element.
           * @param {Element} element Target element
           */
          set_cover: function(element) {
            const cover = this.util.createElement("FIGURE");
            cover.appendChild(element);
            return cover;
          },
          /**
           * @description Return HTML string of caption(FIGCAPTION) element
           * @returns {String}
           */
          create_caption: function() {
            const caption = this.util.createElement("FIGCAPTION");
            caption.innerHTML = "<div>" + this.lang.dialogBox.caption + "</div>";
            return caption;
          }
        };
        if (typeof noGlobal === "undefined") {
          if (!window2.SUNEDITOR_MODULES) {
            Object.defineProperty(window2, "SUNEDITOR_MODULES", {
              enumerable: true,
              writable: false,
              configurable: false,
              value: {}
            });
          }
          Object.defineProperty(window2.SUNEDITOR_MODULES, "component", {
            enumerable: true,
            writable: false,
            configurable: false,
            value: component4
          });
        }
        return component4;
      });
    }
  });

  // ../../node_modules/suneditor/src/plugins/modules/resizing.js
  var require_resizing = __commonJS({
    "../../node_modules/suneditor/src/plugins/modules/resizing.js"(exports, module) {
      "use strict";
      (function(global2, factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global2.document ? factory(global2, true) : function(w) {
            if (!w.document) {
              throw new Error("SUNEDITOR_MODULES a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global2);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        const resizing3 = {
          name: "resizing",
          /**
           * @description Constructor
           * Require context properties when resizing module
              inputX: Element,
              inputY: Element,
              _container: null,
              _cover: null,
              _element: null,
              _element_w: 1,
              _element_h: 1,
              _element_l: 0,
              _element_t: 0,
              _defaultSizeX: 'auto',
              _defaultSizeY: 'auto',
              _origin_w: core.options.imageWidth === 'auto' ? '' : core.options.imageWidth,
              _origin_h: core.options.imageHeight === 'auto' ? '' : core.options.imageHeight,
              _proportionChecked: true,
              // -- select function --
              _resizing: core.options.imageResizing,
              _resizeDotHide: !core.options.imageHeightShow,
              _rotation: core.options.imageRotation,
              _onlyPercentage: core.options.imageSizeOnlyPercentage,
              _ratio: false,
              _ratioX: 1,
              _ratioY: 1
              _captionShow: true,
              // -- when used caption (_captionShow: true) --
              _caption: null,
              _captionChecked: false,
              captionCheckEl: null,
           * @param {Object} core Core object 
           */
          add: function(core) {
            const icons = core.icons;
            const context = core.context;
            context.resizing = {
              _resizeClientX: 0,
              _resizeClientY: 0,
              _resize_plugin: "",
              _resize_w: 0,
              _resize_h: 0,
              _origin_w: 0,
              _origin_h: 0,
              _rotateVertical: false,
              _resize_direction: "",
              _move_path: null,
              _isChange: false,
              alignIcons: {
                basic: icons.align_justify,
                left: icons.align_left,
                right: icons.align_right,
                center: icons.align_center
              }
            };
            let resize_div_container = this.setController_resize(core);
            context.resizing.resizeContainer = resize_div_container;
            context.resizing.resizeDiv = resize_div_container.querySelector(".se-modal-resize");
            context.resizing.resizeDot = resize_div_container.querySelector(".se-resize-dot");
            context.resizing.resizeDisplay = resize_div_container.querySelector(".se-resize-display");
            let resize_button = this.setController_button(core);
            context.resizing.resizeButton = resize_button;
            let resize_handles = context.resizing.resizeHandles = context.resizing.resizeDot.querySelectorAll("span");
            context.resizing.resizeButtonGroup = resize_button.querySelector("._se_resizing_btn_group");
            context.resizing.rotationButtons = resize_button.querySelectorAll("._se_resizing_btn_group ._se_rotation");
            context.resizing.percentageButtons = resize_button.querySelectorAll("._se_resizing_btn_group ._se_percentage");
            context.resizing.alignMenu = resize_button.querySelector(".se-resizing-align-list");
            context.resizing.alignMenuList = context.resizing.alignMenu.querySelectorAll("button");
            context.resizing.alignButton = resize_button.querySelector("._se_resizing_align_button");
            context.resizing.autoSizeButton = resize_button.querySelector("._se_resizing_btn_group ._se_auto_size");
            context.resizing.captionButton = resize_button.querySelector("._se_resizing_caption_button");
            resize_div_container.addEventListener("mousedown", function(e) {
              e.preventDefault();
            });
            resize_handles[0].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_handles[1].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_handles[2].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_handles[3].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_handles[4].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_handles[5].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_handles[6].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_handles[7].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_button.addEventListener("click", this.onClick_resizeButton.bind(core));
            context.element.relative.appendChild(resize_div_container);
            context.element.relative.appendChild(resize_button);
            resize_div_container = null, resize_button = null, resize_handles = null;
          },
          /** resize controller, button (image, iframe, video) */
          setController_resize: function(core) {
            const resize_container = core.util.createElement("DIV");
            resize_container.className = "se-controller se-resizing-container";
            resize_container.style.display = "none";
            resize_container.innerHTML = '<div class="se-modal-resize"></div><div class="se-resize-dot"><span class="tl"></span><span class="tr"></span><span class="bl"></span><span class="br"></span><span class="lw"></span><span class="th"></span><span class="rw"></span><span class="bh"></span><div class="se-resize-display"></div></div>';
            return resize_container;
          },
          setController_button: function(core) {
            const lang = core.lang;
            const icons = core.icons;
            const resize_button = core.util.createElement("DIV");
            resize_button.className = "se-controller se-controller-resizing";
            resize_button.innerHTML = '<div class="se-arrow se-arrow-up"></div><div class="se-btn-group _se_resizing_btn_group"><button type="button" data-command="percent" data-value="1" class="se-tooltip _se_percentage"><span>100%</span><span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.resize100 + '</span></span></button><button type="button" data-command="percent" data-value="0.75" class="se-tooltip _se_percentage"><span>75%</span><span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.resize75 + '</span></span></button><button type="button" data-command="percent" data-value="0.5" class="se-tooltip _se_percentage"><span>50%</span><span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.resize50 + '</span></span></button><button type="button" data-command="auto" class="se-btn se-tooltip _se_auto_size">' + icons.auto_size + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.autoSize + '</span></span></button><button type="button" data-command="rotate" data-value="-90" class="se-btn se-tooltip _se_rotation">' + icons.rotate_left + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.rotateLeft + '</span></span></button><button type="button" data-command="rotate" data-value="90" class="se-btn se-tooltip _se_rotation">' + icons.rotate_right + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.rotateRight + '</span></span></button></div><div class="se-btn-group" style="padding-top: 0;"><button type="button" data-command="mirror" data-value="h" class="se-btn se-tooltip">' + icons.mirror_horizontal + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.mirrorHorizontal + '</span></span></button><button type="button" data-command="mirror" data-value="v" class="se-btn se-tooltip">' + icons.mirror_vertical + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.mirrorVertical + '</span></span></button><button type="button" data-command="onalign" class="se-btn se-tooltip _se_resizing_align_button">' + icons.align_justify + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.toolbar.align + '</span></span></button><div class="se-btn-group-sub sun-editor-common se-list-layer se-resizing-align-list"><div class="se-list-inner"><ul class="se-list-basic"><li><button type="button" class="se-btn-list se-tooltip" data-command="align" data-value="basic">' + icons.align_justify + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.basic + '</span></span></button></li><li><button type="button" class="se-btn-list se-tooltip" data-command="align" data-value="left">' + icons.align_left + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.left + '</span></span></button></li><li><button type="button" class="se-btn-list se-tooltip" data-command="align" data-value="center">' + icons.align_center + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.center + '</span></span></button></li><li><button type="button" class="se-btn-list se-tooltip" data-command="align" data-value="right">' + icons.align_right + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.right + '</span></span></button></li></ul></div></div><button type="button" data-command="caption" class="se-btn se-tooltip _se_resizing_caption_button">' + icons.caption + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.caption + '</span></span></button><button type="button" data-command="revert" class="se-btn se-tooltip">' + icons.revert + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.revertButton + '</span></span></button><button type="button" data-command="update" class="se-btn se-tooltip">' + icons.modify + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.edit + '</span></span></button><button type="button" data-command="delete" class="se-btn se-tooltip">' + icons.delete + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.remove + "</span></span></button></div>";
            return resize_button;
          },
          /**
           * @description Gets the width size
           * @param {Object} contextPlugin context object of plugin (core.context[plugin])
           * @param {Element} element Target element
           * @param {Element} cover Cover element (FIGURE)
           * @param {Element} container Container element (DIV.se-component)
           * @returns {String}
           */
          _module_getSizeX: function(contextPlugin, element, cover, container) {
            if (!element) element = contextPlugin._element;
            if (!cover) cover = contextPlugin._cover;
            if (!container) container = contextPlugin._container;
            if (!element) return "";
            return !/%$/.test(element.style.width) ? element.style.width : (container && this.util.getNumber(container.style.width, 2) || 100) + "%";
          },
          /**
           * @description Gets the height size
           * @param {Object} contextPlugin context object of plugin (core.context[plugin])
           * @param {Element} element Target element
           * @param {Element} cover Cover element (FIGURE)
           * @param {Element} container Container element (DIV.se-component)
           * @returns {String}
           */
          _module_getSizeY: function(contextPlugin, element, cover, container) {
            if (!element) element = contextPlugin._element;
            if (!cover) cover = contextPlugin._cover;
            if (!container) container = contextPlugin._container;
            if (!container || !cover) return element && element.style.height || "";
            return this.util.getNumber(cover.style.paddingBottom, 0) > 0 && !this.context.resizing._rotateVertical ? cover.style.height : !/%$/.test(element.style.height) || !/%$/.test(element.style.width) ? element.style.height : (container && this.util.getNumber(container.style.height, 2) || 100) + "%";
          },
          /**
           * @description Called at the "openModify" to put the size of the current target into the size input element.
           * @param {Object} contextPlugin context object of plugin (core.context[plugin])
           * @param {Object} pluginObj Plugin object
           */
          _module_setModifyInputSize: function(contextPlugin, pluginObj) {
            const percentageRotation = contextPlugin._onlyPercentage && this.context.resizing._rotateVertical;
            contextPlugin.proportion.checked = contextPlugin._proportionChecked = contextPlugin._element.getAttribute("data-proportion") !== "false";
            let x = percentageRotation ? "" : this.plugins.resizing._module_getSizeX.call(this, contextPlugin);
            if (x === contextPlugin._defaultSizeX) x = "";
            if (contextPlugin._onlyPercentage) x = this.util.getNumber(x, 2);
            contextPlugin.inputX.value = x;
            pluginObj.setInputSize.call(this, "x");
            if (!contextPlugin._onlyPercentage) {
              let y = percentageRotation ? "" : this.plugins.resizing._module_getSizeY.call(this, contextPlugin);
              if (y === contextPlugin._defaultSizeY) y = "";
              if (contextPlugin._onlyPercentage) y = this.util.getNumber(y, 2);
              contextPlugin.inputY.value = y;
            }
            contextPlugin.inputX.disabled = percentageRotation ? true : false;
            contextPlugin.inputY.disabled = percentageRotation ? true : false;
            contextPlugin.proportion.disabled = percentageRotation ? true : false;
            pluginObj.setRatio.call(this);
          },
          /**
           * @description It is called in "setInputSize" (input tag keyupEvent), 
           * checks the value entered in the input tag, 
           * calculates the ratio, and sets the calculated value in the input tag of the opposite size.
           * @param {Object} contextPlugin context object of plugin (core.context[plugin])
           * @param {String} xy 'x': width, 'y': height
           */
          _module_setInputSize: function(contextPlugin, xy) {
            if (contextPlugin._onlyPercentage) {
              if (xy === "x" && contextPlugin.inputX.value > 100) contextPlugin.inputX.value = 100;
              return;
            }
            if (contextPlugin.proportion.checked && contextPlugin._ratio && /\d/.test(contextPlugin.inputX.value) && /\d/.test(contextPlugin.inputY.value)) {
              const xUnit = contextPlugin.inputX.value.replace(/\d+|\./g, "") || contextPlugin.sizeUnit;
              const yUnit = contextPlugin.inputY.value.replace(/\d+|\./g, "") || contextPlugin.sizeUnit;
              if (xUnit !== yUnit) return;
              const dec = xUnit === "%" ? 2 : 0;
              if (xy === "x") {
                contextPlugin.inputY.value = this.util.getNumber(contextPlugin._ratioY * this.util.getNumber(contextPlugin.inputX.value, dec), dec) + yUnit;
              } else {
                contextPlugin.inputX.value = this.util.getNumber(contextPlugin._ratioX * this.util.getNumber(contextPlugin.inputY.value, dec), dec) + xUnit;
              }
            }
          },
          /**
           * @description It is called in "setRatio" (input and proportionCheck tags changeEvent), 
           * checks the value of the input tag, calculates the ratio, and resets it in the input tag.
           * @param {Object} contextPlugin context object of plugin (core.context[plugin])
           */
          _module_setRatio: function(contextPlugin) {
            const xValue = contextPlugin.inputX.value;
            const yValue = contextPlugin.inputY.value;
            if (contextPlugin.proportion.checked && /\d+/.test(xValue) && /\d+/.test(yValue)) {
              const xUnit = xValue.replace(/\d+|\./g, "") || contextPlugin.sizeUnit;
              const yUnit = yValue.replace(/\d+|\./g, "") || contextPlugin.sizeUnit;
              if (xUnit !== yUnit) {
                contextPlugin._ratio = false;
              } else if (!contextPlugin._ratio) {
                const x = this.util.getNumber(xValue, 0);
                const y = this.util.getNumber(yValue, 0);
                contextPlugin._ratio = true;
                contextPlugin._ratioX = x / y;
                contextPlugin._ratioY = y / x;
              }
            } else {
              contextPlugin._ratio = false;
            }
          },
          /**
           * @description Revert size of element to origin size (plugin._origin_w, plugin._origin_h)
           * @param {Object} contextPlugin context object of plugin (core.context[plugin])
           */
          _module_sizeRevert: function(contextPlugin) {
            if (contextPlugin._onlyPercentage) {
              contextPlugin.inputX.value = contextPlugin._origin_w > 100 ? 100 : contextPlugin._origin_w;
            } else {
              contextPlugin.inputX.value = contextPlugin._origin_w;
              contextPlugin.inputY.value = contextPlugin._origin_h;
            }
          },
          /**
           * @description Save the size data (element.setAttribute("data-size"))
           * Used at the "setSize" method
           * @param {Object} contextPlugin context object of plugin (core.context[plugin])
           */
          _module_saveCurrentSize: function(contextPlugin) {
            const x = this.plugins.resizing._module_getSizeX.call(this, contextPlugin);
            const y = this.plugins.resizing._module_getSizeY.call(this, contextPlugin);
            contextPlugin._element.setAttribute("width", x.replace("px", ""));
            contextPlugin._element.setAttribute("height", y.replace("px", ""));
            contextPlugin._element.setAttribute("data-size", x + "," + y);
            if (!!contextPlugin._videoRatio) contextPlugin._videoRatio = y;
          },
          /**
           * @description Call the resizing module
           * @param {Element} targetElement Resizing target element
           * @param {string} plugin Plugin name
           * @returns {Object} Size of resizing div {w, h, t, l}
           */
          call_controller_resize: function(targetElement, plugin) {
            const contextResizing = this.context.resizing;
            const contextPlugin = this.context[plugin];
            contextResizing._resize_plugin = plugin;
            const resizeContainer = contextResizing.resizeContainer;
            const resizeDiv = contextResizing.resizeDiv;
            const offset = this.util.getOffset(targetElement, this.context.element.wysiwygFrame);
            const isVertical = contextResizing._rotateVertical = /^(90|270)$/.test(Math.abs(targetElement.getAttribute("data-rotate")).toString());
            const w = isVertical ? targetElement.offsetHeight : targetElement.offsetWidth;
            const h = isVertical ? targetElement.offsetWidth : targetElement.offsetHeight;
            const t = offset.top;
            const l = offset.left - this.context.element.wysiwygFrame.scrollLeft;
            resizeContainer.style.top = t + "px";
            resizeContainer.style.left = l + "px";
            resizeContainer.style.width = w + "px";
            resizeContainer.style.height = h + "px";
            resizeDiv.style.top = "0px";
            resizeDiv.style.left = "0px";
            resizeDiv.style.width = w + "px";
            resizeDiv.style.height = h + "px";
            let align = targetElement.getAttribute("data-align") || "basic";
            align = align === "none" ? "basic" : align;
            const container = this.util.getParentElement(targetElement, this.util.isComponent);
            const cover = this.util.getParentElement(targetElement, "FIGURE");
            const displayX = this.plugins.resizing._module_getSizeX.call(this, contextPlugin, targetElement, cover, container) || "auto";
            const displayY = contextPlugin._onlyPercentage && plugin === "image" ? "" : ", " + (this.plugins.resizing._module_getSizeY.call(this, contextPlugin, targetElement, cover, container) || "auto");
            this.util.changeTxt(contextResizing.resizeDisplay, this.lang.dialogBox[align] + " (" + displayX + displayY + ")");
            contextResizing.resizeButtonGroup.style.display = contextPlugin._resizing ? "" : "none";
            const resizeDotShow = contextPlugin._resizing && !contextPlugin._resizeDotHide && !contextPlugin._onlyPercentage ? "flex" : "none";
            const resizeHandles = contextResizing.resizeHandles;
            for (let i = 0, len = resizeHandles.length; i < len; i++) {
              resizeHandles[i].style.display = resizeDotShow;
            }
            if (contextPlugin._resizing) {
              const rotations = contextResizing.rotationButtons;
              rotations[0].style.display = rotations[1].style.display = contextPlugin._rotation ? "" : "none";
            }
            if (contextPlugin._alignHide) {
              contextResizing.alignButton.style.display = "none";
            } else {
              contextResizing.alignButton.style.display = "";
              const alignList = contextResizing.alignMenuList;
              this.util.changeElement(contextResizing.alignButton.firstElementChild, contextResizing.alignIcons[align]);
              for (let i = 0, len = alignList.length; i < len; i++) {
                if (alignList[i].getAttribute("data-value") === align) this.util.addClass(alignList[i], "on");
                else this.util.removeClass(alignList[i], "on");
              }
            }
            const pButtons = contextResizing.percentageButtons;
            const value = /%$/.test(targetElement.style.width) && /%$/.test(container.style.width) ? this.util.getNumber(container.style.width, 0) / 100 + "" : "";
            for (let i = 0, len = pButtons.length; i < len; i++) {
              if (pButtons[i].getAttribute("data-value") === value) {
                this.util.addClass(pButtons[i], "active");
              } else {
                this.util.removeClass(pButtons[i], "active");
              }
            }
            if (!contextPlugin._captionShow) {
              contextResizing.captionButton.style.display = "none";
            } else {
              contextResizing.captionButton.style.display = "";
              if (this.util.getChildElement(targetElement.parentNode, "figcaption")) {
                this.util.addClass(contextResizing.captionButton, "active");
                contextPlugin._captionChecked = true;
              } else {
                this.util.removeClass(contextResizing.captionButton, "active");
                contextPlugin._captionChecked = false;
              }
            }
            resizeContainer.style.display = "block";
            const addOffset = { left: 0, top: 50 };
            if (this.options.iframe) {
              addOffset.left -= this.context.element.wysiwygFrame.parentElement.offsetLeft;
              addOffset.top -= this.context.element.wysiwygFrame.parentElement.offsetTop;
            }
            this.setControllerPosition(contextResizing.resizeButton, resizeContainer, "bottom", addOffset);
            const onControlsOff = function() {
              this.util.setDisabledButtons.call(this.util, false, this.resizingDisabledButtons);
              this.history._resetCachingButton();
            };
            this.controllersOn(resizeContainer, contextResizing.resizeButton, onControlsOff.bind(this), targetElement, plugin);
            this.util.setDisabledButtons(true, this.resizingDisabledButtons);
            contextResizing._resize_w = w;
            contextResizing._resize_h = h;
            const originSize = (targetElement.getAttribute("origin-size") || "").split(",");
            contextResizing._origin_w = originSize[0] || targetElement.naturalWidth;
            contextResizing._origin_h = originSize[1] || targetElement.naturalHeight;
            return {
              w,
              h,
              t,
              l
            };
          },
          _closeAlignMenu: null,
          /**
           * @description Open align submenu of module
           */
          openAlignMenu: function() {
            const alignButton = this.context.resizing.alignButton;
            this.util.addClass(alignButton, "on");
            this.context.resizing.alignMenu.style.top = alignButton.offsetTop + alignButton.offsetHeight + "px";
            this.context.resizing.alignMenu.style.left = alignButton.offsetLeft - alignButton.offsetWidth / 2 + "px";
            this.context.resizing.alignMenu.style.display = "block";
            this.plugins.resizing._closeAlignMenu = function() {
              this.util.removeClass(this.context.resizing.alignButton, "on");
              this.context.resizing.alignMenu.style.display = "none";
              this.removeDocEvent("click", this.plugins.resizing._closeAlignMenu);
              this.plugins.resizing._closeAlignMenu = null;
            }.bind(this);
            this.addDocEvent("click", this.plugins.resizing._closeAlignMenu);
          },
          /**
           * @description Click event of resizing toolbar
           * Performs the action of the clicked toolbar button.
           * @param {MouseEvent} e Event object
           */
          onClick_resizeButton: function(e) {
            e.stopPropagation();
            const target = e.target;
            const command = target.getAttribute("data-command") || target.parentNode.getAttribute("data-command");
            if (!command) return;
            const value = target.getAttribute("data-value") || target.parentNode.getAttribute("data-value");
            const pluginName = this.context.resizing._resize_plugin;
            const currentContext = this.context[pluginName];
            const contextEl = currentContext._element;
            const currentModule = this.plugins[pluginName];
            e.preventDefault();
            if (typeof this.plugins.resizing._closeAlignMenu === "function") {
              this.plugins.resizing._closeAlignMenu();
              if (command === "onalign") return;
            }
            switch (command) {
              case "auto":
                this.plugins.resizing.resetTransform.call(this, contextEl);
                currentModule.setAutoSize.call(this);
                this.selectComponent(contextEl, pluginName);
                break;
              case "percent":
                let percentY = this.plugins.resizing._module_getSizeY.call(this, currentContext);
                if (this.context.resizing._rotateVertical) {
                  const percentage = contextEl.getAttribute("data-percentage");
                  if (percentage) percentY = percentage.split(",")[1];
                }
                this.plugins.resizing.resetTransform.call(this, contextEl);
                currentModule.setPercentSize.call(this, value * 100, this.util.getNumber(percentY, 0) === null || !/%$/.test(percentY) ? "" : percentY);
                this.selectComponent(contextEl, pluginName);
                break;
              case "mirror":
                const r = contextEl.getAttribute("data-rotate") || "0";
                let x = contextEl.getAttribute("data-rotateX") || "";
                let y = contextEl.getAttribute("data-rotateY") || "";
                if (value === "h" && !this.context.resizing._rotateVertical || value === "v" && this.context.resizing._rotateVertical) {
                  y = y ? "" : "180";
                } else {
                  x = x ? "" : "180";
                }
                contextEl.setAttribute("data-rotateX", x);
                contextEl.setAttribute("data-rotateY", y);
                this.plugins.resizing._setTransForm(contextEl, r, x, y);
                break;
              case "rotate":
                const contextResizing = this.context.resizing;
                const slope = contextEl.getAttribute("data-rotate") * 1 + value * 1;
                const deg = this._w.Math.abs(slope) >= 360 ? 0 : slope;
                contextEl.setAttribute("data-rotate", deg);
                contextResizing._rotateVertical = /^(90|270)$/.test(this._w.Math.abs(deg).toString());
                this.plugins.resizing.setTransformSize.call(this, contextEl, null, null);
                this.selectComponent(contextEl, pluginName);
                break;
              case "onalign":
                this.plugins.resizing.openAlignMenu.call(this);
                return;
              case "align":
                const alignValue = value === "basic" ? "none" : value;
                currentModule.setAlign.call(this, alignValue, null, null, null);
                this.selectComponent(contextEl, pluginName);
                break;
              case "caption":
                const caption = !currentContext._captionChecked;
                currentModule.openModify.call(this, true);
                currentContext._captionChecked = currentContext.captionCheckEl.checked = caption;
                currentModule.update_image.call(this, false, false, false);
                if (caption) {
                  const captionText = this.util.getChildElement(currentContext._caption, function(current) {
                    return current.nodeType === 3;
                  });
                  if (!captionText) {
                    currentContext._caption.focus();
                  } else {
                    this.setRange(captionText, 0, captionText, captionText.textContent.length);
                  }
                  this.controllersOff();
                } else {
                  this.selectComponent(contextEl, pluginName);
                  currentModule.openModify.call(this, true);
                }
                break;
              case "revert":
                currentModule.setOriginSize.call(this);
                this.selectComponent(contextEl, pluginName);
                break;
              case "update":
                currentModule.openModify.call(this);
                this.controllersOff();
                break;
              case "delete":
                currentModule.destroy.call(this);
                break;
            }
            this.history.push(false);
          },
          /**
           * @description Initialize the transform style (rotation) of the element.
           * @param {Element} element Target element
           */
          resetTransform: function(element) {
            const size = (element.getAttribute("data-size") || element.getAttribute("data-origin") || "").split(",");
            this.context.resizing._rotateVertical = false;
            element.style.maxWidth = "";
            element.style.transform = "";
            element.style.transformOrigin = "";
            element.setAttribute("data-rotate", "");
            element.setAttribute("data-rotateX", "");
            element.setAttribute("data-rotateY", "");
            this.plugins[this.context.resizing._resize_plugin].setSize.call(this, size[0] ? size[0] : "auto", size[1] ? size[1] : "", true);
          },
          /**
           * @description Set the transform style (rotation) of the element.
           * @param {Element} element Target element
           * @param {Number|null} width Element's width size
           * @param {Number|null} height Element's height size
           */
          setTransformSize: function(element, width, height) {
            let percentage = element.getAttribute("data-percentage");
            const isVertical = this.context.resizing._rotateVertical;
            const deg = element.getAttribute("data-rotate") * 1;
            let transOrigin = "";
            if (percentage && !isVertical) {
              percentage = percentage.split(",");
              if (percentage[0] === "auto" && percentage[1] === "auto") {
                this.plugins[this.context.resizing._resize_plugin].setAutoSize.call(this);
              } else {
                this.plugins[this.context.resizing._resize_plugin].setPercentSize.call(this, percentage[0], percentage[1]);
              }
            } else {
              const cover = this.util.getParentElement(element, "FIGURE");
              const offsetW = width || element.offsetWidth;
              const offsetH = height || element.offsetHeight;
              const w = (isVertical ? offsetH : offsetW) + "px";
              const h = (isVertical ? offsetW : offsetH) + "px";
              this.plugins[this.context.resizing._resize_plugin].cancelPercentAttr.call(this);
              this.plugins[this.context.resizing._resize_plugin].setSize.call(this, offsetW + "px", offsetH + "px", true);
              cover.style.width = w;
              cover.style.height = !!this.context[this.context.resizing._resize_plugin]._caption ? "" : h;
              if (isVertical) {
                let transW = offsetW / 2 + "px " + offsetW / 2 + "px 0";
                let transH = offsetH / 2 + "px " + offsetH / 2 + "px 0";
                transOrigin = deg === 90 || deg === -270 ? transH : transW;
              }
            }
            element.style.transformOrigin = transOrigin;
            this.plugins.resizing._setTransForm(element, deg.toString(), element.getAttribute("data-rotateX") || "", element.getAttribute("data-rotateY") || "");
            if (isVertical) element.style.maxWidth = "none";
            else element.style.maxWidth = "";
            this.plugins.resizing.setCaptionPosition.call(this, element);
          },
          _setTransForm: function(element, r, x, y) {
            let width = (element.offsetWidth - element.offsetHeight) * (/-/.test(r) ? 1 : -1);
            let translate2 = "";
            if (/[1-9]/.test(r) && (x || y)) {
              translate2 = x ? "Y" : "X";
              switch (r) {
                case "90":
                  translate2 = x && y ? "X" : y ? translate2 : "";
                  break;
                case "270":
                  width *= -1;
                  translate2 = x && y ? "Y" : x ? translate2 : "";
                  break;
                case "-90":
                  translate2 = x && y ? "Y" : x ? translate2 : "";
                  break;
                case "-270":
                  width *= -1;
                  translate2 = x && y ? "X" : y ? translate2 : "";
                  break;
                default:
                  translate2 = "";
              }
            }
            if (r % 180 === 0) {
              element.style.maxWidth = "";
            }
            element.style.transform = "rotate(" + r + "deg)" + (x ? " rotateX(" + x + "deg)" : "") + (y ? " rotateY(" + y + "deg)" : "") + (translate2 ? " translate" + translate2 + "(" + width + "px)" : "");
          },
          /**
           * @description The position of the caption is set automatically.
           * @param {Element} element Target element (not caption element)
           */
          setCaptionPosition: function(element) {
            const figcaption = this.util.getChildElement(this.util.getParentElement(element, "FIGURE"), "FIGCAPTION");
            if (figcaption) {
              figcaption.style.marginTop = (this.context.resizing._rotateVertical ? element.offsetWidth - element.offsetHeight : 0) + "px";
            }
          },
          /**
           * @description Mouse down event of resize handles
           * @param {MouseEvent} e Event object 
           */
          onMouseDown_resize_handle: function(e) {
            e.stopPropagation();
            e.preventDefault();
            const contextResizing = this.context.resizing;
            const direction = contextResizing._resize_direction = e.target.classList[0];
            contextResizing._resizeClientX = e.clientX;
            contextResizing._resizeClientY = e.clientY;
            this.context.element.resizeBackground.style.display = "block";
            contextResizing.resizeButton.style.display = "none";
            contextResizing.resizeDiv.style.float = /l/.test(direction) ? "right" : /r/.test(direction) ? "left" : "none";
            const closureFunc_bind = function closureFunc(e2) {
              if (e2.type === "keydown" && e2.keyCode !== 27) return;
              const change = contextResizing._isChange;
              contextResizing._isChange = false;
              this.removeDocEvent("mousemove", resizing_element_bind);
              this.removeDocEvent("mouseup", closureFunc_bind);
              this.removeDocEvent("keydown", closureFunc_bind);
              if (e2.type === "keydown") {
                this.controllersOff();
                this.context.element.resizeBackground.style.display = "none";
                this.plugins[this.context.resizing._resize_plugin].init.call(this);
              } else {
                this.plugins.resizing.cancel_controller_resize.call(this, direction);
                if (change) this.history.push(false);
              }
            }.bind(this);
            const resizing_element_bind = this.plugins.resizing.resizing_element.bind(this, contextResizing, direction, this.context[contextResizing._resize_plugin]);
            this.addDocEvent("mousemove", resizing_element_bind);
            this.addDocEvent("mouseup", closureFunc_bind);
            this.addDocEvent("keydown", closureFunc_bind);
          },
          /**
           * @description Mouse move event after call "onMouseDown_resize_handle" of resize handles
           * The size of the module's "div" is adjusted according to the mouse move event.
           * @param {Object} contextResizing "core.context.resizing" object (binding argument)
           * @param {String} direction Direction ("tl", "tr", "bl", "br", "lw", "th", "rw", "bh") (binding argument)
           * @param {Object} plugin "core.context[currentPlugin]" object (binding argument)
           * @param {MouseEvent} e Event object
           */
          resizing_element: function(contextResizing, direction, plugin, e) {
            const clientX = e.clientX;
            const clientY = e.clientY;
            let resultW = plugin._element_w;
            let resultH = plugin._element_h;
            const w = plugin._element_w + (/r/.test(direction) ? clientX - contextResizing._resizeClientX : contextResizing._resizeClientX - clientX);
            const h = plugin._element_h + (/b/.test(direction) ? clientY - contextResizing._resizeClientY : contextResizing._resizeClientY - clientY);
            const wh = plugin._element_h / plugin._element_w * w;
            if (/t/.test(direction)) contextResizing.resizeDiv.style.top = plugin._element_h - (/h/.test(direction) ? h : wh) + "px";
            if (/l/.test(direction)) contextResizing.resizeDiv.style.left = plugin._element_w - w + "px";
            if (/r|l/.test(direction)) {
              contextResizing.resizeDiv.style.width = w + "px";
              resultW = w;
            }
            if (/^(t|b)[^h]$/.test(direction)) {
              contextResizing.resizeDiv.style.height = wh + "px";
              resultH = wh;
            } else if (/^(t|b)h$/.test(direction)) {
              contextResizing.resizeDiv.style.height = h + "px";
              resultH = h;
            }
            contextResizing._resize_w = resultW;
            contextResizing._resize_h = resultH;
            this.util.changeTxt(contextResizing.resizeDisplay, this._w.Math.round(resultW) + " x " + this._w.Math.round(resultH));
            contextResizing._isChange = true;
          },
          /**
           * @description Resize the element to the size of the "div" adjusted in the "resizing_element" method.
           * Called at the mouse-up event registered in "onMouseDown_resize_handle".
           * @param {String} direction Direction ("tl", "tr", "bl", "br", "lw", "th", "rw", "bh")
           */
          cancel_controller_resize: function(direction) {
            const isVertical = this.context.resizing._rotateVertical;
            this.controllersOff();
            this.context.element.resizeBackground.style.display = "none";
            let w = this._w.Math.round(isVertical ? this.context.resizing._resize_h : this.context.resizing._resize_w);
            let h = this._w.Math.round(isVertical ? this.context.resizing._resize_w : this.context.resizing._resize_h);
            if (!isVertical && !/%$/.test(w)) {
              const padding = 16;
              const limit = this.context.element.wysiwygFrame.clientWidth - padding * 2 - 2;
              if (this.util.getNumber(w, 0) > limit) {
                h = this._w.Math.round(h / w * limit);
                w = limit;
              }
            }
            const pluginName = this.context.resizing._resize_plugin;
            this.plugins[pluginName].setSize.call(this, w, h, false, direction);
            if (isVertical) this.plugins.resizing.setTransformSize.call(this, this.context[this.context.resizing._resize_plugin]._element, w, h);
            this.selectComponent(this.context[pluginName]._element, pluginName);
          }
        };
        if (typeof noGlobal === "undefined") {
          if (!window2.SUNEDITOR_MODULES) {
            Object.defineProperty(window2, "SUNEDITOR_MODULES", {
              enumerable: true,
              writable: false,
              configurable: false,
              value: {}
            });
          }
          Object.defineProperty(window2.SUNEDITOR_MODULES, "resizing", {
            enumerable: true,
            writable: false,
            configurable: false,
            value: resizing3
          });
        }
        return resizing3;
      });
    }
  });

  // ../../node_modules/suneditor/src/plugins/modules/fileManager.js
  var require_fileManager = __commonJS({
    "../../node_modules/suneditor/src/plugins/modules/fileManager.js"(exports, module) {
      "use strict";
      (function(global2, factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global2.document ? factory(global2, true) : function(w) {
            if (!w.document) {
              throw new Error("SUNEDITOR_MODULES a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global2);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        const fileManager4 = {
          name: "fileManager",
          _xmlHttp: null,
          _checkMediaComponent: function(tag) {
            if (/IMG/i.test(tag)) {
              return !/FIGURE/i.test(tag.parentElement.nodeName) || !/FIGURE/i.test(tag.parentElement.parentElement.nodeName);
            }
            return true;
          },
          /**
           * @description Upload the file to the server.
           * @param {String} uploadUrl Upload server url
           * @param {Object|null} uploadHeader Request header
           * @param {FormData} formData FormData in body
           * @param {Function|null} callBack Success call back function
           * @param {Function|null} errorCallBack Error call back function
           * @example this.plugins.fileManager.upload.call(this, imageUploadUrl, this.options.imageUploadHeader, formData, this.plugins.image.callBack_imgUpload.bind(this, info), this.functions.onImageUploadError);
           */
          upload: function(uploadUrl, uploadHeader, formData, callBack, errorCallBack) {
            this.showLoading();
            const filePlugin = this.plugins.fileManager;
            const xmlHttp = filePlugin._xmlHttp = this.util.getXMLHttpRequest();
            xmlHttp.onreadystatechange = filePlugin._callBackUpload.bind(this, xmlHttp, callBack, errorCallBack);
            xmlHttp.open("post", uploadUrl, true);
            if (uploadHeader !== null && typeof uploadHeader === "object" && this._w.Object.keys(uploadHeader).length > 0) {
              for (let key in uploadHeader) {
                xmlHttp.setRequestHeader(key, uploadHeader[key]);
              }
            }
            xmlHttp.send(formData);
          },
          _callBackUpload: function(xmlHttp, callBack, errorCallBack) {
            if (xmlHttp.readyState === 4) {
              if (xmlHttp.status === 200) {
                try {
                  callBack(xmlHttp);
                } catch (e) {
                  throw Error('[SUNEDITOR.fileManager.upload.callBack.fail] cause : "' + e.message + '"');
                } finally {
                  this.closeLoading();
                }
              } else {
                this.closeLoading();
                const res = !xmlHttp.responseText ? xmlHttp : JSON.parse(xmlHttp.responseText);
                if (typeof errorCallBack !== "function" || errorCallBack("", res, this)) {
                  const err = "[SUNEDITOR.fileManager.upload.serverException] status: " + xmlHttp.status + ", response: " + (res.errorMessage || xmlHttp.responseText);
                  this.functions.noticeOpen(err);
                  throw Error(err);
                }
              }
            }
          },
          /**
           * @description Checke the file's information and modify the tag that does not fit the format.
           * @param {String} pluginName Plugin name
           * @param {Array} tagNames Tag array to check
           * @param {Function|null} uploadEventHandler Event handler to process updated file info after checking (used in "setInfo")
           * @param {Function} modifyHandler A function to modify a tag that does not fit the format (Argument value: Tag element)
           * @param {Boolean} resizing True if the plugin is using a resizing module
           * @example 
           * const modifyHandler = function (tag) {
           *      imagePlugin.onModifyMode.call(this, tag, null);
           *      imagePlugin.openModify.call(this, true);
           *      imagePlugin.update_image.call(this, true, false, true);
           *  }.bind(this);
           *  this.plugins.fileManager.checkInfo.call(this, 'image', ['img'], this.functions.onImageUpload, modifyHandler, true);
           */
          checkInfo: function(pluginName, tagNames, uploadEventHandler, modifyHandler, resizing3) {
            let tags = [];
            for (let i = 0, len = tagNames.length; i < len; i++) {
              tags = tags.concat([].slice.call(this.context.element.wysiwyg.querySelectorAll(tagNames[i] + ':not([data-se-embed="true"])')));
            }
            const fileManagerPlugin = this.plugins.fileManager;
            const context = this.context[pluginName];
            const infoList = context._infoList;
            const setFileInfo = fileManagerPlugin.setInfo.bind(this);
            if (tags.length === infoList.length) {
              if (this._componentsInfoReset) {
                for (let i = 0, len = tags.length; i < len; i++) {
                  setFileInfo(pluginName, tags[i], uploadEventHandler, null, resizing3);
                }
                return;
              } else {
                let infoUpdate = false;
                for (let i = 0, len = infoList.length, info; i < len; i++) {
                  info = infoList[i];
                  if (tags.filter(function(t) {
                    return info.src === t.src && info.index.toString() === t.getAttribute("data-index");
                  }).length === 0) {
                    infoUpdate = true;
                    break;
                  }
                }
                if (!infoUpdate) return;
              }
            }
            const _resize_plugin = resizing3 ? this.context.resizing._resize_plugin : "";
            if (resizing3) this.context.resizing._resize_plugin = pluginName;
            const currentTags = [];
            const infoIndex = [];
            for (let i = 0, len = infoList.length; i < len; i++) {
              infoIndex[i] = infoList[i].index;
            }
            context.__updateTags = tags;
            while (tags.length > 0) {
              const tag = tags.shift();
              if (!this.util.getParentElement(tag, this.util.isMediaComponent) || !fileManagerPlugin._checkMediaComponent(tag)) {
                currentTags.push(context._infoIndex);
                modifyHandler(tag);
              } else if (!tag.getAttribute("data-index") || infoIndex.indexOf(tag.getAttribute("data-index") * 1) < 0) {
                currentTags.push(context._infoIndex);
                tag.removeAttribute("data-index");
                setFileInfo(pluginName, tag, uploadEventHandler, null, resizing3);
              } else {
                currentTags.push(tag.getAttribute("data-index") * 1);
              }
            }
            for (let i = 0, dataIndex; i < infoList.length; i++) {
              dataIndex = infoList[i].index;
              if (currentTags.indexOf(dataIndex) > -1) continue;
              infoList.splice(i, 1);
              if (typeof uploadEventHandler === "function") uploadEventHandler(null, dataIndex, "delete", null, 0, this);
              i--;
            }
            if (resizing3) this.context.resizing._resize_plugin = _resize_plugin;
          },
          /**
           * @description Create info object of file and add it to "_infoList" (this.context[pluginName]._infoList[])
           * @param {String} pluginName Plugin name 
           * @param {Element} element 
           * @param {Function|null} uploadEventHandler Event handler to process updated file info (created in setInfo)
           * @param {Object|null} file 
           * @param {Boolean} resizing True if the plugin is using a resizing module
           * @example 
           * uploadCallBack {.. file = { name: fileList[i].name, size: fileList[i].size };
           * this.plugins.fileManager.setInfo.call(this, 'image', oImg, this.functions.onImageUpload, file, true);
           */
          setInfo: function(pluginName, element, uploadEventHandler, file, resizing3) {
            const _resize_plugin = resizing3 ? this.context.resizing._resize_plugin : "";
            if (resizing3) this.context.resizing._resize_plugin = pluginName;
            const plguin = this.plugins[pluginName];
            const context = this.context[pluginName];
            const infoList = context._infoList;
            let dataIndex = element.getAttribute("data-index");
            let info = null;
            let state = "";
            if (!file) {
              file = {
                "name": element.getAttribute("data-file-name") || (typeof element.src === "string" ? element.src.split("/").pop() : ""),
                "size": element.getAttribute("data-file-size") || 0
              };
            }
            if (!dataIndex || this._componentsInfoInit) {
              state = "create";
              dataIndex = context._infoIndex++;
              element.setAttribute("data-index", dataIndex);
              element.setAttribute("data-file-name", file.name);
              element.setAttribute("data-file-size", file.size);
              info = {
                src: element.src,
                index: dataIndex * 1,
                name: file.name,
                size: file.size
              };
              infoList.push(info);
            } else {
              state = "update";
              dataIndex *= 1;
              for (let i = 0, len = infoList.length; i < len; i++) {
                if (dataIndex === infoList[i].index) {
                  info = infoList[i];
                  break;
                }
              }
              if (!info) {
                dataIndex = context._infoIndex++;
                info = { index: dataIndex };
                infoList.push(info);
              }
              info.src = element.src;
              info.name = element.getAttribute("data-file-name");
              info.size = element.getAttribute("data-file-size") * 1;
            }
            info.element = element;
            info.delete = plguin.destroy.bind(this, element);
            info.select = function(element2) {
              element2.scrollIntoView(true);
              this._w.setTimeout(plguin.select.bind(this, element2));
            }.bind(this, element);
            if (resizing3) {
              if (!element.getAttribute("origin-size") && element.naturalWidth) {
                element.setAttribute("origin-size", element.naturalWidth + "," + element.naturalHeight);
              }
              if (!element.getAttribute("data-origin")) {
                const container = this.util.getParentElement(element, this.util.isMediaComponent);
                const cover = this.util.getParentElement(element, "FIGURE");
                const w = this.plugins.resizing._module_getSizeX.call(this, context, element, cover, container);
                const h = this.plugins.resizing._module_getSizeY.call(this, context, element, cover, container);
                element.setAttribute("data-origin", w + "," + h);
                element.setAttribute("data-size", w + "," + h);
              }
              if (!element.style.width) {
                const size = (element.getAttribute("data-size") || element.getAttribute("data-origin") || "").split(",");
                plguin.onModifyMode.call(this, element, null);
                plguin.applySize.call(this, size[0], size[1]);
              }
              this.context.resizing._resize_plugin = _resize_plugin;
            }
            if (typeof uploadEventHandler === "function") uploadEventHandler(element, dataIndex, state, info, --context._uploadFileLength < 0 ? 0 : context._uploadFileLength, this);
          },
          /**
           * @description Delete info object at "_infoList"
           * @param {String} pluginName Plugin name 
           * @param {Number} index index of info object (this.context[pluginName]._infoList[].index)
           * @param {Function|null} uploadEventHandler Event handler to process updated file info (created in setInfo)
           */
          deleteInfo: function(pluginName, index, uploadEventHandler) {
            if (index >= 0) {
              const infoList = this.context[pluginName]._infoList;
              for (let i = 0, len = infoList.length; i < len; i++) {
                if (index === infoList[i].index) {
                  infoList.splice(i, 1);
                  if (typeof uploadEventHandler === "function") uploadEventHandler(null, index, "delete", null, 0, this);
                  return;
                }
              }
            }
          },
          /**
           * @description Reset info object and "_infoList = []", "_infoIndex = 0"
           * @param {String} pluginName Plugin name 
           * @param {Function|null} uploadEventHandler Event handler to process updated file info (created in setInfo)
           */
          resetInfo: function(pluginName, uploadEventHandler) {
            const context = this.context[pluginName];
            if (typeof uploadEventHandler === "function") {
              const infoList = context._infoList;
              for (let i = 0, len = infoList.length; i < len; i++) {
                uploadEventHandler(null, infoList[i].index, "delete", null, 0, this);
              }
            }
            context._infoList = [];
            context._infoIndex = 0;
          }
        };
        if (typeof noGlobal === "undefined") {
          if (!window2.SUNEDITOR_MODULES) {
            Object.defineProperty(window2, "SUNEDITOR_MODULES", {
              enumerable: true,
              writable: false,
              configurable: false,
              value: {}
            });
          }
          Object.defineProperty(window2.SUNEDITOR_MODULES, "fileManager", {
            enumerable: true,
            writable: false,
            configurable: false,
            value: fileManager4
          });
        }
        return fileManager4;
      });
    }
  });

  // ../../node_modules/suneditor/src/plugins/modules/fileBrowser.js
  var require_fileBrowser = __commonJS({
    "../../node_modules/suneditor/src/plugins/modules/fileBrowser.js"(exports, module) {
      "use strict";
      (function(global2, factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global2.document ? factory(global2, true) : function(w) {
            if (!w.document) {
              throw new Error("SUNEDITOR_MODULES a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global2);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        const fileBrowser2 = {
          name: "fileBrowser",
          _xmlHttp: null,
          _loading: null,
          /**
           * @description Constructor
           * @param {Object} core Core object 
           */
          add: function(core) {
            const context = core.context;
            context.fileBrowser = {
              _closeSignal: false,
              area: null,
              header: null,
              tagArea: null,
              body: null,
              list: null,
              tagElements: null,
              items: [],
              selectedTags: [],
              selectorHandler: null,
              contextPlugin: "",
              columnSize: 4
            };
            let browser_div = core.util.createElement("DIV");
            browser_div.className = "se-file-browser sun-editor-common";
            let back = core.util.createElement("DIV");
            back.className = "se-file-browser-back";
            let content = core.util.createElement("DIV");
            content.className = "se-file-browser-inner";
            content.innerHTML = this.set_browser(core);
            browser_div.appendChild(back);
            browser_div.appendChild(content);
            this._loading = browser_div.querySelector(".se-loading-box");
            context.fileBrowser.area = browser_div;
            context.fileBrowser.header = content.querySelector(".se-file-browser-header");
            context.fileBrowser.titleArea = content.querySelector(".se-file-browser-title");
            context.fileBrowser.tagArea = content.querySelector(".se-file-browser-tags");
            context.fileBrowser.body = content.querySelector(".se-file-browser-body");
            context.fileBrowser.list = content.querySelector(".se-file-browser-list");
            context.fileBrowser.tagArea.addEventListener("click", this.onClickTag.bind(core));
            context.fileBrowser.list.addEventListener("click", this.onClickFile.bind(core));
            content.addEventListener("mousedown", this._onMouseDown_browser.bind(core));
            content.addEventListener("click", this._onClick_browser.bind(core));
            context.element.relative.appendChild(browser_div);
            browser_div = null, back = null, content = null;
          },
          set_browser: function(core) {
            const lang = core.lang;
            return '<div class="se-file-browser-content"><div class="se-file-browser-header"><button type="button" data-command="close" class="se-btn se-file-browser-close" class="close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + core.icons.cancel + '</button><span class="se-file-browser-title"></span><div class="se-file-browser-tags"></div></div><div class="se-file-browser-body"><div class="se-loading-box sun-editor-common"><div class="se-loading-effect"></div></div><div class="se-file-browser-list"></div></div></div>';
          },
          /**
           * @description Event to control the behavior of closing the browser
           * @param {MouseEvent} e Event object
           * @private
           */
          _onMouseDown_browser: function(e) {
            if (/se-file-browser-inner/.test(e.target.className)) {
              this.context.fileBrowser._closeSignal = true;
            } else {
              this.context.fileBrowser._closeSignal = false;
            }
          },
          /**
           * @description Event to close the window when the outside area of the browser or close button is click
           * @param {MouseEvent} e Event object
           * @private
           */
          _onClick_browser: function(e) {
            e.stopPropagation();
            if (/close/.test(e.target.getAttribute("data-command")) || this.context.fileBrowser._closeSignal) {
              this.plugins.fileBrowser.close.call(this);
            }
          },
          /**
           * @description Open a file browser plugin
           * @param {String} pluginName Plugin name using the file browser
           * @param {Function|null} selectorHandler When the function comes as an argument value, it substitutes "context.selectorHandler".
           */
          open: function(pluginName, selectorHandler) {
            if (this.plugins.fileBrowser._bindClose) {
              this._d.removeEventListener("keydown", this.plugins.fileBrowser._bindClose);
              this.plugins.fileBrowser._bindClose = null;
            }
            this.plugins.fileBrowser._bindClose = function(e) {
              if (!/27/.test(e.keyCode)) return;
              this.plugins.fileBrowser.close.call(this);
            }.bind(this);
            this._d.addEventListener("keydown", this.plugins.fileBrowser._bindClose);
            const fileBrowserContext = this.context.fileBrowser;
            fileBrowserContext.contextPlugin = pluginName;
            fileBrowserContext.selectorHandler = selectorHandler;
            const pluginContext = this.context[pluginName];
            const listClassName = pluginContext.listClass;
            if (!this.util.hasClass(fileBrowserContext.list, listClassName)) {
              fileBrowserContext.list.className = "se-file-browser-list " + listClassName;
            }
            if (this.options.popupDisplay === "full") {
              fileBrowserContext.area.style.position = "fixed";
            } else {
              fileBrowserContext.area.style.position = "absolute";
            }
            fileBrowserContext.titleArea.textContent = pluginContext.title;
            fileBrowserContext.area.style.display = "block";
            this.plugins.fileBrowser._drawFileList.call(this, this.context[pluginName].url, this.context[pluginName].header);
          },
          _bindClose: null,
          /**
           * @description Close a fileBrowser plugin
           * The plugin's "init" method is called.
           */
          close: function() {
            const fileBrowserPlugin = this.plugins.fileBrowser;
            if (fileBrowserPlugin._xmlHttp) {
              fileBrowserPlugin._xmlHttp.abort();
            }
            if (fileBrowserPlugin._bindClose) {
              this._d.removeEventListener("keydown", fileBrowserPlugin._bindClose);
              fileBrowserPlugin._bindClose = null;
            }
            const fileBrowserContext = this.context.fileBrowser;
            fileBrowserContext.area.style.display = "none";
            fileBrowserContext.selectorHandler = null;
            fileBrowserContext.selectedTags = [];
            fileBrowserContext.items = [];
            fileBrowserContext.list.innerHTML = fileBrowserContext.tagArea.innerHTML = fileBrowserContext.titleArea.textContent = "";
            if (typeof this.plugins[fileBrowserContext.contextPlugin].init === "function") this.plugins[fileBrowserContext.contextPlugin].init.call(this);
            fileBrowserContext.contextPlugin = "";
          },
          /**
           * @description Show file browser loading box
           */
          showBrowserLoading: function() {
            this._loading.style.display = "block";
          },
          /**
           * @description Close file browser loading box
           */
          closeBrowserLoading: function() {
            this._loading.style.display = "none";
          },
          _drawFileList: function(url, browserHeader) {
            const fileBrowserPlugin = this.plugins.fileBrowser;
            const xmlHttp = fileBrowserPlugin._xmlHttp = this.util.getXMLHttpRequest();
            xmlHttp.onreadystatechange = fileBrowserPlugin._callBackGet.bind(this, xmlHttp);
            xmlHttp.open("get", url, true);
            if (browserHeader !== null && typeof browserHeader === "object" && this._w.Object.keys(browserHeader).length > 0) {
              for (let key in browserHeader) {
                xmlHttp.setRequestHeader(key, browserHeader[key]);
              }
            }
            xmlHttp.send(null);
            this.plugins.fileBrowser.showBrowserLoading();
          },
          _callBackGet: function(xmlHttp) {
            if (xmlHttp.readyState === 4) {
              this.plugins.fileBrowser._xmlHttp = null;
              if (xmlHttp.status === 200) {
                try {
                  const res = JSON.parse(xmlHttp.responseText);
                  if (res.result.length > 0) {
                    this.plugins.fileBrowser._drawListItem.call(this, res.result, true);
                  } else if (res.nullMessage) {
                    this.context.fileBrowser.list.innerHTML = res.nullMessage;
                  }
                } catch (e) {
                  throw Error('[SUNEDITOR.fileBrowser.drawList.fail] cause : "' + e.message + '"');
                } finally {
                  this.plugins.fileBrowser.closeBrowserLoading();
                  this.context.fileBrowser.body.style.maxHeight = this._w.innerHeight - this.context.fileBrowser.header.offsetHeight - 50 + "px";
                }
              } else {
                this.plugins.fileBrowser.closeBrowserLoading();
                if (xmlHttp.status !== 0) {
                  const res = !xmlHttp.responseText ? xmlHttp : JSON.parse(xmlHttp.responseText);
                  const err = "[SUNEDITOR.fileBrowser.get.serverException] status: " + xmlHttp.status + ", response: " + (res.errorMessage || xmlHttp.responseText);
                  throw Error(err);
                }
              }
            }
          },
          _drawListItem: function(items, update) {
            const fileBrowserContext = this.context.fileBrowser;
            const pluginContext = this.context[fileBrowserContext.contextPlugin];
            const _tags = [];
            const len = items.length;
            const columnSize = pluginContext.columnSize || fileBrowserContext.columnSize;
            const splitSize = columnSize <= 1 ? 1 : Math.round(len / columnSize) || 1;
            const drawItemHandler = pluginContext.itemTemplateHandler;
            let tagsHTML = "";
            let listHTML = '<div class="se-file-item-column">';
            let columns = 1;
            for (let i = 0, item, tags; i < len; i++) {
              item = items[i];
              tags = !item.tag ? [] : typeof item.tag === "string" ? item.tag.split(",") : item.tag;
              tags = item.tag = tags.map(function(v) {
                return v.trim();
              });
              listHTML += drawItemHandler(item);
              if ((i + 1) % splitSize === 0 && columns < columnSize && i + 1 < len) {
                columns++;
                listHTML += '</div><div class="se-file-item-column">';
              }
              if (update && tags.length > 0) {
                for (let t = 0, tLen = tags.length, tag; t < tLen; t++) {
                  tag = tags[t];
                  if (tag && _tags.indexOf(tag) === -1) {
                    _tags.push(tag);
                    tagsHTML += '<a title="' + tag + '" aria-label="' + tag + '">' + tag + "</a>";
                  }
                }
              }
            }
            listHTML += "</div>";
            fileBrowserContext.list.innerHTML = listHTML;
            if (update) {
              fileBrowserContext.items = items;
              fileBrowserContext.tagArea.innerHTML = tagsHTML;
              fileBrowserContext.tagElements = fileBrowserContext.tagArea.querySelectorAll("A");
            }
          },
          onClickTag: function(e) {
            const target = e.target;
            if (!this.util.isAnchor(target)) return;
            const tagName = target.textContent;
            const fileBrowserPlugin = this.plugins.fileBrowser;
            const fileBrowserContext = this.context.fileBrowser;
            const selectTag = fileBrowserContext.tagArea.querySelector('a[title="' + tagName + '"]');
            const selectedTags = fileBrowserContext.selectedTags;
            const sTagIndex = selectedTags.indexOf(tagName);
            if (sTagIndex > -1) {
              selectedTags.splice(sTagIndex, 1);
              this.util.removeClass(selectTag, "on");
            } else {
              selectedTags.push(tagName);
              this.util.addClass(selectTag, "on");
            }
            fileBrowserPlugin._drawListItem.call(
              this,
              selectedTags.length === 0 ? fileBrowserContext.items : fileBrowserContext.items.filter(function(item) {
                return item.tag.some(function(tag) {
                  return selectedTags.indexOf(tag) > -1;
                });
              }),
              false
            );
          },
          onClickFile: function(e) {
            e.preventDefault();
            e.stopPropagation();
            const fileBrowserContext = this.context.fileBrowser;
            const listEl = fileBrowserContext.list;
            let target = e.target;
            let command = null;
            if (target === listEl) return;
            while (listEl !== target.parentNode) {
              command = target.getAttribute("data-command");
              if (command) break;
              target = target.parentNode;
            }
            if (!command) return;
            const handler = fileBrowserContext.selectorHandler || this.context[fileBrowserContext.contextPlugin].selectorHandler;
            handler(target, target.parentNode.querySelector(".__se__img_name").textContent);
            this.plugins.fileBrowser.close.call(this);
          }
        };
        if (typeof noGlobal === "undefined") {
          if (!window2.SUNEDITOR_MODULES) {
            Object.defineProperty(window2, "SUNEDITOR_MODULES", {
              enumerable: true,
              writable: false,
              configurable: false,
              value: {}
            });
          }
          Object.defineProperty(window2.SUNEDITOR_MODULES, "fileBrowser", {
            enumerable: true,
            writable: false,
            configurable: false,
            value: fileBrowser2
          });
        }
        return fileBrowser2;
      });
    }
  });

  // ink-document-client-resolver:C:\Users\Win 10\dev\ink\packages\ink-web\src\pages\ui\field\wysiwyg.ink
  var wysiwyg_exports = {};
  __export(wysiwyg_exports, {
    BUILD_ID: () => BUILD_ID,
    ClientRegistry: () => import_Registry17.default,
    TemplateDocument: () => TemplateDocument,
    components: () => components,
    data: () => import_data.default,
    elements: () => elements,
    emitter: () => import_Emitter.default
  });
  var import_Document = __toESM(require_Document());
  var import_Document2 = __toESM(require_Document2());
  var import_Registry17 = __toESM(require_Registry());
  var import_Emitter = __toESM(require_Emitter());
  var import_data = __toESM(require_data());

  // ink-component-resolver:C:\Users\Win 10\dev\ink\packages\ink-web\src\components\api\docs.ink
  var import_Registry = __toESM(require_Registry());
  var import_Component = __toESM(require_Component());
  var import_ink = __toESM(require_ink());
  var Docs_0ab1bce486b32e7cdafc = class extends import_Component.default {
    static id = "0ab1bce486b32e7cdafc";
    static tagname = "docs";
    static classname = "Docs_0ab1bce486b32e7cdafc";
    styles() {
      return ``;
    }
    template() {
      (0, import_ink.classlist)().add(
        "block",
        "w-full",
        "h-full",
        "scroll-y-auto",
        "scroll-x-hidden"
      );
      return () => [
        import_Registry.default.createText(`
`, false),
        import_Registry.default.createElement("article", { "class": `block p-10 tx-t-1` }, [
          ...this._toNodeList((0, import_ink.children)())
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\packages\ink-web\src\components\ide\app.ink
  var import_Registry2 = __toESM(require_Registry());
  var import_Component2 = __toESM(require_Component());
  var import_ink2 = __toESM(require_ink());
  var App_4ec139eab67151540039 = class extends import_Component2.default {
    static id = "4ec139eab67151540039";
    static tagname = "app";
    static classname = "App_4ec139eab67151540039";
    styles() {
      return ``;
    }
    template() {
      const { title, height } = (0, import_ink2.props)();
      const style = height ? `height:${height}px` : "";
      return () => [
        import_Registry2.default.createText(`
`, false),
        import_Registry2.default.createElement("div", { "class": `curved scroll-hidden shadow-0-0-10-0-0-0-5` }, [
          import_Registry2.default.createText(`
  `, false),
          import_Registry2.default.createElement("div", { "class": `relative flex flex-center-y gap-10 p-10 bg-t-1 tx-c-999999 tx-16` }, [
            import_Registry2.default.createText(`
    `, false),
            import_Registry2.default.createElement("span", { "class": `bg-h-999999 pill h-10 w-10` }, []).element,
            import_Registry2.default.createText(`
    `, false),
            import_Registry2.default.createElement("span", { "class": `bg-h-999999 pill h-10 w-10` }, []).element,
            import_Registry2.default.createText(`
    `, false),
            import_Registry2.default.createElement("span", { "class": `bg-h-999999 pill h-10 w-10` }, []).element,
            import_Registry2.default.createText(`
    `, false),
            import_Registry2.default.createElement("span", { "class": `flex flex-center h-full w-full absolute top-0 left-0` }, [
              import_Registry2.default.createText(`
      `, false),
              ...this._toNodeList(title),
              import_Registry2.default.createText(`
    `, false)
            ]).element,
            import_Registry2.default.createText(`
  `, false)
          ]).element,
          import_Registry2.default.createText(`
  `, false),
          import_Registry2.default.createElement("div", { "class": `bg-black tx-t-1 relative`, "style": style }, [
            ...this._toNodeList((0, import_ink2.children)())
          ]).element,
          import_Registry2.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\packages\ink-web\src\components\ide\code.ink
  var import_Registry3 = __toESM(require_Registry());
  var import_Component3 = __toESM(require_Component());
  var import_prismjs = __toESM(require_prism());
  var import_ink3 = __toESM(require_ink());
  var Code_5387662ecbed97347dd0 = class extends import_Component3.default {
    static id = "5387662ecbed97347dd0";
    static tagname = "code";
    static classname = "Code_5387662ecbed97347dd0";
    styles() {
      return `:host {
    display: block;
    font-size: 14px;
    line-height: 20px;
  }
  :host([inline]) {
    display: inline !important;
  }
  :host([inline]),
  :host([inline]) > pre,
  :host([inline]) > pre > code {
    display: inline !important;
  }
  .snippet {
    background-color: #000000;
    color: #ABB2BF;
    height: 100%;
    margin: 0;
    padding: 0;
  }

  .line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
  }
  :host([inline]) .line-numbers {
    position: static;
    padding-left: 0;
  }

  .line-numbers > code {
    position: relative;
    white-space: inherit;
  }

  .line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

  }

  :host([inline]) .line-numbers .line-numbers-rows {
    display: none;
  }

  .line-numbers-rows > span {
    display: block;
    counter-increment: linenumber;
  }

  .line-numbers-rows > span:before {
    content: counter(linenumber);
    color: #999;
    display: block;
    padding-right: 0.8em;
    text-align: right;
  }
  .pad {
    padding: 5px;
  }

  .terminal {
    background-color: #000000;
    color: #EFEFEF;
    font-family: 'Courier New', Courier, monospace;
    font-size: 15px;
    height: 100%;
    padding: 10px;
  }
  .terminal span {
    color: #00FF00;
  }`;
    }
    template() {
      const config = this.props;
      const {
        lang = "markup",
        numbers = false,
        inline = false,
        trim = false,
        ltrim = false,
        rtrim = false,
        detab = 0
      } = config;
      const childlist = (0, import_ink3.children)();
      let snippet = childlist[0]?.textContent || "";
      if (detab) {
        snippet = snippet.replace(
          new RegExp(`\\n {${detab}}`, "g"),
          "\n"
        );
      }
      if (trim) {
        snippet = snippet.trim();
      } else if (ltrim) {
        snippet = snippet.replace(/^\s+/, "");
      } else if (rtrim) {
        snippet = snippet.replace(/\s+$/, "");
      }
      const highlight = (event) => {
        if (!snippet) {
          return;
        }
        const code = import_prismjs.default.highlight(snippet, import_prismjs.default.languages[lang], lang);
        event.detail.target.innerHTML = code;
        if (numbers) {
          const match = code.match(/\n(?!$)/g);
          const total = match ? match.length + 1 : 1;
          const lines = new Array(total + 1).join("<span></span>");
          const wrapper = document.createElement("span");
          wrapper.setAttribute("aria-hidden", "true");
          wrapper.className = "line-numbers-rows";
          wrapper.innerHTML = lines;
          event.detail.target.appendChild(wrapper);
        }
      };
      return () => [
        import_Registry3.default.createElement("link", { "rel": `stylesheet`, "href": `https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/themes/prism.min.css` }).element,
        import_Registry3.default.createText(`
`, false),
        import_Registry3.default.createElement("link", { "rel": `stylesheet`, "href": `https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/themes/prism-tomorrow.min.css` }).element,
        import_Registry3.default.createText(`
`, false),
        ...!!(lang === "bash") ? [
          import_Registry3.default.createText(`
  `, false),
          import_Registry3.default.createElement("div", { "class": `terminal` }, [
            import_Registry3.default.createElement("span", {}, [
              import_Registry3.default.createText(`$`, false)
            ]).element,
            import_Registry3.default.createText(` `, false),
            ...this._toNodeList(childlist)
          ]).element,
          import_Registry3.default.createText(`
`, false)
        ] : !!snippet ? [
          ,
          import_Registry3.default.createText(`
  `, false),
          ...!!numbers ? [
            import_Registry3.default.createText(`
    `, false),
            import_Registry3.default.createElement("pre", { "class": `snippet line-numbers` }, [
              import_Registry3.default.createElement("code", { "mount": highlight }, []).element
            ]).element,
            import_Registry3.default.createText(`
  `, false)
          ] : true ? [
            ,
            import_Registry3.default.createText(`
    `, false),
            import_Registry3.default.createElement("pre", { "class": `snippet pad` }, [
              import_Registry3.default.createElement("code", { "mount": highlight }, []).element
            ]).element,
            import_Registry3.default.createText(`
  `, false)
          ] : [],
          import_Registry3.default.createText(`
`, false)
        ] : true ? [
          ,
          import_Registry3.default.createText(`
  `, false),
          import_Registry3.default.createElement("span", {}, [
            import_Registry3.default.createText(`????`, false)
          ]).element,
          import_Registry3.default.createText(`
`, false)
        ] : [],
        import_Registry3.default.createText(`
`, false)
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\packages\ink-web\src\components\i18n\translate.ink
  var import_Registry4 = __toESM(require_Registry());
  var import_Component4 = __toESM(require_Component());

  // src/components/i18n/index.ts
  var _ = function(phrase, ...variables) {
    let translation = translate(phrase);
    for (let i = 0; i < variables.length; i++) {
      translation = translation.replace("%s", String(variables[i]));
    }
    return translation;
  };
  var translate = function(phrase) {
    return phrase;
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\packages\ink-web\src\components\i18n\translate.ink
  var Translate_794a00a5e900fca28310 = class extends import_Component4.default {
    static id = "794a00a5e900fca28310";
    static tagname = "translate";
    static classname = "Translate_794a00a5e900fca28310";
    styles() {
      return ``;
    }
    template() {
      const { trim = false, p = false, li = false, div = false } = this.props;
      const childlist = this.originalChildren;
      const phrase = [];
      const variables = [];
      for (const child of childlist) {
        if (typeof child === "string") {
          phrase.push(child);
        } else if (child instanceof Node && child.textContent) {
          phrase.push(child.textContent);
        } else {
          phrase.push("%s");
          variables.push(child);
        }
      }
      let words = phrase.join("");
      if (trim) {
        words = words.replace(/\s+/, " ").trim();
      }
      const chunks = translate(words).split("%s");
      const translations = [];
      for (let i = 0; i < chunks.length; i++) {
        translations.push(document.createTextNode(chunks[i]));
        if (variables[i]) {
          translations.push(variables[i]);
        }
      }
      return () => [
        import_Registry4.default.createText(`
    `, false),
        ...!!p ? [
          import_Registry4.default.createText(`
      `, false),
          import_Registry4.default.createElement("p", {}, [
            ...this._toNodeList(translations)
          ]).element,
          import_Registry4.default.createText(`
    `, false)
        ] : !!li ? [
          ,
          import_Registry4.default.createText(`
      `, false),
          import_Registry4.default.createElement("li", {}, [
            ...this._toNodeList(translations)
          ]).element,
          import_Registry4.default.createText(`
    `, false)
        ] : !!div ? [
          ,
          import_Registry4.default.createText(`
      `, false),
          import_Registry4.default.createElement("div", {}, [
            ...this._toNodeList(translations)
          ]).element,
          import_Registry4.default.createText(`
    `, false)
        ] : true ? [
          ,
          import_Registry4.default.createText(`
      `, false),
          ...this._toNodeList(translations),
          import_Registry4.default.createText(`
    `, false)
        ] : []
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\layout\panel.ink
  var import_Registry5 = __toESM(require_Registry());
  var import_Component5 = __toESM(require_Component());
  var Panel_c4c96a14064fc0c4d224 = class extends import_Component5.default {
    static id = "c4c96a14064fc0c4d224";
    static tagname = "panel";
    static classname = "Panel_c4c96a14064fc0c4d224";
    styles() {
      return ``;
    }
    template() {
      const panels = this.originalChildren;
      const section = {
        main: panels.find((panel) => panel.nodeName === "MAIN"),
        head: panels.find((panel) => panel.nodeName === "HEADER"),
        foot: panels.find((panel) => panel.nodeName === "FOOTER"),
        left: panels.find((panel) => panel.nodeName === "ASIDE" && panel.hasAttribute("left")),
        right: panels.find((panel) => panel.nodeName === "ASIDE" && panel.hasAttribute("right"))
      };
      const show = { left: false, right: false };
      this.toggle = (panel) => {
        show[panel] = !show[panel];
        setClassNames.all();
      };
      const setClassNames = {
        all() {
          section.main && this.main();
          section.head && this.head();
          section.foot && this.foot();
          section.left && this.left();
          section.right && this.right();
        },
        head() {
          const { classList } = section.head;
          classList.add("absolute", "top-0", "right-0", "h-60", "transition-500");
          if (section.left) {
            classList.remove("left-0");
            classList.add("left-226");
          } else {
            classList.remove("left-226");
            classList.add("left-0");
          }
          if (show.left) {
            classList.remove("md-left-0");
            classList.add("md-left-226");
          } else {
            classList.remove("md-left-226");
            classList.add("md-left-0");
          }
        },
        foot() {
          const { classList } = section.foot;
          classList.add("absolute", "bottom-0", "right-0", "h-60", "transition-500");
          if (section.left) {
            classList.remove("left-0");
            classList.add("left-226");
          } else {
            classList.remove("left-226");
            classList.add("left-0");
          }
          if (show.left) {
            classList.remove("md-left-0");
            classList.add("md-left-226");
          } else {
            classList.remove("md-left-226");
            classList.add("md-left-0");
          }
        },
        left() {
          const { classList } = section.left;
          classList.add("w-226", "absolute", "bottom-0", "left-0", "top-0", "transition-500");
          if (show.left) {
            classList.remove("md-left--226");
            classList.add("md-left-0");
          } else {
            classList.remove("md-left-0");
            classList.add("md-left--226");
          }
        },
        right() {
          const { classList } = section.right;
          classList.add("w-200", "absolute", "right-0", "transition-500");
          if (section.foot) {
            classList.remove("bottom-0");
            classList.add("bottom-60");
          } else {
            classList.remove("bottom-60");
            classList.add("bottom-0");
          }
          if (section.head) {
            classList.remove("top-0");
            classList.add("top-60");
          } else {
            classList.remove("top-60");
            classList.add("top-0");
          }
          if (show.right) {
            classList.remove("lg-right--200");
            classList.add("lg-right-0");
          } else {
            classList.remove("lg-right-0");
            classList.add("lg-right--200");
          }
        },
        main() {
          const { classList } = section.main;
          classList.add("absolute", "transition-500");
          if (section.head) {
            classList.remove("top-0");
            classList.add("top-60");
          } else {
            classList.remove("top-60");
            classList.add("top-0");
          }
          if (section.foot) {
            classList.remove("bottom-0");
            classList.add("bottom-60");
          } else {
            classList.remove("bottom-60");
            classList.add("bottom-0");
          }
          if (section.left) {
            classList.remove("left-0");
            classList.add("left-226");
          } else {
            classList.remove("left-226");
            classList.add("left-0");
          }
          if (section.right) {
            classList.remove("right-0");
            classList.add("right-200");
          } else {
            classList.remove("right-200");
            classList.add("right-0");
          }
          if (show.left) {
            classList.remove("md-left-0");
            classList.add("md-left-226");
          } else {
            classList.remove("md-left-226");
            classList.add("md-left-0");
          }
          if (show.right) {
            classList.remove("lg-right-0");
            classList.add("lg-right-200");
          } else {
            classList.remove("lg-right-200");
            classList.add("lg-right-0");
          }
        }
      };
      setClassNames.all();
      this.classList.add("block", "relative", "w-full", "vh", "scroll-hidden");
      return () => [
        import_Registry5.default.createText(`
`, false),
        ...this._toNodeList(panels)
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\element\icon.ink
  var import_Registry6 = __toESM(require_Registry());
  var import_Component6 = __toESM(require_Component());
  var import_StyleSet = __toESM(require_StyleSet());
  var import_color = __toESM(require_color());
  var import_display = __toESM(require_display());
  var import_size = __toESM(require_size());
  var Icon_33cb84912ffcb000a388 = class extends import_Component6.default {
    static id = "33cb84912ffcb000a388";
    static tagname = "icon";
    static classname = "Icon_33cb84912ffcb000a388";
    styles() {
      return ``;
    }
    template() {
      const { name: name2, solid, brand } = this.props;
      const styles = new import_StyleSet.default();
      this.styles = () => styles.toString();
      (0, import_display.default)(this.props, styles, "inline-block", ":host");
      (0, import_color.default)(this.props, styles, false, ":host", "color");
      (0, import_size.default)(this.props, styles, false, ":host", "font-size");
      const iconClass = ["fa-fw", `fa-${name2}`];
      iconClass.push(brand ? "fa-brands" : "fa-solid");
      return () => [
        import_Registry6.default.createElement("link", { "rel": `stylesheet`, "type": `text/css`, "href": `https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css` }).element,
        import_Registry6.default.createText(`
`, false),
        import_Registry6.default.createElement("i", { "class": iconClass.join(" ") }, []).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\element\crumbs.ink
  var import_Registry7 = __toESM(require_Registry());
  var import_Component7 = __toESM(require_Component());
  var import_StyleSet2 = __toESM(require_StyleSet());
  var import_bold = __toESM(require_bold());
  var import_color2 = __toESM(require_color());
  var import_display2 = __toESM(require_display());
  var import_size2 = __toESM(require_size());
  var import_underline = __toESM(require_underline());
  var Crumbs_e4598fe781cc66b1ce2c = class extends import_Component7.default {
    static id = "e4598fe781cc66b1ce2c";
    static tagname = "crumbs";
    static classname = "Crumbs_e4598fe781cc66b1ce2c";
    styles() {
      return ``;
    }
    template() {
      const {
        //breadcrumbs list
        crumbs = [],
        //sub-props
        link,
        sep,
        icon,
        //default sizes (to pass to icon component)
        size,
        xs,
        sm,
        md,
        lg,
        xl,
        xl2,
        xl3,
        xl4,
        xl5,
        //default colors (to pass to icon component)
        color,
        white,
        black,
        info,
        warning,
        success,
        error,
        muted,
        primary,
        secondary,
        //others
        spacing = 0
      } = this.propsTree;
      const styles = new import_StyleSet2.default();
      this.styles = () => styles.toString();
      const display = (0, import_display2.default)(this.props, styles, "block", ":host");
      if (display === "flex" || display === "inline-flex") {
        styles.add(":host", "align-items", "center");
      }
      (0, import_size2.default)(this.props, styles, false, ":host", "font-size");
      (0, import_color2.default)(this.props, styles, false, ":host", "color");
      styles.add("a", "cursor", "pointer");
      if (link) {
        (0, import_color2.default)(link, styles, false, "a", "color");
      }
      (0, import_underline.default)(this.props, styles, "a");
      if (spacing) {
        styles.add(".sep", "margin", `0 ${spacing}px`);
      }
      (0, import_bold.default)(this.props, styles, "span");
      const iconProps = icon || {
        //default sizes
        size,
        xs,
        sm,
        md,
        lg,
        xl,
        xl2,
        xl3,
        xl4,
        xl5,
        //default colors
        color,
        white,
        black,
        info,
        warning,
        success,
        error,
        muted,
        primary,
        secondary
      };
      const sepProps = sep || {
        //default sizes
        size,
        xs,
        sm,
        md,
        lg,
        xl,
        xl2,
        xl3,
        xl4,
        xl5,
        //default colors
        color,
        white,
        black,
        info,
        warning,
        success,
        error,
        muted,
        primary,
        secondary
      };
      return () => [
        import_Registry7.default.createText(`
`, false),
        ...Object.entries(crumbs).map(([index, crumb]) => [
          import_Registry7.default.createText(`
  `, false),
          ...!!crumb.icon ? [
            import_Registry7.default.createText(`
    `, false),
            import_Registry7.default.createComponent("interface-icon", Icon_33cb84912ffcb000a388, { ...iconProps, "name": crumb.icon }).element,
            import_Registry7.default.createText(`
  `, false)
          ] : [],
          import_Registry7.default.createText(`
  `, false),
          ...!!(crumb.href && crumb.label) ? [
            import_Registry7.default.createText(`
    `, false),
            import_Registry7.default.createElement("a", { "href": crumb.href }, [
              ...this._toNodeList(crumb.label)
            ]).element,
            import_Registry7.default.createText(`
  `, false)
          ] : !!crumb.label ? [
            ,
            import_Registry7.default.createText(`
    `, false),
            import_Registry7.default.createElement("span", {}, [
              ...this._toNodeList(crumb.label)
            ]).element,
            import_Registry7.default.createText(`
  `, false)
          ] : [],
          import_Registry7.default.createText(`
  `, false),
          ...!!(index < crumbs.length - 1) ? [
            import_Registry7.default.createText(`
    `, false),
            import_Registry7.default.createComponent("interface-icon", Icon_33cb84912ffcb000a388, { ...sepProps, "name": `chevron-right`, "class": `sep` }).element,
            import_Registry7.default.createText(`
  `, false)
          ] : [],
          import_Registry7.default.createText(`
`, false)
        ]).flat()
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\layout\table.ink
  var import_Component13 = __toESM(require_Component());

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\layout\table\table.ink
  var import_Registry8 = __toESM(require_Registry());
  var import_Component8 = __toESM(require_Component());
  var import_StyleSet3 = __toESM(require_StyleSet());
  var Table_cb9231b6c52140a254d4 = class extends import_Component8.default {
    static id = "cb9231b6c52140a254d4";
    static tagname = "table";
    static classname = "Table_cb9231b6c52140a254d4";
    styles() {
      return ``;
    }
    template() {
      const styles = new import_StyleSet3.default();
      this.styles = () => styles.toString();
      styles.add(":host", "display", "table");
      styles.add(":host", "width", "100%");
      return () => [
        import_Registry8.default.createText(`
`, false),
        import_Registry8.default.createElement("slot", {}, []).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\layout\table.ink
  var import_Registry13 = __toESM(require_Registry());
  var import_StyleSet8 = __toESM(require_StyleSet());

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\layout\table\thead.ink
  var import_Registry10 = __toESM(require_Registry());
  var import_Component10 = __toESM(require_Component());

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\layout\table\row.ink
  var import_Registry9 = __toESM(require_Registry());
  var import_Component9 = __toESM(require_Component());
  var import_StyleSet4 = __toESM(require_StyleSet());
  var Row_0b3723ad0a2356b54f11 = class extends import_Component9.default {
    static id = "0b3723ad0a2356b54f11";
    static tagname = "row";
    static classname = "Row_0b3723ad0a2356b54f11";
    styles() {
      return ``;
    }
    template() {
      const styles = new import_StyleSet4.default();
      this.styles = () => styles.toString();
      styles.add(":host", "display", "table-row");
      return () => [
        import_Registry9.default.createText(`
`, false),
        import_Registry9.default.createElement("slot", {}, []).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\layout\table\thead.ink
  var import_StyleSet5 = __toESM(require_StyleSet());
  var Thead_afbcee18613ce58fb77c = class extends import_Component10.default {
    static id = "afbcee18613ce58fb77c";
    static tagname = "thead";
    static classname = "Thead_afbcee18613ce58fb77c";
    styles() {
      return ``;
    }
    template() {
      const styles = new import_StyleSet5.default();
      this.styles = () => styles.toString();
      styles.add(":host", "display", "table-header-group");
      return () => [
        import_Registry10.default.createText(`
`, false),
        import_Registry10.default.createComponent("table-row", Row_0b3723ad0a2356b54f11, {}, [
          import_Registry10.default.createElement("slot", {}, []).element
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\layout\table\tbody.ink
  var import_Registry11 = __toESM(require_Registry());
  var import_Component11 = __toESM(require_Component());
  var import_StyleSet6 = __toESM(require_StyleSet());
  var Tbody_95f498c1427be6bf7334 = class extends import_Component11.default {
    static id = "95f498c1427be6bf7334";
    static tagname = "tbody";
    static classname = "Tbody_95f498c1427be6bf7334";
    styles() {
      return ``;
    }
    template() {
      const styles = new import_StyleSet6.default();
      this.styles = () => styles.toString();
      styles.add(":host", "display", "table-row-group");
      return () => [
        import_Registry11.default.createText(`
`, false),
        import_Registry11.default.createElement("slot", {}, []).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\layout\table\tfoot.ink
  var import_Registry12 = __toESM(require_Registry());
  var import_Component12 = __toESM(require_Component());
  var import_StyleSet7 = __toESM(require_StyleSet());
  var Tfoot_874bedd042c5f2db7353 = class extends import_Component12.default {
    static id = "874bedd042c5f2db7353";
    static tagname = "tfoot";
    static classname = "Tfoot_874bedd042c5f2db7353";
    styles() {
      return ``;
    }
    template() {
      const styles = new import_StyleSet7.default();
      this.styles = () => styles.toString();
      styles.add(":host", "display", "table-footer-group");
      return () => [
        import_Registry12.default.createText(`
`, false),
        import_Registry12.default.createComponent("table-row", Row_0b3723ad0a2356b54f11, {}, [
          import_Registry12.default.createElement("slot", {}, []).element
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\layout\table.ink
  var Table_02bc3cbacda5727a0af3 = class extends import_Component13.default {
    static id = "02bc3cbacda5727a0af3";
    static tagname = "table";
    static classname = "Table_02bc3cbacda5727a0af3";
    styles() {
      return ``;
    }
    template() {
      const {
        //sticky props
        top,
        bottom,
        left,
        right,
        //section classes
        head,
        body,
        odd,
        even,
        foot
      } = this.props;
      const sticky = top || bottom || left || right;
      const headList = typeof head === "string" ? head.split(" ").filter(Boolean) : [];
      const footList = typeof foot === "string" ? foot.split(" ").filter(Boolean) : [];
      const bodyList = typeof body === "string" ? body.split(" ").filter(Boolean) : [];
      const oddList = typeof odd === "string" ? odd.split(" ").filter(Boolean) : [];
      const evenList = typeof even === "string" ? even.split(" ").filter(Boolean) : [];
      const styles = new import_StyleSet8.default();
      this.styles = () => styles.toString();
      styles.add(":host", "width", "100%");
      if (sticky) {
        styles.add(":host", "display", "block");
        styles.add(":host", "position", "relative");
        styles.add(":host", "overflow", "auto");
        styles.add(":host", "height", "100%");
      } else {
        styles.add(":host", "display", "table");
      }
      const rows = [];
      const headers = [];
      const footers = [];
      const children4 = this.originalChildren;
      for (const [i, child] of children4.entries()) {
        if (child.nodeName.includes("HEAD")) {
          headers.push(child);
        } else if (child.nodeName.includes("FOOT")) {
          footers.push(child);
        } else if (child.nodeName.includes("ROW")) {
          rows.push(child);
        }
      }
      for (const [i, header] of headers.entries()) {
        header.setAttribute("head", "");
        if (headList.length > 0) {
          header.classList.add(...headList);
        }
        if (top) {
          header.setAttribute("top", "");
        }
        if (left && i === 0) {
          header.setAttribute("left", "");
        }
        if (right && i === headers.length - 1) {
          header.setAttribute("right", "");
        }
      }
      for (const [i, footer] of footers.entries()) {
        footer.setAttribute("foot", "");
        if (footList.length > 0) {
          footer.classList.add(...footList);
        }
        if (bottom) {
          footer.setAttribute("bottom", "");
        }
        if (left && i === 0) {
          footer.setAttribute("left", "");
        }
        if (right && i === footers.length - 1) {
          footer.setAttribute("right", "");
        }
      }
      for (const [i, row] of rows.entries()) {
        row.setAttribute("row", "");
        Array.from(row.children || []).forEach((cell, j, cells) => {
          bodyList.length > 0 && cell?.classList?.add(...bodyList);
          oddList.length > 0 && i % 2 === 0 && cell?.classList?.add(...oddList);
          evenList.length > 0 && i % 2 === 1 && cell.classList?.add(...evenList);
          if (left && j === 0) {
            cell.setAttribute("left", "");
          }
          if (right && j === cells.length - 1) {
            cell.setAttribute("right", "");
          }
        });
      }
      this.innerText = "";
      headers.length && this.appendChild(
        import_Registry13.default.createComponent(
          "table-thead",
          Thead_afbcee18613ce58fb77c,
          {},
          headers
        ).element
      );
      rows.length && this.appendChild(
        import_Registry13.default.createComponent(
          "table-tbody",
          Tbody_95f498c1427be6bf7334,
          {},
          rows
        ).element
      );
      footers.length && this.appendChild(
        import_Registry13.default.createComponent(
          "table-tfoot",
          Tfoot_874bedd042c5f2db7353,
          {},
          footers
        ).element
      );
      return () => [
        import_Registry13.default.createText(`
`, false),
        ...!!sticky ? [
          import_Registry13.default.createText(`
  `, false),
          import_Registry13.default.createComponent("table-wrapper", Table_cb9231b6c52140a254d4, {}, [
            import_Registry13.default.createText(`
    `, false),
            import_Registry13.default.createElement("slot", {}, []).element,
            import_Registry13.default.createText(`
  `, false)
          ]).element,
          import_Registry13.default.createText(`
`, false)
        ] : true ? [
          ,
          import_Registry13.default.createText(`
  `, false),
          import_Registry13.default.createElement("slot", {}, []).element,
          import_Registry13.default.createText(`
`, false)
        ] : []
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\layout\table\head.ink
  var import_Registry14 = __toESM(require_Registry());
  var import_Component14 = __toESM(require_Component());
  var import_StyleSet9 = __toESM(require_StyleSet());
  var Head_d8755504d9458a2c21da = class extends import_Component14.default {
    static id = "d8755504d9458a2c21da";
    static tagname = "head";
    static classname = "Head_d8755504d9458a2c21da";
    styles() {
      return ``;
    }
    template() {
      const {
        //wrapping
        nowrap,
        wrap1,
        wrap2,
        wrap3,
        wrap4,
        wrap5,
        //sticky
        top,
        left,
        right
      } = this.propsCamel;
      const styles = new import_StyleSet9.default();
      this.styles = () => styles.toString();
      styles.add(":host", "display", "table-cell");
      styles.add(":host([top])", "position", "sticky");
      styles.add(":host([top])", "z-index", "1");
      styles.add(":host([left])", "position", "sticky");
      styles.add(":host([left])", "z-index", "2");
      styles.add(":host([right])", "position", "sticky");
      styles.add(":host([right])", "z-index", "2");
      styles.add(":host([top][left])", "z-index", "3");
      styles.add(":host([top][right])", "z-index", "3");
      if (typeof top === "string" || typeof top === "number") {
        styles.add(":host([top])", "top", top);
      } else {
        styles.add(":host([top])", "top", "0");
      }
      if (typeof left === "string" || typeof left === "number") {
        styles.add(":host([left])", "left", left);
      } else {
        styles.add(":host([left])", "left", "0");
      }
      if (typeof right === "string" || typeof right === "number") {
        styles.add(":host([right])", "right", right);
      } else {
        styles.add(":host([right])", "right", "0");
      }
      if (nowrap) {
        styles.add(":host", "white-space", "nowrap");
      }
      if (wrap1) {
        styles.add(".wrap", "width", "100px");
      } else if (wrap2) {
        styles.add(".wrap", "width", "200px");
      } else if (wrap3) {
        styles.add(".wrap", "width", "300px");
      } else if (wrap4) {
        styles.add(".wrap", "width", "400px");
      } else if (wrap5) {
        styles.add(".wrap", "width", "500px");
      }
      return () => [
        import_Registry14.default.createText(`
`, false),
        import_Registry14.default.createElement("slot", {}, []).element,
        import_Registry14.default.createText(`
`, false),
        ...!!(wrap1 || wrap2 || wrap3 || wrap4 || wrap5) ? [
          import_Registry14.default.createText(`
  `, false),
          import_Registry14.default.createElement("div", { "class": `wrap` }, []).element,
          import_Registry14.default.createText(`
`, false)
        ] : []
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\layout\table\col.ink
  var import_Registry15 = __toESM(require_Registry());
  var import_Component15 = __toESM(require_Component());
  var import_StyleSet10 = __toESM(require_StyleSet());
  var Col_f45aa9d13a1588f1d9ab = class extends import_Component15.default {
    static id = "f45aa9d13a1588f1d9ab";
    static tagname = "col";
    static classname = "Col_f45aa9d13a1588f1d9ab";
    styles() {
      return ``;
    }
    template() {
      const {
        //wrapping
        nowrap,
        wrap1,
        wrap2,
        wrap3,
        wrap4,
        wrap5,
        //sticky
        left,
        right
      } = this.propsCamel;
      const styles = new import_StyleSet10.default();
      this.styles = () => styles.toString();
      styles.add(":host", "display", "table-cell");
      styles.add(":host([left])", "position", "sticky");
      styles.add(":host([left])", "z-index", "2");
      styles.add(":host([right])", "position", "sticky");
      styles.add(":host([right])", "z-index", "2");
      if (typeof left === "string" || typeof left === "number") {
        styles.add(":host([left])", "left", left);
      } else {
        styles.add(":host([left])", "left", "0");
      }
      if (typeof right === "string" || typeof right === "number") {
        styles.add(":host([right])", "right", right);
      } else {
        styles.add(":host([right])", "right", "0");
      }
      if (nowrap) {
        styles.add(":host", "white-space", "nowrap");
      }
      if (wrap1) {
        styles.add(".wrap", "width", "100px");
      } else if (wrap2) {
        styles.add(".wrap", "width", "200px");
      } else if (wrap3) {
        styles.add(".wrap", "width", "300px");
      } else if (wrap4) {
        styles.add(".wrap", "width", "400px");
      } else if (wrap5) {
        styles.add(".wrap", "width", "500px");
      }
      return () => [
        import_Registry15.default.createText(`
`, false),
        import_Registry15.default.createElement("slot", {}, []).element,
        import_Registry15.default.createText(`
`, false),
        ...!!(wrap1 || wrap2 || wrap3 || wrap4 || wrap5) ? [
          import_Registry15.default.createText(`
  `, false),
          import_Registry15.default.createElement("div", { "class": `wrap` }, []).element,
          import_Registry15.default.createText(`
`, false)
        ] : []
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\wysiwyg.ink
  var import_Registry16 = __toESM(require_Registry());
  var import_Component16 = __toESM(require_Component());

  // ../../node_modules/suneditor/src/assets/defaultIcons.js
  var defaultIcons_default = {
    // rtl icon
    rtl: {
      italic: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10.5 15.8" xml:space="preserve"><g><path d="M0.3,0.1c0.3,0,0.5,0,0.7,0c1,0.1,1.7,0.1,2.2,0.1H4L7.2,0l0.2,1.1H7c-0.5,0-1,0.1-1.5,0.3v0.4l0.3,1.9L6,4.4L6.3,6 l0.1,0.4l0.1,0.5c0.1,0.2,0.1,0.4,0.2,0.7s0.1,0.6,0.2,0.9L7,9.1l0.6,2.8l0.3,1.4c0.1,0.4,0.2,0.7,0.4,1c0.4,0.2,0.8,0.3,1.2,0.4 l0.8,0.2l0.2,0.9l-1.1,0c-0.9-0.1-1.5-0.1-1.8-0.1h-2c-0.9,0.1-1.4,0.2-1.5,0.2c-0.1,0-0.2,0-0.3,0H3.4c-0.1,0-0.2,0-0.2,0 l-0.1-0.4c0-0.2-0.1-0.4-0.1-0.6l0.7-0.1c0.4,0,0.8-0.1,1.2-0.2c0-0.1,0-0.2,0-0.3l-0.1-0.5l-0.4-2.4L4,9.6L3.4,6.4 C3.2,5.7,3,4.7,2.7,3.3c0-0.3-0.1-0.5-0.1-0.8C2.5,2.1,2.4,1.9,2.3,1.6C2,1.4,1.6,1.3,1.3,1.2C0.9,1.2,0.5,1.1,0.2,0.9L0,0.4L0,0 L0.3,0.1L0.3,0.1z"/></g></svg>',
      indent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 12.4" xml:space="preserve"><g><g><path d="M15.5,10.1L15.5,10.1c0.1,0,0.3,0.1,0.3,0.3v1.7c0,0.1,0,0.1-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1l-15.2,0 c-0.1,0-0.1,0-0.2-0.1C0,12.2,0,12.2,0,12.1l0-1.7c0-0.1,0-0.1,0.1-0.2c0.1-0.1,0.1-0.1,0.2-0.1C0.3,10.1,15.5,10.1,15.5,10.1z M9.8,6.7c0.1,0,0.1,0,0.2,0.1C10.1,6.9,10.1,7,10.1,7v1.7c0,0.1,0,0.2-0.1,0.2C10,9,9.9,9,9.8,9L0.3,9C0.2,9,0.1,9,0.1,8.9 C0,8.9,0,8.8,0,8.7V7C0,7,0,6.9,0.1,6.8c0.1-0.1,0.1-0.1,0.2-0.1C0.3,6.7,9.8,6.7,9.8,6.7z M0.3,3.4h9.6h0c0.1,0,0.3,0.1,0.3,0.3 v1.7v0c0,0.1-0.1,0.3-0.3,0.3H0.3c-0.1,0-0.1,0-0.2-0.1C0,5.5,0,5.4,0,5.3V3.6c0-0.1,0-0.1,0.1-0.2C0.1,3.4,0.2,3.4,0.3,3.4 L0.3,3.4z M0.3,0l15.2,0c0.1,0,0.1,0,0.2,0.1c0.1,0.1,0.1,0.1,0.1,0.2V2c0,0.1,0,0.2-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1H0.3 c-0.1,0-0.1,0-0.2-0.1C0,2.1,0,2,0,2l0-1.7c0-0.1,0-0.1,0.1-0.2C0.1,0,0.2,0,0.3,0z"/></g><path d="M13.1,3.5L15.7,6c0.1,0.1,0.1,0.3,0,0.4l-2.5,2.5C13.1,9,13,9,12.9,9c-0.1,0-0.1,0-0.2-0.1c-0.1-0.1-0.1-0.1-0.1-0.2V3.7 c0-0.1,0-0.2,0.1-0.2c0.1-0.1,0.1-0.1,0.2-0.1C13,3.4,13.1,3.4,13.1,3.5z"/></g></svg>',
      outdent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 12.4" xml:space="preserve"><g><g><path d="M15.5,10.1L15.5,10.1c0.1,0,0.3,0.1,0.3,0.3v1.7c0,0.1,0,0.1-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1l-15.2,0 c-0.1,0-0.1,0-0.2-0.1C0,12.2,0,12.2,0,12.1l0-1.7c0-0.1,0-0.1,0.1-0.2c0.1-0.1,0.1-0.1,0.2-0.1C0.3,10.1,15.5,10.1,15.5,10.1z M9.8,6.7c0.1,0,0.1,0,0.2,0.1C10.1,6.9,10.1,7,10.1,7v1.7c0,0.1,0,0.2-0.1,0.2C10,9,9.9,9,9.8,9L0.3,9C0.2,9,0.1,9,0.1,8.9 C0,8.9,0,8.8,0,8.7V7C0,7,0,6.9,0.1,6.8c0.1-0.1,0.1-0.1,0.2-0.1C0.3,6.7,9.8,6.7,9.8,6.7z M0.3,3.4h9.6h0c0.1,0,0.3,0.1,0.3,0.3 v1.7v0c0,0.1-0.1,0.3-0.3,0.3H0.3c-0.1,0-0.1,0-0.2-0.1C0,5.5,0,5.4,0,5.3V3.6c0-0.1,0-0.1,0.1-0.2C0.1,3.4,0.2,3.4,0.3,3.4 L0.3,3.4z M0.3,0l15.2,0c0.1,0,0.1,0,0.2,0.1c0.1,0.1,0.1,0.1,0.1,0.2V2c0,0.1,0,0.2-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1H0.3 c-0.1,0-0.1,0-0.2-0.1C0,2.1,0,2,0,2l0-1.7c0-0.1,0-0.1,0.1-0.2C0.1,0,0.2,0,0.3,0z"/></g><path d="M15.5,3.4c0.1,0,0.1,0,0.2,0.1c0.1,0.1,0.1,0.1,0.1,0.2v5.1c0,0.1,0,0.1-0.1,0.2C15.6,9,15.5,9,15.5,9 c-0.1,0-0.1,0-0.2-0.1l-2.5-2.5c-0.1-0.1-0.1-0.3,0-0.4l2.5-2.5C15.3,3.4,15.4,3.4,15.5,3.4z"/></g></svg>',
      list_bullets: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 12.4" xml:space="preserve"><g><path d="M12.4,10.7c0,0.9,0.8,1.7,1.7,1.7c0.9,0,1.7-0.8,1.7-1.7C15.7,9.8,15,9,14.1,9c-0.4,0-0.9,0.2-1.2,0.5 C12.5,9.8,12.4,10.2,12.4,10.7C12.4,10.7,12.4,10.7,12.4,10.7z M12.4,6.2c0,0.9,0.8,1.7,1.7,1.7c0.4,0,0.9-0.2,1.2-0.5 c0.3-0.3,0.4-0.7,0.4-1.1c0-0.9-0.7-1.7-1.6-1.7C13.1,4.6,12.4,5.3,12.4,6.2C12.4,6.2,12.4,6.2,12.4,6.2z M0,9.8v1.7 c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1l10.7,0c0,0,0,0,0,0c0.1,0,0.3-0.1,0.3-0.3V9.8c0-0.1,0-0.1-0.1-0.2 C11.1,9.6,11,9.6,11,9.6l-10.7,0c-0.1,0-0.1,0-0.2,0.1C0,9.7,0,9.8,0,9.8L0,9.8z M12.9,2.9c0.3,0.3,0.7,0.5,1.2,0.5 c0.4,0,0.9-0.2,1.2-0.5c0.7-0.7,0.7-1.7,0-2.4C14.9,0.2,14.5,0,14.1,0c-0.4,0-0.9,0.2-1.2,0.5c-0.3,0.3-0.5,0.7-0.5,1.2 C12.4,2.1,12.5,2.6,12.9,2.9z M0,5.3V7c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1H11c0.1,0,0.1,0,0.2-0.1 c0.1-0.1,0.1-0.1,0.1-0.2V5.3c0,0,0,0,0,0c0-0.1-0.1-0.3-0.3-0.3H0.3c-0.1,0-0.1,0-0.2,0.1C0,5.2,0,5.3,0,5.3L0,5.3z M0,0.8v1.7 c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1h10.7c0.1,0,0.1,0,0.2-0.1c0,0,0.1-0.1,0.1-0.2V0.8c0-0.1,0-0.1-0.1-0.2 c0-0.1-0.1-0.1-0.2-0.1H0.3c-0.1,0-0.1,0-0.2,0.1C0,0.7,0,0.8,0,0.8L0,0.8z"/></g></svg>',
      list_number: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.7" xml:space="preserve"><g><path d="M0,11.5l0,1.7c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1H11c0.1,0,0.2,0,0.2-0.1c0.1-0.1,0.1-0.1,0.1-0.2v-1.7 c0-0.1,0-0.1-0.1-0.2c-0.1-0.1-0.1-0.1-0.2-0.1H0.3c-0.1,0-0.2,0-0.2,0.1C0,11.4,0,11.4,0,11.5L0,11.5z M0,8.7c0,0.1,0,0.1,0.1,0.2 C0.1,8.9,0.2,9,0.3,9H11c0.1,0,0.2,0,0.2-0.1c0.1-0.1,0.1-0.1,0.1-0.2V7c0-0.1,0-0.1-0.1-0.2c-0.1-0.1-0.1-0.1-0.2-0.1l-10.7,0 c-0.1,0-0.2,0-0.2,0.1C0,6.8,0,6.9,0,7C0,7,0,8.7,0,8.7z M0,2.5v1.7c0,0.1,0,0.1,0.1,0.2c0,0,0.1,0.1,0.2,0.1l10.7,0 c0.1,0,0.2,0,0.2-0.1c0.1-0.1,0.1-0.1,0.1-0.2V2.4c0-0.1,0-0.1-0.1-0.2c-0.1,0-0.1,0-0.2,0H0.3c-0.1,0-0.1,0-0.2,0 C0,2.3,0,2.4,0,2.5L0,2.5z"/></g><path d="M15.6,14.2c0-0.3-0.1-0.6-0.3-0.8c-0.2-0.2-0.4-0.4-0.7-0.4l0.9-1v-0.8h-2.9v1.3h0.9v-0.5h0.9l0,0c-0.1,0.1-0.2,0.2-0.3,0.3 s-0.2,0.3-0.4,0.5l-0.3,0.3l0.2,0.5c0.6,0,0.9,0.1,0.9,0.5c0,0.1-0.1,0.3-0.2,0.4c-0.1,0.1-0.3,0.1-0.4,0.1c-0.3,0-0.7-0.1-0.9-0.3 l-0.5,0.8c0.4,0.4,0.9,0.6,1.5,0.6c0.4,0,0.9-0.1,1.2-0.4C15.5,15.1,15.6,14.7,15.6,14.2z"/><path d="M15.6,8.7h-0.9v0.5h-1.1c0-0.2,0.2-0.4,0.4-0.5c0.2-0.2,0.4-0.3,0.7-0.4c0.3-0.2,0.5-0.3,0.7-0.6c0.2-0.2,0.3-0.5,0.3-0.8 c0-0.4-0.2-0.8-0.5-1c-0.6-0.4-1.4-0.5-2-0.1c-0.3,0.2-0.5,0.4-0.6,0.7L13.3,7c0.1-0.3,0.4-0.5,0.7-0.5c0.1,0,0.3,0,0.3,0.1 c0.1,0.1,0.1,0.2,0.1,0.3c0,0.2-0.1,0.3-0.2,0.4c-0.2,0.1-0.3,0.3-0.5,0.4c-0.2,0.1-0.4,0.3-0.6,0.4c-0.2,0.2-0.4,0.4-0.5,0.6 c-0.1,0.2-0.2,0.5-0.2,0.8c0,0.2,0,0.3,0,0.5h3.2L15.6,8.7L15.6,8.7z"/><path d="M15.6,3.6h-1V0h-0.9l-1.2,1.1l0.6,0.7c0.2-0.1,0.3-0.3,0.4-0.5l0,0v2.2h-0.9v0.9h3L15.6,3.6L15.6,3.6z"/></svg>',
      link: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.7" xml:space="preserve"><g><path d="M7.4,9.9l3.1,3.1c0.3,0.3,0.8,0.5,1.3,0.5c0.5,0,0.9-0.2,1.3-0.5c0,0,0,0,0,0c0.7-0.7,0.7-1.9,0-2.6L9.9,7.3 c0-0.1,0-0.2,0-0.3C9.9,7,10,7,10.1,7l2.2-0.2c0.1,0,0.1,0,0.2,0.1l2.1,2.1c0.4,0.4,0.7,0.8,0.9,1.3c0.2,0.5,0.3,1,0.3,1.5 c0,0.5-0.1,1-0.3,1.5c-0.8,2-3.2,3-5.2,2.2c-0.5-0.2-0.9-0.5-1.3-0.9l-2.1-2.1c-0.1,0-0.1-0.1-0.1-0.2L7,10.1C7,10,7,9.9,7.1,9.9 C7.2,9.8,7.3,9.9,7.4,9.9z M1.2,1.1C1.6,0.7,2,0.4,2.5,0.3c1-0.4,2.1-0.4,3.1,0C6,0.4,6.5,0.7,6.8,1.1L9,3.2C9,3.3,9.1,3.3,9,3.4 L8.8,5.6c0,0.1-0.1,0.2-0.2,0.2c-0.1,0.1-0.2,0.1-0.3,0L5.3,2.7C5,2.3,4.5,2.1,4,2.1c-0.5,0-0.9,0.2-1.3,0.5c0,0,0,0,0,0 C2,3.4,2,4.5,2.7,5.2l3.1,3.2c0.1,0.1,0.1,0.2,0,0.3c0,0.1-0.1,0.1-0.2,0.1L3.5,9C3.4,9,3.4,9,3.3,8.9L1.2,6.8c0,0,0,0,0,0 C-0.4,5.2-0.4,2.7,1.2,1.1L1.2,1.1z M14.3,6h-2.6c0,0,0,0,0,0c-0.1,0-0.2-0.1-0.2-0.2c0-0.1,0-0.2,0.1-0.3l2.5-0.7 c0.1,0,0.1,0,0.2,0c0.1,0,0.1,0.1,0.1,0.2l0.1,0.8c0,0.1,0,0.1-0.1,0.2C14.5,6,14.4,6,14.3,6L14.3,6z M10.2,4.1 c0,0.1-0.1,0.2-0.2,0.2l0,0c0,0,0,0,0,0C9.8,4.2,9.7,4.1,9.8,4L9.7,1.4c0-0.1,0-0.1,0.1-0.2c0.1,0,0.1,0,0.2,0h0.8 c0.1,0,0.1,0,0.2,0.1c0,0.1,0,0.1,0,0.2L10.2,4.1L10.2,4.1z M1.5,9.7h1.3h1.3c0.1,0,0.2,0.1,0.2,0.2c0,0.1,0,0.2-0.1,0.3l-2.5,0.6 H1.6c0,0-0.1,0-0.1,0c-0.1,0-0.1-0.1-0.1-0.2L1.2,9.9c0-0.1,0-0.1,0.1-0.2c0-0.1,0.1-0.1,0.2-0.1L1.5,9.7z M5.6,11.6 C5.6,11.6,5.6,11.6,5.6,11.6c0-0.1,0.1-0.2,0.3-0.1c0,0,0,0,0,0c0.1,0,0.2,0.1,0.2,0.2v2.6c0,0.1,0,0.1-0.1,0.2 c0,0-0.1,0.1-0.2,0.1L5,14.5c-0.1,0-0.1,0-0.2-0.1c0-0.1,0-0.1,0-0.2L5.6,11.6L5.6,11.6z"/></g></svg>',
      unlink: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.7" xml:space="preserve"><g><path d="M14.6,14.6c1.6-1.6,1.6-4.1,0-5.7l0,0l-3.1-3.1l-1.2,1.6l2.9,2.9c0.4,0.4,0.6,0.9,0.6,1.5c0,1.1-0.9,2.1-2.1,2.1l0,0 c-0.6,0-1.1-0.2-1.5-0.6l-0.4-0.4l-1.7,1l0.8,0.8C10.4,16.2,13,16.2,14.6,14.6L14.6,14.6L14.6,14.6z M3.6,6C3,5.9,2.6,5.5,2.3,5 S1.9,4,2.1,3.4C2.3,2.9,2.6,2.5,3,2.2C3.5,2,4.1,1.9,4.6,2l3.3,1.4l0.5-2L5.1,0.1C4-0.1,2.9,0,2,0.5C1.1,1.1,0.4,1.9,0.2,3 C-0.1,4,0,5.1,0.6,6C1.1,6.9,1.9,7.6,3,7.8l5.4,2l0.5-2L6.2,6.9L3.6,6z"/></g></svg>'
    },
    // common, ltr icon
    redo: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.59 14.18"><g><path d="M11.58,18.48a6.84,6.84,0,1,1,6.85-6.85s0,.26,0,.67a8,8,0,0,1-.22,1.44l.91-.55a.51.51,0,0,1,.36,0,.45.45,0,0,1,.29.22.47.47,0,0,1,.06.36.45.45,0,0,1-.22.29L17.42,15.3l-.12,0h-.25l-.12-.06-.09-.09-.06-.07,0-.06-.87-2.12a.43.43,0,0,1,0-.37.49.49,0,0,1,.27-.26.41.41,0,0,1,.36,0,.53.53,0,0,1,.27.26l.44,1.09a6.51,6.51,0,0,0,.24-1.36,4.58,4.58,0,0,0,0-.64,5.83,5.83,0,0,0-1.73-4.17,5.88,5.88,0,0,0-8.34,0,5.9,5.9,0,0,0,4.17,10.06.51.51,0,0,1,.33.15.48.48,0,0,1,0,.68.53.53,0,0,1-.33.12Z" transform="translate(-4.48 -4.54)"/></g></svg>',
    undo: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.59 14.18"><g><path d="M5,14a.43.43,0,0,1-.22-.29.46.46,0,0,1,.06-.36.43.43,0,0,1,.29-.22.56.56,0,0,1,.36,0l.91.55a8.27,8.27,0,0,1-.22-1.45,5.07,5.07,0,0,1,0-.67A6.85,6.85,0,1,1,13,18.47a.44.44,0,0,1-.33-.13.48.48,0,0,1,0-.68.51.51,0,0,1,.33-.15A5.89,5.89,0,0,0,17.15,7.45a5.88,5.88,0,0,0-8.33,0,5.84,5.84,0,0,0-1.73,4.17s0,.25,0,.65a6.49,6.49,0,0,0,.24,1.37l.44-1.09a.57.57,0,0,1,.27-.26.41.41,0,0,1,.36,0,.53.53,0,0,1,.27.26.43.43,0,0,1,0,.37L7.82,15l0,.09-.09.09-.1.07-.06,0H7.28l-.13,0-1.09-.63c-.65-.36-1-.57-1.1-.63Z" transform="translate(-4.49 -4.53)"/></g></svg>',
    bold: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.76 15.75"><g><path d="M6.4,3.76V19.5h6.76a5.55,5.55,0,0,0,2-.32,4.93,4.93,0,0,0,1.52-1,4.27,4.27,0,0,0,1.48-3.34,3.87,3.87,0,0,0-.69-2.37,5.74,5.74,0,0,0-.71-.83,3.44,3.44,0,0,0-1.1-.65,3.6,3.6,0,0,0,1.58-1.36,3.66,3.66,0,0,0,.53-1.93,3.7,3.7,0,0,0-1.21-2.87,4.65,4.65,0,0,0-3.25-1.1H6.4Zm2.46,6.65V5.57h3.52a4.91,4.91,0,0,1,1.36.15,2.3,2.3,0,0,1,.85.45,2.06,2.06,0,0,1,.74,1.71,2.3,2.3,0,0,1-.78,1.92,2.54,2.54,0,0,1-.86.46,4.7,4.7,0,0,1-1.32.15H8.86Zm0,7.27V12.15H12.7a4.56,4.56,0,0,1,1.38.17,3.43,3.43,0,0,1,.95.49,2.29,2.29,0,0,1,.92,2,2.73,2.73,0,0,1-.83,2.1,2.66,2.66,0,0,1-.83.58,3.25,3.25,0,0,1-1.26.2H8.86Z" transform="translate(-6.4 -3.75)"/></g></svg>',
    underline: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 9.78 15.74"><g><path d="M14.64,3.76h2.52v7.72a4.51,4.51,0,0,1-.59,2.31,3.76,3.76,0,0,1-1.71,1.53,6.12,6.12,0,0,1-2.64.53,5,5,0,0,1-3.57-1.18,4.17,4.17,0,0,1-1.27-3.24V3.76H9.9v7.3a3,3,0,0,0,.55,2,2.3,2.3,0,0,0,1.83.65,2.26,2.26,0,0,0,1.8-.65,3.09,3.09,0,0,0,.55-2V3.76Zm2.52,13.31V19.5H7.39V17.08h9.77Z" transform="translate(-7.38 -3.76)"/></g></svg>',
    italic: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10.49 15.76"><g><path d="M17.16,3.79l.37,0-.06.38-.14.52A10,10,0,0,1,16.21,5a9.37,9.37,0,0,0-1,.32,6.68,6.68,0,0,0-.25.89c-.06.31-.11.59-.14.85-.3,1.36-.52,2.41-.68,3.14l-.61,3.18L13.1,15l-.43,2.4-.12.46a.62.62,0,0,0,0,.28c.44.1.85.17,1.23.22l.68.11a4.51,4.51,0,0,1-.08.6l-.09.42a.92.92,0,0,0-.23,0l-.43,0a1.37,1.37,0,0,1-.29,0c-.13,0-.63-.08-1.49-.16l-2,0c-.28,0-.87,0-1.78.12L7,19.5l.17-.88.8-.2A6.61,6.61,0,0,0,9.19,18,2.62,2.62,0,0,0,9.61,17l.28-1.41.58-2.75.12-.66c.05-.3.11-.58.17-.86s.12-.51.17-.69l.12-.48.12-.43.31-1.6.15-.65.31-1.91V5.14a3.86,3.86,0,0,0-1.48-.29l-.38,0,.2-1.06,3.24.14.75,0c.45,0,1.18,0,2.18-.09.23,0,.46,0,.71,0Z" transform="translate(-7.04 -3.76)"/></g></svg>',
    strike: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.9"><g><path d="M12.94,13a4.27,4.27,0,0,1,1.32.58,1.46,1.46,0,0,1,.55,1.2,1.87,1.87,0,0,1-.88,1.64,4.17,4.17,0,0,1-2.35.59,4.44,4.44,0,0,1-2.74-.71,2.72,2.72,0,0,1-1-2.17H5.57a4.56,4.56,0,0,0,1.55,3.7,7,7,0,0,0,4.47,1.23,6,6,0,0,0,4.07-1.3,4.24,4.24,0,0,0,1.52-3.37,4,4,0,0,0-.26-1.4h-4ZM6.37,10.24A3.27,3.27,0,0,1,6,8.68a4,4,0,0,1,1.48-3.3,5.92,5.92,0,0,1,3.88-1.21,5.58,5.58,0,0,1,3.91,1.24,4.36,4.36,0,0,1,1.45,3.17H14.44a2.12,2.12,0,0,0-.91-1.81,4.45,4.45,0,0,0-2.44-.55,3.69,3.69,0,0,0-2,.51A1.64,1.64,0,0,0,8.3,8.22a1.3,1.3,0,0,0,.48,1.11,7,7,0,0,0,2.1.78l.28.06.28.08H6.37Zm13.09.68a.73.73,0,0,1,.49.21.66.66,0,0,1,.2.48.64.64,0,0,1-.2.48.71.71,0,0,1-.49.19H5.1a.67.67,0,0,1-.49-.19.66.66,0,0,1-.2-.48.64.64,0,0,1,.2-.48.73.73,0,0,1,.49-.21H19.46Z" transform="translate(-4.41 -4.17)"/></g></svg>',
    subscript: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 14.61"><g><path d="M15.38,4.33H12.74L11.19,7c-.28.46-.51.87-.69,1.21L10.07,9h0l-.44-.8c-.22-.4-.45-.81-.71-1.23L7.34,4.33H4.68L8.26,10,4.4,16.08H7.1l1.69-2.83c.38-.63.72-1.22,1-1.78l.25-.46h0l.49.92c.24.45.48.89.74,1.32L13,16.08h2.61L11.84,10l1.77-2.84,1.77-2.85Zm4.77,13.75H17v-.15c0-.4.05-.64.16-.72a4.42,4.42,0,0,1,1.16-.31,3.3,3.3,0,0,0,1.54-.56A1.84,1.84,0,0,0,20.15,15a1.78,1.78,0,0,0-.44-1.41A2.8,2.8,0,0,0,18,13.25a2.71,2.71,0,0,0-1.69.37,1.83,1.83,0,0,0-.44,1.43v.23H17v-.23q0-.63.18-.78a1.62,1.62,0,0,1,.88-.15,1.59,1.59,0,0,1,.88.15q.18.15.18.75t-.18.75a3.58,3.58,0,0,1-1.18.33,3.33,3.33,0,0,0-1.52.51,1.57,1.57,0,0,0-.32,1.18v1.15h4.27v-.86Z" transform="translate(-4.4 -4.33)"/></g></svg>',
    superscript: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.42"><g><path d="M12,13.14l3.61-5.81H12.94L11.33,10c-.28.46-.51.88-.69,1.25l-.45.83h0l-.45-.85c-.22-.41-.45-.82-.71-1.24L7.4,7.33H4.68l3.66,5.81L4.4,19.33H7.14l1.74-2.87q.58-1,1-1.83l.25-.48h0l.51.94.75,1.37,1.72,2.87h2.67l-1.92-3.09c-1.12-1.8-1.76-2.83-1.92-3.1Zm4.84-4.41h0l0,.15h3.27v.86H15.77V8.58a1.66,1.66,0,0,1,.33-1.22,3.51,3.51,0,0,1,1.56-.51,3.68,3.68,0,0,0,1.21-.34c.13-.1.19-.36.19-.77S19,5.07,18.87,5A1.63,1.63,0,0,0,18,4.8a1.58,1.58,0,0,0-.91.17c-.13.11-.19.38-.19.8V6H15.78V5.76a1.87,1.87,0,0,1,.45-1.47A2.84,2.84,0,0,1,18,3.91a2.8,2.8,0,0,1,1.72.38,1.84,1.84,0,0,1,.45,1.44,1.91,1.91,0,0,1-.34,1.35,3.24,3.24,0,0,1-1.58.57A3.69,3.69,0,0,0,17,8c-.12.1-.17.35-.17.76Z" transform="translate(-4.4 -3.91)"/></g></svg>',
    erase: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.76"><g><path d="M13.69,17.2h6.46v1.31H8.56L4.41,14.37,14,4.75l6.06,6.06L16.89,14l-3.2,3.19Zm-4.61,0h2.77L14.09,15,9.88,10.75,6.25,14.38l1.41,1.41c.84.82,1.31,1.29,1.42,1.41Z" transform="translate(-4.41 -4.75)"/></g></svg>',
    indent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 12.36"><g><path d="M4.68,14.45a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V9.1a.27.27,0,0,1,.08-.19.28.28,0,0,1,.2-.08.25.25,0,0,1,.19.07l2.54,2.54a.29.29,0,0,1,0,.4L4.88,14.36a.24.24,0,0,1-.2.09Zm15.19,1.12a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.25.25,0,0,1-.08-.19V15.84a.27.27,0,0,1,.27-.27H19.87Zm0-3.38a.27.27,0,0,1,.19.08.28.28,0,0,1,.08.21v1.68a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V12.48a.32.32,0,0,1,.08-.21.24.24,0,0,1,.19-.08h9.56Zm0-3.37a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.27-.27V9.1a.27.27,0,0,1,.27-.27h9.56Zm.2-3.29a.28.28,0,0,1,.08.2V7.41a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V5.73a.32.32,0,0,1,.08-.21.25.25,0,0,1,.19-.08H19.87a.28.28,0,0,1,.2.09Z" transform="translate(-4.41 -5.44)"/></g></svg>',
    outdent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 12.36"><g><path d="M19.87,15.57a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.25.25,0,0,1-.08-.19V15.84a.27.27,0,0,1,.27-.27H19.87ZM7.5,14.45a.25.25,0,0,1-.2-.09L4.76,11.84a.29.29,0,0,1,0-.4L7.3,8.9a.29.29,0,0,1,.4,0,.31.31,0,0,1,.07.2v5.06a.32.32,0,0,1-.08.21.26.26,0,0,1-.19.08ZM19.87,8.82a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.27-.27V9.1a.27.27,0,0,1,.27-.27h9.56Zm0,3.37a.27.27,0,0,1,.19.08.28.28,0,0,1,.08.21v1.68a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V12.48a.32.32,0,0,1,.08-.21.24.24,0,0,1,.19-.08h9.56Zm.2-6.66a.28.28,0,0,1,.08.2V7.41a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V5.73a.32.32,0,0,1,.08-.21.25.25,0,0,1,.19-.08H19.87a.28.28,0,0,1,.2.09Z" transform="translate(-4.41 -5.44)"/></g></svg>',
    expansion: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M11.8,13.06l-5.1,5.1H9.51V19.5H4.41V14.4H5.75v2.81L8.3,14.66q2.25-2.23,2.55-2.55Zm8.35-9.3v5.1H18.81V6.05l-5.1,5.1-1-1,5.1-5.1H15.05V3.76Z" transform="translate(-4.41 -3.76)"/></g></svg>',
    reduction: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M14.91,10h2.87v1.38H12.55V6.12h1.38V9l5.24-5.24.48.49.49.48ZM6.77,11.92H12v5.23H10.62V14.26L5.37,19.5l-1-1L9.63,13.3H6.77Z" transform="translate(-4.4 -3.76)"/></g></svg>',
    code_view: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 11.8"><g><path d="M8.09,7.94a.76.76,0,0,1,.53.22.72.72,0,0,1,.21.52.76.76,0,0,1-.22.54L6.18,11.63l2.43,2.44a.69.69,0,0,1,.2.51.66.66,0,0,1-.21.51.75.75,0,0,1-.51.22.63.63,0,0,1-.51-.21h0L4.63,12.15a.7.7,0,0,1-.22-.53.67.67,0,0,1,.25-.55L7.57,8.16a.82.82,0,0,1,.52-.22Zm12.05,3.69a.7.7,0,0,1-.23.52L17,15.1h0a.66.66,0,0,1-.51.21.73.73,0,0,1-.51-.22.75.75,0,0,1-.22-.51.63.63,0,0,1,.21-.51l2.43-2.44L15.92,9.22a.73.73,0,0,1-.22-.53A.74.74,0,0,1,17,8.18h0l2.91,2.91a.67.67,0,0,1,.27.54Zm-5.9-5.9a.73.73,0,0,1,.61.32.71.71,0,0,1,.07.68L11,17a1,1,0,0,1-.22.32.6.6,0,0,1-.35.16.75.75,0,0,1-.69-.26.69.69,0,0,1-.12-.72L13.56,6.23a.75.75,0,0,1,.26-.35.74.74,0,0,1,.42-.15Z" transform="translate(-4.41 -5.73)"/></g></svg>',
    preview: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.65 15.66"><g><path d="M16.19,14.43l2.49,2.49a.73.73,0,0,1,.21.52.67.67,0,0,1-.22.51.7.7,0,0,1-.52.22.69.69,0,0,1-.51-.21l-2.49-2.48a5.17,5.17,0,0,1-1.34.69,4.64,4.64,0,0,1-1.48.24,4.78,4.78,0,1,1,0-9.56,4.79,4.79,0,0,1,1.84.36,4.9,4.9,0,0,1,1.56,1,4.77,4.77,0,0,1,.46,6.18ZM10,14a3.3,3.3,0,0,0,2.34.93A3.37,3.37,0,0,0,14.7,14a3.3,3.3,0,0,0-1.08-5.41,3.47,3.47,0,0,0-2.56,0A3,3,0,0,0,10,9.28,3.31,3.31,0,0,0,10,14ZM16,4a3.86,3.86,0,0,1,2.77,1.14A3.9,3.9,0,0,1,20,7.85v4a.77.77,0,0,1-.22.53.7.7,0,0,1-.52.21.72.72,0,0,1-.74-.74v-4a2.46,2.46,0,0,0-.72-1.73A2.37,2.37,0,0,0,16,5.45H8.53A2.42,2.42,0,0,0,6.08,7.89v7.52a2.41,2.41,0,0,0,.71,1.73,2.46,2.46,0,0,0,1.74.72h4.08a.73.73,0,0,1,0,1.46H8.53a3.85,3.85,0,0,1-2.78-1.14A3.93,3.93,0,0,1,4.6,15.4V7.87A3.94,3.94,0,0,1,5.76,5.09,3.88,3.88,0,0,1,8.54,4H16Z" transform="translate(-4.45 -3.8)"/></g></svg>',
    print: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16.05 16.04"><g><path d="M19.76,15.84a1.29,1.29,0,0,0,.39-.92V8.35A2.05,2.05,0,0,0,19.57,7a1.93,1.93,0,0,0-1.38-.57H6.37a1.95,1.95,0,0,0-2,2v6.56a1.23,1.23,0,0,0,.38.92,1.35,1.35,0,0,0,.93.38h2V14.9l-2,0V8.35a.67.67,0,0,1,.18-.47.62.62,0,0,1,.48-.19H18.18a.6.6,0,0,1,.46.19.66.66,0,0,1,.18.47V14.9h-2v1.32h2A1.35,1.35,0,0,0,19.76,15.84ZM17.52,7.69V5.06a1.31,1.31,0,0,0-.38-.92,1.34,1.34,0,0,0-.94-.38H8.34A1.3,1.3,0,0,0,7,5.06V7.69H8.34V5.06h7.87V7.69h1.31ZM8.34,12.93h7.87l0,5.26H8.34V12.93Zm7.87,5.26v0Zm.65,1.31a.6.6,0,0,0,.46-.19.72.72,0,0,0,.2-.47V12.29a.74.74,0,0,0-.2-.47.6.6,0,0,0-.46-.19H7.68a.6.6,0,0,0-.46.19.72.72,0,0,0-.2.47v6.55a.74.74,0,0,0,.2.47.6.6,0,0,0,.46.19h9.18ZM16.67,9.28a.7.7,0,0,0-.94,0,.63.63,0,0,0-.18.46.67.67,0,0,0,.18.47.68.68,0,0,0,.94,0,.66.66,0,0,0,.18-.47A.58.58,0,0,0,16.67,9.28Z" transform="translate(-4.25 -3.61)"/></g></svg>',
    template: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14.27 15.64"><g><path d="M18.18,19.16a1,1,0,0,0,1-1V5.73a1,1,0,0,0-1-1h-2v1h2V18.19H6.37V5.73h2v-1h-2A.94.94,0,0,0,5.68,5a1,1,0,0,0-.29.7V18.18a.94.94,0,0,0,.29.69,1,1,0,0,0,.69.29H18.18ZM9.82,10.31h4.92a.49.49,0,0,0,.35-.15.47.47,0,0,0,.15-.35.49.49,0,0,0-.15-.35.47.47,0,0,0-.35-.15H9.82a.49.49,0,0,0-.35.15.47.47,0,0,0-.15.35.49.49,0,0,0,.15.35.47.47,0,0,0,.35.15Zm5.9,4.92H8.83a.49.49,0,0,0-.35.15.47.47,0,0,0-.15.35.49.49,0,0,0,.15.35.47.47,0,0,0,.35.15h6.89a.49.49,0,0,0,.35-.15.47.47,0,0,0,.15-.35.51.51,0,0,0-.5-.5ZM7.36,12.77a.49.49,0,0,0,.15.35.47.47,0,0,0,.35.15h8.85a.49.49,0,0,0,.35-.15.47.47,0,0,0,.15-.35.49.49,0,0,0-.15-.35.47.47,0,0,0-.35-.15H7.85a.49.49,0,0,0-.35.15.52.52,0,0,0-.14.35Z" transform="translate(-5.14 -3.77)"/><path d="M14.24,6.71a1,1,0,0,0,1-1,1,1,0,0,0-1-1,1,1,0,0,0-1-1h-2a.94.94,0,0,0-.69.28,1,1,0,0,0-.29.7A.94.94,0,0,0,9.62,5a.91.91,0,0,0-.29.69,1,1,0,0,0,.29.7,1,1,0,0,0,.69.29h3.93Z" transform="translate(-5.14 -3.77)"/></g></svg>',
    line_height: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 13.56"><g><path d="M4.4,4.88V8.26a2,2,0,0,0,.5.39s.1,0,.18-.12a.62.62,0,0,0,.17-.28c.06-.19.13-.44.21-.74s.14-.52.19-.66a.58.58,0,0,1,.21-.3,2.41,2.41,0,0,1,.63-.21,3.83,3.83,0,0,1,.88-.12,9.15,9.15,0,0,1,1.31.06.16.16,0,0,1,.11,0,.26.26,0,0,1,.06.14,4,4,0,0,1,0,.49v2l.05,3.77c0,1.41,0,2.68-.05,3.81a1.79,1.79,0,0,1-.11.49,10.68,10.68,0,0,1-1.4.45,1.12,1.12,0,0,0-.69.43v.31l0,.22.61,0c.85-.08,1.54-.12,2.06-.12a19.76,19.76,0,0,1,2.09.08,15.08,15.08,0,0,0,1.64.08,1.4,1.4,0,0,0,.29,0,1.58,1.58,0,0,0,0-.26l-.05-.43a2.26,2.26,0,0,0-.43-.17l-.77-.22-.15,0a2.55,2.55,0,0,1-.78-.28,2.56,2.56,0,0,1-.11-.75l0-1.29,0-3.15V7.53a10.51,10.51,0,0,1,.06-1.2,3.83,3.83,0,0,1,.6,0l1.88,0a2.18,2.18,0,0,1,.38,0,.45.45,0,0,1,.23.17.9.9,0,0,1,.05.25c0,.16.06.35.1.58a3.33,3.33,0,0,0,.14.55A6.39,6.39,0,0,0,15,9a2.91,2.91,0,0,0,.6-.15,2.77,2.77,0,0,0,0-.46l0-.51,0-2.95-.25,0-.38,0L15,4.94a.71.71,0,0,1-.18.15.45.45,0,0,1-.25.07l-.29,0H8.75l-.15,0H7.45a17,17,0,0,1-1.86,0L5.36,5l-.25-.13ZM19.75,16.14h-.69v-9h.69A.4.4,0,0,0,20.13,7c.06-.11,0-.24-.1-.39L18.92,5.15a.52.52,0,0,0-.86,0L17,6.58c-.12.15-.16.28-.1.39s.18.16.38.16h.69v9h-.69a.4.4,0,0,0-.38.16c-.06.11,0,.24.1.39l1.11,1.43a.52.52,0,0,0,.86,0L20,16.69c.12-.15.16-.28.1-.39a.4.4,0,0,0-.38-.16Z" transform="translate(-4.4 -4.86)"/></g></svg>',
    paragraph_style: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.81 15.74"><g><path d="M18.18,3.76v2h-2V19.5h-2V5.73h-2V19.5h-2V11.63a3.94,3.94,0,0,1,0-7.87h7.87Z" transform="translate(-6.37 -3.76)"/></g></svg>',
    text_style: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 13.76 15.74"><g><path d="M17.68,6.71a2.22,2.22,0,0,0,1.06-.22.74.74,0,0,0,.42-.7.73.73,0,0,0-.08-.33.67.67,0,0,0-.17-.22,1,1,0,0,0-.31-.15L18.26,5l-.45-.09A15.27,15.27,0,0,0,13.26,5V4.74c0-.66-.63-1-1.92-1-.24,0-.43.15-.59.46a4,4,0,0,0-.36,1.14h0v0a26.45,26.45,0,0,1-3.5.35A2,2,0,0,0,5.77,6a.84.84,0,0,0-.37.79,2.14,2.14,0,0,0,.41,1.29,1.23,1.23,0,0,0,1.05.63,16.62,16.62,0,0,0,3.29-.45l-.34,3.35c-.16,1.61-.29,2.9-.37,3.86s-.12,1.66-.12,2.09l0,.65a5.15,5.15,0,0,0,.05.6,1.28,1.28,0,0,0,.16.54.34.34,0,0,0,.28.18,1.16,1.16,0,0,0,.79-.46,3.66,3.66,0,0,0,.68-1,22.08,22.08,0,0,0,1-4.33q.49-3.1.78-6.15a24.69,24.69,0,0,1,4.62-.84Z" transform="translate(-5.4 -3.76)"/></g></svg>',
    save: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M18.53,19.5l.2-.05A1.78,1.78,0,0,0,20.13,18l0-.09V7.14a2,2,0,0,0-.28-.64A3.18,3.18,0,0,0,19.43,6c-.5-.52-1-1-1.55-1.54A2.59,2.59,0,0,0,17.37,4a1.83,1.83,0,0,0-.61-.25H6l-.21,0a1.78,1.78,0,0,0-1.4,1.49l0,.1V17.87a2.49,2.49,0,0,0,.09.37,1.79,1.79,0,0,0,1.44,1.23l.09,0Zm-6.25-.6H6.92a.61.61,0,0,1-.68-.48.78.78,0,0,1,0-.22V12.3a.62.62,0,0,1,.69-.68H17.64a.62.62,0,0,1,.69.69V18.2a.64.64,0,0,1-.71.69H12.28ZM12,9.81H8.15a.63.63,0,0,1-.72-.71v-4a.64.64,0,0,1,.72-.72h7.66a.64.64,0,0,1,.72.72v4a.65.65,0,0,1-.74.72ZM13.5,5V9.18h1.78V5Z" transform="translate(-4.41 -3.76)"/></g></svg>',
    blockquote: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 475.082 475.081"><g><path d="M164.45,219.27h-63.954c-7.614,0-14.087-2.664-19.417-7.994c-5.327-5.33-7.994-11.801-7.994-19.417v-9.132c0-20.177,7.139-37.401,21.416-51.678c14.276-14.272,31.503-21.411,51.678-21.411h18.271c4.948,0,9.229-1.809,12.847-5.424c3.616-3.617,5.424-7.898,5.424-12.847V54.819c0-4.948-1.809-9.233-5.424-12.85c-3.617-3.612-7.898-5.424-12.847-5.424h-18.271c-19.797,0-38.684,3.858-56.673,11.563c-17.987,7.71-33.545,18.132-46.68,31.267c-13.134,13.129-23.553,28.688-31.262,46.677C3.855,144.039,0,162.931,0,182.726v200.991c0,15.235,5.327,28.171,15.986,38.834c10.66,10.657,23.606,15.985,38.832,15.985h109.639c15.225,0,28.167-5.328,38.828-15.985c10.657-10.663,15.987-23.599,15.987-38.834V274.088c0-15.232-5.33-28.168-15.994-38.832C192.622,224.6,179.675,219.27,164.45,219.27z"/><path d="M459.103,235.256c-10.656-10.656-23.599-15.986-38.828-15.986h-63.953c-7.61,0-14.089-2.664-19.41-7.994c-5.332-5.33-7.994-11.801-7.994-19.417v-9.132c0-20.177,7.139-37.401,21.409-51.678c14.271-14.272,31.497-21.411,51.682-21.411h18.267c4.949,0,9.233-1.809,12.848-5.424c3.613-3.617,5.428-7.898,5.428-12.847V54.819c0-4.948-1.814-9.233-5.428-12.85c-3.614-3.612-7.898-5.424-12.848-5.424h-18.267c-19.808,0-38.691,3.858-56.685,11.563c-17.984,7.71-33.537,18.132-46.672,31.267c-13.135,13.129-23.559,28.688-31.265,46.677c-7.707,17.987-11.567,36.879-11.567,56.674v200.991c0,15.235,5.332,28.171,15.988,38.834c10.657,10.657,23.6,15.985,38.828,15.985h109.633c15.229,0,28.171-5.328,38.827-15.985c10.664-10.663,15.985-23.599,15.985-38.834V274.088C475.082,258.855,469.76,245.92,459.103,235.256z"/></g></svg>',
    arrow_down: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 8.67"><g><path d="M18.79,7.52a.8.8,0,0,1,.56-.23.82.82,0,0,1,.79.79.8.8,0,0,1-.23.56l-7.07,7.07a.79.79,0,0,1-.57.25.77.77,0,0,1-.57-.25h0L4.64,8.65a.8.8,0,0,1-.23-.57.82.82,0,0,1,.79-.79.8.8,0,0,1,.56.23L12.28,14l3.26-3.26,3.25-3.26Z" transform="translate(-4.41 -7.29)"/></g></svg>',
    align_justify: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm0,5.9H20.15v-2H4.41v2Zm0,3.94H20.15v-2H4.41v2Zm0,3.93h7.87v-2H4.41v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
    align_left: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm11.8,3.94H4.41v2H16.22v-2Zm-11.8,5.9H18.18v-2H4.41v2Zm0,3.93h9.84v-2H4.41v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
    align_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm3.93,5.9H20.15v-2H8.34v2Zm-2,3.94H20.14v-2H6.37v2Zm3.94,3.93h9.84v-2H10.31v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
    align_center: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm2,3.94v2H18.18v-2H6.37Zm-1,5.9H19.16v-2H5.39v2Zm2,3.93H17.2v-2H7.36v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
    font_color: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.61"><g><path d="M18.5,15.57,14.28,4.32h-3.4L6.65,15.57h3l.8-2.26h4.23l.8,2.26h3ZM14,11.07H11.14L12.54,7,13.25,9c.41,1.18.64,1.86.7,2ZM4.41,16.69v2.24H20.15V16.69H4.41Z" transform="translate(-4.41 -4.32)"/></g></svg>',
    highlight_color: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.66 15.74"><g><path d="M12.32,9.31,13.38,13H11.21l.52-1.83q.46-1.61.54-1.83ZM4.44,3.76H20.1V19.5H4.44V3.76ZM14.71,17.32h2.63L13.7,6H10.89L7.26,17.32H9.89l.63-2.24h3.55l.32,1.12c.18.65.29,1,.32,1.12Z" transform="translate(-4.44 -3.76)"/></g></svg>',
    list_bullets: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 12.37"><g><path d="M7.77,16.12a1.59,1.59,0,0,0-.49-1.18,1.62,1.62,0,0,0-1.19-.49,1.68,1.68,0,1,0,0,3.36,1.67,1.67,0,0,0,1.68-1.69Zm0-4.48A1.67,1.67,0,0,0,6.09,10,1.68,1.68,0,0,0,4.9,12.82a1.62,1.62,0,0,0,1.19.49,1.67,1.67,0,0,0,1.68-1.67Zm12.38,3.64a.27.27,0,0,0-.08-.19.28.28,0,0,0-.2-.09H9.19a.28.28,0,0,0-.2.08.29.29,0,0,0-.08.19V17a.27.27,0,0,0,.28.28H19.87a.27.27,0,0,0,.19-.08.24.24,0,0,0,.08-.2V15.28ZM7.77,7.13a1.63,1.63,0,0,0-.49-1.2,1.61,1.61,0,0,0-1.19-.49,1.61,1.61,0,0,0-1.19.49,1.71,1.71,0,0,0,0,2.4,1.62,1.62,0,0,0,1.19.49,1.61,1.61,0,0,0,1.19-.49,1.63,1.63,0,0,0,.49-1.2Zm12.38,3.66a.28.28,0,0,0-.08-.2.29.29,0,0,0-.19-.08H9.19a.27.27,0,0,0-.28.28v1.69a.27.27,0,0,0,.08.19.24.24,0,0,0,.2.08H19.87a.27.27,0,0,0,.19-.08.25.25,0,0,0,.08-.19V10.79Zm0-4.5a.27.27,0,0,0-.08-.19A.25.25,0,0,0,19.88,6H9.19A.28.28,0,0,0,9,6.1a.26.26,0,0,0-.08.19V8A.27.27,0,0,0,9,8.17a.24.24,0,0,0,.2.08H19.87a.27.27,0,0,0,.19-.08A.25.25,0,0,0,20.14,8V6.29Z" transform="translate(-4.41 -5.44)"/></g></svg>',
    list_number: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.69 15.74"><g><path d="M7.66,18a1.24,1.24,0,0,0-.26-.78,1.17,1.17,0,0,0-.72-.42l.85-1V15H4.58v1.34h.94v-.46l.85,0h0c-.11.11-.22.23-.32.35s-.23.27-.37.47L5.39,17l.23.51c.61-.05.92.11.92.49a.42.42,0,0,1-.18.37.79.79,0,0,1-.45.12A1.41,1.41,0,0,1,5,18.15l-.51.77A2.06,2.06,0,0,0,6,19.5a1.8,1.8,0,0,0,1.2-.41A1.38,1.38,0,0,0,7.66,18Zm0-5.54H6.75V13H5.63A.72.72,0,0,1,6,12.51a5.45,5.45,0,0,1,.66-.45,2.71,2.71,0,0,0,.67-.57,1.19,1.19,0,0,0,.31-.81,1.29,1.29,0,0,0-.45-1,1.86,1.86,0,0,0-2-.11,1.51,1.51,0,0,0-.62.7l.74.52A.87.87,0,0,1,6,10.28a.51.51,0,0,1,.35.12.42.42,0,0,1,.13.33.55.55,0,0,1-.21.4,3,3,0,0,1-.5.38c-.19.13-.39.27-.58.42a2,2,0,0,0-.5.6,1.63,1.63,0,0,0-.21.81,3.89,3.89,0,0,0,.05.48h3.2V12.44Zm12.45,2.82a.27.27,0,0,0-.08-.19.28.28,0,0,0-.21-.08H9.1a.32.32,0,0,0-.21.08.24.24,0,0,0-.08.2V17a.27.27,0,0,0,.08.19.3.3,0,0,0,.21.08H19.83a.32.32,0,0,0,.21-.08.25.25,0,0,0,.08-.19V15.26ZM7.69,7.32h-1V3.76H5.8L4.6,4.88l.63.68a1.85,1.85,0,0,0,.43-.48h0l0,2.24H4.74V8.2h3V7.32Zm12.43,3.42a.27.27,0,0,0-.08-.19.28.28,0,0,0-.21-.08H9.1a.32.32,0,0,0-.21.08.24.24,0,0,0-.08.2v1.71a.27.27,0,0,0,.08.19.3.3,0,0,0,.21.08H19.83a.32.32,0,0,0,.21-.08.25.25,0,0,0,.08-.19V10.74Zm0-4.52A.27.27,0,0,0,20,6,.28.28,0,0,0,19.83,6H9.1A.32.32,0,0,0,8.89,6a.24.24,0,0,0-.08.19V7.93a.27.27,0,0,0,.08.19.32.32,0,0,0,.21.08H19.83A.32.32,0,0,0,20,8.12a.26.26,0,0,0,.08-.2V6.22Z" transform="translate(-4.43 -3.76)"/></g></svg>',
    table: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M4.41,8.05V3.76H8.7V8.05H4.41Zm5.71,0V3.76h4.3V8.05h-4.3Zm5.74-4.29h4.29V8.05H15.86V3.76Zm-11.45,10V9.48H8.7v4.3H4.41Zm5.71,0V9.48h4.3v4.3h-4.3Zm5.74,0V9.48h4.29v4.3H15.86ZM4.41,19.5V15.21H8.7V19.5H4.41Zm5.71,0V15.21h4.3V19.5h-4.3Zm5.74,0V15.21h4.29V19.5H15.86Z" transform="translate(-4.41 -3.76)"/></g></svg>',
    horizontal_rule: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 2.24"><g><path d="M20.15,12.75V10.51H4.41v2.24H20.15Z" transform="translate(-4.41 -10.51)"/></g></svg>',
    show_blocks: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.66 15.67"><g><path d="M19.72,5.58a1.64,1.64,0,0,0-1.64-1.64H6.23a1.62,1.62,0,0,0-1.16.48,1.63,1.63,0,0,0-.48,1.16V9.63a1.6,1.6,0,0,0,.48,1.16,1.62,1.62,0,0,0,1.16.47H18.09a1.67,1.67,0,0,0,1.16-.47,1.62,1.62,0,0,0,.48-1.16V5.58Zm-.94,4.05a.68.68,0,0,1-.7.7H6.23a.66.66,0,0,1-.48-.2.74.74,0,0,1-.21-.5V5.58a.66.66,0,0,1,.2-.48.71.71,0,0,1,.48-.21H18.08a.74.74,0,0,1,.5.21.66.66,0,0,1,.2.48ZM6.48,7.72a.21.21,0,0,0,.17-.07.22.22,0,0,0,.07-.17V7.06a1.27,1.27,0,0,1,.11-.52.37.37,0,0,1,.36-.23H8.77A.25.25,0,0,0,9,6.17a.19.19,0,0,0,0-.23.27.27,0,0,0-.2-.12H7.19a.88.88,0,0,0-.72.39,1.51,1.51,0,0,0-.23.85v.42a.24.24,0,0,0,.24.24Zm-.19.81a.21.21,0,0,0,.17-.07.26.26,0,0,0,.07-.17.24.24,0,0,0-.24-.24.2.2,0,0,0-.16.09.2.2,0,0,0-.07.16.22.22,0,0,0,.07.17.23.23,0,0,0,.16.06Zm8.46,5.1a1.63,1.63,0,0,0-.47-1.16A1.61,1.61,0,0,0,13.12,12H6.23a1.6,1.6,0,0,0-1.16.46,1.62,1.62,0,0,0-.48,1.16v4.05a1.64,1.64,0,0,0,1.64,1.64h6.89a1.6,1.6,0,0,0,1.16-.48,1.62,1.62,0,0,0,.47-1.16Zm-.94,4a.7.7,0,0,1-.2.49.65.65,0,0,1-.5.2H6.23a.66.66,0,0,1-.48-.2.75.75,0,0,1-.21-.49v-4a.74.74,0,0,1,.21-.5.66.66,0,0,1,.48-.2h6.89a.68.68,0,0,1,.7.7v4Zm6.15,0v-4a1.6,1.6,0,0,0-.48-1.16A1.67,1.67,0,0,0,18.32,12H17.1a1.63,1.63,0,0,0-1.16.47,1.61,1.61,0,0,0-.47,1.16v4a1.67,1.67,0,0,0,.47,1.16,1.62,1.62,0,0,0,1.16.48h1.22A1.64,1.64,0,0,0,20,17.68Zm-.94-4v4a.75.75,0,0,1-.21.49.62.62,0,0,1-.48.2H17.11a.69.69,0,0,1-.5-.2.7.7,0,0,1-.2-.49v-4a.68.68,0,0,1,.7-.7h1.22a.66.66,0,0,1,.48.2.72.72,0,0,1,.21.5Z" transform="translate(-4.44 -3.79)"/></g></svg>',
    cancel: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M14.15,11.63l5.61,5.61a1.29,1.29,0,0,1,.38.93,1.27,1.27,0,0,1-.4.93,1.25,1.25,0,0,1-.92.4,1.31,1.31,0,0,1-.94-.4l-5.61-5.61L6.67,19.1a1.31,1.31,0,0,1-.94.4,1.24,1.24,0,0,1-.92-.4,1.27,1.27,0,0,1-.4-.93,1.33,1.33,0,0,1,.38-.93l5.61-5.63L4.79,6a1.26,1.26,0,0,1-.38-.93,1.22,1.22,0,0,1,.4-.92,1.28,1.28,0,0,1,.92-.39,1.38,1.38,0,0,1,.94.38l5.61,5.61,5.61-5.61a1.33,1.33,0,0,1,.94-.38,1.26,1.26,0,0,1,.92.39,1.24,1.24,0,0,1,.4.92,1.29,1.29,0,0,1-.39.93L17,8.81l-2.8,2.82Z" transform="translate(-4.41 -3.76)"/></g></svg>',
    image: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.77"><g><path d="M8.77,8.72a.88.88,0,0,1-.61-.27.82.82,0,0,1-.25-.61.89.89,0,0,1,.25-.62A.82.82,0,0,1,8.77,7a.81.81,0,0,1,.61.25.83.83,0,0,1,.27.62.81.81,0,0,1-.25.61.91.91,0,0,1-.63.27Zm9.62-5a1.74,1.74,0,0,1,1.76,1.76V17.76a1.74,1.74,0,0,1-1.76,1.76H6.16A1.74,1.74,0,0,1,4.4,17.76V5.51A1.74,1.74,0,0,1,6.16,3.75H18.39Zm0,1.75H6.16v8L8.53,11.8a.94.94,0,0,1,.54-.17.86.86,0,0,1,.54.2L11.09,13l3.64-4.55a.78.78,0,0,1,.34-.25.85.85,0,0,1,.42-.07.89.89,0,0,1,.39.12.78.78,0,0,1,.28.29l2.24,3.67V5.51Zm0,12.24V15.6L15.3,10.53,11.89,14.8a.89.89,0,0,1-.59.32.82.82,0,0,1-.64-.18L9,13.62,6.16,15.74v2Z" transform="translate(-4.4 -3.75)"/></g></svg>',
    video: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.55"><g><path d="M20.15,10.26V18.9l-3.94-1.57v1.2H4.41V10.66H16.22v1.23l2-.81,2-.82ZM14.64,17h0V12.54h0v-.31H6V17h8.67Zm3.94-.37v-4l-2.37,1v2l1.18.48,1.19.48ZM7.94,9.86A2.77,2.77,0,0,1,5.19,7.11a2.76,2.76,0,0,1,5.51,0A2.78,2.78,0,0,1,7.94,9.86Zm0-3.93a1.21,1.21,0,0,0-.83.35,1.15,1.15,0,0,0-.34.84A1.09,1.09,0,0,0,7.11,8,1.15,1.15,0,0,0,8,8.28,1.13,1.13,0,0,0,9.11,7.12,1.16,1.16,0,0,0,7.94,5.93Zm5.9,3.93a2.34,2.34,0,0,1-1.67-.68,2.3,2.3,0,0,1-.68-1.67,2.35,2.35,0,0,1,4-1.67,2.37,2.37,0,0,1,0,3.34,2.33,2.33,0,0,1-1.68.68Zm0-3.14a.75.75,0,1,0,.55.22.73.73,0,0,0-.55-.22Z" transform="translate(-4.41 -4.35)"/></g></svg>',
    link: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.72"><g><path d="M13.05,13.63a.24.24,0,0,1,.15.22L13.42,16a.19.19,0,0,1-.08.18l-2.12,2.14a4.08,4.08,0,0,1-1.29.85A4,4,0,0,1,4.71,17a3.92,3.92,0,0,1-.3-1.52A4,4,0,0,1,4.71,14a3.91,3.91,0,0,1,.87-1.3L7.7,10.56a.25.25,0,0,1,.2-.06l2.17.22a.21.21,0,0,1,.19.15.24.24,0,0,1,0,.25L7.12,14.23a1.81,1.81,0,0,0,0,2.58,1.78,1.78,0,0,0,1.29.52,1.74,1.74,0,0,0,1.28-.52L12.8,13.7a.24.24,0,0,1,.25-.07ZM19,4.92a4,4,0,0,1,0,5.66L16.86,12.7a.25.25,0,0,1-.17.08l-2.2-.23a.21.21,0,0,1-.19-.15.22.22,0,0,1,0-.25L17.44,9a1.81,1.81,0,0,0,0-2.58,1.78,1.78,0,0,0-1.29-.52,1.74,1.74,0,0,0-1.28.52L11.76,9.57a.21.21,0,0,1-.25,0,.24.24,0,0,1-.16-.21l-.22-2.17a.19.19,0,0,1,.08-.18l2.12-2.14a4.08,4.08,0,0,1,1.29-.85,4.05,4.05,0,0,1,3.06,0,3.85,3.85,0,0,1,1.3.85ZM5.84,9.82a.25.25,0,0,1-.18-.08.19.19,0,0,1-.07-.19l.11-.77a.2.2,0,0,1,.11-.17.24.24,0,0,1,.2,0l2.5.72a.25.25,0,0,1,.15.27.22.22,0,0,1-.23.21l-2.59,0Zm4.12-2-.73-2.5a.27.27,0,0,1,0-.2A.21.21,0,0,1,9.41,5L10.19,5a.25.25,0,0,1,.19,0,.23.23,0,0,1,.08.18l-.05,2.61a.2.2,0,0,1-.19.23h0A.22.22,0,0,1,10,7.85Zm8.76,5.58a.25.25,0,0,1,.18.08.23.23,0,0,1,.06.2l-.11.77a.25.25,0,0,1-.11.17.21.21,0,0,1-.12,0l-.08,0L16,14a.25.25,0,0,1-.15-.27.22.22,0,0,1,.22-.21l1.29,0,1.33,0Zm-4.12,2,.74,2.51a.28.28,0,0,1,0,.2.23.23,0,0,1-.18.11l-.8.11a.23.23,0,0,1-.17-.07.25.25,0,0,1-.08-.18l0-2.61a.22.22,0,0,1,.22-.22.21.21,0,0,1,.26.15Z" transform="translate(-4.41 -3.77)"/></g></svg>',
    math: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.81 15.73"><g><path d="M17.19,5.73a1,1,0,0,0,.71-.29,1,1,0,0,0,.28-.7,1,1,0,0,0-1-1H7.35a1,1,0,0,0-1,1,.77.77,0,0,0,.13.47h0l4.58,6.43L6.68,17.81a1.25,1.25,0,0,0-.29.71.94.94,0,0,0,.28.7.92.92,0,0,0,.69.28H17.2a1,1,0,0,0,.71-.28,1,1,0,0,0,0-1.39.92.92,0,0,0-.71-.29H9.26l3.87-5.43a.86.86,0,0,0,0-.95L9.26,5.73h7.93Z" transform="translate(-6.38 -3.77)"/></g></svg>',
    unlink: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.72"><g><path d="M19,18.32a4,4,0,0,0,0-5.68L15.85,9.5l-1.17,1.55L17.57,14a2,2,0,0,1,.61,1.47,2.08,2.08,0,0,1-2.09,2.09,2,2,0,0,1-1.47-.61l-.38-.37-1.74,1,.8.78a4,4,0,0,0,5.68,0ZM8,9.77a2,2,0,0,1-1.27-1,1.89,1.89,0,0,1-.21-1.57A2.1,2.1,0,0,1,7.45,6,2,2,0,0,1,9,5.76L12.27,7.2l.49-2L9.48,3.9a4,4,0,0,0-3.06.41A3.82,3.82,0,0,0,4.56,6.73a3.8,3.8,0,0,0,.4,3A3.78,3.78,0,0,0,7.39,11.6l5.38,2,.49-2-2.64-.94L8,9.77Z" transform="translate(-4.41 -3.76)"/></g></svg>',
    table_header: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.74"><g><path d="M17,19.5v-.78H15.5v.78H17Zm-3,0v-.78H12.5v.78H14Zm-3,0v-.78H9.53v.78H11Zm-3,0v-.78H6.53v.78H8Zm10.55,0a1.73,1.73,0,0,0,.85-.35,1.67,1.67,0,0,0,.56-.76l-.71-.31a1.21,1.21,0,0,1-.35.4,1.34,1.34,0,0,1-.53.23l.08.38c.06.24.09.38.1.41Zm-13.7-.63.55-.55A.77.77,0,0,1,5.25,18a1.31,1.31,0,0,1-.06-.38v-.38H4.41v.38a2,2,0,0,0,.12.68,1.6,1.6,0,0,0,.35.57Zm15.27-2.12V15.26h-.78v1.49h.78Zm-15-1V14.23H4.41v1.49h.78Zm15-2V12.26h-.78v1.49h.78Zm-15-1V11.22H4.41v1.51h.78Zm15-2V9.26h-.78v1.51h.78Zm-15-1V8.17H4.41V9.74h.78Zm15-2V6.28h-.78V7.77h.78Zm-15-1.11V5.33L4.48,5.1a.77.77,0,0,0-.07.27,2.72,2.72,0,0,0,0,.28v1h.79ZM19.21,5l.63-.4A1.62,1.62,0,0,0,19.16,4a1.94,1.94,0,0,0-.91-.22v.78a1.31,1.31,0,0,1,.56.12.88.88,0,0,1,.4.36ZM6,4.54H7.78V3.76H6a.82.82,0,0,0-.28.06l.12.35c.07.21.1.33.11.36Zm10.8,0V3.76H15.28v.78h1.49Zm-3,0V3.76H12.28v.78h1.49Zm-3,0V3.76H9.28v.78h1.51ZM6,10.84h12.6V6.91H6Z" transform="translate(-4.4 -3.76)"/></g></svg>',
    merge_cell: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 15.74"><g><path d="M18.92,13.5h1.23v4.15A1.84,1.84,0,0,1,18.3,19.5H14V18.27H18.3a.6.6,0,0,0,.44-.18.59.59,0,0,0,.18-.44V13.5ZM18.3,3.76a1.84,1.84,0,0,1,1.85,1.85V9.82H18.92V5.6a.6.6,0,0,0-.18-.44A.59.59,0,0,0,18.3,5H14V3.76H18.3Zm1.85,8.51H15.6L17.26,14l-.86.86-3.14-3.17L16.4,8.51l.86.86L15.62,11h4.54v1.24Zm-13.9,6h4.27V19.5H6.25A1.84,1.84,0,0,1,4.4,17.65V13.5H5.63v4.15a.61.61,0,0,0,.62.62Zm0-14.51h4.27V5H6.25a.6.6,0,0,0-.44.18.57.57,0,0,0-.17.43V9.81H4.41V5.6A1.83,1.83,0,0,1,6.25,3.76Zm5,7.9L8.15,14.83,7.3,14,9,12.27H4.41V11H8.94L7.3,9.38,7.73,9l.43-.43Z" transform="translate(-4.4 -3.76)"/></g></svg>',
    split_cell: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.74"><g><path d="M10.37,12.25H6.74L8.4,13.94l-.87.86L4.41,11.63,7.53,8.5l.87.86L6.74,11h3.62v1.23Zm9.78-.61L17,14.81,16.13,14l1.66-1.69H14.16V11h3.63L16.13,9.37l.43-.43A5.24,5.24,0,0,1,17,8.51ZM18.9,8.22V5.61a.57.57,0,0,0-.18-.43A.65.65,0,0,0,18.29,5H12.88V18.28h5.41a.7.7,0,0,0,.44-.18.57.57,0,0,0,.18-.43V15h1.23v2.64a1.84,1.84,0,0,1-1.85,1.83h-12A1.84,1.84,0,0,1,4.94,19a1.81,1.81,0,0,1-.54-1.29V15H5.63v2.64a.57.57,0,0,0,.18.43.67.67,0,0,0,.44.18h5.41V5H6.25a.7.7,0,0,0-.44.18.56.56,0,0,0-.17.43V8.22H4.41V5.61A1.8,1.8,0,0,1,5,4.31a1.91,1.91,0,0,1,1.31-.55h12a1.89,1.89,0,0,1,1.31.55,1.8,1.8,0,0,1,.54,1.3V8.23H18.9Z" transform="translate(-4.4 -3.76)"/></g></svg>',
    caption: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.79"><g><path d="M4.41,18.52H20.15v-2H4.41ZM20,4.73H18.07V6h.65v.65H20V4.73ZM17,6V4.73H14.55V6H17ZM13.49,6V4.73H11V6h2.47ZM10,6V4.73H7.5V6H10ZM5.79,6h.65V4.73H4.5V6.67H5.8V6ZM4.5,11.34H5.79V8.48H4.5ZM6.44,13.8H5.79v-.65H4.5v1.94H6.44ZM17,15.09V13.8H14.55v1.29H17Zm-3.52,0V13.8H11v1.29h2.47Zm-3.53,0V13.8H7.5v1.29H10ZM20,13.16H18.72v.65h-.65V15.1H20Zm-1.29-1.82H20V8.48h-1.3v2.86Z" transform="translate(-4.41 -4.73)"/></g></svg>',
    edit: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.73"><g><path d="M7.51,5.68h6l1.52-1.57H6.94a2.4,2.4,0,0,0-1.79.82A2.8,2.8,0,0,0,4.41,6.8V17a2.55,2.55,0,0,0,.75,1.8A2.48,2.48,0,0,0,7,19.5H17.22a2.57,2.57,0,0,0,1.83-.74,2.52,2.52,0,0,0,.77-1.8V8.83l-1.58,1.54v6a1.54,1.54,0,0,1-1.53,1.53H7.51A1.54,1.54,0,0,1,6,16.41V7.21A1.52,1.52,0,0,1,7.51,5.68Zm5.63,7.47h0L10.7,10.74l-1,3.38,1.71-.48,1.7-.49Zm.34-.34h0l5.36-5.32L16.4,5.08,11,10.4l1.23,1.21,1.21,1.2ZM19.93,6.4a.82.82,0,0,0,.22-.48A.54.54,0,0,0,20,5.47L18.45,4A.67.67,0,0,0,18,3.77a.7.7,0,0,0-.48.21l-.74.72,2.44,2.43.37-.37.35-.36Z" transform="translate(-4.41 -3.77)"/></g></svg>',
    delete: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 15.74"><g><path d="M19.16,6.71a.94.94,0,0,0,.69-.28.91.91,0,0,0,.29-.68A1,1,0,0,0,19.85,5a.93.93,0,0,0-.69-.3H14.24A.94.94,0,0,0,14,4.06a.92.92,0,0,0-.7-.3h-2a1,1,0,0,0-.7.3.93.93,0,0,0-.28.68H5.39A.92.92,0,0,0,4.7,5a1,1,0,0,0-.29.71.91.91,0,0,0,.29.68,1,1,0,0,0,.69.28H19.16Zm-12.79,1a1,1,0,0,0-.7.3.94.94,0,0,0-.28.69v8.85A1.88,1.88,0,0,0,6,18.93a1.9,1.9,0,0,0,1.39.57H17.2a1.87,1.87,0,0,0,1.39-.58,1.91,1.91,0,0,0,.58-1.39V8.68A1,1,0,0,0,18.88,8a.89.89,0,0,0-.7-.29,1,1,0,0,0-.69.29.92.92,0,0,0-.29.68v7.87a1,1,0,0,1-1,1H8.34a.94.94,0,0,1-.69-.28,1,1,0,0,1-.29-.71V8.68a1,1,0,0,0-1-1Z" transform="translate(-4.41 -3.76)"/></g></svg>',
    modify: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.74"><g><path d="M19.79,15.23a.66.66,0,0,1,.3.38.59.59,0,0,1-.07.48l-.8,1.38a.66.66,0,0,1-.38.3.59.59,0,0,1-.48-.07l-.68-.38a4.55,4.55,0,0,1-1.34.77v.78a.64.64,0,0,1-.18.45.61.61,0,0,1-.45.18h-1.6a.6.6,0,0,1-.44-.18.66.66,0,0,1-.19-.45v-.78a4.36,4.36,0,0,1-1.32-.77l-.69.38a.58.58,0,0,1-.48.07.66.66,0,0,1-.38-.3l-.38-.66h.83a1.77,1.77,0,0,0,1.23-.52,1.72,1.72,0,0,0,.51-1.23v-.18a3,3,0,0,0,.49-.28l.15.09a1.83,1.83,0,0,0,.88.23A1.75,1.75,0,0,0,15.84,14l.88-1.52a1.7,1.7,0,0,0,.17-1.32,1.66,1.66,0,0,0-.3-.61,1.84,1.84,0,0,0-.51-.45l-.15-.09,0-.29,0-.28.15-.09a1,1,0,0,0,.26-.18l0,.06v.78a4.34,4.34,0,0,1,1.34.77l.68-.38a.68.68,0,0,1,.48-.06.64.64,0,0,1,.38.29l.8,1.38a.58.58,0,0,1,.07.48.63.63,0,0,1-.3.38l-.68.4a3.84,3.84,0,0,1,.08.76,4.13,4.13,0,0,1-.08.78l.34.18.32.2ZM10.17,7.86a1.9,1.9,0,0,1,1.35,3.23,1.85,1.85,0,0,1-1.35.55A1.9,1.9,0,0,1,8.83,8.41a1.92,1.92,0,0,1,1.34-.55Zm1.58,7.2a.73.73,0,0,1-.21.49.66.66,0,0,1-.48.2H9.29a.68.68,0,0,1-.69-.69V14.2a4.75,4.75,0,0,1-1.48-.86l-.75.45a.73.73,0,0,1-.7,0,.63.63,0,0,1-.25-.26L4.54,12a.67.67,0,0,1-.08-.53.71.71,0,0,1,.32-.42l.75-.43a4.8,4.8,0,0,1-.08-.85,4.71,4.71,0,0,1,.08-.85l-.74-.44a.71.71,0,0,1-.32-.42.65.65,0,0,1,.07-.54L5.42,6a.66.66,0,0,1,.42-.32l.18,0a.73.73,0,0,1,.35.09l.75.43A4.68,4.68,0,0,1,8.6,5.33V4.45a.68.68,0,0,1,.69-.69h1.77a.64.64,0,0,1,.48.2.73.73,0,0,1,.21.49v.88a4.75,4.75,0,0,1,1.48.85L14,5.75a.67.67,0,0,1,.34-.09l.18,0a.71.71,0,0,1,.42.32l.89,1.54a.67.67,0,0,1,.06.52.73.73,0,0,1-.32.43l-.75.42a4.8,4.8,0,0,1,.08.85,4.71,4.71,0,0,1-.08.85l.75.43a.66.66,0,0,1,.32.42.73.73,0,0,1-.06.54l-.89,1.52a.69.69,0,0,1-.25.26.7.7,0,0,1-.35.09.64.64,0,0,1-.34-.09l-.75-.45a4.87,4.87,0,0,1-1.48.86v.87ZM7.23,9.75a3,3,0,0,0,.86,2.08,2.94,2.94,0,1,0,4.16-4.16,3,3,0,0,0-2.08-.85A2.94,2.94,0,0,0,7.23,9.75Z" transform="translate(-4.44 -3.76)"/></g></svg>',
    revert: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 14.69"><g><path d="M18.26,15V12.3l1.89-2V15a2.58,2.58,0,0,1-.24,1c-.2.58-.75.92-1.65,1H7.56v2L4.41,15.63,7.56,13v2h10.7ZM6.3,8.28V11L4.41,13V8.28a2.58,2.58,0,0,1,.24-1c.2-.58.75-.92,1.65-1H17v-2l3.15,3.34L17,10.3v-2H6.3Z" transform="translate(-4.4 -4.28)"/></g></svg>',
    auto_size: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M6.71,17.19,6.89,16l1.21-.15A6,6,0,0,1,6.81,13.9a5.78,5.78,0,0,1-.45-2.27A6,6,0,0,1,8.1,7.45a5.83,5.83,0,0,1,4.17-1.73l1-1-1-1A7.89,7.89,0,0,0,5,14.64a7.73,7.73,0,0,0,1.71,2.55Zm5.57,2.31h0A7.86,7.86,0,0,0,17.85,6.07L17.67,7.3l-1.21.15a5.9,5.9,0,0,1,1.29,1.92,5.81,5.81,0,0,1,.45,2.26,5.91,5.91,0,0,1-5.9,5.9l-1,1,.49.49.47.5Z" transform="translate(-4.41 -3.76)"/></g></svg>',
    insert_row_below: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M15.7,1.3c-0.1-0.1-0.1-0.2-0.2-0.2L15.3,1H0.4L0.3,1.1c0,0-0.1,0.1-0.1,0.1c0,0-0.1,0.1-0.1,0.1L0,1.4v7.7l0.1,0.1c0,0.1,0.1,0.1,0.2,0.2l0.1,0.1h2.3V9.3l0.1-0.5L3,8.5l0.1-0.2c-0.1,0-0.2,0-0.3,0H1.2v-6h13.3v6h-1.6c-0.1,0-0.2,0-0.3,0l0.1,0.2l0.2,0.4C12.9,9,13,9.2,13,9.3v0.1h2.3l0.2-0.1c0.1,0,0.1-0.1,0.2-0.2l0.1-0.1V1.4L15.7,1.3z"/><path d="M10.5,7.5C9.9,7.1,9.3,6.8,8.6,6.7c-0.2,0-0.5-0.1-0.7,0c-0.2,0-0.5,0-0.7,0C6.6,6.7,6.1,6.9,5.6,7.3C5.2,7.6,4.7,8,4.4,8.4C4.3,8.6,4.2,8.8,4.2,8.9C4.1,9.1,4,9.3,3.9,9.4C3.9,9.6,3.8,9.7,3.8,9.9c0,0.2-0.1,0.3-0.1,0.5v-0.1c-0.1,0.8,0.1,1.6,0.5,2.4c0.4,0.7,1,1.3,1.7,1.7c0.3,0.2,0.6,0.3,0.9,0.3c0.3,0.1,0.7,0.1,1,0.1c0.3,0,0.7,0,1-0.1c0.3-0.1,0.6-0.2,0.9-0.3c0.5-0.3,0.9-0.6,1.3-1c0.3-0.4,0.6-0.8,0.8-1.3c0.1-0.4,0.2-0.9,0.2-1.4c0-0.5-0.1-1-0.3-1.4C11.5,8.6,11.1,8,10.5,7.5z M10.1,11.3H8.5v1.6H8H7.9H7.3v0v-0.1v-1.4H5.7v-0.4v-0.2v-0.6h0h1.5V8.5h1.2v1.6h1.6V11.3z"/></g></svg>',
    insert_row_above: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M0.1,14.5c0.1,0.1,0.1,0.2,0.2,0.2l0.1,0.1h14.9l0.1-0.1c0,0,0.1-0.1,0.1-0.1c0,0,0.1-0.1,0.1-0.1l0.1-0.1V6.7l-0.1-0.1c0-0.1-0.1-0.1-0.2-0.2l-0.1-0.1h-2.3v0.1l-0.1,0.5l-0.2,0.4l-0.1,0.2c0.1,0,0.2,0,0.3,0h1.6v6H1.3v-6h1.6c0.1,0,0.2,0,0.3,0L3.1,7.3L2.9,6.9C2.8,6.8,2.8,6.6,2.7,6.5V6.3H0.4L0.3,6.4c-0.1,0-0.1,0.1-0.2,0.2L0,6.7v7.7L0.1,14.5z"/><path d="M5.3,8.3c0.6,0.5,1.2,0.8,1.9,0.9c0.2,0,0.5,0.1,0.7,0c0.2,0,0.5,0,0.7,0c0.6-0.1,1.1-0.3,1.6-0.6c0.5-0.3,0.9-0.7,1.2-1.2c0.1-0.2,0.2-0.3,0.3-0.5c0.1-0.2,0.2-0.4,0.2-0.5c0.1-0.1,0.1-0.3,0.1-0.4C12,5.8,12,5.6,12,5.4v0.1c0.1-0.8-0.1-1.6-0.5-2.4c-0.4-0.7-1-1.3-1.7-1.7C9.5,1.3,9.2,1.2,8.9,1.1C8.5,1,8.2,1,7.9,1c-0.3,0-0.7,0-1,0.1C6.6,1.2,6.3,1.3,6,1.4C5.5,1.7,5.1,2,4.7,2.4C4.4,2.8,4.1,3.3,3.9,3.8C3.8,4.2,3.7,4.7,3.7,5.2c0,0.5,0.1,1,0.3,1.4C4.3,7.2,4.7,7.8,5.3,8.3z M5.7,4.5h1.6V2.9h0.5h0.1h0.6v0v0.1v1.4H10v0.4v0.2v0.6h0H8.5v1.6H7.3V5.7H5.7V4.5z"/></g></svg>',
    insert_column_left: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M14.5,15.7c0.1-0.1,0.2-0.1,0.2-0.2l0.1-0.1V0.4l-0.1-0.1c0,0-0.1-0.1-0.1-0.1c0,0-0.1-0.1-0.1-0.1L14.4,0H6.7L6.6,0.1c-0.1,0-0.1,0.1-0.2,0.2L6.3,0.4v2.3h0.1l0.5,0.1L7.3,3l0.2,0.1c0-0.1,0-0.2,0-0.3V1.2h6v13.3h-6v-1.6c0-0.1,0-0.2,0-0.3l-0.2,0.1l-0.4,0.2C6.7,12.9,6.6,13,6.4,13H6.3v2.3l0.1,0.2c0,0.1,0.1,0.1,0.2,0.2l0.1,0.1h7.7L14.5,15.7z"/><path d="M8.3,10.5C8.7,10,9,9.3,9.1,8.6c0-0.2,0.1-0.5,0-0.7c0-0.2,0-0.5,0-0.7C9,6.7,8.8,6.1,8.5,5.7C8.2,5.2,7.8,4.8,7.3,4.5C7.2,4.4,7,4.3,6.9,4.2C6.7,4.1,6.5,4,6.4,4C6.2,3.9,6.1,3.9,5.9,3.8c-0.2,0-0.3-0.1-0.5-0.1h0.1C4.7,3.7,3.8,3.9,3.1,4.3C2.4,4.7,1.8,5.3,1.4,6C1.3,6.3,1.2,6.6,1.1,6.9C1,7.2,1,7.6,1,7.9c0,0.3,0,0.7,0.1,1c0.1,0.3,0.2,0.6,0.3,0.9c0.3,0.5,0.6,0.9,1,1.3c0.4,0.3,0.8,0.6,1.3,0.8C4.2,12,4.7,12.1,5.1,12c0.5,0,1-0.1,1.4-0.3C7.2,11.5,7.8,11.1,8.3,10.5zM4.5,10.1V8.5H2.9V8V7.9V7.3h0H3h1.4V5.7h0.4h0.2h0.6v0v1.5h1.6v1.2H5.7v1.6H4.5z"/></g></svg>',
    insert_column_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M1.3,0.1C1.2,0.2,1.1,0.2,1.1,0.3L1,0.4v14.9l0.1,0.1c0,0,0.1,0.1,0.1,0.1c0,0,0.1,0.1,0.1,0.1l0.1,0.1h7.7l0.1-0.1c0.1,0,0.1-0.1,0.2-0.2l0.1-0.1v-2.3H9.3l-0.5-0.1l-0.4-0.2l-0.2-0.1c0,0.1,0,0.2,0,0.3v1.6h-6V1.3h6v1.6c0,0.1,0,0.2,0,0.3l0.2-0.1l0.4-0.2C9,2.9,9.2,2.8,9.3,2.8h0.1V0.5L9.4,0.3c0-0.1-0.1-0.1-0.2-0.2L9.1,0H1.4L1.3,0.1z"/><path d="M7.5,5.3C7,5.8,6.7,6.5,6.6,7.2c0,0.2-0.1,0.5,0,0.7c0,0.2,0,0.5,0,0.7c0.1,0.6,0.3,1.1,0.6,1.6c0.3,0.5,0.7,0.9,1.2,1.2c0.2,0.1,0.3,0.2,0.5,0.3c0.2,0.1,0.4,0.2,0.5,0.2c0.1,0.1,0.3,0.1,0.4,0.1c0.2,0,0.3,0.1,0.5,0.1h-0.1c0.8,0.1,1.6-0.1,2.4-0.5c0.7-0.4,1.3-1,1.7-1.7c0.2-0.3,0.3-0.6,0.3-0.9c0.1-0.3,0.1-0.7,0.1-1c0-0.3,0-0.7-0.1-1c-0.1-0.3-0.2-0.6-0.3-0.9c-0.3-0.5-0.6-0.9-1-1.3C13,4.4,12.5,4.2,12,4c-0.4-0.1-0.9-0.2-1.4-0.2c-0.5,0-1,0.1-1.4,0.2C8.5,4.3,7.9,4.7,7.5,5.3z M11.3,5.7v1.6h1.6v0.5v0.1v0.6h0h-0.1h-1.4v1.6h-0.4h-0.2h-0.6v0V8.5H8.5V7.3h1.6V5.7H11.3z"/></g></svg>',
    delete_row: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 13.83"><g><path d="M4.7,18.46l.12.08H19.73l.12-.08a.58.58,0,0,0,.22-.22l.08-.12,0-7.69-.08-.11a.77.77,0,0,0-.18-.18l-.11-.08-2.31,0-.08.28-.1.29a1.58,1.58,0,0,1-.12.29l-.14.34s0,0,.18,0H18.9v6H5.64v-6H7.35c.14,0,.2,0,.18,0l-.14-.34a2.85,2.85,0,0,1-.12-.29l-.1-.29-.07-.27-2.31,0-.11.08a.77.77,0,0,0-.18.18l-.08.11,0,7.69.08.12a.47.47,0,0,0,.09.12l.13.09ZM12.11,13a4,4,0,0,0,1.46-.21,4.51,4.51,0,0,0,1.31-.71A4,4,0,0,0,16.26,10a4.32,4.32,0,0,0-.08-2.54,4.34,4.34,0,0,0-1-1.52,4.15,4.15,0,0,0-1.54-1,4.34,4.34,0,0,0-1.35-.22A4.07,4.07,0,0,0,11,4.93,3.94,3.94,0,0,0,9.24,6.07,3.92,3.92,0,0,0,8.15,8.88a3.91,3.91,0,0,0,.12.95A4.16,4.16,0,0,0,12.11,13Zm2.35-4.14v.58H10.09V8.27h4.37v.58Z" transform="translate(-4.4 -4.71)"/></g></svg>',
    delete_column: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 13.81 15.74"><g><path d="M5.66,19.42l.12.08,7.69,0,.11-.08a.77.77,0,0,0,.18-.18l.08-.11,0-2.32-.15,0-.45-.15-.42-.18-.17-.07a1,1,0,0,0,0,.27v1.63h-6V5h6V6.62a.9.9,0,0,0,0,.26l.17-.07.42-.17a3.91,3.91,0,0,1,.45-.15l.15,0,0-2.32L13.75,4a.77.77,0,0,0-.18-.18l-.11-.08H5.79l-.13.07a.63.63,0,0,0-.21.22l-.08.12V19.08l.08.12a.47.47,0,0,0,.09.12.35.35,0,0,0,.12.1Zm9-3.67a4.16,4.16,0,0,0,2.36-.51,4.08,4.08,0,0,0,1.67-1.72,4,4,0,0,0,.35-.91,3.79,3.79,0,0,0,.1-1,4.71,4.71,0,0,0-.11-1,5,5,0,0,0-.3-.87,4.25,4.25,0,0,0-1-1.25,4.49,4.49,0,0,0-1.34-.81A4.26,4.26,0,0,0,15,7.48a3.88,3.88,0,0,0-1.41.25A4.32,4.32,0,0,0,11.86,9,4,4,0,0,0,11,10.94a4.4,4.4,0,0,0-.05.68,4.5,4.5,0,0,0,.05.68,3.93,3.93,0,0,0,.61,1.57,4.22,4.22,0,0,0,1.18,1.2,4.59,4.59,0,0,0,.48.27c.2.1.37.17.5.22a2.44,2.44,0,0,0,.45.12,4.61,4.61,0,0,0,.5.07Zm2.54-4.12v.58H12.87V11h4.37v.59Z" transform="translate(-5.37 -3.76)"/></g></svg>',
    fixed_column_width: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6,5H18A1,1 0 0,1 19,6A1,1 0 0,1 18,7H6A1,1 0 0,1 5,6A1,1 0 0,1 6,5M21,2V4H3V2H21M15,8H17V22H15V8M7,8H9V22H7V8M11,8H13V22H11V8Z" /></svg>',
    rotate_left: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M0.5,10.2c0,0.1,0,0.2,0,0.3v0.2l0,0c0.1,0.3,0.3,0.6,0.4,0.9l0,0C1,11.8,1.3,12,1.5,11.9h0.1h0.2h0.1c0.1-0.1,0.3-0.3,0.4-0.5v-0.2c0-0.1,0-0.2-0.1-0.3l0,0c-0.2-0.2-0.3-0.4-0.3-0.7l0,0C1.8,10,1.7,9.9,1.5,9.8c-0.1,0-0.2,0-0.3,0H0.9C0.7,9.9,0.6,10,0.5,10.2L0.5,10.2z"/><path d="M2.2,11.5L2.2,11.5L2.2,11.5z"/><path d="M5.9,3.6L5.9,3.6L5.9,3.6z"/><path d="M0.1,7.9c0,0.3,0,0.6,0,0.9l0,0l0,0l0,0l0,0c0,0.2,0.1,0.3,0.2,0.4l0,0c0.2,0.1,0.3,0.2,0.5,0.2l0,0l0,0c0.2,0,0.4-0.1,0.5-0.3l0,0c0-0.1,0.1-0.3,0.1-0.4V8.6l0,0c0-0.2,0-0.5,0-0.7l0,0c0-0.2-0.1-0.4-0.2-0.5C1.1,7.3,0.9,7.2,0.7,7.2S0.3,7.3,0.2,7.4C0.1,7.5,0,7.7,0.1,7.9z"/><path d="M1.9,12.7L1.9,12.7c0,0.2,0,0.4,0.2,0.5l0,0l0.2,0.3l0,0c0.2,0.1,0.3,0.2,0.5,0.4l0,0l0,0l0,0l0,0C2.9,14,3,14.1,3.2,14.1s0.4-0.1,0.5-0.2c0.1-0.2,0.2-0.3,0.2-0.5v-0.1c0-0.2-0.1-0.4-0.2-0.5l0,0l-0.4-0.4l-0.2-0.2l0,0C3,12.1,2.8,12,2.6,12l0,0c-0.2,0-0.4,0.1-0.5,0.2l0,0C2,12.3,1.9,12.5,1.9,12.7z"/><path d="M6.6,15c0,0.2,0.1,0.4,0.2,0.5c0.1,0.1,0.2,0.2,0.4,0.3l0,0c0.3,0,0.5,0,0.7,0h0.3l0,0c0.2,0,0.4-0.1,0.5-0.2c0.1-0.2,0.2-0.3,0.2-0.5l0,0l0,0c0-0.2-0.1-0.4-0.2-0.5l0,0c-0.1-0.1-0.3-0.2-0.5-0.2l0,0H7.9c-0.1,0-0.3,0-0.5,0l0,0H7.3c-0.2-0.1-0.3,0-0.5,0.1l0,0C6.7,14.6,6.6,14.8,6.6,15L6.6,15L6.6,15L6.6,15z"/><path d="M4.2,7.4C4,7.5,4,7.7,4,7.9c0,0.2,0,0.4,0.2,0.5l0,0l3.2,3.2l0,0c0.1,0.1,0.3,0.2,0.5,0.2s0.3-0.1,0.5-0.2l0,0l3.2-3.2l0,0c0.1-0.1,0.2-0.3,0.2-0.5c0-0.2-0.1-0.4-0.2-0.5l0,0C11.5,7.3,11,6.7,10,5.8l0,0L8.4,4.2l0,0C8.3,4.1,8.1,4,7.9,4S7.5,4.1,7.4,4.2L4.2,7.4L4.2,7.4z M6.8,9L5.7,7.9l2.2-2.2l2.3,2.2l-2.3,2.2C7.7,9.9,7.3,9.5,6.8,9L6.8,9z"/><path d="M4.1,14.1C4,14.2,4,14.3,4,14.4v0.2l0,0c0.1,0.1,0.2,0.3,0.4,0.4l0,0c0.3,0.1,0.6,0.2,0.9,0.4h0.1h0.1l0,0c0.2,0,0.3-0.1,0.5-0.1l0,0c0.2-0.1,0.3-0.3,0.3-0.4l0,0l0,0l0,0l0,0v-0.2c0-0.1-0.1-0.2-0.1-0.3l0,0C6.1,14.2,6,14.1,5.8,14l0,0c-0.3-0.1-0.5-0.2-0.8-0.2l0,0c-0.1-0.1-0.2-0.1-0.3-0.1H4.5C4.3,13.7,4.2,13.9,4.1,14.1z"/><path d="M9.3,14.4c0,0.1-0.1,0.3,0,0.4V15l0,0c0,0.1,0.1,0.3,0.5,0.4c0.1,0.1,0.3,0.1,0.4,0.1l0,0h0.1l0,0c0.3-0.1,0.6-0.2,0.9-0.3l0,0c0.1-0.1,0.2-0.2,0.3-0.4l0.1-0.3c0-0.1-0.1-0.2-0.1-0.3l0,0c-0.1-0.2-0.2-0.3-0.4-0.4l0,0h-0.3c-0.1,0-0.2,0-0.3,0l0,0c-0.2,0.1-0.5,0.2-0.8,0.3l0,0C9.5,14.1,9.4,14.2,9.3,14.4L9.3,14.4z"/><path d="M11.4,14.7L11.4,14.7L11.4,14.7z"/><path d="M9.5,15.3L9.5,15.3L9.5,15.3z"/><path d="M15.9,7.9c0-1-0.2-2-0.6-3l0,0c-0.4-1-1-1.9-1.7-2.6C12.8,1.6,12,1,11,0.6l0,0C10.1,0.2,9,0,8,0C7.3,0,6.5,0.1,5.8,0.3l0,0C5.2,0.5,4.6,0.8,4,1.1L3.1,0.2l0,0C2.9,0.1,2.8,0,2.6,0H2.4l0,0C2.2,0,2,0.2,1.9,0.4l0,0L0.1,4.9l0,0C0,5,0,5.1,0,5.2c0,0.2,0.1,0.4,0.2,0.5l0,0c0.2,0.1,0.3,0.2,0.5,0.2h0.1H1l0,0l4.7-1.8l0,0C5.9,4,6.1,3.8,6.1,3.6V3.4C6.1,3.2,6,3,5.9,2.9l0,0L5.1,2.1c0.4-0.2,0.8-0.4,1.3-0.5c0.5-0.1,1.1-0.2,1.7-0.2c0.9,0,1.7,0.2,2.5,0.5l0,0c0.8,0.3,1.5,0.8,2.1,1.4c0.6,0.6,1.1,1.3,1.4,2.1l0,0c0.3,0.8,0.5,1.6,0.5,2.5s-0.2,1.7-0.5,2.5l0,0c-0.3,0.8-0.8,1.5-1.4,2.1c-0.2,0.2-0.4,0.3-0.6,0.5l0,0c-0.2,0.1-0.3,0.3-0.3,0.5v0.1c0,0.1,0,0.3,0.1,0.4l0,0c0.1,0.2,0.3,0.3,0.5,0.3l0,0c0.1,0,0.3-0.1,0.4-0.2l0,0l0,0l0,0l0,0c0.2-0.2,0.5-0.4,0.7-0.6l0,0l0,0l0,0l0,0c0.7-0.8,1.3-1.6,1.7-2.6C15.6,10,15.8,9,15.9,7.9z M1.9,4C2,3.8,2.1,3.5,2.3,3.1l0,0L2.7,2l1.2,1.2L1.9,4z"/><path d="M6.8,15.5L6.8,15.5L6.8,15.5z"/></g></svg>',
    rotate_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M9.9,15.3L9.9,15.3L9.9,15.3z"/><path d="M6.9,15.1L6.9,15.1c0,0.1,0.1,0.3,0.2,0.4l0,0c0.1,0.2,0.3,0.3,0.5,0.3l0,0h0.3c0.2,0,0.4,0,0.7,0l0,0c0.2-0.1,0.3-0.2,0.4-0.3c0.1-0.1,0.2-0.2,0.2-0.4V15c0-0.2-0.1-0.4-0.2-0.4c-0.2-0.1-0.3-0.2-0.5-0.2H8.4l0,0c-0.1,0-0.3,0-0.5,0H7.6l0,0c-0.2,0-0.4,0.1-0.5,0.2C7,14.7,6.9,14.9,6.9,15.1z"/><path d="M6.5,14.4L6.5,14.4L6.5,14.4z"/><path d="M5.8,5.8L5.8,5.8c-1,0.9-1.5,1.5-1.7,1.6l0,0C4,7.5,4,7.7,4,7.9c0,0.2,0,0.4,0.2,0.5l0,0l3.2,3.2l0,0c0.2,0.1,0.3,0.2,0.5,0.2s0.4-0.1,0.5-0.2l0,0l3.2-3.2l0,0c0.1-0.1,0.2-0.3,0.2-0.5c0-0.2-0.1-0.4-0.2-0.5l0,0L8.4,4.2C8.3,4.1,8.1,4,7.9,4C7.7,4,7.5,4.1,7.4,4.2l0,0L5.8,5.8z M5.6,7.9l2.3-2.2l2.2,2.2L9,9l0,0l0,0l0,0l0,0c-0.5,0.6-0.9,0.9-1.1,1.1L5.6,7.9z"/><path d="M9,15.5L9,15.5L9,15.5z"/><path d="M9.6,14.7v0.2l0,0l0,0l0,0l0,0c0.1,0.2,0.1,0.3,0.3,0.3c0.1,0.1,0.3,0.1,0.4,0.1l0,0h0.1h0.1c0.3-0.1,0.6-0.3,0.9-0.4l0,0c0.1-0.1,0.2-0.2,0.3-0.4l0,0v-0.2c0-0.1,0-0.2-0.1-0.3c-0.1-0.2-0.2-0.3-0.4-0.4H11c-0.1,0-0.2,0.1-0.3,0.1l0,0c-0.2,0.1-0.4,0.2-0.7,0.3l0,0l0,0c-0.1,0.1-0.3,0.2-0.4,0.4C9.6,14.5,9.6,14.6,9.6,14.7z"/><path d="M9,14.5L9,14.5L9,14.5z"/><path d="M9.6,14.4L9.6,14.4L9.6,14.4z"/><path d="M11.7,14L11.7,14L11.7,14z"/><path d="M15.6,7.4L15.6,7.4L15.6,7.4z"/><path d="M15,9.4c0.2,0,0.4,0,0.6-0.2l0,0c0.1-0.1,0.2-0.2,0.2-0.4l0,0l0,0l0,0l0,0c0-0.3,0-0.6,0-0.9c0-0.2-0.1-0.4-0.2-0.5c-0.1-0.1-0.3-0.2-0.5-0.2s-0.4,0.1-0.5,0.2c-0.1,0.1-0.2,0.3-0.2,0.5l0,0c0,0.2,0,0.4,0,0.7l0,0v0.1c0,0.1,0,0.3,0.1,0.4l0,0C14.6,9.3,14.8,9.4,15,9.4L15,9.4L15,9.4z"/><path d="M14,12h0.1h0.2h0.1c0.2,0,0.5-0.2,0.6-0.4l0,0c0.2-0.3,0.3-0.6,0.4-0.9l0,0v-0.2c0-0.1-0.1-0.2-0.1-0.3c-0.1-0.2-0.2-0.3-0.4-0.4h-0.3c-0.1,0-0.2,0-0.3,0C14.2,9.9,14,10,14,10.3l0,0c-0.1,0.2-0.2,0.5-0.3,0.7l0,0c-0.1,0.1-0.1,0.2-0.1,0.3v0.2l0,0l0,0C13.6,11.6,13.8,11.8,14,12z"/><path d="M14.6,7.4L14.6,7.4L14.6,7.4z"/><path d="M4.4,14.2c-0.1,0.1-0.1,0.2-0.1,0.3l0.1,0.2c0,0.2,0.2,0.3,0.3,0.4l0,0c0.3,0.1,0.6,0.3,1.1,0.4l0,0h0.1l0,0c0.1,0,0.2-0.1,0.4-0.2c0.1,0,0.2-0.2,0.3-0.3l0,0v-0.2c0-0.1-0.1-0.3-0.2-0.4c-0.1-0.1-0.2-0.2-0.4-0.3l0,0c-0.2-0.1-0.5-0.2-0.7-0.3l0,0c-0.1,0-0.2,0-0.3,0H4.7l0,0C4.6,13.9,4.4,14,4.4,14.2L4.4,14.2z"/><path d="M11.9,13.3c0,0.2,0.1,0.4,0.2,0.6c0.1,0.1,0.3,0.2,0.5,0.2s0.4-0.1,0.5-0.2l0,0l0,0l0,0l0,0c0.1-0.1,0.3-0.3,0.4-0.4l0,0l0.2-0.3l0,0c0.1-0.2,0.2-0.3,0.2-0.5l0,0c0-0.2-0.1-0.4-0.2-0.5l0,0c-0.1-0.1-0.3-0.2-0.5-0.2l0,0c-0.2,0-0.4,0.1-0.5,0.2l0,0l-0.2,0.2l-0.4,0.4l0,0C12,13,11.9,13.1,11.9,13.3L11.9,13.3z"/><path d="M12.1,13.8L12.1,13.8L12.1,13.8z"/><path d="M11.9,13.3L11.9,13.3L11.9,13.3z"/><path d="M15.9,5.2c0-0.1-0.1-0.2-0.1-0.3l0,0L14,0.4l0,0C13.9,0.2,13.7,0,13.5,0l0,0l0,0h-0.2c-0.2,0-0.4,0.1-0.5,0.2l0,0l-0.9,0.9c-0.5-0.3-1.1-0.6-1.8-0.8l0,0C9.4,0.1,8.7,0,7.9,0c-1,0-2,0.2-3,0.6S3,1.6,2.3,2.3C1.6,3.1,1,3.9,0.6,4.9l0,0C0.2,5.8,0,6.8,0,7.9c0,1,0.2,2,0.6,3s0.9,1.8,1.7,2.6l0,0l0,0l0,0l0,0c0.2,0.2,0.5,0.4,0.7,0.6l0,0l0,0l0,0l0,0c0.2,0.1,0.3,0.2,0.5,0.2l0,0c0.2,0,0.4-0.1,0.6-0.3l0,0c0.1-0.1,0.1-0.3,0.1-0.4v-0.1l0,0C4.1,13.3,4,13.1,3.9,13l0,0c-0.2-0.1-0.4-0.3-0.6-0.5c-0.6-0.6-1.1-1.3-1.4-2.1l0,0C1.6,9.6,1.4,8.8,1.4,7.9s0.2-1.7,0.5-2.5l0,0c0.3-0.8,0.8-1.5,1.4-2.1c0.6-0.6,1.3-1.1,2.1-1.4l0,0C6.2,1.6,7,1.4,7.9,1.4c0.6,0,1.1,0.1,1.7,0.2c0.5,0.1,0.9,0.3,1.3,0.5l-0.8,0.8l0,0C10,3.1,9.9,3.2,9.9,3.4v0.2l0,0l0,0c0,0.2,0.2,0.4,0.4,0.5l0,0l4.5,1.8l0,0H15h0.1c0.2,0,0.4-0.1,0.5-0.2l0,0C15.7,5.6,15.8,5.4,15.9,5.2z M11.8,3.2L13,2l0.4,1.1l0,0c0.2,0.4,0.3,0.7,0.4,0.9L11.8,3.2z"/></g></svg>',
    mirror_horizontal: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14.75 15.74"><g><path d="M13.75,3.76l5.9,15.74h-5.9V3.76ZM4.9,19.5,10.8,3.76V19.5H4.9Z" transform="translate(-4.9 -3.76)"/></g></svg>',
    mirror_vertical: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.75"><g><path d="M20.15,13.1,4.41,19V13.1H20.15ZM4.41,4.25l15.74,5.9H4.41V4.25Z" transform="translate(-4.41 -4.25)"/></g></svg>',
    checked: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 12.1"><g><path d="M4.59,12.23l.12.18L9.43,17.5a.58.58,0,0,0,.84,0L20,7.45h0a.58.58,0,0,0,0-.84l-.85-.85a.58.58,0,0,0-.84,0H18.2l-8.12,8.41a.29.29,0,0,1-.42,0l-3.4-3.63a.58.58,0,0,0-.84,0l-.85.85a.6.6,0,0,0-.14.21.51.51,0,0,0,0,.44c.05.06.1.13.16.19Z" transform="translate(-4.38 -5.58)"/></g></svg>',
    line_break: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19,6a1,1,0,0,0-1,1v4a1,1,0,0,1-1,1H7.41l1.3-1.29A1,1,0,0,0,7.29,9.29l-3,3a1,1,0,0,0-.21.33,1,1,0,0,0,0,.76,1,1,0,0,0,.21.33l3,3a1,1,0,0,0,1.42,0,1,1,0,0,0,0-1.42L7.41,14H17a3,3,0,0,0,3-3V7A1,1,0,0,0,19,6Z"/></svg>',
    audio: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z" /></svg>',
    image_gallery: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="30 30 150 150"><g><path d="M152.775,120.548V51.651c0-12.271-9.984-22.254-22.254-22.254H43.727c-12.271,0-22.254,9.983-22.254,22.254v68.896c0,12.27,9.983,22.254,22.254,22.254h86.795C142.791,142.802,152.775,132.817,152.775,120.548z M36.394,51.651c0-4.042,3.291-7.333,7.333-7.333h86.795c4.042,0,7.332,3.291,7.332,7.333v23.917l-14.938-17.767c-1.41-1.678-3.487-2.649-5.68-2.658h-0.029c-2.184,0-4.255,0.954-5.674,2.613L76.709,98.519l-9.096-9.398c-1.427-1.474-3.392-2.291-5.448-2.273c-2.052,0.025-4.004,0.893-5.396,2.4L36.394,111.32V51.651z M41.684,127.585l20.697-22.416l9.312,9.622c1.461,1.511,3.489,2.334,5.592,2.27c2.101-0.066,4.075-1.013,5.44-2.612l34.436-40.308l20.693,24.613v21.794c0,4.042-3.29,7.332-7.332,7.332H43.727C43.018,127.88,42.334,127.775,41.684,127.585z M182.616,152.5V75.657c0-4.12-3.34-7.46-7.461-7.46c-4.119,0-7.46,3.34-7.46,7.46V152.5c0,4.112-3.347,7.46-7.461,7.46h-94c-4.119,0-7.46,3.339-7.46,7.459c0,4.123,3.341,7.462,7.46,7.462h94C172.576,174.881,182.616,164.841,182.616,152.5z"/></g></svg>',
    bookmark: '<svg viewBox="0 0 24 24"><path d="M17,3H7A2,2 0 0,0 5,5V21L12,18L19,21V5C19,3.89 18.1,3 17,3Z" /></svg>',
    download: '<svg viewBox="0 0 24 24"><path d="M2 12H4V17H20V12H22V17C22 18.11 21.11 19 20 19H4C2.9 19 2 18.11 2 17V12M12 15L17.55 9.54L16.13 8.13L13 11.25V2H11V11.25L7.88 8.13L6.46 9.55L12 15Z" /></svg>',
    dir_ltr: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M9 4v4c-1.1 0-2-.9-2-2s.9-2 2-2m8-2H9C6.79 2 5 3.79 5 6s1.79 4 4 4v5h2V4h2v11h2V4h2V2zm0 12v3H5v2h12v3l4-4-4-4z"/></svg>',
    dir_rtl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M10 4v4c-1.1 0-2-.9-2-2s.9-2 2-2m8-2h-8C7.79 2 6 3.79 6 6s1.79 4 4 4v5h2V4h2v11h2V4h2V2zM8 14l-4 4 4 4v-3h12v-2H8v-3z"/></svg>',
    // Error
    alert_outline: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11,15H13V17H11V15M11,7H13V13H11V7M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20Z" /></svg>',
    // More icons
    more_text: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="10 10 180 180"><g><path d="M49.711,142.188h49.027c2.328,0.002,4.394,1.492,5.129,3.699l9.742,29.252c0.363,1.092,1.385,1.828,2.537,1.83l15.883,0.01c0.859,0,1.667-0.412,2.17-1.109s0.641-1.594,0.37-2.41l-16.625-50.045L86.503,28.953c-0.36-1.097-1.383-1.839-2.537-1.842H64.532c-1.153-0.001-2.178,0.736-2.542,1.831L13.847,173.457c-0.271,0.816-0.135,1.713,0.369,2.412c0.503,0.697,1.311,1.109,2.171,1.109h15.872c1.151,0,2.173-0.736,2.537-1.828l9.793-29.287C45.325,143.66,47.39,142.18,49.711,142.188L49.711,142.188z M53.493,119.098l15.607-46.9c0.744-2.196,2.806-3.674,5.125-3.674s4.381,1.478,5.125,3.674l15.607,46.904c0.537,1.621,0.263,3.402-0.736,4.789c-1.018,1.408-2.649,2.24-4.386,2.24H58.615c-1.736,0-3.368-0.832-4.386-2.24C53.23,122.504,52.956,120.721,53.493,119.098L53.493,119.098z M190.465,63.32c0-2.919-1.015-5.396-3.059-7.428c-2.029-2.031-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.016-7.388,3.047c-2.029,2.032-3.056,4.498-3.056,7.386c0,2.889,1.026,5.354,3.056,7.385c2.032,2.032,4.499,3.059,7.388,3.059c2.887,0,5.354-1.026,7.383-3.059C189.45,68.633,190.465,66.178,190.465,63.32L190.465,63.32z M190.465,101.994c0-2.858-1.015-5.313-3.059-7.333c-2.029-2.042-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.005-7.388,3.047c-2.029,2.021-3.056,4.486-3.056,7.376c0,2.887,1.026,5.352,3.056,7.395c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,107.389,190.465,104.914,190.465,101.994L190.465,101.994z M190.465,140.76c0-2.918-1.015-5.395-3.059-7.438c-2.029-2.041-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.006-7.388,3.047c-2.029,2.043-3.056,4.52-3.056,7.438c0,2.922,1.026,5.398,3.056,7.439c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,146.158,190.465,143.682,190.465,140.76L190.465,140.76z"/></g></svg>',
    more_paragraph: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="10 10 180 180"><g><path d="M128.39,28.499H63.493c-25.558,0-46.354,20.796-46.354,46.354c0,25.559,20.796,46.353,46.354,46.353h9.271v55.625h18.542V47.04h9.271V176.83h18.543V47.04h9.271V28.499z M72.764,102.664h-9.271c-15.337,0-27.813-12.475-27.813-27.812c0-15.336,12.476-27.813,27.813-27.813h9.271V102.664z M190.465,63.32c0-2.919-1.015-5.396-3.059-7.428c-2.029-2.031-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.016-7.388,3.047c-2.029,2.032-3.056,4.498-3.056,7.386c0,2.889,1.026,5.354,3.056,7.385c2.032,2.032,4.499,3.059,7.388,3.059c2.887,0,5.354-1.026,7.383-3.059C189.45,68.633,190.465,66.178,190.465,63.32L190.465,63.32z M190.465,101.994c0-2.858-1.015-5.313-3.059-7.333c-2.029-2.042-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.005-7.388,3.047c-2.029,2.021-3.056,4.486-3.056,7.376c0,2.887,1.026,5.352,3.056,7.395c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,107.389,190.465,104.914,190.465,101.994L190.465,101.994z M190.465,140.76c0-2.918-1.015-5.395-3.059-7.438c-2.029-2.041-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.006-7.388,3.047c-2.029,2.043-3.056,4.52-3.056,7.438c0,2.922,1.026,5.398,3.056,7.439c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,146.158,190.465,143.682,190.465,140.76L190.465,140.76z"/></g></svg>',
    more_plus: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="35 30 140 140"><g><path d="M137.215,102.045c0,3.498-2.835,6.332-6.333,6.332H24.549c-3.498,0-6.334-2.834-6.334-6.332l0,0c0-3.498,2.836-6.333,6.334-6.333h106.333C134.38,95.711,137.215,98.547,137.215,102.045L137.215,102.045z M77.715,161.545c-3.498,0-6.333-2.836-6.333-6.334V48.878c0-3.498,2.836-6.333,6.333-6.333l0,0c3.498,0,6.334,2.835,6.334,6.333v106.333C84.049,158.709,81.213,161.545,77.715,161.545L77.715,161.545z M190.465,63.32c0-2.919-1.015-5.396-3.059-7.428c-2.029-2.031-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.016-7.388,3.047c-2.029,2.032-3.056,4.498-3.056,7.386c0,2.889,1.026,5.354,3.056,7.385c2.032,2.032,4.499,3.059,7.388,3.059c2.887,0,5.354-1.026,7.383-3.059C189.45,68.632,190.465,66.177,190.465,63.32L190.465,63.32z M190.465,101.993c0-2.858-1.015-5.313-3.059-7.333c-2.029-2.042-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.005-7.388,3.047c-2.029,2.021-3.056,4.486-3.056,7.376c0,2.888,1.026,5.353,3.056,7.396c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,107.389,190.465,104.914,190.465,101.993L190.465,101.993z M190.465,140.76c0-2.918-1.015-5.395-3.059-7.438c-2.029-2.041-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.006-7.388,3.047c-2.029,2.043-3.056,4.52-3.056,7.438c0,2.922,1.026,5.398,3.056,7.439c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,146.158,190.465,143.682,190.465,140.76L190.465,140.76z"/></g></svg>',
    more_horizontal: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 3.58"><g><path d="M4.64,10.73a1.84,1.84,0,0,1,.65-.65,1.76,1.76,0,0,1,1.79,0A1.79,1.79,0,0,1,8,11.63a1.84,1.84,0,0,1-.25.9,1.69,1.69,0,0,1-.65.65,1.8,1.8,0,0,1-2.69-1.55A2.08,2.08,0,0,1,4.64,10.73Zm6.09,0a1.84,1.84,0,0,1,.65-.65,1.78,1.78,0,0,1,2.67,1.55,1.73,1.73,0,0,1-.24.9,1.84,1.84,0,0,1-.65.65,1.76,1.76,0,0,1-1.79,0,1.79,1.79,0,0,1-.64-2.44Zm6.08,0a1.69,1.69,0,0,1,.65-.65,1.76,1.76,0,0,1,1.79,0,1.79,1.79,0,0,1,.9,1.54,1.73,1.73,0,0,1-.24.9,1.84,1.84,0,0,1-.65.65,1.8,1.8,0,0,1-2.69-1.55A2,2,0,0,1,16.81,10.73Z" transform="translate(-4.39 -9.84)"/></g></svg>',
    more_vertical: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 3.94 15.75"><g><path d="M12.28,7.69a1.92,1.92,0,0,1-1.39-.58,2,2,0,0,1-.58-1.39,1.92,1.92,0,0,1,.58-1.39,2,2,0,0,1,1.39-.58,1.92,1.92,0,0,1,1.39.58,2,2,0,0,1,.58,1.39,1.92,1.92,0,0,1-.58,1.39,2,2,0,0,1-1.39.58Zm0,2a1.92,1.92,0,0,1,1.39.58,2,2,0,0,1,.58,1.39A1.92,1.92,0,0,1,13.67,13a2,2,0,0,1-1.39.58A1.92,1.92,0,0,1,10.89,13a2,2,0,0,1-.58-1.39,2,2,0,0,1,2-2Zm0,5.9a1.92,1.92,0,0,1,1.39.58,2,2,0,0,1,.58,1.39,1.92,1.92,0,0,1-.58,1.39,2,2,0,0,1-1.39.58,1.92,1.92,0,0,1-1.39-.58,2,2,0,0,1-.58-1.39,1.92,1.92,0,0,1,.58-1.39,1.94,1.94,0,0,1,1.39-.58Z" transform="translate(-10.31 -3.75)"/></g></svg>',
    // Not currently used
    attachment: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8.38 15.68"><g><path d="M15.23,6h1v9.78a3.88,3.88,0,0,1-1.31,2.45,4,4,0,0,1-6.57-2.45V7A3,3,0,0,1,9.2,4.89a3,3,0,0,1,5,2.09v8.31a1.92,1.92,0,0,1-.58,1.39,2,2,0,0,1-1.39.58,1.92,1.92,0,0,1-1.39-.58,2,2,0,0,1-.58-1.39V8h1v7.32a1,1,0,0,0,.29.69,1,1,0,0,0,.69.28A.9.9,0,0,0,13,16a1,1,0,0,0,.29-.69V7a1.92,1.92,0,0,0-.58-1.39A2,2,0,0,0,11.27,5a1.92,1.92,0,0,0-1.39.58A2,2,0,0,0,9.33,7v8.31a3,3,0,1,0,5.9,0V6Z" transform="translate(-8.08 -3.78)"/></g></svg>',
    map: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.7 15.62"><g><path d="M12.05,12.42a2.93,2.93,0,1,1,2.07-5A2.88,2.88,0,0,1,15,9.49a3,3,0,0,1-.86,2.07,2.89,2.89,0,0,1-2.07.86Zm0-5.36a2.43,2.43,0,0,0-1.72,4.16,2.48,2.48,0,0,0,1.72.72,2.44,2.44,0,0,0,0-4.88Zm0-3.3A5.84,5.84,0,0,1,17.9,9.62a9.94,9.94,0,0,1-1.73,5A33.59,33.59,0,0,1,12.84,19a1.52,1.52,0,0,1-.23.2,1,1,0,0,1-.55.2h0a1,1,0,0,1-.55-.2,1.52,1.52,0,0,1-.23-.2,33.59,33.59,0,0,1-3.33-4.32,9.93,9.93,0,0,1-1.72-5,5.84,5.84,0,0,1,5.85-5.86ZM12,18.34l.08.05.06-.06a35.58,35.58,0,0,0,3.06-3.93,9.35,9.35,0,0,0,1.74-4.77,4.88,4.88,0,0,0-4.88-4.88A4.79,4.79,0,0,0,8.6,6.17,4.84,4.84,0,0,0,7.17,9.62,9.29,9.29,0,0,0,8.91,14.4,36,36,0,0,0,12,18.34Z" transform="translate(-6.2 -3.76)"/></g></svg>',
    magic_stick: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 15.75"><g><path d="M19.86,19.21a1,1,0,0,0,.28-.68,1,1,0,0,0-.28-.7L13,10.93a1,1,0,0,0-.7-.28,1,1,0,0,0-.68,1.65l6.9,6.9a1,1,0,0,0,.69.29.93.93,0,0,0,.69-.28ZM9.19,8.55a3,3,0,0,0,1.68,0,14.12,14.12,0,0,0,1.41-.32A11.26,11.26,0,0,0,10.8,7.06c-.56-.36-.86-.56-.91-.58S10,5.91,10,5.11s0-1.26-.15-1.37a4.35,4.35,0,0,0-1.19.71c-.53.4-.81.62-.87.68a9,9,0,0,0-2-.6,6.84,6.84,0,0,0-.76-.09s0,.27.08.77a8.6,8.6,0,0,0,.61,2q-.09.09-.69.87a3.59,3.59,0,0,0-.68,1.17c.12.17.57.23,1.36.15S7,9.26,7.15,9.23s.21.36.57.91a10.49,10.49,0,0,0,1.14,1.48c0-.1.14-.57.31-1.4a3,3,0,0,0,0-1.67Z" transform="translate(-4.41 -3.74)"/></g></svg>',
    empty_file: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12.78 15.75"><g><path d="M14.73,3.76,18.67,7.7v9.84a2,2,0,0,1-2,2H7.84a1.89,1.89,0,0,1-1.38-.58,2,2,0,0,1-.57-1.39V5.73a1.93,1.93,0,0,1,.57-1.38,2,2,0,0,1,1.38-.58h6.62l.26,0v0Zm2.95,4.92h-2a1.93,1.93,0,0,1-1.38-.57,2,2,0,0,1-.58-1.4V6.17c0-.36,0-.84,0-1.43H7.85a1,1,0,0,0-.7.29,1,1,0,0,0-.29.7V17.54a1,1,0,0,0,.29.69,1,1,0,0,0,.69.29h8.85a1,1,0,0,0,.71-.29.92.92,0,0,0,.28-.69Zm0-1L14.73,4.74v2A1,1,0,0,0,15,7.4a1,1,0,0,0,.69.29Z" transform="translate(-5.89 -3.76)"/></g></svg>'
  };

  // ../../node_modules/suneditor/src/lib/constructor.js
  var import_en = __toESM(require_en());

  // ../../node_modules/suneditor/src/lib/util.js
  var util = {
    _d: null,
    _w: null,
    isIE: null,
    isIE_Edge: null,
    isOSX_IOS: null,
    isChromium: null,
    isMobile: null,
    isResizeObserverSupported: null,
    _propertiesInit: function() {
      if (this._d) return;
      this._d = document;
      this._w = window;
      this.isIE = navigator.userAgent.indexOf("Trident") > -1;
      this.isIE_Edge = navigator.userAgent.indexOf("Trident") > -1 || navigator.appVersion.indexOf("Edge") > -1;
      this.isOSX_IOS = /(Mac|iPhone|iPod|iPad)/.test(navigator.platform);
      this.isChromium = !!window.chrome;
      this.isResizeObserverSupported = typeof ResizeObserver === "function";
      this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    },
    _allowedEmptyNodeList: ".se-component, pre, blockquote, hr, li, table, img, iframe, video, audio, canvas",
    /**
     * @description HTML Reserved Word Converter.
     * @param {String} contents 
     * @returns {String} HTML string
     * @private
     */
    _HTMLConvertor: function(contents) {
      const ec = { "&": "&amp;", "\xA0": "&nbsp;", "'": "&apos;", '"': "&quot;", "<": "&lt;", ">": "&gt;" };
      return contents.replace(/&|\u00A0|'|"|<|>/g, function(m) {
        return typeof ec[m] === "string" ? ec[m] : m;
      });
    },
    /**
     * @description Unicode Character 'ZERO WIDTH SPACE' (\u200B)
     */
    zeroWidthSpace: String.fromCharCode(8203),
    /**
     * @description Regular expression to find 'zero width space' (/\u200B/g)
     */
    zeroWidthRegExp: new RegExp(String.fromCharCode(8203), "g"),
    /**
     * @description Regular expression to find only 'zero width space' (/^\u200B+$/)
     */
    onlyZeroWidthRegExp: new RegExp("^" + String.fromCharCode(8203) + "+$"),
    fontValueMap: {
      "xx-small": 1,
      "x-small": 2,
      "small": 3,
      "medium": 4,
      "large": 5,
      "x-large": 6,
      "xx-large": 7
    },
    /**
     * @description A method that checks If the text is blank or to see if it contains 'ZERO WIDTH SPACE' or empty (util.zeroWidthSpace)
     * @param {String|Node} text String value or Node
     * @returns {Boolean}
     */
    onlyZeroWidthSpace: function(text) {
      if (text === null || text === void 0) return false;
      if (typeof text !== "string") text = text.textContent;
      return text === "" || this.onlyZeroWidthRegExp.test(text);
    },
    /**
     * @description Gets XMLHttpRequest object
     * @returns {XMLHttpRequest|ActiveXObject}
     */
    getXMLHttpRequest: function() {
      if (this._w.ActiveXObject) {
        try {
          return new ActiveXObject("Msxml2.XMLHTTP");
        } catch (e) {
          try {
            return new ActiveXObject("Microsoft.XMLHTTP");
          } catch (e1) {
            return null;
          }
        }
      } else if (this._w.XMLHttpRequest) {
        return new XMLHttpRequest();
      } else {
        return null;
      }
    },
    /**
     * @description Object.values
     * @param {Object|null} obj Object parameter.
     * @returns {Array}
     */
    getValues: function(obj) {
      return !obj ? [] : this._w.Object.keys(obj).map(function(i) {
        return obj[i];
      });
    },
    /**
     * @description Convert the CamelCase To the KebabCase.
     * @param {String|Array} param [Camel string]
     * @returns {String|Array}
     */
    camelToKebabCase: function(param) {
      if (typeof param === "string") {
        return param.replace(/[A-Z]/g, function(letter) {
          return "-" + letter.toLowerCase();
        });
      } else {
        return param.map(function(str) {
          return util.camelToKebabCase(str);
        });
      }
    },
    /**
     * @description Convert the KebabCase To the CamelCase.
     * @param {String|Array} param [KebabCase string]
     * @returns {String|Array}
     */
    kebabToCamelCase: function(param) {
      if (typeof param === "string") {
        return param.replace(/-[a-zA-Z]/g, function(letter) {
          return letter.replace("-", "").toUpperCase();
        });
      } else {
        return param.map(function(str) {
          return util.camelToKebabCase(str);
        });
      }
    },
    /**
     * @description Create Element node
     * @param {String} elementName Element name
     * @returns {Element}
     */
    createElement: function(elementName) {
      return this._d.createElement(elementName);
    },
    /**
     * @description Create text node
     * @param {String} text text contents
     * @returns {Node}
     */
    createTextNode: function(text) {
      return this._d.createTextNode(text || "");
    },
    /**
     * @description The editor checks tags by string.
     * If there is "<" or ">" in the attribute of tag, HTML is broken when checking the tag.
     * When using an attribute with "<" or ">", use "HTMLEncoder" to save. (ex: math(katex))
     * @param {String} contents HTML or Text string
     * @returns {String}
     */
    HTMLEncoder: function(contents) {
      const ec = { "<": "$lt;", ">": "$gt;" };
      return contents.replace(/<|>/g, function(m) {
        return typeof ec[m] === "string" ? ec[m] : m;
      });
    },
    /**
     * @description The editor checks tags by string.
     * If there is "<" or ">" in the attribute of tag, HTML is broken when checking the tag.
     * Decoder of data stored as "HTMLEncoder" (ex: math(katex))
     * @param {String} contents HTML or Text string
     * @returns {String}
     */
    HTMLDecoder: function(contents) {
      const ec = { "$lt;": "<", "$gt;": ">" };
      return contents.replace(/\$lt;|\$gt;/g, function(m) {
        return typeof ec[m] === "string" ? ec[m] : m;
      });
    },
    /**
     * @description This method run Object.prototype.hasOwnProperty.call(obj, key)
     * @param {Object} obj Object
     * @param {String} key obj.key
     * @returns {Boolean}
     */
    hasOwn: function(obj, key) {
      return this._hasOwn.call(obj, key);
    },
    _hasOwn: Object.prototype.hasOwnProperty,
    /**
     * @deprecated
     * @description Get the the tag path of the arguments value
     * If not found, return the first found value
     * @param {Array} nameArray File name array
     * @param {String} extension js, css
     * @returns {String}
     */
    getIncludePath: function(nameArray, extension) {
      let path = "";
      const pathList = [];
      const tagName = extension === "js" ? "script" : "link";
      const src = extension === "js" ? "src" : "href";
      let fileName = "(?:";
      for (let i = 0, len = nameArray.length; i < len; i++) {
        fileName += nameArray[i] + (i < len - 1 ? "|" : ")");
      }
      const regExp = new this._w.RegExp("(^|.*[\\/])" + fileName + "(\\.[^\\/]+)?." + extension + "(?:\\?.*|;.*)?$", "i");
      const extRegExp = new this._w.RegExp(".+\\." + extension + "(?:\\?.*|;.*)?$", "i");
      for (let c = this._d.getElementsByTagName(tagName), i = 0; i < c.length; i++) {
        if (extRegExp.test(c[i][src])) {
          pathList.push(c[i]);
        }
      }
      for (let i = 0; i < pathList.length; i++) {
        let editorTag = pathList[i][src].match(regExp);
        if (editorTag) {
          path = editorTag[0];
          break;
        }
      }
      if (path === "") path = pathList.length > 0 ? pathList[0][src] : "";
      -1 === path.indexOf(":/") && "//" !== path.slice(0, 2) && (path = 0 === path.indexOf("/") ? location.href.match(/^.*?:\/\/[^\/]*/)[0] + path : location.href.match(/^[^\?]*\/(?:)/)[0] + path);
      if (!path) throw "[SUNEDITOR.util.getIncludePath.fail] The SUNEDITOR installation path could not be automatically detected. (name: +" + name + ", extension: " + extension + ")";
      return path;
    },
    /**
     * @deprecated
     * @description Returns the CSS text that has been applied to the current page.
     * @param {Document|null} doc To get the CSS text of an document(core._wd). If null get the current document.
     * @returns {String} Styles string
     */
    getPageStyle: function(doc) {
      let cssText = "";
      const sheets = (doc || this._d).styleSheets;
      for (let i = 0, len = sheets.length, rules; i < len; i++) {
        try {
          rules = sheets[i].cssRules;
        } catch (e) {
          continue;
        }
        if (rules) {
          for (let c = 0, cLen = rules.length; c < cLen; c++) {
            cssText += rules[c].cssText;
          }
        }
      }
      return cssText;
    },
    /**
     * @description Get the argument iframe's document object
     * @param {Element} iframe Iframe element (context.element.wysiwygFrame)
     * @returns {Document}
     */
    getIframeDocument: function(iframe) {
      let wDocument = iframe.contentWindow || iframe.contentDocument;
      if (wDocument.document) wDocument = wDocument.document;
      return wDocument;
    },
    /**
     * @description Get attributes of argument element to string ('class="---" name="---" ')
     * @param {Element} element Element object
     * @param {Array|null} exceptAttrs Array of attribute names to exclude from the result
     * @returns {String}
     */
    getAttributesToString: function(element, exceptAttrs) {
      if (!element.attributes) return "";
      const attrs = element.attributes;
      let attrString = "";
      for (let i = 0, len = attrs.length; i < len; i++) {
        if (exceptAttrs && exceptAttrs.indexOf(attrs[i].name) > -1) continue;
        attrString += attrs[i].name + '="' + attrs[i].value + '" ';
      }
      return attrString;
    },
    /**
     * @descriptionGets Get the length in bytes of a string.
     * referencing code: "https://github.com/shaan1974/myrdin/blob/master/expressions/string.js#L11"
     * @param {String} text String text
     * @returns {Number}
     */
    getByteLength: function(text) {
      if (!text || !text.toString) return 0;
      text = text.toString();
      const encoder = this._w.encodeURIComponent;
      let cr, cl;
      if (this.isIE_Edge) {
        cl = this._w.unescape(encoder(text)).length;
        cr = 0;
        if (encoder(text).match(/(%0A|%0D)/gi) !== null) {
          cr = encoder(text).match(/(%0A|%0D)/gi).length;
        }
        return cl + cr;
      } else {
        cl = new this._w.TextEncoder("utf-8").encode(text).length;
        cr = 0;
        if (encoder(text).match(/(%0A|%0D)/gi) !== null) {
          cr = encoder(text).match(/(%0A|%0D)/gi).length;
        }
        return cl + cr;
      }
    },
    /**
     * @description It is judged whether it is the edit region top div element or iframe's body tag.
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isWysiwygDiv: function(element) {
      return element && element.nodeType === 1 && (this.hasClass(element, "se-wrapper-wysiwyg") || /^BODY$/i.test(element.nodeName));
    },
    /**
     * @description It is judged whether it is the contenteditable property is false.
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isNonEditable: function(element) {
      return element && element.nodeType === 1 && element.getAttribute("contenteditable") === "false";
    },
    /**
     * @description It is judged whether it is a node related to the text style.
     * (strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code)
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isTextStyleElement: function(element) {
      return element && element.nodeType !== 3 && /^(strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)$/i.test(element.nodeName);
    },
    /**
     * @description It is judged whether it is the input element (INPUT, TEXTAREA)
     * @param {Node} element The node to check
     * @returns 
     */
    isInputElement: function(element) {
      return element && element.nodeType === 1 && /^(INPUT|TEXTAREA)$/i.test(element.nodeName);
    },
    /**
     * @description It is judged whether it is the format element (P, DIV, H[1-6], PRE, LI | class="__se__format__replace_xxx")
     * Format element also contain "free format Element"
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isFormatElement: function(element) {
      return element && element.nodeType === 1 && (/^(P|DIV|H[1-6]|PRE|LI|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, "(\\s|^)__se__format__replace_.+(\\s|$)|(\\s|^)__se__format__free_.+(\\s|$)")) && !this.isComponent(element) && !this.isWysiwygDiv(element);
    },
    /**
     * @description It is judged whether it is the range format element. (BLOCKQUOTE, OL, UL, FIGCAPTION, TABLE, THEAD, TBODY, TR, TH, TD | class="__se__format__range_xxx")
     * Range format element is wrap the "format element" and "component"
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isRangeFormatElement: function(element) {
      return element && element.nodeType === 1 && (/^(BLOCKQUOTE|OL|UL|FIGCAPTION|TABLE|THEAD|TBODY|TR|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, "(\\s|^)__se__format__range_.+(\\s|$)"));
    },
    /**
     * @description It is judged whether it is the closure range format element. (TH, TD | class="__se__format__range__closure_xxx")
     * Closure range format elements is included in the range format element.
     *  - Closure range format element is wrap the "format element" and "component"
     *  You cannot exit this format with the Enter key or Backspace key.
     *  Use it only in special cases. ([ex] format of table cells)
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isClosureRangeFormatElement: function(element) {
      return element && element.nodeType === 1 && (/^(TH|TD)$/i.test(element.nodeName) || this.hasClass(element, "(\\s|^)__se__format__range__closure_.+(\\s|$)"));
    },
    /**
     * @description It is judged whether it is the free format element. (PRE | class="__se__format__free_xxx")
     * Free format elements is included in the format element.
     * Free format elements's line break is "BR" tag.
     *  Entering the Enter key in the space on the last line ends "Free Format" and appends "Format".
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isFreeFormatElement: function(element) {
      return element && element.nodeType === 1 && (/^PRE$/i.test(element.nodeName) || this.hasClass(element, "(\\s|^)__se__format__free_.+(\\s|$)")) && !this.isComponent(element) && !this.isWysiwygDiv(element);
    },
    /**
     * @description It is judged whether it is the closure free format element. (class="__se__format__free__closure_xxx")
     * Closure free format elements is included in the free format element.
     *  - Closure free format elements's line break is "BR" tag.
     *  You cannot exit this format with the Enter key or Backspace key.
     *  Use it only in special cases. ([ex] format of table cells)
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isClosureFreeFormatElement: function(element) {
      return element && element.nodeType === 1 && this.hasClass(element, "(\\s|^)__se__format__free__closure_.+(\\s|$)");
    },
    /**
     * @description It is judged whether it is the component[img, iframe, video, audio, table] cover(class="se-component") and table, hr
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isComponent: function(element) {
      return element && (/se-component/.test(element.className) || /^(TABLE|HR)$/.test(element.nodeName));
    },
    /**
     * @description Checks for "__se__uneditable" in the class list.
     * Components with class "__se__uneditable" cannot be modified.
     * @param {Element} element The element to check
     * @returns {Boolean}
     */
    isUneditableComponent: function(element) {
      return element && this.hasClass(element, "__se__uneditable");
    },
    /**
     * @description It is judged whether it is the component [img, iframe] cover(class="se-component")
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isMediaComponent: function(element) {
      return element && /se-component/.test(element.className);
    },
    /**
     * @description It is judged whether it is the not checking node. (class="katex", "__se__tag")
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isNotCheckingNode: function(element) {
      return element && /katex|__se__tag/.test(element.className);
    },
    /**
     * @description If a parent node that contains an argument node finds a format node (util.isFormatElement), it returns that node.
     * @param {Node} element Reference node.
     * @param {Function|null} validation Additional validation function.
     * @returns {Element|null}
     */
    getFormatElement: function(element, validation) {
      if (!element) return null;
      if (!validation) {
        validation = function() {
          return true;
        };
      }
      while (element) {
        if (this.isWysiwygDiv(element)) return null;
        if (this.isRangeFormatElement(element)) element.firstElementChild;
        if (this.isFormatElement(element) && validation(element)) return element;
        element = element.parentNode;
      }
      return null;
    },
    /**
     * @description If a parent node that contains an argument node finds a format node (util.isRangeFormatElement), it returns that node.
     * @param {Node} element Reference node.
     * @param {Function|null} validation Additional validation function.
     * @returns {Element|null}
     */
    getRangeFormatElement: function(element, validation) {
      if (!element) return null;
      if (!validation) {
        validation = function() {
          return true;
        };
      }
      while (element) {
        if (this.isWysiwygDiv(element)) return null;
        if (this.isRangeFormatElement(element) && !/^(THEAD|TBODY|TR)$/i.test(element.nodeName) && validation(element)) return element;
        element = element.parentNode;
      }
      return null;
    },
    /**
     * @description If a parent node that contains an argument node finds a free format node (util.isFreeFormatElement), it returns that node.
     * @param {Node} element Reference node.
     * @param {Function|null} validation Additional validation function.
     * @returns {Element|null}
     */
    getFreeFormatElement: function(element, validation) {
      if (!element) return null;
      if (!validation) {
        validation = function() {
          return true;
        };
      }
      while (element) {
        if (this.isWysiwygDiv(element)) return null;
        if (this.isFreeFormatElement(element) && validation(element)) return element;
        element = element.parentNode;
      }
      return null;
    },
    /**
     * @description If a parent node that contains an argument node finds a closure free format node (util.isClosureFreeFormatElement), it returns that node.
     * @param {Node} element Reference node.
     * @param {Function|null} validation Additional validation function.
     * @returns {Element|null}
     */
    getClosureFreeFormatElement: function(element, validation) {
      if (!element) return null;
      if (!validation) {
        validation = function() {
          return true;
        };
      }
      while (element) {
        if (this.isWysiwygDiv(element)) return null;
        if (this.isClosureFreeFormatElement(element) && validation(element)) return element;
        element = element.parentNode;
      }
      return null;
    },
    /**
     * @description Add style and className of copyEl to originEl
     * @param {Element} originEl Origin element
     * @param {Element} copyEl Element to copy
     * @param {Array|null} blacklist Blacklist array(LowerCase)
     */
    copyTagAttributes: function(originEl, copyEl, blacklist) {
      if (copyEl.style.cssText) {
        const copyStyles = copyEl.style;
        for (let i = 0, len = copyStyles.length; i < len; i++) {
          originEl.style[copyStyles[i]] = copyStyles[copyStyles[i]];
        }
      }
      const attrs = copyEl.attributes;
      for (let i = 0, len = attrs.length, name2; i < len; i++) {
        name2 = attrs[i].name.toLowerCase();
        if (blacklist && blacklist.indexOf(name2) > -1 || !attrs[i].value) originEl.removeAttribute(name2);
        else if (name2 !== "style") originEl.setAttribute(attrs[i].name, attrs[i].value);
      }
    },
    /**
     * @description Copy and apply attributes of format tag that should be maintained. (style, class) Ignore "__se__format__" class
     * @param {Element} originEl Origin element
     * @param {Element} copyEl Element to copy
     */
    copyFormatAttributes: function(originEl, copyEl) {
      copyEl = copyEl.cloneNode(false);
      copyEl.className = copyEl.className.replace(/(\s|^)__se__format__[^\s]+/g, "");
      this.copyTagAttributes(originEl, copyEl);
    },
    /**
     * @description Get the item from the array that matches the condition.
     * @param {Array|HTMLCollection|NodeList} array Array to get item
     * @param {Function|null} validation Conditional function
     * @param {Boolean} multi If true, returns all items that meet the criteria otherwise, returns an empty array.
     * If false, returns only one item that meet the criteria otherwise return null.
     * @returns {Array|Node|null}
     */
    getArrayItem: function(array, validation, multi) {
      if (!array || array.length === 0) return null;
      validation = validation || function() {
        return true;
      };
      const arr = [];
      for (let i = 0, len = array.length, a; i < len; i++) {
        a = array[i];
        if (validation(a)) {
          if (!multi) return a;
          else arr.push(a);
        }
      }
      return !multi ? null : arr;
    },
    /**
     * @description Check if an array contains an element 
     * @param {Array|HTMLCollection|NodeList} array element array
     * @param {Node} element The element to check for
     * @returns {Boolean}
     */
    arrayIncludes: function(array, element) {
      for (let i = 0; i < array.length; i++) {
        if (array[i] === element) {
          return true;
        }
      }
      return false;
    },
    /**
     * @description Get the index of the argument value in the element array
     * @param {Array|HTMLCollection|NodeList} array element array
     * @param {Node} element The element to find index
     * @returns {Number}
     */
    getArrayIndex: function(array, element) {
      let idx = -1;
      for (let i = 0, len = array.length; i < len; i++) {
        if (array[i] === element) {
          idx = i;
          break;
        }
      }
      return idx;
    },
    /**
     * @description Get the next index of the argument value in the element array
     * @param {Array|HTMLCollection|NodeList} array element array
     * @param {Node} item The element to find index
     * @returns {Number}
     */
    nextIdx: function(array, item) {
      let idx = this.getArrayIndex(array, item);
      if (idx === -1) return -1;
      return idx + 1;
    },
    /**
     * @description Get the previous index of the argument value in the element array
     * @param {Array|HTMLCollection|NodeList} array Element array
     * @param {Node} item The element to find index
     * @returns {Number}
     */
    prevIdx: function(array, item) {
      let idx = this.getArrayIndex(array, item);
      if (idx === -1) return -1;
      return idx - 1;
    },
    /**
     * @description Returns the index compared to other sibling nodes.
     * @param {Node} node The Node to find index
     * @returns {Number}
     */
    getPositionIndex: function(node) {
      let idx = 0;
      while (node = node.previousSibling) {
        idx += 1;
      }
      return idx;
    },
    /**
     * @description Returns the position of the "node" in the "parentNode" in a numerical array.
     * ex) <p><span>aa</span><span>bb</span></p> : getNodePath(node: "bb", parentNode: "<P>") -> [1, 0]
     * @param {Node} node The Node to find position path
     * @param {Node|null} parentNode Parent node. If null, wysiwyg div area
     * @param {Object|null} _newOffsets If you send an object of the form "{s: 0, e: 0}", the text nodes that are attached together are merged into one, centered on the "node" argument.
     * "_newOffsets.s" stores the length of the combined characters after "node" and "_newOffsets.e" stores the length of the combined characters before "node".
     * Do not use unless absolutely necessary.
     * @returns {Array}
     */
    getNodePath: function(node, parentNode, _newOffsets) {
      const path = [];
      let finds = true;
      this.getParentElement(node, function(el) {
        if (el === parentNode) finds = false;
        if (finds && !this.isWysiwygDiv(el)) {
          if (_newOffsets && el.nodeType === 3) {
            let temp = null, tempText = null;
            _newOffsets.s = _newOffsets.e = 0;
            let previous = el.previousSibling;
            while (previous && previous.nodeType === 3) {
              tempText = previous.textContent.replace(this.zeroWidthRegExp, "");
              _newOffsets.s += tempText.length;
              el.textContent = tempText + el.textContent;
              temp = previous;
              previous = previous.previousSibling;
              this.removeItem(temp);
            }
            let next = el.nextSibling;
            while (next && next.nodeType === 3) {
              tempText = next.textContent.replace(this.zeroWidthRegExp, "");
              _newOffsets.e += tempText.length;
              el.textContent += tempText;
              temp = next;
              next = next.nextSibling;
              this.removeItem(temp);
            }
          }
          path.push(el);
        }
        return false;
      }.bind(this));
      return path.map(this.getPositionIndex).reverse();
    },
    /**
     * @description Returns the node in the location of the path array obtained from "util.getNodePath".
     * @param {Array} offsets Position array, array obtained from "util.getNodePath"
     * @param {Node} parentNode Base parent element
     * @returns {Node}
     */
    getNodeFromPath: function(offsets, parentNode) {
      let current = parentNode;
      let nodes;
      for (let i = 0, len = offsets.length; i < len; i++) {
        nodes = current.childNodes;
        if (nodes.length === 0) break;
        if (nodes.length <= offsets[i]) {
          current = nodes[nodes.length - 1];
        } else {
          current = nodes[offsets[i]];
        }
      }
      return current;
    },
    /**
     * @description Compares the style and class for equal values.
     * Returns true if both are text nodes.
     * @param {Node} a Node to compare
     * @param {Node} b Node to compare
     * @returns {Boolean}
     */
    isSameAttributes: function(a, b) {
      if (a.nodeType === 3 && b.nodeType === 3) return true;
      if (a.nodeType === 3 || b.nodeType === 3) return false;
      const style_a = a.style;
      const style_b = b.style;
      let compStyle = 0;
      for (let i = 0, len = style_a.length; i < len; i++) {
        if (style_a[style_a[i]] === style_b[style_a[i]]) compStyle++;
      }
      const class_a = a.classList;
      const class_b = b.classList;
      const reg = this._w.RegExp;
      let compClass = 0;
      for (let i = 0, len = class_a.length; i < len; i++) {
        if (reg("(s|^)" + class_a[i] + "(s|$)").test(class_b.value)) compClass++;
      }
      return compStyle === style_b.length && compStyle === style_a.length && (compClass === class_b.length && compClass === class_a.length);
    },
    /**
     * @description Check the line element(util.isFormatElement) is empty.
     * @param {Element} element Format element node
     * @returns {Boolean}
     */
    isEmptyLine: function(element) {
      return !element || !element.parentNode || !element.querySelector("IMG, IFRAME, AUDIO, VIDEO, CANVAS, TABLE") && element.children.length === 0 && this.onlyZeroWidthSpace(element.textContent);
    },
    /**
     * @description Check the span's attributes are empty.
     * @param {Element|null} element Element node
     * @returns {Boolean}
     */
    isSpanWithoutAttr: function(element) {
      return !!element && element.nodeType === 1 && /^SPAN$/i.test(element.nodeName) && !element.className && !element.style.cssText;
    },
    /**
     * @description Check the node is a list (ol, ul)
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isList: function(node) {
      return node && /^(OL|UL)$/i.test(typeof node === "string" ? node : node.nodeName);
    },
    /**
     * @description Check the node is a list cell (li)
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isListCell: function(node) {
      return node && /^LI$/i.test(typeof node === "string" ? node : node.nodeName);
    },
    /**
     * @description Check the node is a table (table, thead, tbody, tr, th, td)
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isTable: function(node) {
      return node && /^(TABLE|THEAD|TBODY|TR|TH|TD)$/i.test(typeof node === "string" ? node : node.nodeName);
    },
    /**
     * @description Check the node is a table cell (td, th)
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isCell: function(node) {
      return node && /^(TD|TH)$/i.test(typeof node === "string" ? node : node.nodeName);
    },
    /**
     * @description Check the node is a break node (BR)
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isBreak: function(node) {
      return node && /^BR$/i.test(typeof node === "string" ? node : node.nodeName);
    },
    /**
     * @description Check the node is a anchor node (A)
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isAnchor: function(node) {
      return node && /^A$/i.test(typeof node === "string" ? node : node.nodeName);
    },
    /**
     * @description Check the node is a media node (img, iframe, audio, video, canvas)
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isMedia: function(node) {
      return node && /^(IMG|IFRAME|AUDIO|VIDEO|CANVAS)$/i.test(typeof node === "string" ? node : node.nodeName);
    },
    /**
     * @description Check the node is a figure tag or util.isMedia()
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isFigures: function(node) {
      return node && (this.isMedia(node) || /^(FIGURE)$/i.test(typeof node === "string" ? node : node.nodeName));
    },
    /**
     * @description Checks for numeric (with decimal point).
     * @param {String|Number} text Text string or number
     * @returns {Boolean}
     */
    isNumber: function(text) {
      return !!text && /^-?\d+(\.\d+)?$/.test(text + "");
    },
    /**
     * @description Get a number.
     * @param {String|Number} text Text string or number
     * @param {Number} maxDec Maximum number of decimal places (-1 : Infinity)
     * @returns {Number}
     */
    getNumber: function(text, maxDec) {
      if (!text) return 0;
      let number = (text + "").match(/-?\d+(\.\d+)?/);
      if (!number || !number[0]) return 0;
      number = number[0];
      return maxDec < 0 ? number * 1 : maxDec === 0 ? this._w.Math.round(number * 1) : (number * 1).toFixed(maxDec) * 1;
    },
    /**
     * @description Get all "children" of the argument value element (Without text nodes)
     * @param {Element} element element to get child node
     * @param {Function|null} validation Conditional function
     * @returns {Array}
     */
    getListChildren: function(element, validation) {
      const children4 = [];
      if (!element || !element.children || element.children.length === 0) return children4;
      validation = validation || function() {
        return true;
      };
      (function recursionFunc(current) {
        if (element !== current && validation(current)) {
          children4.push(current);
        }
        if (!!current.children) {
          for (let i = 0, len = current.children.length; i < len; i++) {
            recursionFunc(current.children[i]);
          }
        }
      })(element);
      return children4;
    },
    /**
     * @description Get all "childNodes" of the argument value element (Include text nodes)
     * @param {Node} element element to get child node
     * @param {Function|null} validation Conditional function
     * @returns {Array}
     */
    getListChildNodes: function(element, validation) {
      const children4 = [];
      if (!element || element.childNodes.length === 0) return children4;
      validation = validation || function() {
        return true;
      };
      (function recursionFunc(current) {
        if (element !== current && validation(current)) {
          children4.push(current);
        }
        for (let i = 0, len = current.childNodes.length; i < len; i++) {
          recursionFunc(current.childNodes[i]);
        }
      })(element);
      return children4;
    },
    /**
     * @description Returns the number of parents nodes.
     * "0" when the parent node is the WYSIWYG area.
     * "-1" when the element argument is the WYSIWYG area.
     * @param {Node} element The element to check
     * @returns {Number}
     */
    getElementDepth: function(element) {
      if (!element || this.isWysiwygDiv(element)) return -1;
      let depth = 0;
      element = element.parentNode;
      while (element && !this.isWysiwygDiv(element)) {
        depth += 1;
        element = element.parentNode;
      }
      return depth;
    },
    /**
     * @description Compares two elements to find a common ancestor, and returns the order of the two elements.
     * @param {Node} a Node to compare.
     * @param {Node} b Node to compare.
     * @returns {Object} { ancesstor, a, b, result: (a > b ? 1 : a < b ? -1 : 0) };
     */
    compareElements: function(a, b) {
      let aNode = a, bNode = b;
      while (aNode && bNode && aNode.parentNode !== bNode.parentNode) {
        aNode = aNode.parentNode;
        bNode = bNode.parentNode;
      }
      if (!aNode || !bNode) return { ancestor: null, a, b, result: 0 };
      const children4 = aNode.parentNode.childNodes;
      const aIndex = this.getArrayIndex(children4, aNode);
      const bIndex = this.getArrayIndex(children4, bNode);
      return {
        ancestor: aNode.parentNode,
        a: aNode,
        b: bNode,
        result: aIndex > bIndex ? 1 : aIndex < bIndex ? -1 : 0
      };
    },
    /**
     * @description Get the parent element of the argument value.
     * A tag that satisfies the query condition is imported.
     * Returns null if not found.
     * @param {Node} element Reference element
     * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.
     * Not use it like jquery.
     * Only one condition can be entered at a time.
     * @returns {Element|null}
     */
    getParentElement: function(element, query) {
      let check;
      if (typeof query === "function") {
        check = query;
      } else {
        let attr;
        if (/^\./.test(query)) {
          attr = "className";
          query = query.split(".")[1];
        } else if (/^#/.test(query)) {
          attr = "id";
          query = "^" + query.split("#")[1] + "$";
        } else if (/^:/.test(query)) {
          attr = "name";
          query = "^" + query.split(":")[1] + "$";
        } else {
          attr = "nodeName";
          query = "^" + query + "$";
        }
        const regExp = new this._w.RegExp(query, "i");
        check = function(el) {
          return regExp.test(el[attr]);
        };
      }
      while (element && !check(element)) {
        if (this.isWysiwygDiv(element)) {
          return null;
        }
        element = element.parentNode;
      }
      return element;
    },
    /**
     * @description Gets the previous sibling last child. If there is no sibling, then it'll take it from the closest ancestor with child
     * Returns null if not found.
     * @param {Node} node Reference element
     * @param {Node|null} ceiling Highest boundary allowed
     * @returns {Node|null}
     */
    getPreviousDeepestNode: function(node, ceiling) {
      let previousNode = node.previousSibling;
      if (!previousNode) {
        for (let parentNode = node.parentNode; parentNode; parentNode = parentNode.parentNode) {
          if (parentNode === ceiling) return null;
          if (parentNode.previousSibling) {
            previousNode = parentNode.previousSibling;
            break;
          }
        }
        if (!previousNode) return null;
      }
      while (previousNode.lastChild) previousNode = previousNode.lastChild;
      return previousNode;
    },
    /**
     * @description Gets the next sibling first child. If there is no sibling, then it'll take it from the closest ancestor with child
     * Returns null if not found.
     * @param {Node} node Reference element
     * @param {Node|null} ceiling Highest boundary allowed
     * @returns {Node|null}
     */
    getNextDeepestNode: function(node, ceiling) {
      let nextNode = node.nextSibling;
      if (!nextNode) {
        for (let parentNode = node.parentNode; parentNode; parentNode = parentNode.parentNode) {
          if (parentNode === ceiling) return null;
          if (parentNode.nextSibling) {
            nextNode = parentNode.nextSibling;
            break;
          }
        }
        if (!nextNode) return null;
      }
      while (nextNode.firstChild) nextNode = nextNode.firstChild;
      return nextNode;
    },
    /**
     * @description Get the child element of the argument value.
     * A tag that satisfies the query condition is imported.
     * Returns null if not found.
     * @param {Node} element Reference element
     * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.
     * @param {Boolean} last If true returns the last node among the found child nodes. (default: first node)
     * Not use it like jquery.
     * Only one condition can be entered at a time.
     * @returns {Element|null}
     */
    getChildElement: function(element, query, last) {
      let check;
      if (typeof query === "function") {
        check = query;
      } else {
        let attr;
        if (/^\./.test(query)) {
          attr = "className";
          query = query.split(".")[1];
        } else if (/^#/.test(query)) {
          attr = "id";
          query = "^" + query.split("#")[1] + "$";
        } else if (/^:/.test(query)) {
          attr = "name";
          query = "^" + query.split(":")[1] + "$";
        } else {
          attr = "nodeName";
          query = "^" + (query === "text" ? "#" + query : query) + "$";
        }
        const regExp = new this._w.RegExp(query, "i");
        check = function(el) {
          return regExp.test(el[attr]);
        };
      }
      const childList = this.getListChildNodes(element, function(current) {
        return check(current);
      });
      return childList[last ? childList.length - 1 : 0];
    },
    /**
     * @description 1. The first node of all the child nodes of the "first" element is returned.
     * 2. The last node of all the child nodes of the "last" element is returned.
     * 3. When there is no "last" element, the first and last nodes of all the children of the "first" element are returned.
     * { sc: "first", ec: "last" }
     * @param {Node} first First element
     * @param {Node|null} last Last element
     * @returns {Object}
     */
    getEdgeChildNodes: function(first, last) {
      if (!first) return;
      if (!last) last = first;
      while (first && first.nodeType === 1 && first.childNodes.length > 0 && !this.isBreak(first)) first = first.firstChild;
      while (last && last.nodeType === 1 && last.childNodes.length > 0 && !this.isBreak(last)) last = last.lastChild;
      return {
        sc: first,
        ec: last || first
      };
    },
    /**
     * @description Returns the position of the left and top of argument. {left:0, top:0}
     * @param {Node} element Target node
     * @param {Element|null} wysiwygFrame When use iframe option, iframe object should be sent (context.element.wysiwygFrame)
     * @returns {Object}
     */
    getOffset: function(element, wysiwygFrame) {
      let offsetLeft = 0;
      let offsetTop = 0;
      let offsetElement = element.nodeType === 3 ? element.parentElement : element;
      const wysiwyg = this.getParentElement(element, this.isWysiwygDiv.bind(this));
      while (offsetElement && !this.hasClass(offsetElement, "se-container") && offsetElement !== wysiwyg) {
        offsetLeft += offsetElement.offsetLeft;
        offsetTop += offsetElement.offsetTop;
        offsetElement = offsetElement.offsetParent;
      }
      const iframe = wysiwygFrame && /iframe/i.test(wysiwygFrame.nodeName);
      return {
        left: offsetLeft + (iframe ? wysiwygFrame.parentElement.offsetLeft : 0),
        top: offsetTop - (wysiwyg ? wysiwyg.scrollTop : 0) + (iframe ? wysiwygFrame.parentElement.offsetTop : 0)
      };
    },
    /**
     * @description It compares the start and end indexes of "a" and "b" and returns the number of overlapping indexes in the range.
     * ex) 1, 5, 4, 6 => "2" (4 ~ 5)
     * @param {Number} aStart Start index of "a"
     * @param {Number} aEnd End index of "a"
     * @param {Number} bStart Start index of "b"
     * @param {Number} bEnd Start index of "b"
     * @returns {Number}
     */
    getOverlapRangeAtIndex: function(aStart, aEnd, bStart, bEnd) {
      if (aStart <= bEnd ? aEnd < bStart : aEnd > bStart) return 0;
      const overlap = (aStart > bStart ? aStart : bStart) - (aEnd < bEnd ? aEnd : bEnd);
      return (overlap < 0 ? overlap * -1 : overlap) + 1;
    },
    /**
     * @description Set the text content value of the argument value element
     * @param {Node} element Element to replace text content
     * @param {String} txt Text to be applied
     */
    changeTxt: function(element, txt) {
      if (!element || !txt) return;
      element.textContent = txt;
    },
    /**
     * @description Replace element
     * @param {Element} element Target element
     * @param {String|Element} newElement String or element of the new element to apply
     */
    changeElement: function(element, newElement) {
      if (typeof newElement === "string") {
        if (element.outerHTML) {
          element.outerHTML = newElement;
        } else {
          const doc = this.createElement("DIV");
          doc.innerHTML = newElement;
          newElement = doc.firstChild;
          element.parentNode.replaceChild(newElement, element);
        }
      } else if (newElement.nodeType === 1) {
        element.parentNode.replaceChild(newElement, element);
      }
    },
    /**
     * @description Set style, if all styles are deleted, the style properties are deleted.
     * @param {Element} element Element to set style
     * @param {String} styleName Style attribute name (marginLeft, textAlign...)
     * @param {String|Number} value Style value
     */
    setStyle: function(element, styleName, value) {
      element.style[styleName] = value;
      if (!value && !element.style.cssText) {
        element.removeAttribute("style");
      }
    },
    /**
     * @description Determine whether any of the matched elements are assigned the given class
     * @param {Element} element Elements to search class name
     * @param {String} className Class name to search for
     * @returns {Boolean}
     */
    hasClass: function(element, className) {
      if (!element) return;
      return new this._w.RegExp(className).test(element.className);
    },
    /**
     * @description Append the className value of the argument value element
     * @param {Element} element Elements to add class name
     * @param {String} className Class name to be add
     */
    addClass: function(element, className) {
      if (!element) return;
      const check = new this._w.RegExp("(\\s|^)" + className + "(\\s|$)");
      if (check.test(element.className)) return;
      element.className += (element.className.length > 0 ? " " : "") + className;
    },
    /**
     * @description Delete the className value of the argument value element
     * @param {Element} element Elements to remove class name
     * @param {String} className Class name to be remove
     */
    removeClass: function(element, className) {
      if (!element) return;
      const check = new this._w.RegExp("(\\s|^)" + className + "(\\s|$)");
      element.className = element.className.replace(check, " ").trim();
      if (!element.className.trim()) element.removeAttribute("class");
    },
    /**
     * @description Argument value If there is no class name, insert it and delete the class name if it exists
     * @param {Element} element Elements to replace class name
     * @param {String} className Class name to be change
     * @returns {Boolean|undefined}
     */
    toggleClass: function(element, className) {
      if (!element) return;
      let result = false;
      const check = new this._w.RegExp("(\\s|^)" + className + "(\\s|$)");
      if (check.test(element.className)) {
        element.className = element.className.replace(check, " ").trim();
      } else {
        element.className += " " + className;
        result = true;
      }
      if (!element.className.trim()) element.removeAttribute("class");
      return result;
    },
    /**
     * @description Checks if element can't be easily enabled
     * @param {Element} element Element to check for
     */
    isImportantDisabled: function(element) {
      return element.hasAttribute("data-important-disabled");
    },
    /**
     * @description In the predefined code view mode, the buttons except the executable button are changed to the 'disabled' state.
     * core.codeViewDisabledButtons (An array of buttons whose class name is not "se-code-view-enabled")
     * core.resizingDisabledButtons (An array of buttons whose class name is not "se-resizing-enabled")
     * @param {Boolean} disabled Disabled value
     * @param {Array|HTMLCollection|NodeList} buttonList Button array
     * @param {Boolean} important If priveleged mode should be used (Necessary to switch importantDisabled buttons)
     */
    setDisabledButtons: function(disabled, buttonList, important) {
      for (let i = 0, len = buttonList.length; i < len; i++) {
        let button = buttonList[i];
        if (important || !this.isImportantDisabled(button)) button.disabled = disabled;
        if (important) {
          if (disabled) {
            button.setAttribute("data-important-disabled", "");
          } else {
            button.removeAttribute("data-important-disabled");
          }
        }
      }
    },
    /**
     * @description Delete argumenu value element
     * @param {Node} item Node to be remove
     */
    removeItem: function(item) {
      if (!item) return;
      if (typeof item.remove === "function") item.remove();
      else if (item.parentNode) item.parentNode.removeChild(item);
    },
    /**
     * @description Delete all parent nodes that match the condition.
     * Returns an {sc: previousSibling, ec: nextSibling}(the deleted node reference) or null.
     * @param {Node} item Node to be remove
     * @param {Function|null} validation Validation function. default(Deleted if it only have breakLine and blanks)
     * @param {Element|null} stopParent Stop when the parent node reaches stopParent
     * @returns {Object|null} {sc: previousSibling, ec: nextSibling}
     */
    removeItemAllParents: function(item, validation, stopParent) {
      if (!item) return null;
      let cc = null;
      if (!validation) {
        validation = function(current) {
          if (current === stopParent || this.isComponent(current)) return false;
          const text = current.textContent.trim();
          return text.length === 0 || /^(\n|\u200B)+$/.test(text);
        }.bind(this);
      }
      (function recursionFunc(element) {
        if (!util.isWysiwygDiv(element)) {
          const parent = element.parentNode;
          if (parent && validation(element)) {
            cc = {
              sc: element.previousElementSibling,
              ec: element.nextElementSibling
            };
            util.removeItem(element);
            recursionFunc(parent);
          }
        }
      })(item);
      return cc;
    },
    /**
     * @description Detach Nested all nested lists under the "baseNode".
     * Returns a list with nested removed.
     * @param {Node} baseNode Element on which to base.
     * @param {Boolean} all If true, it also detach all nested lists of a returned list.
     * @returns {Element}
     */
    detachNestedList: function(baseNode, all) {
      const rNode = this._deleteNestedList(baseNode);
      let rangeElement, cNodes;
      if (rNode) {
        rangeElement = rNode.cloneNode(false);
        cNodes = rNode.childNodes;
        const index = this.getPositionIndex(baseNode);
        while (cNodes[index]) {
          rangeElement.appendChild(cNodes[index]);
        }
      } else {
        rangeElement = baseNode;
      }
      let rChildren;
      if (!all) {
        const depth = this.getElementDepth(baseNode) + 2;
        rChildren = this.getListChildren(baseNode, function(current) {
          return this.isListCell(current) && !current.previousElementSibling && this.getElementDepth(current) === depth;
        }.bind(this));
      } else {
        rChildren = this.getListChildren(rangeElement, function(current) {
          return this.isListCell(current) && !current.previousElementSibling;
        }.bind(this));
      }
      for (let i = 0, len = rChildren.length; i < len; i++) {
        this._deleteNestedList(rChildren[i]);
      }
      if (rNode) {
        rNode.parentNode.insertBefore(rangeElement, rNode.nextSibling);
        if (cNodes && cNodes.length === 0) this.removeItem(rNode);
      }
      return rangeElement === baseNode ? rangeElement.parentNode : rangeElement;
    },
    /**
     * @description Sub function of util.detachNestedList method.
     * @private
     */
    _deleteNestedList: function(baseNode) {
      const baseParent = baseNode.parentNode;
      let sibling = baseParent;
      let parent = sibling.parentNode;
      let liSibling, liParent, child, index, c;
      while (this.isListCell(parent)) {
        index = this.getPositionIndex(baseNode);
        liSibling = parent.nextElementSibling;
        liParent = parent.parentNode;
        child = sibling;
        while (child) {
          sibling = sibling.nextSibling;
          if (this.isList(child)) {
            c = child.childNodes;
            while (c[index]) {
              liParent.insertBefore(c[index], liSibling);
            }
            if (c.length === 0) this.removeItem(child);
          } else {
            liParent.appendChild(child);
          }
          child = sibling;
        }
        sibling = liParent;
        parent = liParent.parentNode;
      }
      if (baseParent.children.length === 0) this.removeItem(baseParent);
      return liParent;
    },
    /**
     * @description Split all tags based on "baseNode"
     * Returns the last element of the splited tag.
     * @param {Node} baseNode Element or text node on which to base
     * @param {Number|Node|null} offset Text offset of "baseNode" (Only valid when "baseNode" is a text node)
     * @param {Number} depth The nesting depth of the element being split. (default: 0)
     * @returns {Element}
     */
    splitElement: function(baseNode, offset, depth) {
      if (this.isWysiwygDiv(baseNode)) return baseNode;
      if (offset && !this.isNumber(offset)) {
        const children5 = baseNode.childNodes;
        let index2 = this.getPositionIndex(offset);
        const prev = baseNode.cloneNode(false);
        const next2 = baseNode.cloneNode(false);
        for (let i = 0, len = children5.length; i < len; i++) {
          if (i < index2) prev.appendChild(children5[i]);
          else if (i > index2) next2.appendChild(children5[i]);
          else continue;
          i--;
          len--;
          index2--;
        }
        if (prev.childNodes.length > 0) baseNode.parentNode.insertBefore(prev, baseNode);
        if (next2.childNodes.length > 0) baseNode.parentNode.insertBefore(next2, baseNode.nextElementSibling);
        return baseNode;
      }
      const bp = baseNode.parentNode;
      let index = 0;
      let suffixIndex = 1;
      let next = true;
      let newEl, children4, temp;
      if (!depth || depth < 0) depth = 0;
      if (baseNode.nodeType === 3) {
        index = this.getPositionIndex(baseNode);
        if (offset >= 0 && baseNode.length !== offset) {
          baseNode.splitText(offset);
          const after = this.getNodeFromPath([index + 1], bp);
          if (this.onlyZeroWidthSpace(after)) after.data = this.zeroWidthSpace;
        }
      } else if (baseNode.nodeType === 1) {
        if (offset === 0) {
          while (baseNode.firstChild) {
            baseNode = baseNode.firstChild;
          }
          if (baseNode.nodeType === 3) {
            const after = this.createTextNode(this.zeroWidthSpace);
            baseNode.parentNode.insertBefore(after, baseNode);
            baseNode = after;
          }
        }
        if (!baseNode.previousSibling) {
          if (this.getElementDepth(baseNode) === depth) next = false;
        } else {
          baseNode = baseNode.previousSibling;
        }
      }
      if (baseNode.nodeType === 1) suffixIndex = 0;
      let depthEl = baseNode;
      while (this.getElementDepth(depthEl) > depth) {
        index = this.getPositionIndex(depthEl) + suffixIndex;
        depthEl = depthEl.parentNode;
        temp = newEl;
        newEl = depthEl.cloneNode(false);
        children4 = depthEl.childNodes;
        if (temp) {
          if (this.isListCell(newEl) && this.isList(temp) && temp.firstElementChild) {
            newEl.innerHTML = temp.firstElementChild.innerHTML;
            util.removeItem(temp.firstElementChild);
            if (temp.children.length > 0) newEl.appendChild(temp);
          } else {
            newEl.appendChild(temp);
          }
        }
        while (children4[index]) {
          newEl.appendChild(children4[index]);
        }
      }
      if (depthEl.childNodes.length <= 1 && (!depthEl.firstChild || depthEl.firstChild.textContent.length === 0)) depthEl.innerHTML = "<br>";
      const pElement = depthEl.parentNode;
      if (next) depthEl = depthEl.nextSibling;
      if (!newEl) return depthEl;
      this.mergeSameTags(newEl, null, false);
      this.mergeNestedTags(newEl, function(current) {
        return this.isList(current);
      }.bind(this));
      if (newEl.childNodes.length > 0) pElement.insertBefore(newEl, depthEl);
      else newEl = depthEl;
      if (this.isListCell(newEl) && newEl.children && this.isList(newEl.children[0])) {
        newEl.insertBefore(this.createElement("BR"), newEl.children[0]);
      }
      if (bp.childNodes.length === 0) this.removeItem(bp);
      return newEl;
    },
    /**
     * @description Use with "npdePath (util.getNodePath)" to merge the same attributes and tags if they are present and modify the nodepath.
     * If "offset" has been changed, it will return as much "offset" as it has been modified.
     * An array containing change offsets is returned in the order of the "nodePathArray" array.
     * @param {Element} element Element
     * @param {Array|null} nodePathArray Array of NodePath object ([util.getNodePath(), ..])
     * @param {Boolean} onlyText If true, non-text nodes(!util._isIgnoreNodeChange) like 'span', 'strong'.. are ignored.
     * @returns {Array} [offset, ..]
     */
    mergeSameTags: function(element, nodePathArray, onlyText) {
      const inst = this;
      const nodePathLen = nodePathArray ? nodePathArray.length : 0;
      let offsets = null;
      if (nodePathLen) {
        offsets = this._w.Array.apply(null, new this._w.Array(nodePathLen)).map(this._w.Number.prototype.valueOf, 0);
      }
      (function recursionFunc(current, depth, depthIndex) {
        const children4 = current.childNodes;
        for (let i = 0, len = children4.length, child, next; i < len; i++) {
          child = children4[i];
          next = children4[i + 1];
          if (!child) break;
          if (onlyText && inst._isIgnoreNodeChange(child) || !onlyText && (inst.isTable(child) || inst.isListCell(child) || inst.isFormatElement(child) && !inst.isFreeFormatElement(child))) {
            if (inst.isTable(child) || inst.isListCell(child)) {
              recursionFunc(child, depth + 1, i);
            }
            continue;
          }
          if (len === 1 && current.nodeName === child.nodeName && current.parentNode) {
            if (nodePathLen) {
              let path, c, p, cDepth, spliceDepth;
              for (let n = 0; n < nodePathLen; n++) {
                path = nodePathArray[n];
                if (path && path[depth] === i) {
                  c = child, p = current, cDepth = depth, spliceDepth = true;
                  while (cDepth >= 0) {
                    if (inst.getArrayIndex(p.childNodes, c) !== path[cDepth]) {
                      spliceDepth = false;
                      break;
                    }
                    c = child.parentNode;
                    p = c.parentNode;
                    cDepth--;
                  }
                  if (spliceDepth) {
                    path.splice(depth, 1);
                    path[depth] = i;
                  }
                }
              }
            }
            inst.copyTagAttributes(child, current);
            current.parentNode.insertBefore(child, current);
            inst.removeItem(current);
          }
          if (!next) {
            if (child.nodeType === 1) recursionFunc(child, depth + 1, i);
            break;
          }
          if (child.nodeName === next.nodeName && inst.isSameAttributes(child, next) && child.href === next.href) {
            const childs = child.childNodes;
            let childLength = 0;
            for (let n = 0, nLen = childs.length; n < nLen; n++) {
              if (childs[n].textContent.length > 0) childLength++;
            }
            const l = child.lastChild;
            const r = next.firstChild;
            let addOffset = 0;
            if (l && r) {
              const textOffset = l.nodeType === 3 && r.nodeType === 3;
              addOffset = l.textContent.length;
              let tempL = l.previousSibling;
              while (tempL && tempL.nodeType === 3) {
                addOffset += tempL.textContent.length;
                tempL = tempL.previousSibling;
              }
              if (childLength > 0 && l.nodeType === 3 && r.nodeType === 3 && (l.textContent.length > 0 || r.textContent.length > 0)) childLength--;
              if (nodePathLen) {
                let path = null;
                for (let n = 0; n < nodePathLen; n++) {
                  path = nodePathArray[n];
                  if (path && path[depth] > i) {
                    if (depth > 0 && path[depth - 1] !== depthIndex) continue;
                    path[depth] -= 1;
                    if (path[depth + 1] >= 0 && path[depth] === i) {
                      path[depth + 1] += childLength;
                      if (textOffset) {
                        if (l && l.nodeType === 3 && r && r.nodeType === 3) {
                          offsets[n] += addOffset;
                        }
                      }
                    }
                  }
                }
              }
            }
            if (child.nodeType === 3) {
              addOffset = child.textContent.length;
              child.textContent += next.textContent;
              if (nodePathLen) {
                let path = null;
                for (let n = 0; n < nodePathLen; n++) {
                  path = nodePathArray[n];
                  if (path && path[depth] > i) {
                    if (depth > 0 && path[depth - 1] !== depthIndex) continue;
                    path[depth] -= 1;
                    if (path[depth + 1] >= 0 && path[depth] === i) {
                      path[depth + 1] += childLength;
                      offsets[n] += addOffset;
                    }
                  }
                }
              }
            } else {
              child.innerHTML += next.innerHTML;
            }
            inst.removeItem(next);
            i--;
          } else if (child.nodeType === 1) {
            recursionFunc(child, depth + 1, i);
          }
        }
      })(element, 0, 0);
      return offsets;
    },
    /**
     * @description Remove nested tags without other child nodes.
     * @param {Element} element Element object
     * @param {Function|String|null} validation Validation function / String("tag1|tag2..") / If null, all tags are applicable.
     */
    mergeNestedTags: function(element, validation) {
      if (typeof validation === "string") {
        validation = function(current) {
          return this.test(current.tagName);
        }.bind(new this._w.RegExp("^(" + (validation ? validation : ".+") + ")$", "i"));
      } else if (typeof validation !== "function") {
        validation = function() {
          return true;
        };
      }
      (function recursionFunc(current) {
        let children4 = current.children;
        if (children4.length === 1 && children4[0].nodeName === current.nodeName && validation(current)) {
          const temp = children4[0];
          children4 = temp.children;
          while (children4[0]) {
            current.appendChild(children4[0]);
          }
          current.removeChild(temp);
        }
        for (let i = 0, len = current.children.length; i < len; i++) {
          recursionFunc(current.children[i]);
        }
      })(element);
    },
    /**
     * @description Delete a empty child node of argument element.
     * @param {Element} element Element node
     * @param {Node|null} notRemoveNode Do not remove node
     * @param {boolean} forceDelete When all child nodes are deleted, the parent node is also deleted.
     */
    removeEmptyNode: function(element, notRemoveNode, forceDelete) {
      const inst = this;
      if (notRemoveNode) {
        notRemoveNode = inst.getParentElement(notRemoveNode, function(current) {
          return element === current.parentElement;
        });
      }
      (function recursionFunc(current) {
        if (inst._notTextNode(current) || current === notRemoveNode || inst.isNonEditable(current)) return 0;
        if (current !== element && inst.onlyZeroWidthSpace(current.textContent) && (!current.firstChild || !inst.isBreak(current.firstChild)) && !current.querySelector(inst._allowedEmptyNodeList)) {
          if (current.parentNode) {
            current.parentNode.removeChild(current);
            return -1;
          }
        } else {
          const children4 = current.children;
          for (let i = 0, len = children4.length, r = 0; i < len; i++) {
            if (!children4[i + r] || inst.isComponent(children4[i + r])) continue;
            r += recursionFunc(children4[i + r]);
          }
        }
        return 0;
      })(element);
      if (element.childNodes.length === 0) {
        if (forceDelete) {
          this.removeItem(element);
        } else {
          element.innerHTML = "<br>";
        }
      }
    },
    /**
     * @description Remove whitespace between tags in HTML string.
     * @param {String} html HTML string
     * @returns {String}
     */
    htmlRemoveWhiteSpace: function(html) {
      if (!html) return "";
      return html.trim().replace(/<\/?(?!strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)[^>^<]+>\s+(?=<)/ig, function(m) {
        return m.replace(/\n/g, "").replace(/\s+/, " ");
      });
    },
    /**
     * @description HTML code compression
     * @param {string} html HTML string
     * @returns {string} HTML string
     */
    htmlCompress: function(html) {
      return html.replace(/\n/g, "").replace(/(>)(?:\s+)(<)/g, "$1$2");
    },
    /**
     * @description Sort a element array by depth of element.
     * @param {Array} array Array object
     * @param {Boolean} des true: descending order / false: ascending order
     */
    sortByDepth: function(array, des) {
      const t = !des ? -1 : 1;
      const f = t * -1;
      array.sort(function(a, b) {
        if (!this.isListCell(a) || !this.isListCell(b)) return 0;
        a = this.getElementDepth(a);
        b = this.getElementDepth(b);
        return a > b ? t : a < b ? f : 0;
      }.bind(this));
    },
    /**
     * @description Escape a string for safe use in regular expressions.
     * @param {String} string String to escape
     * @returns {String}
     */
    escapeStringRegexp: function(string) {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    },
    _isExcludeSelectionElement: function(element) {
      return !/FIGCAPTION/i.test(element.nodeName) && (this.isComponent(element) || /FIGURE/i.test(element.nodeName));
    },
    /**
     * @description Nodes that need to be added without modification when changing text nodes
     * @param {Node} element Element to check
     * @returns {Boolean}
     * @private
     */
    _isIgnoreNodeChange: function(element) {
      return element && element.nodeType !== 3 && (this.isNonEditable(element) || !this.isTextStyleElement(element));
    },
    /**
     * @description Nodes that must remain undetached when changing text nodes (A, Label, Code, Span:font-size)
     * @param {Node|String} element Element to check
     * @returns {Boolean}
     * @private
     */
    _isMaintainedNode: function(element) {
      return element && element.nodeType !== 3 && /^(a|label|code|summary)$/i.test(typeof element === "string" ? element : element.nodeName);
    },
    /**
     * @description Node with font-size style
     * @param {Node} element Element to check
     * @returns {Boolean}
     * @private
     */
    _isSizeNode: function(element) {
      return element && element.nodeType !== 3 && this.isTextStyleElement(element) && !!element.style.fontSize;
    },
    /**
     * @description Nodes without text
     * @param {Node} element Element to check
     * @returns {Boolean}
     * @private
     */
    _notTextNode: function(element) {
      return element && element.nodeType !== 3 && (this.isComponent(element) || /^(br|input|select|canvas|img|iframe|audio|video)$/i.test(typeof element === "string" ? element : element.nodeName));
    },
    /**
     * @deprecated
     * @description Check disallowed tags
     * @param {Node} element Element to check
     * @returns {Boolean}
     * @private
     */
    _disallowedTags: function(element) {
      return /^(meta|script|link|style|[a-z]+\:[a-z]+)$/i.test(element.nodeName);
    },
    /**
     * @description Create whitelist RegExp object.
     * Return RegExp format: new RegExp("<\\/?\\b(?!" + list + ")\\b[^>^<]*+>", "gi")
     * @param {String} list Tags list ("br|p|div|pre...")
     * @returns {RegExp}
     */
    createTagsWhitelist: function(list) {
      return new RegExp("<\\/?\\b(?!\\b" + (list || "").replace(/\|/g, "\\b|\\b") + "\\b)[^>]*>", "gi");
    },
    /**
     * @description Create blacklist RegExp object.
     * Return RegExp format: new RegExp("<\\/?\\b(?:" + list + ")\\b[^>^<]*+>", "gi")
     * @param {String} list Tags list ("br|p|div|pre...")
     * @returns {RegExp}
     */
    createTagsBlacklist: function(list) {
      return new RegExp("<\\/?\\b(?:\\b" + (list || "^").replace(/\|/g, "\\b|\\b") + "\\b)[^>]*>", "gi");
    },
    /**
     * @description Fix tags that do not fit the editor format.
     * @param {Element} documentFragment Document fragment "DOCUMENT_FRAGMENT_NODE" (nodeType === 11)
     * @param {RegExp} htmlCheckWhitelistRegExp Editor tags whitelist (core._htmlCheckWhitelistRegExp)
     * @param {RegExp} htmlCheckBlacklistRegExp Editor tags blacklist (core._htmlCheckBlacklistRegExp)
     * @param {Function} classNameFilter Class name filter function
     * @private
     */
    _consistencyCheckOfHTML: function(documentFragment, htmlCheckWhitelistRegExp, htmlCheckBlacklistRegExp, classNameFilter) {
      const removeTags = [], emptyTags = [], wrongList = [], withoutFormatCells = [];
      const wrongTags = this.getListChildNodes(documentFragment, function(current) {
        if (current.nodeType !== 1) {
          if (this.isList(current.parentElement)) removeTags.push(current);
          return false;
        }
        if (htmlCheckBlacklistRegExp.test(current.nodeName) || !htmlCheckWhitelistRegExp.test(current.nodeName) && current.childNodes.length === 0 && this.isNotCheckingNode(current)) {
          removeTags.push(current);
          return false;
        }
        const nrtag = !this.getParentElement(current, this.isNotCheckingNode);
        if (!this.isTable(current) && !this.isListCell(current) && !this.isAnchor(current) && (this.isFormatElement(current) || this.isRangeFormatElement(current) || this.isTextStyleElement(current)) && current.childNodes.length === 0 && nrtag) {
          emptyTags.push(current);
          return false;
        }
        if (this.isList(current.parentNode) && !this.isList(current) && !this.isListCell(current)) {
          wrongList.push(current);
          return false;
        }
        if (this.isCell(current)) {
          const fel = current.firstElementChild;
          if (!this.isFormatElement(fel) && !this.isRangeFormatElement(fel) && !this.isComponent(fel)) {
            withoutFormatCells.push(current);
            return false;
          }
        }
        if (nrtag && current.className) {
          const className = new this._w.Array(current.classList).map(classNameFilter).join(" ").trim();
          if (className) current.className = className;
          else current.removeAttribute("class");
        }
        const result = current.parentNode !== documentFragment && nrtag && (this.isListCell(current) && !this.isList(current.parentNode) || (this.isFormatElement(current) || this.isComponent(current)) && !this.isRangeFormatElement(current.parentNode) && !this.getParentElement(current, this.isComponent));
        return result;
      }.bind(this));
      for (let i = 0, len = removeTags.length; i < len; i++) {
        this.removeItem(removeTags[i]);
      }
      const checkTags = [];
      for (let i = 0, len = wrongTags.length, t, p; i < len; i++) {
        t = wrongTags[i];
        p = t.parentNode;
        if (!p || !p.parentNode) continue;
        if (this.getParentElement(t, this.isListCell)) {
          const cellChildren = t.childNodes;
          for (let j = cellChildren.length - 1; len >= 0; j--) {
            p.insertBefore(t, cellChildren[j]);
          }
          checkTags.push(t);
        } else {
          p.parentNode.insertBefore(t, p);
          checkTags.push(p);
        }
      }
      for (let i = 0, len = checkTags.length, t; i < len; i++) {
        t = checkTags[i];
        if (this.onlyZeroWidthSpace(t.textContent.trim())) {
          this.removeItem(t);
        }
      }
      for (let i = 0, len = emptyTags.length; i < len; i++) {
        this.removeItem(emptyTags[i]);
      }
      for (let i = 0, len = wrongList.length, t, tp, children4, p; i < len; i++) {
        t = wrongList[i];
        p = t.parentNode;
        if (!p) continue;
        tp = this.createElement("LI");
        if (this.isFormatElement(t)) {
          children4 = t.childNodes;
          while (children4[0]) {
            tp.appendChild(children4[0]);
          }
          p.insertBefore(tp, t);
          this.removeItem(t);
        } else {
          t = t.nextSibling;
          tp.appendChild(wrongList[i]);
          p.insertBefore(tp, t);
        }
      }
      for (let i = 0, len = withoutFormatCells.length, t, f; i < len; i++) {
        t = withoutFormatCells[i];
        f = this.createElement("DIV");
        f.innerHTML = t.textContent.trim().length === 0 && t.children.length === 0 ? "<br>" : t.innerHTML;
        t.innerHTML = f.outerHTML;
      }
    },
    _setDefaultOptionStyle: function(options, defaultStyle) {
      let optionStyle = "";
      if (options.height) optionStyle += "height:" + options.height + ";";
      if (options.minHeight) optionStyle += "min-height:" + options.minHeight + ";";
      if (options.maxHeight) optionStyle += "max-height:" + options.maxHeight + ";";
      if (options.position) optionStyle += "position:" + options.position + ";";
      if (options.width) optionStyle += "width:" + options.width + ";";
      if (options.minWidth) optionStyle += "min-width:" + options.minWidth + ";";
      if (options.maxWidth) optionStyle += "max-width:" + options.maxWidth + ";";
      let top = "", frame = "", editor = "";
      defaultStyle = optionStyle + defaultStyle;
      const styleArr = defaultStyle.split(";");
      for (let i = 0, len = styleArr.length, s; i < len; i++) {
        s = styleArr[i].trim();
        if (!s) continue;
        if (/^(min-|max-)?width\s*:/.test(s) || /^(z-index|position)\s*:/.test(s)) {
          top += s + ";";
          continue;
        }
        if (/^(min-|max-)?height\s*:/.test(s)) {
          if (/^height/.test(s) && s.split(":")[1].trim() === "auto") {
            options.height = "auto";
          }
          frame += s + ";";
          continue;
        }
        editor += s + ";";
      }
      return {
        top,
        frame,
        editor
      };
    },
    _setIframeDocument: function(frame, options) {
      frame.setAttribute("scrolling", "auto");
      frame.contentDocument.head.innerHTML = '<meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">' + this._setIframeCssTags(options);
      frame.contentDocument.body.className = options._editableClass;
      frame.contentDocument.body.setAttribute("contenteditable", true);
      frame.contentDocument.body.setAttribute("autocorrect", "off");
    },
    _setIframeCssTags: function(options) {
      const linkNames = options.iframeCSSFileName;
      const wRegExp = this._w.RegExp;
      let tagString = "";
      for (let f = 0, len = linkNames.length, path; f < len; f++) {
        path = [];
        if (/(^https?:\/\/)|(^data:text\/css,)/.test(linkNames[f])) {
          path.push(linkNames[f]);
        } else {
          const CSSFileName = new wRegExp("(^|.*[\\/])" + linkNames[f] + "(\\..+)?\\.css(?:\\?.*|;.*)?$", "i");
          for (let c = document.getElementsByTagName("link"), i = 0, len2 = c.length, styleTag; i < len2; i++) {
            styleTag = c[i].href.match(CSSFileName);
            if (styleTag) path.push(styleTag[0]);
          }
        }
        if (!path || path.length === 0) throw '[SUNEDITOR.constructor.iframe.fail] The suneditor CSS files installation path could not be automatically detected. Please set the option property "iframeCSSFileName" before creating editor instances.';
        for (let i = 0, len2 = path.length; i < len2; i++) {
          tagString += '<link href="' + path[i] + '" rel="stylesheet">';
        }
      }
      return tagString + (options.height === "auto" ? "<style>\n/** Iframe height auto */\nbody{height: min-content; overflow: hidden;}\n</style>" : "");
    }
  };
  var util_default = util;

  // ../../node_modules/suneditor/src/lib/constructor.js
  var constructor_default = {
    /**
     * @description document create
     * @param {Element} element Textarea
     * @param {Object} options Options
     * @returns {Object}
     */
    init: function(element, options) {
      if (typeof options !== "object") options = {};
      const doc = document;
      this._initOptions(element, options);
      const top_div = doc.createElement("DIV");
      top_div.className = "sun-editor" + (options.rtl ? " se-rtl" : "");
      if (element.id) top_div.id = "suneditor_" + element.id;
      const relative = doc.createElement("DIV");
      relative.className = "se-container";
      const tool_bar = this._createToolBar(doc, options.buttonList, options.plugins, options);
      const toolbarShadow = tool_bar.element.cloneNode(false);
      toolbarShadow.className += " se-toolbar-shadow";
      tool_bar.element.style.visibility = "hidden";
      if (tool_bar.pluginCallButtons.math) this._checkKatexMath(options.katex);
      const arrow = doc.createElement("DIV");
      arrow.className = "se-arrow";
      const sticky_dummy = doc.createElement("DIV");
      sticky_dummy.className = "se-toolbar-sticky-dummy";
      const editor_div = doc.createElement("DIV");
      editor_div.className = "se-wrapper";
      const initElements = this._initElements(options, top_div, tool_bar.element, arrow);
      const bottomBar = initElements.bottomBar;
      const wysiwyg_div = initElements.wysiwygFrame;
      const placeholder_span = initElements.placeholder;
      let textarea = initElements.codeView;
      const resizing_bar = bottomBar.resizingBar;
      const navigation = bottomBar.navigation;
      const char_wrapper = bottomBar.charWrapper;
      const char_counter = bottomBar.charCounter;
      const loading_box = doc.createElement("DIV");
      loading_box.className = "se-loading-box sun-editor-common";
      loading_box.innerHTML = '<div class="se-loading-effect"></div>';
      const line_breaker = doc.createElement("DIV");
      line_breaker.className = "se-line-breaker";
      line_breaker.innerHTML = '<button class="se-btn">' + options.icons.line_break + "</button>";
      const line_breaker_t = doc.createElement("DIV");
      line_breaker_t.className += "se-line-breaker-component";
      const line_breaker_b = line_breaker_t.cloneNode(true);
      line_breaker_t.innerHTML = line_breaker_b.innerHTML = options.icons.line_break;
      const resize_back = doc.createElement("DIV");
      resize_back.className = "se-resizing-back";
      const focusTemp = doc.createElement("INPUT");
      focusTemp.tabIndex = -1;
      focusTemp.style.cssText = "position: fixed !important; top: -10000px !important; display: block !important; width: 0 !important; height: 0 !important; margin: 0 !important; padding: 0 !important;";
      const toolbarContainer = options.toolbarContainer;
      if (toolbarContainer) {
        toolbarContainer.appendChild(tool_bar.element);
        toolbarContainer.appendChild(toolbarShadow);
      }
      const resizingBarContainer = options.resizingBarContainer;
      if (resizing_bar && resizingBarContainer) resizingBarContainer.appendChild(resizing_bar);
      editor_div.appendChild(textarea);
      if (placeholder_span) editor_div.appendChild(placeholder_span);
      if (!toolbarContainer) {
        relative.appendChild(tool_bar.element);
        relative.appendChild(toolbarShadow);
      }
      relative.appendChild(sticky_dummy);
      relative.appendChild(editor_div);
      relative.appendChild(resize_back);
      relative.appendChild(loading_box);
      relative.appendChild(line_breaker);
      relative.appendChild(line_breaker_t);
      relative.appendChild(line_breaker_b);
      relative.appendChild(focusTemp);
      if (resizing_bar && !resizingBarContainer) relative.appendChild(resizing_bar);
      top_div.appendChild(relative);
      textarea = this._checkCodeMirror(options, textarea);
      return {
        constructed: {
          _top: top_div,
          _relative: relative,
          _toolBar: tool_bar.element,
          _toolbarShadow: toolbarShadow,
          _menuTray: tool_bar._menuTray,
          _editorArea: editor_div,
          _wysiwygArea: wysiwyg_div,
          _codeArea: textarea,
          _placeholder: placeholder_span,
          _resizingBar: resizing_bar,
          _navigation: navigation,
          _charWrapper: char_wrapper,
          _charCounter: char_counter,
          _loading: loading_box,
          _lineBreaker: line_breaker,
          _lineBreaker_t: line_breaker_t,
          _lineBreaker_b: line_breaker_b,
          _resizeBack: resize_back,
          _stickyDummy: sticky_dummy,
          _arrow: arrow,
          _focusTemp: focusTemp
        },
        options,
        plugins: tool_bar.plugins,
        pluginCallButtons: tool_bar.pluginCallButtons,
        _responsiveButtons: tool_bar.responsiveButtons
      };
    },
    /**
     * @description Check the CodeMirror option to apply the CodeMirror and return the CodeMirror element.
     * @param {Object} options options
     * @param {Element} textarea textarea element
     * @private
     */
    _checkCodeMirror: function(options, textarea) {
      if (options.codeMirror) {
        const cmOptions = [{
          mode: "htmlmixed",
          htmlMode: true,
          lineNumbers: true,
          lineWrapping: true
        }, options.codeMirror.options || {}].reduce(function(init, option) {
          for (let key in option) {
            if (util_default.hasOwn(option, key)) init[key] = option[key];
          }
          return init;
        }, {});
        if (options.height === "auto") {
          cmOptions.viewportMargin = Infinity;
          cmOptions.height = "auto";
        }
        const cm = options.codeMirror.src.fromTextArea(textarea, cmOptions);
        cm.display.wrapper.style.cssText = textarea.style.cssText;
        options.codeMirrorEditor = cm;
        textarea = cm.display.wrapper;
        textarea.className += " se-wrapper-code-mirror";
      }
      return textarea;
    },
    /**
     * @description Check for a katex object.
     * @param {Object} katex katex object
     * @private
     */
    _checkKatexMath: function(katex) {
      if (!katex) throw Error('[SUNEDITOR.create.fail] To use the math button you need to add a "katex" object to the options.');
      const katexOptions = [{
        throwOnError: false
      }, katex.options || {}].reduce(function(init, option) {
        for (let key in option) {
          if (util_default.hasOwn(option, key)) init[key] = option[key];
        }
        return init;
      }, {});
      katex.options = katexOptions;
    },
    /**
     * @description Add or reset options
     * @param {Object} mergeOptions New options property
     * @param {Object} context Context object of core
     * @param {Object} originOptions Origin options
     * @returns {Object} pluginCallButtons
     * @private
     */
    _setOptions: function(mergeOptions, context, originOptions) {
      this._initOptions(context.element.originElement, mergeOptions);
      const el = context.element;
      const relative = el.relative;
      const editorArea = el.editorArea;
      const isNewToolbarContainer = mergeOptions.toolbarContainer && mergeOptions.toolbarContainer !== originOptions.toolbarContainer;
      const isNewToolbar = mergeOptions.lang !== originOptions.lang || mergeOptions.buttonList !== originOptions.buttonList || mergeOptions.mode !== originOptions.mode || isNewToolbarContainer;
      const tool_bar = this._createToolBar(document, isNewToolbar ? mergeOptions.buttonList : originOptions.buttonList, mergeOptions.plugins, mergeOptions);
      if (tool_bar.pluginCallButtons.math) this._checkKatexMath(mergeOptions.katex);
      const arrow = document.createElement("DIV");
      arrow.className = "se-arrow";
      if (isNewToolbar) {
        tool_bar.element.style.visibility = "hidden";
        if (isNewToolbarContainer) {
          mergeOptions.toolbarContainer.appendChild(tool_bar.element);
          el.toolbar.parentElement.removeChild(el.toolbar);
        } else {
          el.toolbar.parentElement.replaceChild(tool_bar.element, el.toolbar);
        }
        el.toolbar = tool_bar.element;
        el._menuTray = tool_bar._menuTray;
        el._arrow = arrow;
      }
      const initElements = this._initElements(mergeOptions, el.topArea, isNewToolbar ? tool_bar.element : el.toolbar, arrow);
      const bottomBar = initElements.bottomBar;
      const wysiwygFrame = initElements.wysiwygFrame;
      const placeholder_span = initElements.placeholder;
      let code = initElements.codeView;
      if (el.resizingBar) util_default.removeItem(el.resizingBar);
      if (bottomBar.resizingBar) {
        if (mergeOptions.resizingBarContainer && mergeOptions.resizingBarContainer !== originOptions.resizingBarContainer) {
          mergeOptions.resizingBarContainer.appendChild(bottomBar.resizingBar);
        } else {
          relative.appendChild(bottomBar.resizingBar);
        }
      }
      editorArea.innerHTML = "";
      editorArea.appendChild(code);
      if (placeholder_span) editorArea.appendChild(placeholder_span);
      code = this._checkCodeMirror(mergeOptions, code);
      el.resizingBar = bottomBar.resizingBar;
      el.navigation = bottomBar.navigation;
      el.charWrapper = bottomBar.charWrapper;
      el.charCounter = bottomBar.charCounter;
      el.wysiwygFrame = wysiwygFrame;
      el.code = code;
      el.placeholder = placeholder_span;
      if (mergeOptions.rtl) util_default.addClass(el.topArea, "se-rtl");
      else util_default.removeClass(el.topArea, "se-rtl");
      return {
        callButtons: tool_bar.pluginCallButtons,
        plugins: tool_bar.plugins,
        toolbar: tool_bar
      };
    },
    /**
     * @description Initialize property of suneditor elements
     * @param {Object} options Options
     * @param {Element} topDiv Suneditor top div
     * @param {Element} toolBar Tool bar
     * @param {Element} toolBarArrow Tool bar arrow (balloon editor)
     * @returns {Object} Bottom bar elements (resizingBar, navigation, charWrapper, charCounter)
     * @private
     */
    _initElements: function(options, topDiv, toolBar, toolBarArrow) {
      topDiv.style.cssText = options._editorStyles.top;
      if (/inline/i.test(options.mode)) {
        toolBar.className += " se-toolbar-inline";
        toolBar.style.width = options.toolbarWidth;
      } else if (/balloon/i.test(options.mode)) {
        toolBar.className += " se-toolbar-balloon";
        toolBar.style.width = options.toolbarWidth;
        toolBar.appendChild(toolBarArrow);
      }
      const wysiwygDiv = document.createElement(!options.iframe ? "DIV" : "IFRAME");
      wysiwygDiv.className = "se-wrapper-inner se-wrapper-wysiwyg";
      if (!options.iframe) {
        wysiwygDiv.setAttribute("contenteditable", true);
        wysiwygDiv.setAttribute("autocorrect", "off");
        wysiwygDiv.setAttribute("scrolling", "auto");
        for (let key in options.iframeAttributes) {
          wysiwygDiv.setAttribute(key, options.iframeAttributes[key]);
        }
        wysiwygDiv.className += " " + options._editableClass;
        wysiwygDiv.style.cssText = options._editorStyles.frame + options._editorStyles.editor;
        wysiwygDiv.className += options.className;
      } else {
        wysiwygDiv.allowFullscreen = true;
        wysiwygDiv.frameBorder = 0;
        wysiwygDiv.style.cssText = options._editorStyles.frame;
        wysiwygDiv.className += options.className;
      }
      const textarea = document.createElement("TEXTAREA");
      textarea.className = "se-wrapper-inner se-wrapper-code" + options.className;
      textarea.style.cssText = options._editorStyles.frame;
      textarea.style.display = "none";
      if (options.height === "auto") textarea.style.overflow = "hidden";
      let resizingBar = null;
      let navigation = null;
      let charWrapper = null;
      let charCounter = null;
      if (options.resizingBar) {
        resizingBar = document.createElement("DIV");
        resizingBar.className = "se-resizing-bar sun-editor-common";
        navigation = document.createElement("DIV");
        navigation.className = "se-navigation sun-editor-common";
        resizingBar.appendChild(navigation);
        if (options.charCounter) {
          charWrapper = document.createElement("DIV");
          charWrapper.className = "se-char-counter-wrapper";
          if (options.charCounterLabel) {
            const charLabel = document.createElement("SPAN");
            charLabel.className = "se-char-label";
            charLabel.textContent = options.charCounterLabel;
            charWrapper.appendChild(charLabel);
          }
          charCounter = document.createElement("SPAN");
          charCounter.className = "se-char-counter";
          charCounter.textContent = "0";
          charWrapper.appendChild(charCounter);
          if (options.maxCharCount > 0) {
            const char_max = document.createElement("SPAN");
            char_max.textContent = " / " + options.maxCharCount;
            charWrapper.appendChild(char_max);
          }
          resizingBar.appendChild(charWrapper);
        }
      }
      let placeholder = null;
      if (options.placeholder) {
        placeholder = document.createElement("SPAN");
        placeholder.className = "se-placeholder";
        placeholder.innerText = options.placeholder;
      }
      return {
        bottomBar: {
          resizingBar,
          navigation,
          charWrapper,
          charCounter
        },
        wysiwygFrame: wysiwygDiv,
        codeView: textarea,
        placeholder
      };
    },
    /**
     * @description Initialize options
     * @param {Element} element Options object
     * @param {Object} options Options object
     * @private
     */
    _initOptions: function(element, options) {
      const plugins = {};
      if (options.plugins) {
        const _plugins = options.plugins;
        const pluginsValues = _plugins.length ? _plugins : Object.keys(_plugins).map(function(name2) {
          return _plugins[name2];
        });
        for (let i = 0, len = pluginsValues.length, p; i < len; i++) {
          p = pluginsValues[i].default || pluginsValues[i];
          plugins[p.name] = p;
        }
      }
      options.plugins = plugins;
      options.strictMode = options.strictMode !== false;
      options.lang = options.lang || import_en.default;
      options.value = typeof options.value === "string" ? options.value : null;
      options.allowedClassNames = new util_default._w.RegExp((options.allowedClassNames && typeof options.allowedClassNames === "string" ? options.allowedClassNames + "|" : "") + "^__se__|se-|katex");
      options.historyStackDelayTime = typeof options.historyStackDelayTime === "number" ? options.historyStackDelayTime : 400;
      options.frameAttrbutes = options.frameAttrbutes || {};
      options.defaultTag = typeof options.defaultTag === "string" && options.defaultTag.length > 0 ? options.defaultTag : "p";
      const textTags = options.textTags = [{ bold: "STRONG", underline: "U", italic: "EM", strike: "DEL", sub: "SUB", sup: "SUP" }, options.textTags || {}].reduce(function(_default, _new) {
        for (let key in _new) {
          _default[key] = _new[key];
        }
        return _default;
      }, {});
      options._textTagsMap = {
        "strong": textTags.bold.toLowerCase(),
        "b": textTags.bold.toLowerCase(),
        "u": textTags.underline.toLowerCase(),
        "ins": textTags.underline.toLowerCase(),
        "em": textTags.italic.toLowerCase(),
        "i": textTags.italic.toLowerCase(),
        "del": textTags.strike.toLowerCase(),
        "strike": textTags.strike.toLowerCase(),
        "s": textTags.strike.toLowerCase(),
        "sub": textTags.sub.toLowerCase(),
        "sup": textTags.sup.toLowerCase()
      };
      options._defaultCommand = {
        bold: options.textTags.bold,
        underline: options.textTags.underline,
        italic: options.textTags.italic,
        strike: options.textTags.strike,
        subscript: options.textTags.sub,
        superscript: options.textTags.sup
      };
      options.__allowedScriptTag = options.__allowedScriptTag === true;
      const whitelist = "br|p|div|pre|blockquote|h1|h2|h3|h4|h5|h6|ol|ul|li|hr|figure|figcaption|img|iframe|audio|video|source|table|thead|tbody|tr|th|td|a|b|strong|var|i|em|u|ins|s|span|strike|del|sub|sup|code|svg|path|details|summary";
      options.tagsBlacklist = options.tagsBlacklist || "";
      options._defaultTagsWhitelist = (typeof options._defaultTagsWhitelist === "string" ? options._defaultTagsWhitelist : whitelist) + (options.__allowedScriptTag ? "|script" : "");
      options._editorTagsWhitelist = options.addTagsWhitelist === "*" ? "*" : this._setWhitelist(options._defaultTagsWhitelist + (typeof options.addTagsWhitelist === "string" && options.addTagsWhitelist.length > 0 ? "|" + options.addTagsWhitelist : ""), options.tagsBlacklist);
      options.pasteTagsBlacklist = options.tagsBlacklist + (options.tagsBlacklist && options.pasteTagsBlacklist ? "|" + options.pasteTagsBlacklist : options.pasteTagsBlacklist || "");
      options.pasteTagsWhitelist = options.pasteTagsWhitelist === "*" ? "*" : this._setWhitelist(typeof options.pasteTagsWhitelist === "string" ? options.pasteTagsWhitelist : options._editorTagsWhitelist, options.pasteTagsBlacklist);
      options.attributesWhitelist = !options.attributesWhitelist || typeof options.attributesWhitelist !== "object" ? null : options.attributesWhitelist;
      options.attributesBlacklist = !options.attributesBlacklist || typeof options.attributesBlacklist !== "object" ? null : options.attributesBlacklist;
      options.mode = options.mode || "classic";
      options.rtl = !!options.rtl;
      options.lineAttrReset = ["id"].concat(options.lineAttrReset && typeof options.lineAttrReset === "string" ? options.lineAttrReset.toLowerCase().split("|") : []);
      options._editableClass = "sun-editor-editable" + (options.rtl ? " se-rtl" : "");
      options._printClass = typeof options._printClass === "string" ? options._printClass : null;
      options.toolbarWidth = options.toolbarWidth ? util_default.isNumber(options.toolbarWidth) ? options.toolbarWidth + "px" : options.toolbarWidth : "auto";
      options.toolbarContainer = typeof options.toolbarContainer === "string" ? document.querySelector(options.toolbarContainer) : options.toolbarContainer;
      options.stickyToolbar = /balloon/i.test(options.mode) || !!options.toolbarContainer ? -1 : options.stickyToolbar === void 0 ? 0 : /^\d+/.test(options.stickyToolbar) ? util_default.getNumber(options.stickyToolbar, 0) : -1;
      options.hideToolbar = !!options.hideToolbar;
      options.fullScreenOffset = options.fullScreenOffset === void 0 ? 0 : /^\d+/.test(options.fullScreenOffset) ? util_default.getNumber(options.fullScreenOffset, 0) : 0;
      options.fullPage = !!options.fullPage;
      options.iframe = options.fullPage || !!options.iframe;
      options.iframeAttributes = options.iframeAttributes || {};
      options.iframeCSSFileName = options.iframe ? typeof options.iframeCSSFileName === "string" ? [options.iframeCSSFileName] : options.iframeCSSFileName || ["suneditor"] : null;
      options.previewTemplate = typeof options.previewTemplate === "string" ? options.previewTemplate : null;
      options.printTemplate = typeof options.printTemplate === "string" ? options.printTemplate : null;
      options.codeMirror = options.codeMirror ? options.codeMirror.src ? options.codeMirror : { src: options.codeMirror } : null;
      options.katex = options.katex ? options.katex.src ? options.katex : { src: options.katex } : null;
      options.mathFontSize = !!options.mathFontSize ? options.mathFontSize : [
        { text: "1", value: "1em" },
        { text: "1.5", value: "1.5em" },
        { text: "2", value: "2em" },
        { text: "2.5", value: "2.5em" }
      ];
      options.position = typeof options.position === "string" ? options.position : null;
      options.display = options.display || (element.style.display === "none" || !element.style.display ? "block" : element.style.display);
      options.popupDisplay = options.popupDisplay || "full";
      options.resizingBar = options.resizingBar === void 0 ? /inline|balloon/i.test(options.mode) ? false : true : options.resizingBar;
      options.showPathLabel = !options.resizingBar ? false : typeof options.showPathLabel === "boolean" ? options.showPathLabel : true;
      options.resizeEnable = options.resizeEnable === void 0 ? true : !!options.resizeEnable;
      options.resizingBarContainer = typeof options.resizingBarContainer === "string" ? document.querySelector(options.resizingBarContainer) : options.resizingBarContainer;
      options.charCounter = options.maxCharCount > 0 ? true : typeof options.charCounter === "boolean" ? options.charCounter : false;
      options.charCounterType = typeof options.charCounterType === "string" ? options.charCounterType : "char";
      options.charCounterLabel = typeof options.charCounterLabel === "string" ? options.charCounterLabel.trim() : null;
      options.maxCharCount = util_default.isNumber(options.maxCharCount) && options.maxCharCount > -1 ? options.maxCharCount * 1 : null;
      options.width = options.width ? util_default.isNumber(options.width) ? options.width + "px" : options.width : element.clientWidth ? element.clientWidth + "px" : "100%";
      options.minWidth = (util_default.isNumber(options.minWidth) ? options.minWidth + "px" : options.minWidth) || "";
      options.maxWidth = (util_default.isNumber(options.maxWidth) ? options.maxWidth + "px" : options.maxWidth) || "";
      options.height = options.height ? util_default.isNumber(options.height) ? options.height + "px" : options.height : element.clientHeight ? element.clientHeight + "px" : "auto";
      options.minHeight = (util_default.isNumber(options.minHeight) ? options.minHeight + "px" : options.minHeight) || "";
      options.maxHeight = (util_default.isNumber(options.maxHeight) ? options.maxHeight + "px" : options.maxHeight) || "";
      options.className = typeof options.className === "string" && options.className.length > 0 ? " " + options.className : "";
      options.defaultStyle = typeof options.defaultStyle === "string" ? options.defaultStyle : "";
      options.font = !options.font ? ["Arial", "Comic Sans MS", "Courier New", "Impact", "Georgia", "tahoma", "Trebuchet MS", "Verdana"] : options.font;
      options.fontSize = !options.fontSize ? null : options.fontSize;
      options.formats = !options.formats ? null : options.formats;
      options.colorList = !options.colorList ? null : options.colorList;
      options.lineHeights = !options.lineHeights ? null : options.lineHeights;
      options.paragraphStyles = !options.paragraphStyles ? null : options.paragraphStyles;
      options.textStyles = !options.textStyles ? null : options.textStyles;
      options.fontSizeUnit = typeof options.fontSizeUnit === "string" ? options.fontSizeUnit.trim().toLowerCase() || "px" : "px";
      options.alignItems = typeof options.alignItems === "object" ? options.alignItems : options.rtl ? ["right", "center", "left", "justify"] : ["left", "center", "right", "justify"];
      options.imageResizing = options.imageResizing === void 0 ? true : options.imageResizing;
      options.imageHeightShow = options.imageHeightShow === void 0 ? true : !!options.imageHeightShow;
      options.imageAlignShow = options.imageAlignShow === void 0 ? true : !!options.imageAlignShow;
      options.imageWidth = !options.imageWidth ? "auto" : util_default.isNumber(options.imageWidth) ? options.imageWidth + "px" : options.imageWidth;
      options.imageHeight = !options.imageHeight ? "auto" : util_default.isNumber(options.imageHeight) ? options.imageHeight + "px" : options.imageHeight;
      options.imageSizeOnlyPercentage = !!options.imageSizeOnlyPercentage;
      options._imageSizeUnit = options.imageSizeOnlyPercentage ? "%" : "px";
      options.imageRotation = options.imageRotation !== void 0 ? options.imageRotation : !(options.imageSizeOnlyPercentage || !options.imageHeightShow);
      options.imageFileInput = options.imageFileInput === void 0 ? true : options.imageFileInput;
      options.imageUrlInput = options.imageUrlInput === void 0 || !options.imageFileInput ? true : options.imageUrlInput;
      options.imageUploadHeader = options.imageUploadHeader || null;
      options.imageUploadUrl = typeof options.imageUploadUrl === "string" ? options.imageUploadUrl : null;
      options.imageUploadSizeLimit = /\d+/.test(options.imageUploadSizeLimit) ? util_default.getNumber(options.imageUploadSizeLimit, 0) : null;
      options.imageMultipleFile = !!options.imageMultipleFile;
      options.imageAccept = typeof options.imageAccept !== "string" || options.imageAccept.trim() === "*" ? "image/*" : options.imageAccept.trim() || "image/*";
      options.imageGalleryUrl = typeof options.imageGalleryUrl === "string" ? options.imageGalleryUrl : null;
      options.imageGalleryHeader = options.imageGalleryHeader || null;
      options.videoResizing = options.videoResizing === void 0 ? true : options.videoResizing;
      options.videoHeightShow = options.videoHeightShow === void 0 ? true : !!options.videoHeightShow;
      options.videoAlignShow = options.videoAlignShow === void 0 ? true : !!options.videoAlignShow;
      options.videoRatioShow = options.videoRatioShow === void 0 ? true : !!options.videoRatioShow;
      options.videoWidth = !options.videoWidth || !util_default.getNumber(options.videoWidth, 0) ? "" : util_default.isNumber(options.videoWidth) ? options.videoWidth + "px" : options.videoWidth;
      options.videoHeight = !options.videoHeight || !util_default.getNumber(options.videoHeight, 0) ? "" : util_default.isNumber(options.videoHeight) ? options.videoHeight + "px" : options.videoHeight;
      options.videoSizeOnlyPercentage = !!options.videoSizeOnlyPercentage;
      options._videoSizeUnit = options.videoSizeOnlyPercentage ? "%" : "px";
      options.videoRotation = options.videoRotation !== void 0 ? options.videoRotation : !(options.videoSizeOnlyPercentage || !options.videoHeightShow);
      options.videoRatio = util_default.getNumber(options.videoRatio, 4) || 0.5625;
      options.videoRatioList = !options.videoRatioList ? null : options.videoRatioList;
      options.youtubeQuery = (options.youtubeQuery || "").replace("?", "");
      options.vimeoQuery = (options.vimeoQuery || "").replace("?", "");
      options.videoFileInput = !!options.videoFileInput;
      options.videoUrlInput = options.videoUrlInput === void 0 || !options.videoFileInput ? true : options.videoUrlInput;
      options.videoUploadHeader = options.videoUploadHeader || null;
      options.videoUploadUrl = typeof options.videoUploadUrl === "string" ? options.videoUploadUrl : null;
      options.videoUploadSizeLimit = /\d+/.test(options.videoUploadSizeLimit) ? util_default.getNumber(options.videoUploadSizeLimit, 0) : null;
      options.videoMultipleFile = !!options.videoMultipleFile;
      options.videoTagAttrs = options.videoTagAttrs || null;
      options.videoIframeAttrs = options.videoIframeAttrs || null;
      options.videoAccept = typeof options.videoAccept !== "string" || options.videoAccept.trim() === "*" ? "video/*" : options.videoAccept.trim() || "video/*";
      options.audioWidth = !options.audioWidth ? "" : util_default.isNumber(options.audioWidth) ? options.audioWidth + "px" : options.audioWidth;
      options.audioHeight = !options.audioHeight ? "" : util_default.isNumber(options.audioHeight) ? options.audioHeight + "px" : options.audioHeight;
      options.audioFileInput = !!options.audioFileInput;
      options.audioUrlInput = options.audioUrlInput === void 0 || !options.audioFileInput ? true : options.audioUrlInput;
      options.audioUploadHeader = options.audioUploadHeader || null;
      options.audioUploadUrl = typeof options.audioUploadUrl === "string" ? options.audioUploadUrl : null;
      options.audioUploadSizeLimit = /\d+/.test(options.audioUploadSizeLimit) ? util_default.getNumber(options.audioUploadSizeLimit, 0) : null;
      options.audioMultipleFile = !!options.audioMultipleFile;
      options.audioTagAttrs = options.audioTagAttrs || null;
      options.audioAccept = typeof options.audioAccept !== "string" || options.audioAccept.trim() === "*" ? "audio/*" : options.audioAccept.trim() || "audio/*";
      options.tableCellControllerPosition = typeof options.tableCellControllerPosition === "string" ? options.tableCellControllerPosition.toLowerCase() : "cell";
      options.linkTargetNewWindow = !!options.linkTargetNewWindow;
      options.linkProtocol = typeof options.linkProtocol === "string" ? options.linkProtocol : null;
      options.linkRel = Array.isArray(options.linkRel) ? options.linkRel : [];
      options.linkRelDefault = options.linkRelDefault || {};
      options.tabDisable = !!options.tabDisable;
      options.shortcutsDisable = Array.isArray(options.shortcutsDisable) ? options.shortcutsDisable : [];
      options.shortcutsHint = options.shortcutsHint === void 0 ? true : !!options.shortcutsHint;
      options.callBackSave = !options.callBackSave ? null : options.callBackSave;
      options.templates = !options.templates ? null : options.templates;
      options.placeholder = typeof options.placeholder === "string" ? options.placeholder : null;
      options.mediaAutoSelect = options.mediaAutoSelect === void 0 ? true : !!options.mediaAutoSelect;
      options.buttonList = !!options.buttonList ? options.buttonList : [
        ["undo", "redo"],
        ["bold", "underline", "italic", "strike", "subscript", "superscript"],
        ["removeFormat"],
        ["outdent", "indent"],
        ["fullScreen", "showBlocks", "codeView"],
        ["preview", "print"]
      ];
      if (options.rtl) {
        options.buttonList = options.buttonList.reverse();
      }
      options.icons = !options.icons || typeof options.icons !== "object" ? defaultIcons_default : [defaultIcons_default, options.icons].reduce(function(_default, _new) {
        for (let key in _new) {
          if (util_default.hasOwn(_new, key)) _default[key] = _new[key];
        }
        return _default;
      }, {});
      options.icons = !options.rtl ? options.icons : [options.icons, options.icons.rtl].reduce(function(_default, _new) {
        for (let key in _new) {
          if (util_default.hasOwn(_new, key)) _default[key] = _new[key];
        }
        return _default;
      }, {});
      options.__listCommonStyle = options.__listCommonStyle || ["fontSize", "color", "fontFamily", "fontWeight", "fontStyle"];
      options._editorStyles = util_default._setDefaultOptionStyle(options, options.defaultStyle);
    },
    _setWhitelist: function(whitelist, blacklist) {
      if (typeof blacklist !== "string") return whitelist;
      blacklist = blacklist.split("|");
      whitelist = whitelist.split("|");
      for (let i = 0, len = blacklist.length, index; i < len; i++) {
        index = whitelist.indexOf(blacklist[i]);
        if (index > -1) whitelist.splice(index, 1);
      }
      return whitelist.join("|");
    },
    /**
     * @description Suneditor's Default button list
     * @param {Object} options options
     * @private
     */
    _defaultButtons: function(options) {
      const icons = options.icons;
      const lang = options.lang;
      const cmd = util_default.isOSX_IOS ? "\u2318" : "CTRL";
      const addShift = util_default.isOSX_IOS ? "\u21E7" : "+SHIFT";
      const shortcutsDisable = !options.shortcutsHint ? ["bold", "strike", "underline", "italic", "undo", "indent", "save"] : options.shortcutsDisable;
      const indentKey = options.rtl ? ["[", "]"] : ["]", "["];
      const indentIcon = options.rtl ? [icons.outdent, icons.indent] : [icons.indent, icons.outdent];
      return {
        /** default command */
        bold: ["", lang.toolbar.bold + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("bold") > -1 ? "" : cmd + '+<span class="se-shortcut-key">B</span>') + "</span>", "bold", "", icons.bold],
        underline: ["", lang.toolbar.underline + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("underline") > -1 ? "" : cmd + '+<span class="se-shortcut-key">U</span>') + "</span>", "underline", "", icons.underline],
        italic: ["", lang.toolbar.italic + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("italic") > -1 ? "" : cmd + '+<span class="se-shortcut-key">I</span>') + "</span>", "italic", "", icons.italic],
        strike: ["", lang.toolbar.strike + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("strike") > -1 ? "" : cmd + addShift + '+<span class="se-shortcut-key">S</span>') + "</span>", "strike", "", icons.strike],
        subscript: ["", lang.toolbar.subscript, "SUB", "", icons.subscript],
        superscript: ["", lang.toolbar.superscript, "SUP", "", icons.superscript],
        removeFormat: ["", lang.toolbar.removeFormat, "removeFormat", "", icons.erase],
        indent: ["", lang.toolbar.indent + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("indent") > -1 ? "" : cmd + '+<span class="se-shortcut-key">' + indentKey[0] + "</span>") + "</span>", "indent", "", indentIcon[0]],
        outdent: ["", lang.toolbar.outdent + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("indent") > -1 ? "" : cmd + '+<span class="se-shortcut-key">' + indentKey[1] + "</span>") + "</span>", "outdent", "", indentIcon[1]],
        fullScreen: ["se-code-view-enabled se-resizing-enabled", lang.toolbar.fullScreen, "fullScreen", "", icons.expansion],
        showBlocks: ["", lang.toolbar.showBlocks, "showBlocks", "", icons.show_blocks],
        codeView: ["se-code-view-enabled se-resizing-enabled", lang.toolbar.codeView, "codeView", "", icons.code_view],
        undo: ["", lang.toolbar.undo + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("undo") > -1 ? "" : cmd + '+<span class="se-shortcut-key">Z</span>') + "</span>", "undo", "", icons.undo],
        redo: ["", lang.toolbar.redo + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("undo") > -1 ? "" : cmd + '+<span class="se-shortcut-key">Y</span> / ' + cmd + addShift + '+<span class="se-shortcut-key">Z</span>') + "</span>", "redo", "", icons.redo],
        preview: ["se-resizing-enabled", lang.toolbar.preview, "preview", "", icons.preview],
        print: ["se-resizing-enabled", lang.toolbar.print, "print", "", icons.print],
        dir: ["", lang.toolbar[options.rtl ? "dir_ltr" : "dir_rtl"], "dir", "", icons[options.rtl ? "dir_ltr" : "dir_rtl"]],
        dir_ltr: ["", lang.toolbar.dir_ltr, "dir_ltr", "", icons.dir_ltr],
        dir_rtl: ["", lang.toolbar.dir_rtl, "dir_rtl", "", icons.dir_rtl],
        save: ["se-resizing-enabled", lang.toolbar.save + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("save") > -1 ? "" : cmd + '+<span class="se-shortcut-key">S</span>') + "</span>", "save", "", icons.save],
        /** plugins - command */
        blockquote: ["", lang.toolbar.tag_blockquote, "blockquote", "command", icons.blockquote],
        /** plugins - submenu */
        font: ["se-btn-select se-btn-tool-font", lang.toolbar.font, "font", "submenu", '<span class="txt">' + lang.toolbar.font + "</span>" + icons.arrow_down],
        formatBlock: ["se-btn-select se-btn-tool-format", lang.toolbar.formats, "formatBlock", "submenu", '<span class="txt">' + lang.toolbar.formats + "</span>" + icons.arrow_down],
        fontSize: ["se-btn-select se-btn-tool-size", lang.toolbar.fontSize, "fontSize", "submenu", '<span class="txt">' + lang.toolbar.fontSize + "</span>" + icons.arrow_down],
        fontColor: ["", lang.toolbar.fontColor, "fontColor", "submenu", icons.font_color],
        hiliteColor: ["", lang.toolbar.hiliteColor, "hiliteColor", "submenu", icons.highlight_color],
        align: ["se-btn-align", lang.toolbar.align, "align", "submenu", options.rtl ? icons.align_right : icons.align_left],
        list: ["", lang.toolbar.list, "list", "submenu", icons.list_number],
        horizontalRule: ["btn_line", lang.toolbar.horizontalRule, "horizontalRule", "submenu", icons.horizontal_rule],
        table: ["", lang.toolbar.table, "table", "submenu", icons.table],
        lineHeight: ["", lang.toolbar.lineHeight, "lineHeight", "submenu", icons.line_height],
        template: ["", lang.toolbar.template, "template", "submenu", icons.template],
        paragraphStyle: ["", lang.toolbar.paragraphStyle, "paragraphStyle", "submenu", icons.paragraph_style],
        textStyle: ["", lang.toolbar.textStyle, "textStyle", "submenu", icons.text_style],
        /** plugins - dialog */
        link: ["", lang.toolbar.link, "link", "dialog", icons.link],
        image: ["", lang.toolbar.image, "image", "dialog", icons.image],
        video: ["", lang.toolbar.video, "video", "dialog", icons.video],
        audio: ["", lang.toolbar.audio, "audio", "dialog", icons.audio],
        math: ["", lang.toolbar.math, "math", "dialog", icons.math],
        /** plugins - fileBrowser */
        imageGallery: ["", lang.toolbar.imageGallery, "imageGallery", "fileBrowser", icons.image_gallery]
      };
    },
    /**
     * @description Create a group div containing each module
     * @returns {Object}
     * @private
     */
    _createModuleGroup: function() {
      const oDiv = util_default.createElement("DIV");
      oDiv.className = "se-btn-module se-btn-module-border";
      const oUl = util_default.createElement("UL");
      oUl.className = "se-menu-list";
      oDiv.appendChild(oUl);
      return {
        "div": oDiv,
        "ul": oUl
      };
    },
    /**
     * @description Create a button element
     * @param {string} buttonClass className in button
     * @param {string} title Title in button
     * @param {string} dataCommand The data-command property of the button
     * @param {string} dataDisplay The data-display property of the button ('dialog', 'submenu', 'command')
     * @param {string} innerHTML Html in button
     * @param {string} _disabled Button disabled
     * @param {Object} _icons Icons
     * @returns {Object}
     * @private
     */
    _createButton: function(buttonClass, title, dataCommand, dataDisplay, innerHTML, _disabled, _icons) {
      const oLi = util_default.createElement("LI");
      const oButton = util_default.createElement("BUTTON");
      const label = title || dataCommand;
      oButton.setAttribute("type", "button");
      oButton.setAttribute("class", "se-btn" + (buttonClass ? " " + buttonClass : "") + " se-tooltip");
      oButton.setAttribute("data-command", dataCommand);
      oButton.setAttribute("data-display", dataDisplay);
      oButton.setAttribute("aria-label", label.replace(/<span .+<\/span>/, ""));
      oButton.setAttribute("tabindex", "-1");
      if (!innerHTML) innerHTML = '<span class="se-icon-text">!</span>';
      if (/^default\./i.test(innerHTML)) {
        innerHTML = _icons[innerHTML.replace(/^default\./i, "")];
      }
      if (/^text\./i.test(innerHTML)) {
        innerHTML = innerHTML.replace(/^text\./i, "");
        oButton.className += " se-btn-more-text";
      }
      innerHTML += '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + label + "</span></span>";
      if (_disabled) oButton.setAttribute("disabled", true);
      oButton.innerHTML = innerHTML;
      oLi.appendChild(oButton);
      return {
        "li": oLi,
        "button": oButton
      };
    },
    /**
     * @description Create editor HTML
     * @param {Array} doc document object
     * @param {Array} buttonList option.buttonList
     * @param {Object|null} plugins Plugins
     * @param {Array} options options
     * @returns {Object} { element: (Element) Toolbar element, plugins: (Array|null) Plugins Array, pluginCallButtons: (Object), responsiveButtons: (Array) }
     * @private
     */
    _createToolBar: function(doc, buttonList, plugins, options) {
      const separator_vertical = doc.createElement("DIV");
      separator_vertical.className = "se-toolbar-separator-vertical";
      const tool_bar = doc.createElement("DIV");
      tool_bar.className = "se-toolbar sun-editor-common";
      const _buttonTray = doc.createElement("DIV");
      _buttonTray.className = "se-btn-tray";
      tool_bar.appendChild(_buttonTray);
      buttonList = JSON.parse(JSON.stringify(buttonList));
      const icons = options.icons;
      const defaultButtonList = this._defaultButtons(options);
      const pluginCallButtons = {};
      const responsiveButtons = [];
      let module = null;
      let button = null;
      let moduleElement = null;
      let buttonElement = null;
      let pluginName = "";
      let vertical = false;
      const moreLayer = util_default.createElement("DIV");
      moreLayer.className = "se-toolbar-more-layer";
      buttonGroupLoop:
        for (let i = 0, more, moreContainer, moreCommand, buttonGroup, align; i < buttonList.length; i++) {
          more = false;
          align = "";
          buttonGroup = buttonList[i];
          moduleElement = this._createModuleGroup();
          if (typeof buttonGroup === "object") {
            for (let j = 0, moreButton; j < buttonGroup.length; j++) {
              button = buttonGroup[j];
              moreButton = false;
              if (/^\%\d+/.test(button) && j === 0) {
                buttonGroup[0] = button.replace(/[^\d]/g, "");
                responsiveButtons.push(buttonGroup);
                buttonList.splice(i--, 1);
                continue buttonGroupLoop;
              }
              if (typeof button === "object") {
                if (typeof button.add === "function") {
                  pluginName = button.name;
                  module = defaultButtonList[pluginName];
                  plugins[pluginName] = button;
                } else {
                  pluginName = button.name;
                  module = [button.buttonClass, button.title, button.name, button.dataDisplay, button.innerHTML, button._disabled];
                }
              } else {
                if (/^\-/.test(button)) {
                  align = button.substr(1);
                  moduleElement.div.className += " module-float-" + align;
                  continue;
                }
                if (/^\#/.test(button)) {
                  const option = button.substr(1);
                  if (option === "fix") moduleElement.ul.className += " se-menu-dir-fix";
                  continue;
                }
                if (/^\:/.test(button)) {
                  moreButton = true;
                  const matched = button.match(/^\:([^\-]+)\-([^\-]+)\-([^\-]+)/);
                  moreCommand = "__se__" + matched[1].trim();
                  const title = matched[2].trim();
                  const innerHTML = matched[3].trim();
                  module = ["se-btn-more", title, moreCommand, "MORE", innerHTML];
                } else {
                  module = defaultButtonList[button];
                }
                pluginName = button;
                if (!module) {
                  const custom = plugins[pluginName];
                  if (!custom) throw Error("[SUNEDITOR.create.toolbar.fail] The button name of a plugin that does not exist. [" + pluginName + "]");
                  module = [custom.buttonClass, custom.title, custom.name, custom.display, custom.innerHTML, custom._disabled];
                }
              }
              buttonElement = this._createButton(module[0], module[1], module[2], module[3], module[4], module[5], icons);
              (more ? moreContainer : moduleElement.ul).appendChild(buttonElement.li);
              if (plugins[pluginName]) {
                pluginCallButtons[pluginName] = buttonElement.button;
              }
              if (moreButton) {
                more = true;
                moreContainer = util_default.createElement("DIV");
                moreContainer.className = "se-more-layer " + moreCommand;
                moreContainer.innerHTML = '<div class="se-more-form"><ul class="se-menu-list"' + (align ? ' style="float: ' + align + ';"' : "") + "></ul></div>";
                moreLayer.appendChild(moreContainer);
                moreContainer = moreContainer.firstElementChild.firstElementChild;
              }
            }
            if (vertical) {
              const sv = separator_vertical.cloneNode(false);
              _buttonTray.appendChild(sv);
            }
            _buttonTray.appendChild(moduleElement.div);
            vertical = true;
          } else if (/^\/$/.test(buttonGroup)) {
            const enterDiv = doc.createElement("DIV");
            enterDiv.className = "se-btn-module-enter";
            _buttonTray.appendChild(enterDiv);
            vertical = false;
          }
        }
      switch (_buttonTray.children.length) {
        case 0:
          _buttonTray.style.display = "none";
          break;
        case 1:
          util_default.removeClass(_buttonTray.firstElementChild, "se-btn-module-border");
          break;
        default:
          if (options.rtl) {
            const sv = separator_vertical.cloneNode(false);
            sv.style.float = _buttonTray.lastElementChild.style.float;
            _buttonTray.appendChild(sv);
          }
      }
      if (responsiveButtons.length > 0) responsiveButtons.unshift(buttonList);
      if (moreLayer.children.length > 0) _buttonTray.appendChild(moreLayer);
      const _menuTray = doc.createElement("DIV");
      _menuTray.className = "se-menu-tray";
      tool_bar.appendChild(_menuTray);
      const tool_cover = doc.createElement("DIV");
      tool_cover.className = "se-toolbar-cover";
      tool_bar.appendChild(tool_cover);
      if (options.hideToolbar) tool_bar.style.display = "none";
      return {
        "element": tool_bar,
        "plugins": plugins,
        "pluginCallButtons": pluginCallButtons,
        "responsiveButtons": responsiveButtons,
        "_menuTray": _menuTray,
        "_buttonTray": _buttonTray
      };
    }
  };

  // ../../node_modules/suneditor/src/lib/context.js
  var _Context = function(element, cons, options) {
    return {
      element: {
        originElement: element,
        topArea: cons._top,
        relative: cons._relative,
        toolbar: cons._toolBar,
        _toolbarShadow: cons._toolbarShadow,
        _buttonTray: cons._toolBar.querySelector(".se-btn-tray"),
        _menuTray: cons._menuTray,
        resizingBar: cons._resizingBar,
        navigation: cons._navigation,
        charWrapper: cons._charWrapper,
        charCounter: cons._charCounter,
        editorArea: cons._editorArea,
        wysiwygFrame: cons._wysiwygArea,
        wysiwyg: cons._wysiwygArea,
        // if (options.iframe) cons._wysiwygArea.contentDocument.body
        code: cons._codeArea,
        placeholder: cons._placeholder,
        loading: cons._loading,
        lineBreaker: cons._lineBreaker,
        lineBreaker_t: cons._lineBreaker_t,
        lineBreaker_b: cons._lineBreaker_b,
        resizeBackground: cons._resizeBack,
        _stickyDummy: cons._stickyDummy,
        _arrow: cons._arrow,
        _focusTemp: cons._focusTemp
      },
      tool: {
        cover: cons._toolBar.querySelector(".se-toolbar-cover"),
        bold: cons._toolBar.querySelector('[data-command="bold"]'),
        underline: cons._toolBar.querySelector('[data-command="underline"]'),
        italic: cons._toolBar.querySelector('[data-command="italic"]'),
        strike: cons._toolBar.querySelector('[data-command="strike"]'),
        sub: cons._toolBar.querySelector('[data-command="SUB"]'),
        sup: cons._toolBar.querySelector('[data-command="SUP"]'),
        undo: cons._toolBar.querySelector('[data-command="undo"]'),
        redo: cons._toolBar.querySelector('[data-command="redo"]'),
        save: cons._toolBar.querySelector('[data-command="save"]'),
        outdent: cons._toolBar.querySelector('[data-command="outdent"]'),
        indent: cons._toolBar.querySelector('[data-command="indent"]'),
        fullScreen: cons._toolBar.querySelector('[data-command="fullScreen"]'),
        showBlocks: cons._toolBar.querySelector('[data-command="showBlocks"]'),
        codeView: cons._toolBar.querySelector('[data-command="codeView"]'),
        dir: cons._toolBar.querySelector('[data-command="dir"]'),
        dir_ltr: cons._toolBar.querySelector('[data-command="dir_ltr"]'),
        dir_rtl: cons._toolBar.querySelector('[data-command="dir_rtl"]')
      },
      options,
      option: options
    };
  };
  var context_default = _Context;

  // ../../node_modules/suneditor/src/lib/history.js
  function history_default(core, change) {
    const _w = core._w;
    const util2 = core.util;
    const delayTime = core.options.historyStackDelayTime;
    let editor = core.context.element;
    let undo = core.context.tool.undo;
    let redo = core.context.tool.redo;
    let pushDelay = null;
    let stackIndex = 0;
    let stack = [];
    function setContentsFromStack() {
      const item = stack[stackIndex];
      editor.wysiwyg.innerHTML = item.contents;
      core.setRange(util2.getNodeFromPath(item.s.path, editor.wysiwyg), item.s.offset, util2.getNodeFromPath(item.e.path, editor.wysiwyg), item.e.offset);
      core.focus();
      if (stack.length <= 1) {
        if (undo) undo.setAttribute("disabled", true);
        if (redo) redo.setAttribute("disabled", true);
      } else {
        if (stackIndex === 0) {
          if (undo) undo.setAttribute("disabled", true);
          if (redo) redo.removeAttribute("disabled");
        } else if (stackIndex === stack.length - 1) {
          if (undo) undo.removeAttribute("disabled");
          if (redo) redo.setAttribute("disabled", true);
        } else {
          if (undo) undo.removeAttribute("disabled");
          if (redo) redo.removeAttribute("disabled");
        }
      }
      core.controllersOff();
      core._checkComponents();
      core._setCharCount();
      core._resourcesStateChange();
      change();
    }
    function pushStack() {
      core._checkComponents();
      const current = editor.wysiwyg.innerHTML;
      if (!current || !!stack[stackIndex] && current === stack[stackIndex].contents) return;
      stackIndex++;
      const range = core._variable._range;
      if (stack.length > stackIndex) {
        stack = stack.slice(0, stackIndex);
        if (redo) redo.setAttribute("disabled", true);
      }
      if (!range) {
        stack[stackIndex] = {
          contents: current,
          s: { path: [0, 0], offset: [0, 0] },
          e: { path: 0, offset: 0 }
        };
      } else {
        stack[stackIndex] = {
          contents: current,
          s: {
            path: util2.getNodePath(range.startContainer, null, null),
            offset: range.startOffset
          },
          e: {
            path: util2.getNodePath(range.endContainer, null, null),
            offset: range.endOffset
          }
        };
      }
      if (stackIndex === 1 && undo) undo.removeAttribute("disabled");
      core._setCharCount();
      change();
    }
    return {
      /**
       * @description History stack
       */
      stack,
      /**
       * @description Saving the current status to the history object stack
       * If "delay" is true, it will be saved after (options.historyStackDelayTime || 400) miliseconds
       * If the function is called again with the "delay" argument true before it is saved, the delay time is renewal
       * You can specify the delay time by sending a number.
       * @param {Boolean|Number} delay If true, Add stack without delay time.
       */
      push: function(delay) {
        _w.setTimeout(core._resourcesStateChange.bind(core));
        const time = typeof delay === "number" ? delay > 0 ? delay : 0 : !delay ? 0 : delayTime;
        if (!time || pushDelay) {
          _w.clearTimeout(pushDelay);
          if (!time) {
            pushStack();
            return;
          }
        }
        pushDelay = _w.setTimeout(function() {
          _w.clearTimeout(pushDelay);
          pushDelay = null;
          pushStack();
        }, time);
      },
      /**
       * @description Undo function
       */
      undo: function() {
        if (stackIndex > 0) {
          stackIndex--;
          setContentsFromStack();
        }
      },
      /**
       * @description Redo function
       */
      redo: function() {
        if (stack.length - 1 > stackIndex) {
          stackIndex++;
          setContentsFromStack();
        }
      },
      /**
       * @description Go to the history stack for that index.
       * If "index" is -1, go to the last stack
       */
      go: function(index) {
        stackIndex = index < 0 ? stack.length - 1 : index;
        setContentsFromStack();
      },
      /**
       * @description Get the current history stack index.
       * @returns {Number} Current Stack index
       */
      getCurrentIndex: function() {
        return stackIndex;
      },
      /**
       * @description Reset the history object
       */
      reset: function(ignoreChangeEvent) {
        if (undo) undo.setAttribute("disabled", true);
        if (redo) redo.setAttribute("disabled", true);
        core._variable.isChanged = false;
        if (core.context.tool.save) core.context.tool.save.setAttribute("disabled", true);
        stack.splice(0);
        stackIndex = 0;
        stack[stackIndex] = {
          contents: core.getContents(true),
          s: {
            path: [0, 0],
            offset: 0
          },
          e: {
            path: [0, 0],
            offset: 0
          }
        };
        if (!ignoreChangeEvent) change();
      },
      /**
       * @description Reset the disabled state of the buttons to fit the current stack.
       * @private
       */
      _resetCachingButton: function() {
        editor = core.context.element;
        undo = core.context.tool.undo;
        redo = core.context.tool.redo;
        if (stackIndex === 0) {
          if (undo) undo.setAttribute("disabled", true);
          if (redo && stackIndex === stack.length - 1) redo.setAttribute("disabled", true);
          core._variable.isChanged = false;
          if (core.context.tool.save) core.context.tool.save.setAttribute("disabled", true);
        } else if (stackIndex === stack.length - 1) {
          if (redo) redo.setAttribute("disabled", true);
        }
      },
      /**
       * @description Remove all stacks and remove the timeout function.
       * @private
       */
      _destroy: function() {
        if (pushDelay) _w.clearTimeout(pushDelay);
        stack = null;
      }
    };
  }

  // ../../node_modules/suneditor/src/plugins/modules/_notice.js
  var notice_default = {
    name: "notice",
    /**
     * @description Constructor
     * @param {Object} core Core object 
     */
    add: function(core) {
      const context = core.context;
      context.notice = {};
      let notice_div = core.util.createElement("DIV");
      let notice_span = core.util.createElement("SPAN");
      let notice_button = core.util.createElement("BUTTON");
      notice_div.className = "se-notice";
      notice_button.className = "close";
      notice_button.setAttribute("aria-label", "Close");
      notice_button.setAttribute("title", core.lang.dialogBox.close);
      notice_button.innerHTML = core.icons.cancel;
      notice_div.appendChild(notice_span);
      notice_div.appendChild(notice_button);
      context.notice.modal = notice_div;
      context.notice.message = notice_span;
      notice_button.addEventListener("click", this.onClick_cancel.bind(core));
      context.element.editorArea.appendChild(notice_div);
      notice_div = null;
    },
    /**
     * @description Event when clicking the cancel button
     * @param {MouseEvent} e Event object
     */
    onClick_cancel: function(e) {
      e.preventDefault();
      e.stopPropagation();
      this.plugins.notice.close.call(this);
    },
    /**
     * @description  Open the notice panel
     * @param {String} text Notice message
     */
    open: function(text) {
      this.context.notice.message.textContent = text;
      this.context.notice.modal.style.display = "block";
    },
    /**
     * @description  Open the notice panel
     */
    close: function() {
      this.context.notice.modal.style.display = "none";
    }
  };

  // ../../node_modules/suneditor/src/lib/core.js
  function core_default(context, pluginCallButtons, plugins, lang, options, _responsiveButtons) {
    const _d = context.element.originElement.ownerDocument || document;
    const _w = _d.defaultView || window;
    const util2 = util_default;
    const icons = options.icons;
    const core = {
      _d,
      _w,
      _parser: new _w.DOMParser(),
      _prevRtl: options.rtl,
      _editorHeight: 0,
      _editorHeightPadding: 0,
      _listCamel: options.__listCommonStyle,
      _listKebab: util2.camelToKebabCase(options.__listCommonStyle),
      __focusTemp: context.element._focusTemp,
      /**
       * @description Document object of the iframe if created as an iframe || _d
       * @private
       */
      _wd: null,
      /**
       * @description Window object of the iframe if created as an iframe || _w
       * @private
       */
      _ww: null,
      /**
       * @description Closest ShadowRoot to editor if found
       * @private
       */
      _shadowRoot: null,
      /**
       * @description Block controller mousedown events in "shadowRoot" environment
       * @private
       */
      _shadowRootControllerEventTarget: null,
      /**
       * @description Util object
       */
      util: util2,
      /**
       * @description Functions object
       */
      functions: null,
      /**
       * @description Editor options
       */
      options: null,
      /**
       * @description Computed style of the wysiwyg area (window.getComputedStyle(context.element.wysiwyg))
       */
      wwComputedStyle: null,
      /**
       * @description Notice object
       */
      notice: notice_default,
      /**
       * @description Default icons object
       */
      icons,
      /**
       * @description History object for undo, redo
       */
      history: null,
      /**
       * @description Elements and user options parameters of the suneditor
       */
      context,
      /**
       * @description Plugin buttons
       */
      pluginCallButtons,
      /**
       * @description Loaded plugins
       */
      plugins: plugins || {},
      /**
       * @description Whether the plugin is initialized
       */
      initPlugins: {},
      /**
       * @description Object for managing submenu elements
       * @private
       */
      _targetPlugins: {},
      /**
       * @description Save rendered submenus and containers
       * @private
       */
      _menuTray: {},
      /**
       * @description loaded language
       */
      lang,
      /**
       * @description The selection node (core.getSelectionNode()) to which the effect was last applied
       */
      effectNode: null,
      /**
       * @description submenu element
       */
      submenu: null,
      /**
       * @description container element
       */
      container: null,
      /**
       * @description current subment name
       * @private
       */
      _submenuName: "",
      /**
       * @description binded submenuOff method
       * @private
       */
      _bindedSubmenuOff: null,
      /**
       * @description binded containerOff method
       * @private
       */
      _bindedContainerOff: null,
      /**
       * @description active button element in submenu
       */
      submenuActiveButton: null,
      /**
       * @description active button element in container
       */
      containerActiveButton: null,
      /**
       * @description The elements array to be processed unvisible when the controllersOff function is executed (resizing, link modified button, table controller)
       */
      controllerArray: [],
      /**
       * @description The name of the plugin that called the currently active controller
       */
      currentControllerName: "",
      /**
       * @description The target element of current controller
       */
      currentControllerTarget: null,
      /**
       * @description The file component object of current selected file tag (getFileComponent)
       */
      currentFileComponentInfo: null,
      /**
       * @description An array of buttons whose class name is not "se-code-view-enabled"
       */
      codeViewDisabledButtons: [],
      /**
       * @description An array of buttons whose class name is not "se-resizing-enabled"
       */
      resizingDisabledButtons: [],
      /**
       * @description active more layer element in submenu
       * @private
       */
      _moreLayerActiveButton: null,
      /**
       * @description Tag whitelist RegExp object used in "_consistencyCheckOfHTML" method
       * ^(options._editorTagsWhitelist)$
       * @private
       */
      _htmlCheckWhitelistRegExp: null,
      /**
       * @description Tag blacklist RegExp object used in "_consistencyCheckOfHTML" method
       * @private
       */
      _htmlCheckBlacklistRegExp: null,
      /**
       * @description RegExp when using check disallowd tags. (b, i, ins, strike, s)
       * @private
       */
      _disallowedTextTagsRegExp: null,
      /**
       * @description Editor tags whitelist (RegExp object)
       * util.createTagsWhitelist(options._editorTagsWhitelist)
       */
      editorTagsWhitelistRegExp: null,
      /**
       * @description Editor tags blacklist (RegExp object)
       * util.createTagsBlacklist(options.tagsBlacklist)
       */
      editorTagsBlacklistRegExp: null,
      /**
       * @description Tag whitelist when pasting (RegExp object)
       * util.createTagsWhitelist(options.pasteTagsWhitelist)
       */
      pasteTagsWhitelistRegExp: null,
      /**
       * @description Tag blacklist when pasting (RegExp object)
       * util.createTagsBlacklist(options.pasteTagsBlacklist)
       */
      pasteTagsBlacklistRegExp: null,
      /**
       * @description Boolean value of whether the editor has focus
       */
      hasFocus: false,
      /**
       * @description Boolean value of whether the editor is disabled
       */
      isDisabled: false,
      /**
       * @description Boolean value of whether the editor is readOnly
       */
      isReadOnly: false,
      /**
       * @description Attributes whitelist used by the cleanHTML method
       * @private
       */
      _attributesWhitelistRegExp: null,
      _attributesWhitelistRegExp_all_data: null,
      /**
       * @description Attributes blacklist used by the cleanHTML method
       * @private
       */
      _attributesBlacklistRegExp: null,
      /**
       * @description Attributes of tags whitelist used by the cleanHTML method
       * @private
       */
      _attributesTagsWhitelist: null,
      /**
       * @description Attributes of tags blacklist used by the cleanHTML method
       * @private
       */
      _attributesTagsBlacklist: null,
      /**
       * @description binded controllersOff method
       * @private
       */
      _bindControllersOff: null,
      /**
       * @description Is inline mode?
       * @private
       */
      _isInline: null,
      /**
       * @description Is balloon|balloon-always mode?
       * @private
       */
      _isBalloon: null,
      /**
       * @description Is balloon-always mode?
       * @private
       */
      _isBalloonAlways: null,
      /**
       * @description Required value when using inline mode to sticky toolbar
       * @private
       */
      _inlineToolbarAttr: { top: "", width: "", isShow: false },
      /**
       * @description Variable that controls the "blur" event in the editor of inline or balloon mode when the focus is moved to submenu
       * @private
       */
      _notHideToolbar: false,
      /**
       * @description Variable value that sticky toolbar mode
       * @private
       */
      _sticky: false,
      /**
       * @description Variables for controlling focus and blur events
       * @private
       */
      _antiBlur: false,
      /**
       * @description Component line breaker element
       * @private
       */
      _lineBreaker: null,
      _lineBreakerButton: null,
      /**
       * @description If true, (initialize, reset) all indexes of image, video information
       * @private
       */
      _componentsInfoInit: true,
      _componentsInfoReset: false,
      /**
       * @description Plugins array with "active" method.
       * "activePlugins" runs the "add" method when creating the editor.
       */
      activePlugins: null,
      /**
       * @description Information of tags that should maintain HTML structure, style, class name, etc. (In use by "math" plugin)
       * When inserting "html" such as paste, it is executed on the "html" to be inserted. (core.cleanHTML)
       * Basic Editor Actions:
       * 1. All classes not starting with "__se__" or "se-" in the editor are removed.
       * 2. The style of all tags except the "span" tag is removed from the editor.
       * "managedTagsInfo" structure ex:
       * managedTagsInfo: {
       *   query: '.__se__xxx, se-xxx'
       *   map: {
       *     '__se__xxx': method.bind(core),
       *     'se-xxx': method.bind(core),
       *   }
       * }
       * @example
       * Define in the following return format in the "managedTagInfo" function of the plugin.
       * managedTagInfo() => {
       *  return {
       *    className: 'string', // Class name to identify the tag. ("__se__xxx", "se-xxx")
       *    // Change the html of the "element". ("element" is the element found with "className".)
       *    // "method" is executed by binding "core".
       *    method: function (element) {
       *      // this === core
       *      element.innerHTML = // (rendered html);
       *    }
       *  }
       * }
       */
      managedTagsInfo: null,
      /**
       * @description cashing: options.charCounterType === 'byte-html'
       * @private
       */
      _charTypeHTML: false,
      /**
       * @description Array of "checkFileInfo" functions with the core bound
       * (Plugins with "checkFileInfo" and "resetFileInfo" methods)
       * "fileInfoPlugins" runs the "add" method when creating the editor.
       * "checkFileInfo" method is always call just before the "change" event.
       * @private
       */
      _fileInfoPluginsCheck: null,
      /**
       * @description Array of "resetFileInfo" functions with the core bound
       * (Plugins with "checkFileInfo" and "resetFileInfo" methods)
       * "checkFileInfo" method is always call just before the "functions.setOptions" method.
       * @private
       */
      _fileInfoPluginsReset: null,
      /**
       * @description Variables for file component management
       * @private
       */
      _fileManager: {
        tags: null,
        regExp: null,
        queryString: null,
        pluginRegExp: null,
        pluginMap: null
      },
      /**
       * @description Elements that need to change text or className for each selection change
       * After creating the editor, "activePlugins" are added.
       * @property {Element} STRONG bold button
       * @property {Element} U underline button
       * @property {Element} EM italic button
       * @property {Element} DEL strike button
       * @property {Element} SUB subscript button
       * @property {Element} SUP superscript button
       * @property {Element} OUTDENT outdent button
       * @property {Element} INDENT indent button
       */
      commandMap: {},
      /**
       * @description CSS properties related to style tags 
       * @private
       */
      _commandMapStyles: {
        STRONG: ["font-weight"],
        U: ["text-decoration"],
        EM: ["font-style"],
        DEL: ["text-decoration"]
      },
      /**
       * @description Style button related to edit area
       * @property {Element} fullScreen fullScreen button element
       * @property {Element} showBlocks showBlocks button element
       * @property {Element} codeView codeView button element
       * @private
       */
      _styleCommandMap: null,
      /**
       * @private
       */
      _cleanStyleRegExp: {
        div: new _w.RegExp("\\s*[^-a-zA-Z](.+)\\s*:[^;]+(?!;)*", "ig"),
        span: new _w.RegExp("\\s*[^-a-zA-Z](font-family|font-size|color|background-color)\\s*:[^;]+(?!;)*", "ig"),
        format: new _w.RegExp("\\s*[^-a-zA-Z](text-align|margin-left|margin-right|width|height|line-height)\\s*:[^;]+(?!;)*", "ig"),
        fontSizeUnit: new _w.RegExp("\\d+" + options.fontSizeUnit + "$", "i")
      },
      /**
       * @description Variables used internally in editor operation
       * @property {Boolean} isCodeView State of code view
       * @property {Boolean} isFullScreen State of full screen
       * @property {Number} innerHeight_fullScreen InnerHeight in editor when in full screen
       * @property {Number} resizeClientY Remember the vertical size of the editor before resizing the editor (Used when calculating during resize operation)
       * @property {Number} tabSize Indent size of tab (4)
       * @property {Number} codeIndent Indent size of Code view mode (2)
       * @property {Number} minResizingSize Minimum size of editing area when resized {Number} (.se-wrapper-inner {min-height: 65px;} || 65)
       * @property {Array} currentNodes  An array of the current cursor's node structure
       * @private
       */
      _variable: {
        isChanged: false,
        isCodeView: false,
        isFullScreen: false,
        innerHeight_fullScreen: 0,
        resizeClientY: 0,
        tabSize: 4,
        codeIndent: 2,
        minResizingSize: util2.getNumber(context.element.wysiwygFrame.style.minHeight || "65", 0),
        currentNodes: [],
        currentNodesMap: [],
        _range: null,
        _selectionNode: null,
        _originCssText: context.element.topArea.style.cssText,
        _bodyOverflow: "",
        _editorAreaOriginCssText: "",
        _wysiwygOriginCssText: "",
        _codeOriginCssText: "",
        _fullScreenAttrs: { sticky: false, balloon: false, inline: false },
        _lineBreakComp: null,
        _lineBreakDir: ""
      },
      /**
       * @description Temp variable for set line attrs
       * @private
       */
      _formatAttrsTemp: null,
      /**
       * @description Save the current buttons states to "allCommandButtons" object
       * @private
       */
      _saveButtonStates: function() {
        if (!this.allCommandButtons) this.allCommandButtons = {};
        const currentButtons = this.context.element._buttonTray.querySelectorAll(".se-menu-list button[data-display]");
        for (let i = 0, element, command; i < currentButtons.length; i++) {
          element = currentButtons[i];
          command = element.getAttribute("data-command");
          this.allCommandButtons[command] = element;
        }
      },
      /**
       * @description Recover the current buttons states from "allCommandButtons" object
       * @private
       */
      _recoverButtonStates: function() {
        if (this.allCommandButtons) {
          const currentButtons = this.context.element._buttonTray.querySelectorAll(".se-menu-list button[data-display]");
          for (let i = 0, button, command, oldButton; i < currentButtons.length; i++) {
            button = currentButtons[i];
            command = button.getAttribute("data-command");
            oldButton = this.allCommandButtons[command];
            if (oldButton) {
              button.parentElement.replaceChild(oldButton, button);
              if (this.context.tool[command]) this.context.tool[command] = oldButton;
            }
          }
        }
      },
      /**
       * @description If the plugin is not added, add the plugin and call the 'add' function.
       * If the plugin is added call callBack function.
       * @param {String} pluginName The name of the plugin to call
       * @param {function} callBackFunction Function to be executed immediately after module call
       * @param {Element|null} _target Plugin target button (This is not necessary if you have a button list when creating the editor)
       */
      callPlugin: function(pluginName, callBackFunction, _target) {
        _target = _target || pluginCallButtons[pluginName];
        if (!this.plugins[pluginName]) {
          throw Error('[SUNEDITOR.core.callPlugin.fail] The called plugin does not exist or is in an invalid format. (pluginName:"' + pluginName + '")');
        } else if (!this.initPlugins[pluginName]) {
          this.plugins[pluginName].add(this, _target);
          this.initPlugins[pluginName] = true;
        } else if (typeof this._targetPlugins[pluginName] === "object" && !!_target) {
          this.initMenuTarget(pluginName, _target, this._targetPlugins[pluginName]);
        }
        if (this.plugins[pluginName].active && !this.commandMap[pluginName] && !!_target) {
          this.commandMap[pluginName] = _target;
          this.activePlugins.push(pluginName);
        }
        if (typeof callBackFunction === "function") callBackFunction();
      },
      /**
       * @description If the module is not added, add the module and call the 'add' function
       * @param {Array} moduleArray module object's Array [dialog, resizing]
       */
      addModule: function(moduleArray) {
        for (let i = 0, len = moduleArray.length, moduleName; i < len; i++) {
          moduleName = moduleArray[i].name;
          if (!this.plugins[moduleName]) {
            this.plugins[moduleName] = moduleArray[i];
          }
          if (!this.initPlugins[moduleName]) {
            this.initPlugins[moduleName] = true;
            if (typeof this.plugins[moduleName].add === "function") this.plugins[moduleName].add(this);
          }
        }
      },
      /**
       * @description Gets the current editor-relative scroll offset.
       * @returns {Object} {top, left}
       */
      getGlobalScrollOffset: function() {
        let t = 0, l = 0;
        let el = context.element.topArea;
        while (el) {
          t += el.scrollTop;
          l += el.scrollLeft;
          el = el.parentElement;
        }
        el = this._shadowRoot ? this._shadowRoot.host : null;
        while (el) {
          t += el.scrollTop;
          l += el.scrollLeft;
          el = el.parentElement;
        }
        return {
          top: t,
          left: l
        };
      },
      /**
       * @description Method for managing submenu element.
       * You must add the "submenu" element using the this method at custom plugin.
       * @param {String} pluginName Plugin name
       * @param {Element|null} target Target button
       * @param {Element} menu Submenu element
       */
      initMenuTarget: function(pluginName, target, menu) {
        if (!target) {
          this._targetPlugins[pluginName] = menu;
        } else {
          context.element._menuTray.appendChild(menu);
          this._targetPlugins[pluginName] = true;
          this._menuTray[target.getAttribute("data-command")] = menu;
        }
      },
      /**
       * @description Enable submenu
       * @param {Element} element Submenu's button element to call
       */
      submenuOn: function(element) {
        if (this._bindedSubmenuOff) this._bindedSubmenuOff();
        if (this._bindControllersOff) this.controllersOff();
        const submenuName = this._submenuName = element.getAttribute("data-command");
        const menu = this.submenu = this._menuTray[submenuName];
        this.submenuActiveButton = element;
        this._setMenuPosition(element, menu);
        this._bindedSubmenuOff = this.submenuOff.bind(this);
        this.addDocEvent("mousedown", this._bindedSubmenuOff, false);
        if (this.plugins[submenuName].on) this.plugins[submenuName].on.call(this);
        this._antiBlur = true;
      },
      /**
       * @description Disable submenu
       */
      submenuOff: function() {
        this.removeDocEvent("mousedown", this._bindedSubmenuOff);
        this._bindedSubmenuOff = null;
        if (this.submenu) {
          this._submenuName = "";
          this.submenu.style.display = "none";
          this.submenu = null;
          util2.removeClass(this.submenuActiveButton, "on");
          this.submenuActiveButton = null;
          this._notHideToolbar = false;
        }
        this._antiBlur = false;
      },
      /**
       * @description Disable more layer
       */
      moreLayerOff: function() {
        if (this._moreLayerActiveButton) {
          const layer = context.element.toolbar.querySelector("." + this._moreLayerActiveButton.getAttribute("data-command"));
          layer.style.display = "none";
          util2.removeClass(this._moreLayerActiveButton, "on");
          this._moreLayerActiveButton = null;
        }
      },
      /**
       * @description Enable container
       * @param {Element} element Container's button element to call
       */
      containerOn: function(element) {
        if (this._bindedContainerOff) this._bindedContainerOff();
        const containerName = this._containerName = element.getAttribute("data-command");
        const menu = this.container = this._menuTray[containerName];
        this.containerActiveButton = element;
        this._setMenuPosition(element, menu);
        this._bindedContainerOff = this.containerOff.bind(this);
        this.addDocEvent("mousedown", this._bindedContainerOff, false);
        if (this.plugins[containerName].on) this.plugins[containerName].on.call(this);
        this._antiBlur = true;
      },
      /**
       * @description Disable container
       */
      containerOff: function() {
        this.removeDocEvent("mousedown", this._bindedContainerOff);
        this._bindedContainerOff = null;
        if (this.container) {
          this._containerName = "";
          this.container.style.display = "none";
          this.container = null;
          util2.removeClass(this.containerActiveButton, "on");
          this.containerActiveButton = null;
          this._notHideToolbar = false;
        }
        this._antiBlur = false;
      },
      /**
       * @description Set the menu position. (submenu, container)
       * @param {*} element Button element
       * @param {*} menu Menu element
       * @private
       */
      _setMenuPosition: function(element, menu) {
        menu.style.visibility = "hidden";
        menu.style.display = "block";
        menu.style.height = "";
        util2.addClass(element, "on");
        const toolbar = this.context.element.toolbar;
        const toolbarW = toolbar.offsetWidth;
        const toolbarOffset = event._getEditorOffsets(context.element.toolbar);
        const menuW = menu.offsetWidth;
        const l = element.parentElement.offsetLeft + 3;
        if (options.rtl) {
          const elementW = element.offsetWidth;
          const rtlW = menuW > elementW ? menuW - elementW : 0;
          const rtlL = rtlW > 0 ? 0 : elementW - menuW;
          menu.style.left = l - rtlW + rtlL + "px";
          if (toolbarOffset.left > event._getEditorOffsets(menu).left) {
            menu.style.left = "0px";
          }
        } else {
          const overLeft = toolbarW <= menuW ? 0 : toolbarW - (l + menuW);
          if (overLeft < 0) menu.style.left = l + overLeft + "px";
          else menu.style.left = l + "px";
        }
        let t = 0;
        let offsetEl = element;
        while (offsetEl && offsetEl !== toolbar) {
          t += offsetEl.offsetTop;
          offsetEl = offsetEl.offsetParent;
        }
        const bt = t;
        if (this._isBalloon) {
          t += toolbar.offsetTop + element.offsetHeight;
        } else {
          t -= element.offsetHeight;
        }
        const toolbarTop = toolbarOffset.top;
        const menuHeight = menu.offsetHeight;
        const scrollTop = this.getGlobalScrollOffset().top;
        const menuHeight_bottom = _w.innerHeight - (toolbarTop - scrollTop + bt + element.parentElement.offsetHeight);
        if (menuHeight_bottom < menuHeight) {
          let menuTop = -1 * (menuHeight - bt + 3);
          const insTop = toolbarTop - scrollTop + menuTop;
          const menuHeight_top = menuHeight + (insTop < 0 ? insTop : 0);
          if (menuHeight_top > menuHeight_bottom) {
            menu.style.height = menuHeight_top + "px";
            menuTop = -1 * (menuHeight_top - bt + 3);
          } else {
            menu.style.height = menuHeight_bottom + "px";
            menuTop = bt + element.parentElement.offsetHeight;
          }
          menu.style.top = menuTop + "px";
        } else {
          menu.style.top = bt + element.parentElement.offsetHeight + "px";
        }
        menu.style.visibility = "";
      },
      /**
       * @description Show controller at editor area (controller elements, function, "controller target element(@Required)", "controller name(@Required)", etc..)
       * @param {*} arguments controller elements, functions..
       */
      controllersOn: function() {
        if (this._bindControllersOff) this._bindControllersOff();
        this.controllerArray = [];
        for (let i = 0, arg; i < arguments.length; i++) {
          arg = arguments[i];
          if (!arg) continue;
          if (typeof arg === "string") {
            this.currentControllerName = arg;
            continue;
          }
          if (typeof arg === "function") {
            this.controllerArray.push(arg);
            continue;
          }
          if (!util2.hasClass(arg, "se-controller")) {
            this.currentControllerTarget = arg;
            this.currentFileComponentInfo = this.getFileComponent(arg);
            continue;
          }
          if (arg.style) {
            arg.style.display = "block";
            if (this._shadowRoot && this._shadowRootControllerEventTarget.indexOf(arg) === -1) {
              arg.addEventListener("mousedown", function(e) {
                e.preventDefault();
                e.stopPropagation();
              });
              this._shadowRootControllerEventTarget.push(arg);
            }
          }
          this.controllerArray.push(arg);
        }
        this._bindControllersOff = this.controllersOff.bind(this);
        this.addDocEvent("mousedown", this._bindControllersOff, false);
        this.addDocEvent("keydown", this._bindControllersOff, false);
        this._antiBlur = true;
        if (typeof functions.showController === "function") functions.showController(this.currentControllerName, this.controllerArray, this);
      },
      /**
       * @description Hide controller at editor area (link button, image resize button..)
       * @param {KeyboardEvent|MouseEvent|null} e Event object when called from mousedown and keydown events registered in "core.controllersOn"
       */
      controllersOff: function(e) {
        this._lineBreaker.style.display = "none";
        const len = this.controllerArray.length;
        if (e && e.target && len > 0) {
          for (let i = 0; i < len; i++) {
            if (typeof this.controllerArray[i].contains === "function" && this.controllerArray[i].contains(e.target)) return;
          }
        }
        if (this._fileManager.pluginRegExp.test(this.currentControllerName) && e && e.type === "keydown" && e.keyCode !== 27) return;
        context.element.lineBreaker_t.style.display = context.element.lineBreaker_b.style.display = "none";
        this._variable._lineBreakComp = null;
        this.currentControllerName = "";
        this.currentControllerTarget = null;
        this.currentFileComponentInfo = null;
        this.effectNode = null;
        if (!this._bindControllersOff) return;
        this.removeDocEvent("mousedown", this._bindControllersOff);
        this.removeDocEvent("keydown", this._bindControllersOff);
        this._bindControllersOff = null;
        if (len > 0) {
          for (let i = 0; i < len; i++) {
            if (typeof this.controllerArray[i] === "function") this.controllerArray[i]();
            else this.controllerArray[i].style.display = "none";
          }
          this.controllerArray = [];
        }
        this._antiBlur = false;
      },
      /**
       * @description Specify the position of the controller.
       * @param {Element} controller Controller element.
       * @param {Element} referEl Element that is the basis of the controller's position.
       * @param {String} position Type of position ("top" | "bottom")
       * When using the "top" position, there should not be an arrow on the controller.
       * When using the "bottom" position there should be an arrow on the controller.
       * @param {Object} addOffset These are the left and top values that need to be added specially. 
       * This argument is required. - {left: 0, top: 0}
       * Please enter the value based on ltr mode.
       * Calculated automatically in rtl mode.
       */
      setControllerPosition: function(controller, referEl, position, addOffset) {
        if (options.rtl) addOffset.left *= -1;
        const offset = util2.getOffset(referEl, context.element.wysiwygFrame);
        controller.style.visibility = "hidden";
        controller.style.display = "block";
        const topMargin = position === "top" ? -(controller.offsetHeight + 2) : referEl.offsetHeight + 12;
        controller.style.top = offset.top + topMargin + addOffset.top + "px";
        const l = offset.left - context.element.wysiwygFrame.scrollLeft + addOffset.left;
        const controllerW = controller.offsetWidth;
        const referElW = referEl.offsetWidth;
        const allow = util2.hasClass(controller.firstElementChild, "se-arrow") ? controller.firstElementChild : null;
        if (options.rtl) {
          const rtlW = controllerW > referElW ? controllerW - referElW : 0;
          const rtlL = rtlW > 0 ? 0 : referElW - controllerW;
          controller.style.left = l - rtlW + rtlL + "px";
          if (rtlW > 0) {
            if (allow) allow.style.left = (controllerW - 14 < 10 + rtlW ? controllerW - 14 : 10 + rtlW) + "px";
          }
          const overSize = context.element.wysiwygFrame.offsetLeft - controller.offsetLeft;
          if (overSize > 0) {
            controller.style.left = "0px";
            if (allow) allow.style.left = overSize + "px";
          }
        } else {
          controller.style.left = l + "px";
          const overSize = context.element.wysiwygFrame.offsetWidth - (controller.offsetLeft + controllerW);
          if (overSize < 0) {
            controller.style.left = controller.offsetLeft + overSize + "px";
            if (allow) allow.style.left = 20 - overSize + "px";
          } else {
            if (allow) allow.style.left = "20px";
          }
        }
        controller.style.visibility = "";
      },
      /**
       * @description javascript execCommand
       * @param {String} command javascript execCommand function property
       * @param {Boolean|undefined} showDefaultUI javascript execCommand function property
       * @param {String|undefined} value javascript execCommand function property
       */
      execCommand: function(command, showDefaultUI, value) {
        this._wd.execCommand(command, showDefaultUI, command === "formatBlock" ? "<" + value + ">" : value);
        this.history.push(true);
      },
      /**
       * @description Focus to wysiwyg area using "native focus function"
       */
      nativeFocus: function() {
        this.__focus();
        this._editorRange();
      },
      /**
       * @description Focus method
       * @private
       */
      __focus: function() {
        const caption = util2.getParentElement(this.getSelectionNode(), "figcaption");
        if (caption) {
          caption.focus();
        } else {
          context.element.wysiwyg.focus();
        }
      },
      /**
       * @description Focus to wysiwyg area
       */
      focus: function() {
        if (context.element.wysiwygFrame.style.display === "none") return;
        if (options.iframe) {
          this.nativeFocus();
        } else {
          try {
            const range = this.getRange();
            if (range.startContainer === range.endContainer && util2.isWysiwygDiv(range.startContainer)) {
              const currentNode = range.commonAncestorContainer.children[range.startOffset];
              if (!util2.isFormatElement(currentNode) && !util2.isComponent(currentNode)) {
                const format = util2.createElement(options.defaultTag);
                const br = util2.createElement("BR");
                format.appendChild(br);
                context.element.wysiwyg.insertBefore(format, currentNode);
                this.setRange(br, 0, br, 0);
                return;
              }
            }
            this.setRange(range.startContainer, range.startOffset, range.endContainer, range.endOffset);
          } catch (e) {
            this.nativeFocus();
          }
        }
        event._applyTagEffects();
        if (this._isBalloon) event._toggleToolbarBalloon();
      },
      /**
       * @description If "focusEl" is a component, then that component is selected; if it is a format element, the last text is selected
       * If "focusEdge" is null, then selected last element
       * @param {Element|null} focusEl Focus element
       */
      focusEdge: function(focusEl) {
        if (!focusEl) focusEl = context.element.wysiwyg.lastElementChild;
        const fileComponentInfo = this.getFileComponent(focusEl);
        if (fileComponentInfo) {
          this.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName);
        } else if (focusEl) {
          focusEl = util2.getChildElement(focusEl, function(current) {
            return current.childNodes.length === 0 || current.nodeType === 3;
          }, true);
          if (!focusEl) this.nativeFocus();
          else this.setRange(focusEl, focusEl.textContent.length, focusEl, focusEl.textContent.length);
        } else {
          this.focus();
        }
      },
      /**
       * @description Focusout to wysiwyg area (.blur())
       */
      blur: function() {
        if (options.iframe) {
          context.element.wysiwygFrame.blur();
        } else {
          context.element.wysiwyg.blur();
        }
      },
      /**
       * @description Set current editor's range object and return.
       * @param {Node} startCon The startContainer property of the selection object.
       * @param {Number} startOff The startOffset property of the selection object.
       * @param {Node} endCon The endContainer property of the selection object.
       * @param {Number} endOff The endOffset property of the selection object.
       * @returns {Object} Range object.
       */
      setRange: function(startCon, startOff, endCon, endOff) {
        if (!startCon || !endCon) return;
        if (startOff > startCon.textContent.length) startOff = startCon.textContent.length;
        if (endOff > endCon.textContent.length) endOff = endCon.textContent.length;
        if (util2.isFormatElement(startCon)) {
          startCon = startCon.childNodes[startOff] || startCon.childNodes[startOff - 1] || startCon;
          startOff = startOff > 0 ? startCon.nodeType === 1 ? 1 : startCon.textContent ? startCon.textContent.length : 0 : 0;
        }
        if (util2.isFormatElement(endCon)) {
          endCon = endCon.childNodes[endOff] || endCon.childNodes[endOff - 1] || endCon;
          endOff = endOff > 0 ? endCon.nodeType === 1 ? 1 : endCon.textContent ? endCon.textContent.length : 0 : 0;
        }
        const range = this._wd.createRange();
        try {
          range.setStart(startCon, startOff);
          range.setEnd(endCon, endOff);
        } catch (error) {
          console.warn("[SUNEDITOR.core.focus.error] " + error);
          this.nativeFocus();
          return;
        }
        const selection = this.getSelection();
        if (selection.removeAllRanges) {
          selection.removeAllRanges();
        }
        selection.addRange(range);
        this._rangeInfo(range, this.getSelection());
        if (options.iframe) this.__focus();
        return range;
      },
      /**
       * @description Remove range object and button effect
       */
      removeRange: function() {
        this._variable._range = null;
        this._variable._selectionNode = null;
        if (this.hasFocus) this.getSelection().removeAllRanges();
        this._setKeyEffect([]);
      },
      /**
       * @description Get current editor's range object
       * @returns {Object}
       */
      getRange: function() {
        const range = this._variable._range || this._createDefaultRange();
        const selection = this.getSelection();
        if (range.collapsed === selection.isCollapsed || !context.element.wysiwyg.contains(selection.focusNode)) return range;
        if (selection.rangeCount > 0) {
          this._variable._range = selection.getRangeAt(0);
          return this._variable._range;
        } else {
          const sc = selection.anchorNode, ec = selection.focusNode, so = selection.anchorOffset, eo = selection.focusOffset;
          const compareValue = util2.compareElements(sc, ec);
          const rightDir = compareValue.ancestor && (compareValue.result === 0 ? so <= eo : compareValue.result > 1 ? true : false);
          return this.setRange(
            rightDir ? sc : ec,
            rightDir ? so : eo,
            rightDir ? ec : sc,
            rightDir ? eo : so
          );
        }
      },
      /**
       * @description If the "range" object is a non-editable area, add a line at the top of the editor and update the "range" object.
       * Returns a new "range" or argument "range".
       * @param {Object} range core.getRange()
       * @param {Element|null} container If there is "container" argument, it creates a line in front of the container.
       * @returns {Object} range
       */
      getRange_addLine: function(range, container) {
        if (this._selectionVoid(range)) {
          const wysiwyg = context.element.wysiwyg;
          const op = util2.createElement(options.defaultTag);
          op.innerHTML = "<br>";
          wysiwyg.insertBefore(op, container && container !== wysiwyg ? container.nextElementSibling : wysiwyg.firstElementChild);
          this.setRange(op.firstElementChild, 0, op.firstElementChild, 1);
          range = this._variable._range;
        }
        return range;
      },
      /**
       * @description Get window selection obejct
       * @returns {Object}
       */
      getSelection: function() {
        const selection = this._shadowRoot && this._shadowRoot.getSelection ? this._shadowRoot.getSelection() : this._ww.getSelection();
        if (!this._variable._range && !context.element.wysiwyg.contains(selection.focusNode)) {
          selection.removeAllRanges();
          selection.addRange(this._createDefaultRange());
        }
        return selection;
      },
      /**
       * @description Get current select node
       * @returns {Node}
       */
      getSelectionNode: function() {
        if (!context.element.wysiwyg.contains(this._variable._selectionNode)) this._editorRange();
        if (!this._variable._selectionNode) {
          const selectionNode = util2.getChildElement(context.element.wysiwyg.firstChild, function(current) {
            return current.childNodes.length === 0 || current.nodeType === 3;
          }, false);
          if (!selectionNode) {
            this._editorRange();
          } else {
            this._variable._selectionNode = selectionNode;
            return selectionNode;
          }
        }
        return this._variable._selectionNode;
      },
      /**
       * @description Saving the range object and the currently selected node of editor
       * @private
       */
      _editorRange: function() {
        const activeEl = this._wd.activeElement;
        if (util2.isInputElement(activeEl)) {
          this._variable._selectionNode = activeEl;
          return activeEl;
        }
        const selection = this.getSelection();
        if (!selection) return null;
        let range = null;
        if (selection.rangeCount > 0) {
          range = selection.getRangeAt(0);
        } else {
          range = this._createDefaultRange();
        }
        this._rangeInfo(range, selection);
      },
      /**
       * @description Set "range" and "selection" info.
       * @param {Object} range range object.
       * @param {Object} selection selection object.
       */
      _rangeInfo: function(range, selection) {
        let selectionNode = null;
        this._variable._range = range;
        if (range.collapsed) {
          if (util2.isWysiwygDiv(range.commonAncestorContainer)) selectionNode = range.commonAncestorContainer.children[range.startOffset] || range.commonAncestorContainer;
          else selectionNode = range.commonAncestorContainer;
        } else {
          selectionNode = selection.extentNode || selection.anchorNode;
        }
        this._variable._selectionNode = selectionNode;
      },
      /**
       * @description Return the range object of editor's first child node
       * @returns {Object}
       * @private
       */
      _createDefaultRange: function() {
        const wysiwyg = context.element.wysiwyg;
        const range = this._wd.createRange();
        let firstFormat = wysiwyg.firstElementChild;
        let focusEl = null;
        if (!firstFormat) {
          firstFormat = util2.createElement(options.defaultTag);
          focusEl = util2.createElement("BR");
          firstFormat.appendChild(focusEl);
          wysiwyg.appendChild(firstFormat);
        } else {
          focusEl = firstFormat.firstChild;
          if (!focusEl) {
            focusEl = util2.createElement("BR");
            firstFormat.appendChild(focusEl);
          }
        }
        range.setStart(focusEl, 0);
        range.setEnd(focusEl, 0);
        return range;
      },
      /**
       * @description Returns true if there is no valid "selection".
       * @param {Object} range core.getRange()
       * @returns {Object} range
       * @private
       */
      _selectionVoid: function(range) {
        const comm = range.commonAncestorContainer;
        return util2.isWysiwygDiv(range.startContainer) && util2.isWysiwygDiv(range.endContainer) || /FIGURE/i.test(comm.nodeName) || this._fileManager.regExp.test(comm.nodeName) || util2.isMediaComponent(comm);
      },
      /**
       * @description Reset range object to text node selected status.
       * @returns {Boolean} Returns false if there is no valid selection.
       * @private
       */
      _resetRangeToTextNode: function() {
        const range = this.getRange();
        if (this._selectionVoid(range)) return false;
        let startCon = range.startContainer;
        let startOff = range.startOffset;
        let endCon = range.endContainer;
        let endOff = range.endOffset;
        let tempCon, tempOffset, tempChild;
        if (util2.isFormatElement(startCon)) {
          if (!startCon.childNodes[startOff]) {
            startCon = startCon.lastChild || startCon;
            startOff = startCon.textContent.length;
          } else {
            startCon = startCon.childNodes[startOff] || startCon;
            startOff = 0;
          }
          while (startCon && startCon.nodeType === 1 && startCon.firstChild) {
            startCon = startCon.firstChild || startCon;
            startOff = 0;
          }
        }
        if (util2.isFormatElement(endCon)) {
          endCon = endCon.childNodes[endOff] || endCon.lastChild || endCon;
          while (endCon && endCon.nodeType === 1 && endCon.lastChild) {
            endCon = endCon.lastChild;
          }
          endOff = endCon.textContent.length;
        }
        tempCon = util2.isWysiwygDiv(startCon) ? context.element.wysiwyg.firstChild : startCon;
        tempOffset = startOff;
        if (util2.isBreak(tempCon) || tempCon.nodeType === 1 && tempCon.childNodes.length > 0) {
          const onlyBreak = util2.isBreak(tempCon);
          if (!onlyBreak) {
            while (tempCon && !util2.isBreak(tempCon) && tempCon.nodeType === 1) {
              tempCon = tempCon.childNodes[tempOffset] || tempCon.nextElementSibling || tempCon.nextSibling;
              tempOffset = 0;
            }
            let format = util2.getFormatElement(tempCon, null);
            if (format === util2.getRangeFormatElement(format, null)) {
              format = util2.createElement(util2.getParentElement(tempCon, util2.isCell) ? "DIV" : options.defaultTag);
              tempCon.parentNode.insertBefore(format, tempCon);
              format.appendChild(tempCon);
            }
          }
          if (util2.isBreak(tempCon)) {
            const emptyText = util2.createTextNode(util2.zeroWidthSpace);
            tempCon.parentNode.insertBefore(emptyText, tempCon);
            tempCon = emptyText;
            if (onlyBreak) {
              if (startCon === endCon) {
                endCon = tempCon;
                endOff = 1;
              }
            }
          }
        }
        startCon = tempCon;
        startOff = tempOffset;
        tempCon = util2.isWysiwygDiv(endCon) ? context.element.wysiwyg.lastChild : endCon;
        tempOffset = endOff;
        if (util2.isBreak(tempCon) || tempCon.nodeType === 1 && tempCon.childNodes.length > 0) {
          const onlyBreak = util2.isBreak(tempCon);
          if (!onlyBreak) {
            while (tempCon && !util2.isBreak(tempCon) && tempCon.nodeType === 1) {
              tempChild = tempCon.childNodes;
              if (tempChild.length === 0) break;
              tempCon = tempChild[tempOffset > 0 ? tempOffset - 1 : tempOffset] || !/FIGURE/i.test(tempChild[0].nodeName) ? tempChild[0] : tempCon.previousElementSibling || tempCon.previousSibling || startCon;
              tempOffset = tempOffset > 0 ? tempCon.textContent.length : tempOffset;
            }
            let format = util2.getFormatElement(tempCon, null);
            if (format === util2.getRangeFormatElement(format, null)) {
              format = util2.createElement(util2.isCell(format) ? "DIV" : options.defaultTag);
              tempCon.parentNode.insertBefore(format, tempCon);
              format.appendChild(tempCon);
            }
          }
          if (util2.isBreak(tempCon)) {
            const emptyText = util2.createTextNode(util2.zeroWidthSpace);
            tempCon.parentNode.insertBefore(emptyText, tempCon);
            tempCon = emptyText;
            tempOffset = 1;
            if (onlyBreak && !tempCon.previousSibling) {
              util2.removeItem(endCon);
            }
          }
        }
        endCon = tempCon;
        endOff = tempOffset;
        this.setRange(startCon, startOff, endCon, endOff);
        return true;
      },
      /**
       * @description Returns a "formatElement"(util.isFormatElement) array from the currently selected range.
       * @param {Function|null} validation The validation function. (Replaces the default validation function-util.isFormatElement(current))
       * @returns {Array}
       */
      getSelectedElements: function(validation) {
        if (!this._resetRangeToTextNode()) return [];
        let range = this.getRange();
        if (util2.isWysiwygDiv(range.startContainer)) {
          const children4 = context.element.wysiwyg.children;
          if (children4.length === 0) return [];
          this.setRange(children4[0], 0, children4[children4.length - 1], children4[children4.length - 1].textContent.trim().length);
          range = this.getRange();
        }
        const startCon = range.startContainer;
        const endCon = range.endContainer;
        const commonCon = range.commonAncestorContainer;
        const lineNodes = util2.getListChildren(commonCon, function(current) {
          return validation ? validation(current) : util2.isFormatElement(current);
        });
        if (!util2.isWysiwygDiv(commonCon) && !util2.isRangeFormatElement(commonCon)) lineNodes.unshift(util2.getFormatElement(commonCon, null));
        if (startCon === endCon || lineNodes.length === 1) return lineNodes;
        let startLine = util2.getFormatElement(startCon, null);
        let endLine = util2.getFormatElement(endCon, null);
        let startIdx = null;
        let endIdx = null;
        const onlyTable = function(current) {
          return util2.isTable(current) ? /^TABLE$/i.test(current.nodeName) : true;
        };
        let startRangeEl = util2.getRangeFormatElement(startLine, onlyTable);
        let endRangeEl = util2.getRangeFormatElement(endLine, onlyTable);
        if (util2.isTable(startRangeEl) && util2.isListCell(startRangeEl.parentNode)) startRangeEl = startRangeEl.parentNode;
        if (util2.isTable(endRangeEl) && util2.isListCell(endRangeEl.parentNode)) endRangeEl = endRangeEl.parentNode;
        const sameRange = startRangeEl === endRangeEl;
        for (let i = 0, len = lineNodes.length, line; i < len; i++) {
          line = lineNodes[i];
          if (startLine === line || !sameRange && line === startRangeEl) {
            startIdx = i;
            continue;
          }
          if (endLine === line || !sameRange && line === endRangeEl) {
            endIdx = i;
            break;
          }
        }
        if (startIdx === null) startIdx = 0;
        if (endIdx === null) endIdx = lineNodes.length - 1;
        return lineNodes.slice(startIdx, endIdx + 1);
      },
      /**
       * @description Get format elements and components from the selected area. (P, DIV, H[1-6], OL, UL, TABLE..)
       * If some of the component are included in the selection, get the entire that component.
       * @param {Boolean} removeDuplicate If true, if there is a parent and child tag among the selected elements, the child tag is excluded.
       * @returns {Array}
       */
      getSelectedElementsAndComponents: function(removeDuplicate) {
        const commonCon = this.getRange().commonAncestorContainer;
        const myComponent = util2.getParentElement(commonCon, util2.isComponent);
        const selectedLines = util2.isTable(commonCon) ? this.getSelectedElements(null) : this.getSelectedElements(function(current) {
          const component4 = this.getParentElement(current, this.isComponent);
          return this.isFormatElement(current) && (!component4 || component4 === myComponent) || this.isComponent(current) && !this.getFormatElement(current);
        }.bind(util2));
        if (removeDuplicate) {
          for (let i = 0, len = selectedLines.length; i < len; i++) {
            for (let j = i - 1; j >= 0; j--) {
              if (selectedLines[j].contains(selectedLines[i])) {
                selectedLines.splice(i, 1);
                i--;
                len--;
                break;
              }
            }
          }
        }
        return selectedLines;
      },
      /**
       * @description Determine if this offset is the edge offset of container
       * @param {Node} container The node of the selection object. (range.startContainer..)
       * @param {Number} offset The offset of the selection object. (core.getRange().startOffset...)
       * @param {String|undefined} dir Select check point - Both edge, Front edge or End edge. ("front": Front edge, "end": End edge, undefined: Both edge)
       * @returns {Boolean}
       */
      isEdgePoint: function(container, offset, dir) {
        return dir !== "end" && offset === 0 || (!dir || dir !== "front") && !container.nodeValue && offset === 1 || (!dir || dir === "end") && !!container.nodeValue && offset === container.nodeValue.length;
      },
      /**
       * @description Check if the container and offset values are the edges of the format tag
       * @param {Node} container The node of the selection object. (range.startContainer..)
       * @param {Number} offset The offset of the selection object. (core.getRange().startOffset...)
       * @param {String} dir Select check point - "front": Front edge, "end": End edge, undefined: Both edge.
       * @returns {Array|null}
       * @private
       */
      _isEdgeFormat: function(node, offset, dir) {
        if (!this.isEdgePoint(node, offset, dir)) return false;
        const result = [];
        dir = dir === "front" ? "previousSibling" : "nextSibling";
        while (node && !util2.isFormatElement(node) && !util2.isWysiwygDiv(node)) {
          if (!node[dir] || util2.isBreak(node[dir]) && !node[dir][dir]) {
            if (node.nodeType === 1) result.push(node.cloneNode(false));
            node = node.parentNode;
          } else {
            return null;
          }
        }
        return result;
      },
      /**
       * @description Show loading box
       */
      showLoading: function() {
        context.element.loading.style.display = "block";
      },
      /**
       * @description Close loading box
       */
      closeLoading: function() {
        context.element.loading.style.display = "none";
      },
      /**
       * @description Append format element to sibling node of argument element.
       * If the "formatNodeName" argument value is present, the tag of that argument value is inserted,
       * If not, the currently selected format tag is inserted.
       * @param {Element} element Insert as siblings of that element
       * @param {String|Element|null} formatNode Node name or node obejct to be inserted
       * @returns {Element}
       */
      appendFormatTag: function(element, formatNode) {
        if (!element || !element.parentNode) return null;
        const currentFormatEl = util2.getFormatElement(this.getSelectionNode(), null);
        let oFormat = null;
        if (!util2.isFormatElement(element) && util2.isFreeFormatElement(currentFormatEl || element.parentNode)) {
          oFormat = util2.createElement("BR");
        } else {
          const oFormatName = formatNode ? typeof formatNode === "string" ? formatNode : formatNode.nodeName : util2.isFormatElement(currentFormatEl) && !util2.isRangeFormatElement(currentFormatEl) && !util2.isFreeFormatElement(currentFormatEl) ? currentFormatEl.nodeName : options.defaultTag;
          oFormat = util2.createElement(oFormatName);
          oFormat.innerHTML = "<br>";
          if (formatNode && typeof formatNode !== "string" || !formatNode && util2.isFormatElement(currentFormatEl)) {
            util2.copyTagAttributes(oFormat, formatNode || currentFormatEl, ["id"]);
          }
        }
        if (util2.isCell(element)) element.insertBefore(oFormat, element.nextElementSibling);
        else element.parentNode.insertBefore(oFormat, element.nextElementSibling);
        return oFormat;
      },
      /**
       * @description The method to insert a element and return. (used elements : table, hr, image, video)
       * If "element" is "HR", insert and return the new line.
       * @param {Element} element Element to be inserted
       * @param {Boolean} notHistoryPush When true, it does not update the history stack and the selection object and return EdgeNodes (util.getEdgeChildNodes)
       * @param {Boolean} checkCharCount If true, if "options.maxCharCount" is exceeded when "element" is added, null is returned without addition.
       * @param {Boolean} notSelect If true, Do not automatically select the inserted component.
       * @returns {Element}
       */
      insertComponent: function(element, notHistoryPush, checkCharCount, notSelect) {
        if (this.isReadOnly || checkCharCount && !this.checkCharCount(element, null)) {
          return null;
        }
        const r = this.removeNode();
        this.getRange_addLine(this.getRange(), r.container);
        let oNode = null;
        let selectionNode = this.getSelectionNode();
        let formatEl = util2.getFormatElement(selectionNode, null);
        if (util2.isListCell(formatEl)) {
          this.insertNode(element, selectionNode === formatEl ? null : r.container.nextSibling, false);
          if (!element.nextSibling) element.parentNode.appendChild(util2.createElement("BR"));
        } else {
          if (this.getRange().collapsed && (r.container.nodeType === 3 || util2.isBreak(r.container))) {
            const depthFormat = util2.getParentElement(r.container, function(current) {
              return this.isRangeFormatElement(current);
            }.bind(util2));
            oNode = util2.splitElement(r.container, r.offset, !depthFormat ? 0 : util2.getElementDepth(depthFormat) + 1);
            if (oNode) formatEl = oNode.previousSibling;
          }
          this.insertNode(element, util2.isRangeFormatElement(formatEl) ? null : formatEl, false);
          if (formatEl && util2.onlyZeroWidthSpace(formatEl)) util2.removeItem(formatEl);
        }
        if (!notSelect) {
          this.setRange(element, 0, element, 0);
          const fileComponentInfo = this.getFileComponent(element);
          if (fileComponentInfo) {
            this.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName);
          } else if (oNode) {
            oNode = util2.getEdgeChildNodes(oNode, null).sc || oNode;
            this.setRange(oNode, 0, oNode, 0);
          }
        }
        if (!notHistoryPush) this.history.push(1);
        return oNode || element;
      },
      /**
       * @description Gets the file component and that plugin name
       * return: {target, component, pluginName} | null
       * @param {Element} element Target element (figure tag, component div, file tag)
       * @returns {Object|null}
       */
      getFileComponent: function(element) {
        if (!this._fileManager.queryString || !element) return null;
        let target, pluginName;
        if (/^FIGURE$/i.test(element.nodeName) || /se-component/.test(element.className)) {
          target = element.querySelector(this._fileManager.queryString);
        }
        if (!target && element.nodeName && this._fileManager.regExp.test(element.nodeName)) {
          target = element;
        }
        if (target) {
          pluginName = this._fileManager.pluginMap[target.nodeName.toLowerCase()];
          if (pluginName) {
            return {
              target,
              component: util2.getParentElement(target, util2.isComponent),
              pluginName
            };
          }
        }
        return null;
      },
      /**
       * @description The component(image, video) is selected and the resizing module is called.
       * @param {Element} element Element tag (img, iframe, video)
       * @param {String} pluginName Plugin name (image, video)
       */
      selectComponent: function(element, pluginName) {
        if (util2.isUneditableComponent(util2.getParentElement(element, util2.isComponent)) || util2.isUneditableComponent(element)) return false;
        if (!this.hasFocus) this.focus();
        const plugin = this.plugins[pluginName];
        if (!plugin) return;
        _w.setTimeout(function() {
          if (typeof plugin.select === "function") this.callPlugin(pluginName, plugin.select.bind(this, element), null);
          this._setComponentLineBreaker(element);
        }.bind(this));
      },
      /**
       * @description Set line breaker of component
       * @param {Element} element Element tag (img, iframe, video)
       * @private
       */
      _setComponentLineBreaker: function(element) {
        this._lineBreaker.style.display = "none";
        const container = util2.getParentElement(element, util2.isComponent);
        const t_style = context.element.lineBreaker_t.style;
        const b_style = context.element.lineBreaker_b.style;
        const target = this.context.resizing.resizeContainer.style.display === "block" ? this.context.resizing.resizeContainer : element;
        const isList = util2.isListCell(container.parentNode);
        let componentTop, wScroll, w;
        if (isList ? !container.previousSibling : !util2.isFormatElement(container.previousElementSibling)) {
          this._variable._lineBreakComp = container;
          wScroll = context.element.wysiwyg.scrollTop;
          componentTop = util2.getOffset(element, context.element.wysiwygFrame).top + wScroll;
          w = target.offsetWidth / 2 / 2;
          t_style.top = componentTop - wScroll - 12 + "px";
          t_style.left = util2.getOffset(target).left + w + "px";
          t_style.display = "block";
        } else {
          t_style.display = "none";
        }
        if (isList ? !container.nextSibling : !util2.isFormatElement(container.nextElementSibling)) {
          if (!componentTop) {
            this._variable._lineBreakComp = container;
            wScroll = context.element.wysiwyg.scrollTop;
            componentTop = util2.getOffset(element, context.element.wysiwygFrame).top + wScroll;
            w = target.offsetWidth / 2 / 2;
          }
          b_style.top = componentTop + target.offsetHeight - wScroll - 12 + "px";
          b_style.left = util2.getOffset(target).left + target.offsetWidth - w - 24 + "px";
          b_style.display = "block";
        } else {
          b_style.display = "none";
        }
      },
      _checkDuplicateNode: function(oNode, parentNode) {
        (function recursionFunc(current) {
          core._dupleCheck(current, parentNode);
          const childNodes = current.childNodes;
          for (let i = 0, len = childNodes.length; i < len; i++) {
            recursionFunc(childNodes[i]);
          }
        })(oNode);
      },
      _dupleCheck: function(oNode, parentNode) {
        if (!util2.isTextStyleElement(oNode)) return;
        const oStyles = (oNode.style.cssText.match(/[^;]+;/g) || []).map(function(v) {
          return v.trim();
        });
        const nodeName = oNode.nodeName;
        if (/^span$/i.test(nodeName) && oStyles.length === 0) return oNode;
        let duple = false;
        (function recursionFunc(ancestor) {
          if (util2.isWysiwygDiv(ancestor) || !util2.isTextStyleElement(ancestor)) return;
          if (ancestor.nodeName === nodeName) {
            duple = true;
            const styles = ancestor.style.cssText.match(/[^;]+;/g) || [];
            for (let i = 0, len = styles.length, j; i < len; i++) {
              if ((j = oStyles.indexOf(styles[i].trim())) > -1) {
                oStyles.splice(j, 1);
              }
            }
            for (let i = 0, len = ancestor.classList.length; i < len; i++) {
              oNode.classList.remove(ancestor.classList[i]);
            }
          }
          recursionFunc(ancestor.parentElement);
        })(parentNode);
        if (duple) {
          if (!(oNode.style.cssText = oStyles.join(" "))) {
            oNode.setAttribute("style", "");
            oNode.removeAttribute("style");
          }
          if (!oNode.attributes.length) {
            oNode.setAttribute("data-se-duple", "true");
          }
        }
        return oNode;
      },
      /**
       * @description Delete selected node and insert argument value node and return.
       * If the "afterNode" exists, it is inserted after the "afterNode"
       * Inserting a text node merges with both text nodes on both sides and returns a new "{ container, startOffset, endOffset }".
       * @param {Node} oNode Element to be inserted
       * @param {Node|null} afterNode If the node exists, it is inserted after the node
       * @param {Boolean} checkCharCount If true, if "options.maxCharCount" is exceeded when "element" is added, null is returned without addition.
       * @returns {Object|Node|null}
       */
      insertNode: function(oNode, afterNode, checkCharCount) {
        if (this.isReadOnly || checkCharCount && !this.checkCharCount(oNode, null)) {
          return null;
        }
        let fNode = null;
        let range = this.getRange();
        let line = util2.isListCell(range.commonAncestorContainer) ? range.commonAncestorContainer : util2.getFormatElement(this.getSelectionNode(), null);
        let insertListCell = util2.isListCell(line) && (util2.isListCell(oNode) || util2.isList(oNode));
        let parentNode, originAfter, tempAfterNode, tempParentNode = null;
        const freeFormat = util2.isFreeFormatElement(line);
        const isFormats = !freeFormat && (util2.isFormatElement(oNode) || util2.isRangeFormatElement(oNode)) || util2.isComponent(oNode);
        if (insertListCell) {
          tempAfterNode = afterNode || util2.isList(oNode) ? line.lastChild : line.nextElementSibling;
          tempParentNode = util2.isList(oNode) ? line : (tempAfterNode || line).parentNode;
        }
        if (!afterNode && (isFormats || util2.isComponent(oNode) || util2.isMedia(oNode))) {
          const isEdge = this.isEdgePoint(range.endContainer, range.endOffset, "end");
          const r = this.removeNode();
          const container = r.container;
          const prevContainer = container === r.prevContainer && range.collapsed ? null : r.prevContainer;
          if (insertListCell && prevContainer) {
            tempParentNode = prevContainer.nodeType === 3 ? prevContainer.parentNode : prevContainer;
            if (tempParentNode.contains(container)) {
              let sameParent = true;
              tempAfterNode = container;
              while (tempAfterNode.parentNode && tempAfterNode.parentNode !== tempParentNode) {
                tempAfterNode = tempAfterNode.parentNode;
                sameParent = false;
              }
              if (sameParent && container === prevContainer) tempAfterNode = tempAfterNode.nextSibling;
            } else {
              tempAfterNode = null;
            }
          } else if (insertListCell && util2.isListCell(container) && !line.parentElement) {
            line = util2.createElement("LI");
            tempParentNode.appendChild(line);
            container.appendChild(tempParentNode);
            tempAfterNode = null;
          } else if (container.nodeType === 3 || util2.isBreak(container) || insertListCell) {
            const depthFormat = util2.getParentElement(container, function(current) {
              return this.isRangeFormatElement(current) || this.isListCell(current);
            }.bind(util2));
            afterNode = util2.splitElement(container, r.offset, !depthFormat ? 0 : util2.getElementDepth(depthFormat) + 1);
            if (!afterNode) {
              tempAfterNode = afterNode = line;
            } else if (insertListCell) {
              if (line.contains(container)) {
                const subList = util2.isList(line.lastElementChild);
                let newCell = null;
                if (!isEdge) {
                  newCell = line.cloneNode(false);
                  newCell.appendChild(afterNode.textContent.trim() ? afterNode : util2.createTextNode(util2.zeroWidthSpace));
                }
                if (subList) {
                  if (!newCell) {
                    newCell = line.cloneNode(false);
                    newCell.appendChild(util2.createTextNode(util2.zeroWidthSpace));
                  }
                  newCell.appendChild(line.lastElementChild);
                }
                if (newCell) {
                  line.parentNode.insertBefore(newCell, line.nextElementSibling);
                  tempAfterNode = afterNode = newCell;
                }
              }
            } else {
              afterNode = afterNode.previousSibling;
            }
          }
        }
        range = !afterNode && !isFormats ? this.getRange_addLine(this.getRange(), null) : this.getRange();
        const commonCon = range.commonAncestorContainer;
        const startOff = range.startOffset;
        const endOff = range.endOffset;
        const formatRange = range.startContainer === commonCon && util2.isFormatElement(commonCon);
        const startCon = formatRange ? commonCon.childNodes[startOff] || commonCon.childNodes[0] || range.startContainer : range.startContainer;
        const endCon = formatRange ? commonCon.childNodes[endOff] || commonCon.childNodes[commonCon.childNodes.length - 1] || range.endContainer : range.endContainer;
        if (!insertListCell) {
          if (!afterNode) {
            parentNode = startCon;
            if (startCon.nodeType === 3) {
              parentNode = startCon.parentNode;
            }
            if (range.collapsed) {
              if (commonCon.nodeType === 3) {
                if (commonCon.textContent.length > endOff) afterNode = commonCon.splitText(endOff);
                else afterNode = commonCon.nextSibling;
              } else {
                if (!util2.isBreak(parentNode)) {
                  let c = parentNode.childNodes[startOff];
                  const focusNode = c && c.nodeType === 3 && util2.onlyZeroWidthSpace(c) && util2.isBreak(c.nextSibling) ? c.nextSibling : c;
                  if (focusNode) {
                    if (!focusNode.nextSibling && util2.isBreak(focusNode)) {
                      parentNode.removeChild(focusNode);
                      afterNode = null;
                    } else {
                      afterNode = util2.isBreak(focusNode) && !util2.isBreak(oNode) ? focusNode : focusNode.nextSibling;
                    }
                  } else {
                    afterNode = null;
                  }
                } else {
                  afterNode = parentNode;
                  parentNode = parentNode.parentNode;
                }
              }
            } else {
              const isSameContainer = startCon === endCon;
              if (isSameContainer) {
                if (this.isEdgePoint(endCon, endOff)) afterNode = endCon.nextSibling;
                else afterNode = endCon.splitText(endOff);
                let removeNode = startCon;
                if (!this.isEdgePoint(startCon, startOff)) removeNode = startCon.splitText(startOff);
                parentNode.removeChild(removeNode);
                if (parentNode.childNodes.length === 0 && isFormats) {
                  parentNode.innerHTML = "<br>";
                }
              } else {
                const removedTag = this.removeNode();
                const container = removedTag.container;
                const prevContainer = removedTag.prevContainer;
                if (container && container.childNodes.length === 0 && isFormats) {
                  if (util2.isFormatElement(container)) {
                    container.innerHTML = "<br>";
                  } else if (util2.isRangeFormatElement(container)) {
                    container.innerHTML = "<" + options.defaultTag + "><br></" + options.defaultTag + ">";
                  }
                }
                if (util2.isListCell(container) && oNode.nodeType === 3) {
                  parentNode = container;
                  afterNode = null;
                } else if (!isFormats && prevContainer) {
                  parentNode = prevContainer.nodeType === 3 ? prevContainer.parentNode : prevContainer;
                  if (parentNode.contains(container)) {
                    let sameParent = true;
                    afterNode = container;
                    while (afterNode.parentNode && afterNode.parentNode !== parentNode) {
                      afterNode = afterNode.parentNode;
                      sameParent = false;
                    }
                    if (sameParent && container === prevContainer) afterNode = afterNode.nextSibling;
                  } else {
                    afterNode = null;
                  }
                } else if (util2.isWysiwygDiv(container) && !util2.isFormatElement(oNode)) {
                  parentNode = container.appendChild(util2.createElement(options.defaultTag));
                  afterNode = null;
                } else {
                  afterNode = isFormats ? endCon : container === prevContainer ? container.nextSibling : container;
                  parentNode = !afterNode || !afterNode.parentNode ? commonCon : afterNode.parentNode;
                }
                while (afterNode && !util2.isFormatElement(afterNode) && afterNode.parentNode !== commonCon) {
                  afterNode = afterNode.parentNode;
                }
              }
            }
          } else {
            parentNode = afterNode.parentNode;
            afterNode = afterNode.nextSibling;
            originAfter = true;
          }
        }
        try {
          if (!insertListCell) {
            if (util2.isWysiwygDiv(afterNode) || parentNode === context.element.wysiwyg.parentNode) {
              parentNode = context.element.wysiwyg;
              afterNode = null;
            }
            if (util2.isFormatElement(oNode) || util2.isRangeFormatElement(oNode) || !util2.isListCell(parentNode) && util2.isComponent(oNode)) {
              const oldParent = parentNode;
              if (util2.isList(afterNode)) {
                parentNode = afterNode;
                afterNode = null;
              } else if (util2.isListCell(afterNode)) {
                parentNode = afterNode.previousElementSibling || afterNode;
              } else if (!originAfter && !afterNode) {
                const r = this.removeNode();
                const container = r.container.nodeType === 3 ? util2.isListCell(util2.getFormatElement(r.container, null)) ? r.container : util2.getFormatElement(r.container, null) || r.container.parentNode : r.container;
                const rangeCon = util2.isWysiwygDiv(container) || util2.isRangeFormatElement(container);
                parentNode = rangeCon ? container : container.parentNode;
                afterNode = rangeCon ? null : container.nextSibling;
              }
              if (oldParent.childNodes.length === 0 && parentNode !== oldParent) util2.removeItem(oldParent);
            }
            if (isFormats && !freeFormat && !util2.isRangeFormatElement(parentNode) && !util2.isListCell(parentNode) && !util2.isWysiwygDiv(parentNode)) {
              afterNode = parentNode.nextElementSibling;
              parentNode = parentNode.parentNode;
            }
            if (util2.isWysiwygDiv(parentNode) && (oNode.nodeType === 3 || util2.isBreak(oNode))) {
              const fomatNode = util2.createElement(options.defaultTag);
              fomatNode.appendChild(oNode);
              fNode = oNode;
              oNode = fomatNode;
            }
          }
          if (insertListCell) {
            if (!tempParentNode.parentNode) {
              parentNode = context.element.wysiwyg;
              afterNode = null;
            } else {
              parentNode = tempParentNode;
              afterNode = tempAfterNode;
            }
          } else {
            afterNode = parentNode === afterNode ? parentNode.lastChild : afterNode;
          }
          if (util2.isListCell(oNode) && !util2.isList(parentNode)) {
            if (util2.isListCell(parentNode)) {
              afterNode = parentNode.nextElementSibling;
              parentNode = parentNode.parentNode;
            } else {
              const ul = util2.createElement("ol");
              parentNode.insertBefore(ul, afterNode);
              parentNode = ul;
              afterNode = null;
            }
            insertListCell = true;
          }
          this._checkDuplicateNode(oNode, parentNode);
          parentNode.insertBefore(oNode, afterNode);
          if (insertListCell) {
            if (util2.onlyZeroWidthSpace(line.textContent.trim())) {
              util2.removeItem(line);
              oNode = oNode.lastChild;
            } else {
              const chList = util2.getArrayItem(line.children, util2.isList);
              if (chList) {
                if (oNode !== chList) {
                  oNode.appendChild(chList);
                  oNode = chList.previousSibling;
                } else {
                  parentNode.appendChild(oNode);
                  oNode = parentNode;
                }
                if (util2.onlyZeroWidthSpace(line.textContent.trim())) {
                  util2.removeItem(line);
                }
              }
            }
          }
        } catch (error) {
          parentNode.appendChild(oNode);
          console.warn("[SUNEDITOR.insertNode.warn] " + error);
        } finally {
          if (fNode) oNode = fNode;
          const dupleNodes = parentNode.querySelectorAll("[data-se-duple]");
          if (dupleNodes.length > 0) {
            for (let i = 0, len = dupleNodes.length, d, c, ch, parent; i < len; i++) {
              d = dupleNodes[i];
              ch = d.childNodes;
              parent = d.parentNode;
              while (ch[0]) {
                c = ch[0];
                parent.insertBefore(c, d);
              }
              if (d === oNode) oNode = c;
              util2.removeItem(d);
            }
          }
          if ((util2.isFormatElement(oNode) || util2.isComponent(oNode)) && startCon === endCon) {
            const cItem = util2.getFormatElement(commonCon, null);
            if (cItem && cItem.nodeType === 1 && util2.isEmptyLine(cItem)) {
              util2.removeItem(cItem);
            }
          }
          if (freeFormat && (util2.isFormatElement(oNode) || util2.isRangeFormatElement(oNode))) {
            oNode = this._setIntoFreeFormat(oNode);
          }
          if (!util2.isComponent(oNode)) {
            let offset = 1;
            if (oNode.nodeType === 3) {
              offset = oNode.textContent.length;
              this.setRange(oNode, offset, oNode, offset);
            } else if (!util2.isBreak(oNode) && !util2.isListCell(oNode) && util2.isFormatElement(parentNode)) {
              let zeroWidth = null;
              if (!oNode.previousSibling || util2.isBreak(oNode.previousSibling)) {
                zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
                oNode.parentNode.insertBefore(zeroWidth, oNode);
              }
              if (!oNode.nextSibling || util2.isBreak(oNode.nextSibling)) {
                zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
                oNode.parentNode.insertBefore(zeroWidth, oNode.nextSibling);
              }
              if (util2._isIgnoreNodeChange(oNode)) {
                oNode = oNode.nextSibling;
                offset = 0;
              }
            }
            this.setRange(oNode, offset, oNode, offset);
          }
          return oNode;
        }
      },
      _setIntoFreeFormat: function(oNode) {
        const parentNode = oNode.parentNode;
        let oNodeChildren, lastONode;
        while (util2.isFormatElement(oNode) || util2.isRangeFormatElement(oNode)) {
          oNodeChildren = oNode.childNodes;
          lastONode = null;
          while (oNodeChildren[0]) {
            lastONode = oNodeChildren[0];
            if (util2.isFormatElement(lastONode) || util2.isRangeFormatElement(lastONode)) {
              this._setIntoFreeFormat(lastONode);
              if (!oNode.parentNode) break;
              oNodeChildren = oNode.childNodes;
              continue;
            }
            parentNode.insertBefore(lastONode, oNode);
          }
          if (oNode.childNodes.length === 0) util2.removeItem(oNode);
          oNode = util2.createElement("BR");
          parentNode.insertBefore(oNode, lastONode.nextSibling);
        }
        return oNode;
      },
      /**
       * @description Delete the currently selected nodes and reset selection range
       * Returns {container: "the last element after deletion", offset: "offset", prevContainer: "previousElementSibling Of the deleted area"}
       * @returns {Object}
       */
      removeNode: function() {
        this._resetRangeToTextNode();
        const range = this.getRange();
        if (range.startContainer === range.endContainer) {
          const fileComponent = util2.getParentElement(range.startContainer, util2.isMediaComponent);
          if (fileComponent) {
            const br = util2.createElement("BR");
            const format = util2.createElement(options.defaultTag);
            format.appendChild(br);
            util2.changeElement(fileComponent, format);
            core.setRange(format, 0, format, 0);
            this.history.push(true);
            return {
              container: format,
              offset: 0,
              prevContainer: null
            };
          }
        }
        const isStartEdge = range.startOffset === 0;
        const isEndEdge = core.isEdgePoint(range.endContainer, range.endOffset, "end");
        let prevContainer = null;
        let startPrevEl = null;
        let endNextEl = null;
        if (isStartEdge) {
          startPrevEl = util2.getFormatElement(range.startContainer);
          if (startPrevEl) {
            prevContainer = startPrevEl.previousElementSibling;
            startPrevEl = prevContainer;
          }
        }
        if (isEndEdge) {
          endNextEl = util2.getFormatElement(range.endContainer);
          endNextEl = endNextEl ? endNextEl.nextElementSibling : endNextEl;
        }
        let container, offset = 0;
        let startCon = range.startContainer;
        let endCon = range.endContainer;
        let startOff = range.startOffset;
        let endOff = range.endOffset;
        const commonCon = range.commonAncestorContainer.nodeType === 3 && range.commonAncestorContainer.parentNode === startCon.parentNode ? startCon.parentNode : range.commonAncestorContainer;
        if (commonCon === startCon && commonCon === endCon) {
          startCon = commonCon.children[startOff];
          endCon = commonCon.children[endOff];
          startOff = endOff = 0;
        }
        if (!startCon || !endCon) return {
          container: commonCon,
          offset: 0
        };
        if (startCon === endCon && range.collapsed) {
          if (startCon.textContent && util2.onlyZeroWidthSpace(startCon.textContent.substr(startOff))) {
            return {
              container: startCon,
              offset: startOff,
              prevContainer: startCon && startCon.parentNode ? startCon : null
            };
          }
        }
        let beforeNode = null;
        let afterNode = null;
        const childNodes = util2.getListChildNodes(commonCon, null);
        let startIndex = util2.getArrayIndex(childNodes, startCon);
        let endIndex = util2.getArrayIndex(childNodes, endCon);
        if (childNodes.length > 0 && startIndex > -1 && endIndex > -1) {
          for (let i = startIndex + 1, startNode = startCon; i >= 0; i--) {
            if (childNodes[i] === startNode.parentNode && childNodes[i].firstChild === startNode && startOff === 0) {
              startIndex = i;
              startNode = startNode.parentNode;
            }
          }
          for (let i = endIndex - 1, endNode = endCon; i > startIndex; i--) {
            if (childNodes[i] === endNode.parentNode && childNodes[i].nodeType === 1) {
              childNodes.splice(i, 1);
              endNode = endNode.parentNode;
              --endIndex;
            }
          }
        } else {
          if (childNodes.length === 0) {
            if (util2.isFormatElement(commonCon) || util2.isRangeFormatElement(commonCon) || util2.isWysiwygDiv(commonCon) || util2.isBreak(commonCon) || util2.isMedia(commonCon)) {
              return {
                container: commonCon,
                offset: 0
              };
            } else if (commonCon.nodeType === 3) {
              return {
                container: commonCon,
                offset: endOff
              };
            }
            childNodes.push(commonCon);
            startCon = endCon = commonCon;
          } else {
            startCon = endCon = childNodes[0];
            if (util2.isBreak(startCon) || util2.onlyZeroWidthSpace(startCon)) {
              return {
                container: util2.isMedia(commonCon) ? commonCon : startCon,
                offset: 0
              };
            }
          }
          startIndex = endIndex = 0;
        }
        for (let i = startIndex; i <= endIndex; i++) {
          const item = childNodes[i];
          if (item.length === 0 || item.nodeType === 3 && item.data === void 0) {
            this._nodeRemoveListItem(item);
            continue;
          }
          if (item === startCon) {
            if (startCon.nodeType === 1) {
              if (util2.isComponent(startCon)) continue;
              else beforeNode = util2.createTextNode(startCon.textContent);
            } else {
              if (item === endCon) {
                beforeNode = util2.createTextNode(startCon.substringData(0, startOff) + endCon.substringData(endOff, endCon.length - endOff));
                offset = startOff;
              } else {
                beforeNode = util2.createTextNode(startCon.substringData(0, startOff));
              }
            }
            if (beforeNode.length > 0) {
              startCon.data = beforeNode.data;
            } else {
              this._nodeRemoveListItem(startCon);
            }
            if (item === endCon) break;
            continue;
          }
          if (item === endCon) {
            if (endCon.nodeType === 1) {
              if (util2.isComponent(endCon)) continue;
              else afterNode = util2.createTextNode(endCon.textContent);
            } else {
              afterNode = util2.createTextNode(endCon.substringData(endOff, endCon.length - endOff));
            }
            if (afterNode.length > 0) {
              endCon.data = afterNode.data;
            } else {
              this._nodeRemoveListItem(endCon);
            }
            continue;
          }
          this._nodeRemoveListItem(item);
        }
        const endUl = util2.getParentElement(endCon, "ul");
        const startLi = util2.getParentElement(startCon, "li");
        if (endUl && startLi && startLi.contains(endUl)) {
          container = endUl.previousSibling;
          offset = container.textContent.length;
        } else {
          container = endCon && endCon.parentNode ? endCon : startCon && startCon.parentNode ? startCon : range.endContainer || range.startContainer;
          offset = !isStartEdge && !isEndEdge ? offset : isEndEdge ? container.textContent.length : 0;
        }
        if (!util2.isWysiwygDiv(container) && container.childNodes.length === 0) {
          const rc = util2.removeItemAllParents(container, null, null);
          if (rc) container = rc.sc || rc.ec || context.element.wysiwyg;
        }
        if (!util2.getFormatElement(container) && !(startCon && startCon.parentNode)) {
          if (endNextEl) {
            container = endNextEl;
            offset = 0;
          } else if (startPrevEl) {
            container = startPrevEl;
            offset = 1;
          }
        }
        this.setRange(container, offset, container, offset);
        this.history.push(true);
        return {
          container,
          offset,
          prevContainer
        };
      },
      _nodeRemoveListItem: function(item) {
        const format = util2.getFormatElement(item, null);
        util2.removeItem(item);
        if (!util2.isListCell(format)) return;
        util2.removeItemAllParents(format, null, null);
        if (format && util2.isList(format.firstChild)) {
          format.insertBefore(util2.createTextNode(util2.zeroWidthSpace), format.firstChild);
        }
      },
      /**
       * @description Appended all selected format Element to the argument element and insert
       * @param {Element} rangeElement Element of wrap the arguments (BLOCKQUOTE...)
       */
      applyRangeFormatElement: function(rangeElement) {
        this.getRange_addLine(this.getRange(), null);
        const rangeLines = this.getSelectedElementsAndComponents(false);
        if (!rangeLines || rangeLines.length === 0) return;
        linesLoop:
          for (let i = 0, len = rangeLines.length, line, nested, fEl, lEl, f, l; i < len; i++) {
            line = rangeLines[i];
            if (!util2.isListCell(line)) continue;
            nested = line.lastElementChild;
            if (nested && util2.isListCell(line.nextElementSibling) && rangeLines.indexOf(line.nextElementSibling) > -1) {
              lEl = nested.lastElementChild;
              if (rangeLines.indexOf(lEl) > -1) {
                let list = null;
                while (list = lEl.lastElementChild) {
                  if (util2.isList(list)) {
                    if (rangeLines.indexOf(list.lastElementChild) > -1) {
                      lEl = list.lastElementChild;
                    } else {
                      continue linesLoop;
                    }
                  }
                }
                fEl = nested.firstElementChild;
                f = rangeLines.indexOf(fEl);
                l = rangeLines.indexOf(lEl);
                rangeLines.splice(f, l - f + 1);
                len = rangeLines.length;
                continue;
              }
            }
          }
        let last = rangeLines[rangeLines.length - 1];
        let standTag, beforeTag, pElement;
        if (util2.isRangeFormatElement(last) || util2.isFormatElement(last)) {
          standTag = last;
        } else {
          standTag = util2.getRangeFormatElement(last, null) || util2.getFormatElement(last, null);
        }
        if (util2.isCell(standTag)) {
          beforeTag = null;
          pElement = standTag;
        } else {
          beforeTag = standTag.nextSibling;
          pElement = standTag.parentNode;
        }
        let parentDepth = util2.getElementDepth(standTag);
        let listParent = null;
        const lineArr = [];
        const removeItems = function(parent, origin, before) {
          let cc = null;
          if (parent !== origin && !util2.isTable(origin)) {
            if (origin && util2.getElementDepth(parent) === util2.getElementDepth(origin)) return before;
            cc = util2.removeItemAllParents(origin, null, parent);
          }
          return cc ? cc.ec : before;
        };
        for (let i = 0, len = rangeLines.length, line, originParent, depth, before, nextLine, nextList, nested; i < len; i++) {
          line = rangeLines[i];
          originParent = line.parentNode;
          if (!originParent || rangeElement.contains(originParent)) continue;
          depth = util2.getElementDepth(line);
          if (util2.isList(originParent)) {
            if (listParent === null) {
              if (nextList) {
                listParent = nextList;
                nested = true;
                nextList = null;
              } else {
                listParent = originParent.cloneNode(false);
              }
            }
            lineArr.push(line);
            nextLine = rangeLines[i + 1];
            if (i === len - 1 || nextLine && nextLine.parentNode !== originParent) {
              if (nextLine && line.contains(nextLine.parentNode)) {
                nextList = nextLine.parentNode.cloneNode(false);
              }
              let list = originParent.parentNode, p;
              while (util2.isList(list)) {
                p = util2.createElement(list.nodeName);
                p.appendChild(listParent);
                listParent = p;
                list = list.parentNode;
              }
              const edge2 = this.detachRangeFormatElement(originParent, lineArr, null, true, true);
              if (parentDepth >= depth) {
                parentDepth = depth;
                pElement = edge2.cc;
                beforeTag = removeItems(pElement, originParent, edge2.ec);
                if (beforeTag) pElement = beforeTag.parentNode;
              } else if (pElement === edge2.cc) {
                beforeTag = edge2.ec;
              }
              if (pElement !== edge2.cc) {
                before = removeItems(pElement, edge2.cc, before);
                if (before !== void 0) beforeTag = before;
                else beforeTag = edge2.cc;
              }
              for (let c = 0, cLen = edge2.removeArray.length; c < cLen; c++) {
                listParent.appendChild(edge2.removeArray[c]);
              }
              if (!nested) rangeElement.appendChild(listParent);
              if (nextList) edge2.removeArray[edge2.removeArray.length - 1].appendChild(nextList);
              listParent = null;
              nested = false;
            }
          } else {
            if (parentDepth >= depth) {
              parentDepth = depth;
              pElement = originParent;
              beforeTag = line.nextSibling;
            }
            rangeElement.appendChild(line);
            if (pElement !== originParent) {
              before = removeItems(pElement, originParent);
              if (before !== void 0) beforeTag = before;
            }
          }
        }
        this.effectNode = null;
        util2.mergeSameTags(rangeElement, null, false);
        util2.mergeNestedTags(rangeElement, function(current) {
          return this.isList(current);
        }.bind(util2));
        if (beforeTag && util2.getElementDepth(beforeTag) > 0 && (util2.isList(beforeTag.parentNode) || util2.isList(beforeTag.parentNode.parentNode))) {
          const depthFormat = util2.getParentElement(beforeTag, function(current) {
            return this.isRangeFormatElement(current) && !this.isList(current);
          }.bind(util2));
          const splitRange = util2.splitElement(beforeTag, null, !depthFormat ? 0 : util2.getElementDepth(depthFormat) + 1);
          splitRange.parentNode.insertBefore(rangeElement, splitRange);
        } else {
          pElement.insertBefore(rangeElement, beforeTag);
          removeItems(rangeElement, beforeTag);
        }
        const edge = util2.getEdgeChildNodes(rangeElement.firstElementChild, rangeElement.lastElementChild);
        if (rangeLines.length > 1) {
          this.setRange(edge.sc, 0, edge.ec, edge.ec.textContent.length);
        } else {
          this.setRange(edge.ec, edge.ec.textContent.length, edge.ec, edge.ec.textContent.length);
        }
        this.history.push(false);
      },
      /**
       * @description The elements of the "selectedFormats" array are detached from the "rangeElement" element. ("LI" tags are converted to "P" tags)
       * When "selectedFormats" is null, all elements are detached and return {cc: parentNode, sc: nextSibling, ec: previousSibling, removeArray: [Array of removed elements]}.
       * @param {Element} rangeElement Range format element (PRE, BLOCKQUOTE, OL, UL...)
       * @param {Array|null} selectedFormats Array of format elements (P, DIV, LI...) to remove.
       * If null, Applies to all elements and return {cc: parentNode, sc: nextSibling, ec: previousSibling}
       * @param {Element|null} newRangeElement The node(rangeElement) to replace the currently wrapped node.
       * @param {Boolean} remove If true, deleted without detached.
       * @param {Boolean} notHistoryPush When true, it does not update the history stack and the selection object and return EdgeNodes (util.getEdgeChildNodes)
       * @returns {Object}
       */
      detachRangeFormatElement: function(rangeElement, selectedFormats, newRangeElement, remove, notHistoryPush) {
        const range = this.getRange();
        let so = range.startOffset;
        let eo = range.endOffset;
        let children4 = util2.getListChildNodes(rangeElement, function(current) {
          return current.parentNode === rangeElement;
        });
        let parent = rangeElement.parentNode;
        let firstNode = null;
        let lastNode = null;
        let rangeEl = rangeElement.cloneNode(false);
        const removeArray = [];
        const newList = util2.isList(newRangeElement);
        let insertedNew = false;
        let reset = false;
        let moveComplete = false;
        function appendNode(parent2, insNode, sibling, originNode) {
          if (util2.onlyZeroWidthSpace(insNode)) {
            insNode.innerHTML = util2.zeroWidthSpace;
            so = eo = 1;
          }
          if (insNode.nodeType === 3) {
            parent2.insertBefore(insNode, sibling);
            return insNode;
          }
          const insChildren = (moveComplete ? insNode : originNode).childNodes;
          let format = insNode.cloneNode(false);
          let first = null;
          let c = null;
          while (insChildren[0]) {
            c = insChildren[0];
            if (util2._notTextNode(c) && !util2.isBreak(c) && !util2.isListCell(format)) {
              if (format.childNodes.length > 0) {
                if (!first) first = format;
                parent2.insertBefore(format, sibling);
                format = insNode.cloneNode(false);
              }
              parent2.insertBefore(c, sibling);
              if (!first) first = c;
            } else {
              format.appendChild(c);
            }
          }
          if (format.childNodes.length > 0) {
            if (util2.isListCell(parent2) && util2.isListCell(format) && util2.isList(sibling)) {
              if (newList) {
                first = sibling;
                while (sibling) {
                  format.appendChild(sibling);
                  sibling = sibling.nextSibling;
                }
                parent2.parentNode.insertBefore(format, parent2.nextElementSibling);
              } else {
                const originNext = originNode.nextElementSibling;
                const detachRange = util2.detachNestedList(originNode, false);
                if (rangeElement !== detachRange || originNext !== originNode.nextElementSibling) {
                  const fChildren = format.childNodes;
                  while (fChildren[0]) {
                    originNode.appendChild(fChildren[0]);
                  }
                  rangeElement = detachRange;
                  reset = true;
                }
              }
            } else {
              parent2.insertBefore(format, sibling);
            }
            if (!first) first = format;
          }
          return first;
        }
        for (let i = 0, len = children4.length, insNode, lineIndex, next; i < len; i++) {
          insNode = children4[i];
          if (insNode.nodeType === 3 && util2.isList(rangeEl)) continue;
          moveComplete = false;
          if (remove && i === 0) {
            if (!selectedFormats || selectedFormats.length === len || selectedFormats[0] === insNode) {
              firstNode = rangeElement.previousSibling;
            } else {
              firstNode = rangeEl;
            }
          }
          if (selectedFormats) lineIndex = selectedFormats.indexOf(insNode);
          if (selectedFormats && lineIndex === -1) {
            if (!rangeEl) rangeEl = rangeElement.cloneNode(false);
            rangeEl.appendChild(insNode);
          } else {
            if (selectedFormats) next = selectedFormats[lineIndex + 1];
            if (rangeEl && rangeEl.children.length > 0) {
              parent.insertBefore(rangeEl, rangeElement);
              rangeEl = null;
            }
            if (!newList && util2.isListCell(insNode)) {
              if (next && util2.getElementDepth(insNode) !== util2.getElementDepth(next) && (util2.isListCell(parent) || util2.getArrayItem(insNode.children, util2.isList, false))) {
                const insNext = insNode.nextElementSibling;
                const detachRange = util2.detachNestedList(insNode, false);
                if (rangeElement !== detachRange || insNext !== insNode.nextElementSibling) {
                  rangeElement = detachRange;
                  reset = true;
                }
              } else {
                const inner = insNode;
                insNode = util2.createElement(remove ? inner.nodeName : util2.isList(rangeElement.parentNode) || util2.isListCell(rangeElement.parentNode) ? "LI" : util2.isCell(rangeElement.parentNode) ? "DIV" : options.defaultTag);
                const isCell = util2.isListCell(insNode);
                const innerChildren = inner.childNodes;
                while (innerChildren[0]) {
                  if (util2.isList(innerChildren[0]) && !isCell) break;
                  insNode.appendChild(innerChildren[0]);
                }
                util2.copyFormatAttributes(insNode, inner);
                moveComplete = true;
              }
            } else {
              insNode = insNode.cloneNode(false);
            }
            if (!reset) {
              if (!remove) {
                if (newRangeElement) {
                  if (!insertedNew) {
                    parent.insertBefore(newRangeElement, rangeElement);
                    insertedNew = true;
                  }
                  insNode = appendNode(newRangeElement, insNode, null, children4[i]);
                } else {
                  insNode = appendNode(parent, insNode, rangeElement, children4[i]);
                }
                if (!reset) {
                  if (selectedFormats) {
                    lastNode = insNode;
                    if (!firstNode) {
                      firstNode = insNode;
                    }
                  } else if (!firstNode) {
                    firstNode = lastNode = insNode;
                  }
                }
              } else {
                removeArray.push(insNode);
                util2.removeItem(children4[i]);
              }
              if (reset) {
                reset = moveComplete = false;
                children4 = util2.getListChildNodes(rangeElement, function(current) {
                  return current.parentNode === rangeElement;
                });
                rangeEl = rangeElement.cloneNode(false);
                parent = rangeElement.parentNode;
                i = -1;
                len = children4.length;
                continue;
              }
            }
          }
        }
        const rangeParent = rangeElement.parentNode;
        let rangeRight = rangeElement.nextSibling;
        if (rangeEl && rangeEl.children.length > 0) {
          rangeParent.insertBefore(rangeEl, rangeRight);
        }
        if (newRangeElement) firstNode = newRangeElement.previousSibling;
        else if (!firstNode) firstNode = rangeElement.previousSibling;
        rangeRight = rangeElement.nextSibling !== rangeEl ? rangeElement.nextSibling : rangeEl ? rangeEl.nextSibling : null;
        if (rangeElement.children.length === 0 || rangeElement.textContent.length === 0) {
          util2.removeItem(rangeElement);
        } else {
          util2.removeEmptyNode(rangeElement, null, false);
        }
        let edge = null;
        if (remove) {
          edge = {
            cc: rangeParent,
            sc: firstNode,
            so,
            ec: rangeRight,
            eo,
            removeArray
          };
        } else {
          if (!firstNode) firstNode = lastNode;
          if (!lastNode) lastNode = firstNode;
          const childEdge = util2.getEdgeChildNodes(firstNode, lastNode.parentNode ? firstNode : lastNode);
          edge = {
            cc: (childEdge.sc || childEdge.ec).parentNode,
            sc: childEdge.sc,
            so,
            ec: childEdge.ec,
            eo,
            removeArray: null
          };
        }
        this.effectNode = null;
        if (notHistoryPush) return edge;
        if (!remove && edge) {
          if (!selectedFormats) {
            this.setRange(edge.sc, 0, edge.sc, 0);
          } else {
            this.setRange(edge.sc, so, edge.ec, eo);
          }
        }
        this.history.push(false);
      },
      /**
       * @description "selectedFormats" array are detached from the list element.
       * The return value is applied when the first and last lines of "selectedFormats" are "LI" respectively.
       * @param {Array} selectedFormats Array of format elements (LI, P...) to remove.
       * @param {Boolean} remove If true, deleted without detached.
       * @returns {Object} {sc: <LI>, ec: <LI>}.
       */
      detachList: function(selectedFormats, remove) {
        let rangeArr = {};
        let listFirst = false;
        let listLast = false;
        let first = null;
        let last = null;
        const passComponent = function(current) {
          return !this.isComponent(current);
        }.bind(util2);
        for (let i = 0, len = selectedFormats.length, r, o, lastIndex, isList; i < len; i++) {
          lastIndex = i === len - 1;
          o = util2.getRangeFormatElement(selectedFormats[i], passComponent);
          isList = util2.isList(o);
          if (!r && isList) {
            r = o;
            rangeArr = { r, f: [util2.getParentElement(selectedFormats[i], "LI")] };
            if (i === 0) listFirst = true;
          } else if (r && isList) {
            if (r !== o) {
              const edge = this.detachRangeFormatElement(rangeArr.f[0].parentNode, rangeArr.f, null, remove, true);
              o = selectedFormats[i].parentNode;
              if (listFirst) {
                first = edge.sc;
                listFirst = false;
              }
              if (lastIndex) last = edge.ec;
              if (isList) {
                r = o;
                rangeArr = { r, f: [util2.getParentElement(selectedFormats[i], "LI")] };
                if (lastIndex) listLast = true;
              } else {
                r = null;
              }
            } else {
              rangeArr.f.push(util2.getParentElement(selectedFormats[i], "LI"));
              if (lastIndex) listLast = true;
            }
          }
          if (lastIndex && util2.isList(r)) {
            const edge = this.detachRangeFormatElement(rangeArr.f[0].parentNode, rangeArr.f, null, remove, true);
            if (listLast || len === 1) last = edge.ec;
            if (listFirst) first = edge.sc || last;
          }
        }
        return {
          sc: first,
          ec: last
        };
      },
      /**
       * @description Add, update, and delete nodes from selected text.
       * 1. If there is a node in the "appendNode" argument, a node with the same tags and attributes as "appendNode" is added to the selection text.
       * 2. If it is in the same tag, only the tag's attributes are changed without adding a tag.
       * 3. If the "appendNode" argument is null, the node of the selection is update or remove without adding a new node.
       * 4. The same style as the style attribute of the "styleArray" argument is deleted.
       *    (Styles should be put with attribute names from css. ["background-color"])
       * 5. The same class name as the class attribute of the "styleArray" argument is deleted.
       *    (The class name is preceded by "." [".className"])
       * 6. Use a list of styles and classes of "appendNode" in "styleArray" to avoid duplicate property values.
       * 7. If a node with all styles and classes removed has the same tag name as "appendNode" or "removeNodeArray", or "appendNode" is null, that node is deleted.
       * 8. Regardless of the style and class of the node, the tag with the same name as the "removeNodeArray" argument value is deleted.
       * 9. If the "strictRemove" argument is true, only nodes with all styles and classes removed from the nodes of "removeNodeArray" are removed.
       *10. It won't work if the parent node has the same class and same value style.
       *    However, if there is a value in "removeNodeArray", it works and the text node is separated even if there is no node to replace.
       * @param {Element|null} appendNode The element to be added to the selection. If it is null, only delete the node.
       * @param {Array|null} styleArray The style or className attribute name Array to check (['font-size'], ['.className'], ['font-family', 'color', '.className']...])
       * @param {Array|null} removeNodeArray An array of node names to remove types from, remove all formats when "appendNode" is null and there is an empty array or null value. (['span'], ['strong', 'em'] ...])
       * @param {Boolean|null} strictRemove If true, only nodes with all styles and classes removed from the nodes of "removeNodeArray" are removed.
       */
      nodeChange: function(appendNode, styleArray, removeNodeArray, strictRemove) {
        this._resetRangeToTextNode();
        let range = this.getRange_addLine(this.getRange(), null);
        styleArray = styleArray && styleArray.length > 0 ? styleArray : false;
        removeNodeArray = removeNodeArray && removeNodeArray.length > 0 ? removeNodeArray : false;
        const isRemoveNode = !appendNode;
        const isRemoveFormat = isRemoveNode && !removeNodeArray && !styleArray;
        let startCon = range.startContainer;
        let startOff = range.startOffset;
        let endCon = range.endContainer;
        let endOff = range.endOffset;
        if (isRemoveFormat && range.collapsed && util2.isFormatElement(startCon.parentNode) || startCon === endCon && startCon.nodeType === 1 && util2.isNonEditable(startCon)) {
          const format = startCon.parentNode;
          if (!util2.isListCell(format) || !util2.getValues(format.style).some(function(k) {
            return this._listKebab.indexOf(k) > -1;
          }.bind(this))) return;
        }
        if (range.collapsed && !isRemoveFormat) {
          if (startCon.nodeType === 1 && !util2.isBreak(startCon) && !util2.isComponent(startCon)) {
            let afterNode = null;
            const focusNode = startCon.childNodes[startOff];
            if (focusNode) {
              if (!focusNode.nextSibling) {
                afterNode = null;
              } else {
                afterNode = util2.isBreak(focusNode) ? focusNode : focusNode.nextSibling;
              }
            }
            const zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
            startCon.insertBefore(zeroWidth, afterNode);
            this.setRange(zeroWidth, 1, zeroWidth, 1);
            range = this.getRange();
            startCon = range.startContainer;
            startOff = range.startOffset;
            endCon = range.endContainer;
            endOff = range.endOffset;
          }
        }
        if (util2.isFormatElement(startCon)) {
          startCon = startCon.childNodes[startOff] || startCon.firstChild;
          startOff = 0;
        }
        if (util2.isFormatElement(endCon)) {
          endCon = endCon.childNodes[endOff] || endCon.lastChild;
          endOff = endCon.textContent.length;
        }
        if (isRemoveNode) {
          appendNode = util2.createElement("DIV");
        }
        const wRegExp = _w.RegExp;
        const newNodeName = appendNode.nodeName;
        if (!isRemoveFormat && startCon === endCon && !removeNodeArray && appendNode) {
          let sNode = startCon;
          let checkCnt = 0;
          const checkAttrs = [];
          const checkStyles = appendNode.style;
          for (let i = 0, len = checkStyles.length; i < len; i++) {
            checkAttrs.push(checkStyles[i]);
          }
          const ckeckClasses = appendNode.classList;
          for (let i = 0, len = ckeckClasses.length; i < len; i++) {
            checkAttrs.push("." + ckeckClasses[i]);
          }
          if (checkAttrs.length > 0) {
            while (!util2.isFormatElement(sNode) && !util2.isWysiwygDiv(sNode)) {
              for (let i = 0; i < checkAttrs.length; i++) {
                if (sNode.nodeType === 1) {
                  const s = checkAttrs[i];
                  const classReg = /^\./.test(s) ? new wRegExp("\\s*" + s.replace(/^\./, "") + "(\\s+|$)", "ig") : false;
                  const styleCheck = isRemoveNode ? !!sNode.style[s] : !!sNode.style[s] && !!appendNode.style[s] && sNode.style[s] === appendNode.style[s];
                  const classCheck = classReg === false ? false : isRemoveNode ? !!sNode.className.match(classReg) : !!sNode.className.match(classReg) && !!appendNode.className.match(classReg);
                  if (styleCheck || classCheck) {
                    checkCnt++;
                  }
                }
              }
              sNode = sNode.parentNode;
            }
            if (checkCnt >= checkAttrs.length) return;
          }
        }
        let start = {}, end = {};
        let newNode, styleRegExp = "", classRegExp = "", removeNodeRegExp = "";
        if (styleArray) {
          for (let i = 0, len = styleArray.length, s; i < len; i++) {
            s = styleArray[i];
            if (/^\./.test(s)) {
              classRegExp += (classRegExp ? "|" : "\\s*(?:") + s.replace(/^\./, "");
            } else {
              styleRegExp += (styleRegExp ? "|" : "(?:;|^|\\s)(?:") + s;
            }
          }
          if (styleRegExp) {
            styleRegExp += ")\\s*:[^;]*\\s*(?:;|$)";
            styleRegExp = new wRegExp(styleRegExp, "ig");
          }
          if (classRegExp) {
            classRegExp += ")(?=\\s+|$)";
            classRegExp = new wRegExp(classRegExp, "ig");
          }
        }
        if (removeNodeArray) {
          removeNodeRegExp = "^(?:" + removeNodeArray[0];
          for (let i = 1; i < removeNodeArray.length; i++) {
            removeNodeRegExp += "|" + removeNodeArray[i];
          }
          removeNodeRegExp += ")$";
          removeNodeRegExp = new wRegExp(removeNodeRegExp, "i");
        }
        const wBoolean = _w.Boolean;
        const _removeCheck = { v: false };
        const validation = function(checkNode) {
          const vNode = checkNode.cloneNode(false);
          if (vNode.nodeType === 3 || util2.isBreak(vNode)) return vNode;
          if (isRemoveFormat) return null;
          const tagRemove = !removeNodeRegExp && isRemoveNode || removeNodeRegExp && removeNodeRegExp.test(vNode.nodeName);
          if (tagRemove && !strictRemove) {
            _removeCheck.v = true;
            return null;
          }
          const originStyle = vNode.style.cssText;
          let style = "";
          if (styleRegExp && originStyle.length > 0) {
            style = originStyle.replace(styleRegExp, "").trim();
            if (style !== originStyle) _removeCheck.v = true;
          }
          const originClasses = vNode.className;
          let classes = "";
          if (classRegExp && originClasses.length > 0) {
            classes = originClasses.replace(classRegExp, "").trim();
            if (classes !== originClasses) _removeCheck.v = true;
          }
          if (isRemoveNode) {
            if ((classRegExp || !originClasses) && (styleRegExp || !originStyle) && !style && !classes && tagRemove) {
              _removeCheck.v = true;
              return null;
            }
          }
          if (style || classes || vNode.nodeName !== newNodeName || wBoolean(styleRegExp) !== wBoolean(originStyle) || wBoolean(classRegExp) !== wBoolean(originClasses)) {
            if (styleRegExp && originStyle.length > 0) vNode.style.cssText = style;
            if (!vNode.style.cssText) {
              vNode.removeAttribute("style");
            }
            if (classRegExp && originClasses.length > 0) vNode.className = classes.trim();
            if (!vNode.className.trim()) {
              vNode.removeAttribute("class");
            }
            if (!vNode.style.cssText && !vNode.className && (vNode.nodeName === newNodeName || tagRemove)) {
              _removeCheck.v = true;
              return null;
            }
            return vNode;
          }
          _removeCheck.v = true;
          return null;
        };
        const lineNodes = this.getSelectedElements(null);
        range = this.getRange();
        startCon = range.startContainer;
        startOff = range.startOffset;
        endCon = range.endContainer;
        endOff = range.endOffset;
        if (!util2.getFormatElement(startCon, null)) {
          startCon = util2.getChildElement(lineNodes[0], function(current) {
            return current.nodeType === 3;
          }, false);
          startOff = 0;
        }
        if (!util2.getFormatElement(endCon, null)) {
          endCon = util2.getChildElement(lineNodes[lineNodes.length - 1], function(current) {
            return current.nodeType === 3;
          }, false);
          endOff = endCon.textContent.length;
        }
        const oneLine = util2.getFormatElement(startCon, null) === util2.getFormatElement(endCon, null);
        const endLength = lineNodes.length - (oneLine ? 0 : 1);
        newNode = appendNode.cloneNode(false);
        const isRemoveAnchor = isRemoveFormat || isRemoveNode && function(arr) {
          for (let n = 0, len = arr.length; n < len; n++) {
            if (util2._isMaintainedNode(arr[n]) || util2._isSizeNode(arr[n])) return true;
          }
          return false;
        }(removeNodeArray);
        const isSizeNode = isRemoveNode || util2._isSizeNode(newNode);
        const _getMaintainedNode = this._util_getMaintainedNode.bind(util2, isRemoveAnchor, isSizeNode);
        const _isMaintainedNode = this._util_isMaintainedNode.bind(util2, isRemoveAnchor, isSizeNode);
        if (oneLine) {
          if (this._resetCommonListCell(lineNodes[0], styleArray)) range = this.setRange(startCon, startOff, endCon, endOff);
          const newRange = this._nodeChange_oneLine(lineNodes[0], newNode, validation, startCon, startOff, endCon, endOff, isRemoveFormat, isRemoveNode, range.collapsed, _removeCheck, _getMaintainedNode, _isMaintainedNode);
          start.container = newRange.startContainer;
          start.offset = newRange.startOffset;
          end.container = newRange.endContainer;
          end.offset = newRange.endOffset;
          if (start.container === end.container && util2.onlyZeroWidthSpace(start.container)) {
            start.offset = end.offset = 1;
          }
          this._setCommonListStyle(newRange.ancestor, null);
        } else {
          let appliedCommonList = false;
          if (endLength > 0 && this._resetCommonListCell(lineNodes[endLength], styleArray)) appliedCommonList = true;
          if (this._resetCommonListCell(lineNodes[0], styleArray)) appliedCommonList = true;
          if (appliedCommonList) this.setRange(startCon, startOff, endCon, endOff);
          if (endLength > 0) {
            newNode = appendNode.cloneNode(false);
            end = this._nodeChange_endLine(lineNodes[endLength], newNode, validation, endCon, endOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode);
          }
          for (let i = endLength - 1, newRange; i > 0; i--) {
            this._resetCommonListCell(lineNodes[i], styleArray);
            newNode = appendNode.cloneNode(false);
            newRange = this._nodeChange_middleLine(lineNodes[i], newNode, validation, isRemoveFormat, isRemoveNode, _removeCheck, end.container);
            if (newRange.endContainer && newRange.ancestor.contains(newRange.endContainer)) {
              end.ancestor = null;
              end.container = newRange.endContainer;
            }
            this._setCommonListStyle(newRange.ancestor, null);
          }
          newNode = appendNode.cloneNode(false);
          start = this._nodeChange_startLine(lineNodes[0], newNode, validation, startCon, startOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode, end.container);
          if (start.endContainer) {
            end.ancestor = null;
            end.container = start.endContainer;
          }
          if (endLength <= 0) {
            end = start;
          } else if (!end.container) {
            end.ancestor = null;
            end.container = start.container;
            end.offset = start.container.textContent.length;
          }
          this._setCommonListStyle(start.ancestor, null);
          this._setCommonListStyle(end.ancestor || util2.getFormatElement(end.container), null);
        }
        this.controllersOff();
        this.setRange(start.container, start.offset, end.container, end.offset);
        this.history.push(false);
      },
      /**
       * @description Reset common style of list cell
       * @param {Element} el List cell element. <li>
       * @param {Array|null} styleArray Style array
       * @private
       */
      _resetCommonListCell: function(el, styleArray) {
        if (!util2.isListCell(el)) return;
        if (!styleArray) styleArray = this._listKebab;
        const children4 = util2.getArrayItem(el.childNodes, function(current) {
          return !util2.isBreak(current);
        }, true);
        const elStyles = el.style;
        const ec = [], ek = [], elKeys = util2.getValues(elStyles);
        for (let i = 0, len = this._listKebab.length; i < len; i++) {
          if (elKeys.indexOf(this._listKebab[i]) > -1 && styleArray.indexOf(this._listKebab[i]) > -1) {
            ec.push(this._listCamel[i]);
            ek.push(this._listKebab[i]);
          }
        }
        if (!ec.length) return;
        const refer = util2.createElement("SPAN");
        for (let i = 0, len = ec.length; i < len; i++) {
          refer.style[ec[i]] = elStyles[ek[i]];
          elStyles.removeProperty(ek[i]);
        }
        let sel = refer.cloneNode(false);
        let r = null, appliedEl = false;
        for (let i = 0, len = children4.length, c, s; i < len; i++) {
          c = children4[i];
          if (options._textTagsMap[c.nodeName.toLowerCase()]) continue;
          s = util2.getValues(c.style);
          if (s.length === 0 || ec.some(function(k) {
            return s.indexOf(k) === -1;
          }) && s.some(function(k) {
            ec.indexOf(k) > -1;
          })) {
            r = c.nextSibling;
            sel.appendChild(c);
          } else if (sel.childNodes.length > 0) {
            el.insertBefore(sel, r);
            sel = refer.cloneNode(false);
            r = null;
            appliedEl = true;
          }
        }
        if (sel.childNodes.length > 0) {
          el.insertBefore(sel, r);
          appliedEl = true;
        }
        if (!elStyles.length) {
          el.removeAttribute("style");
        }
        return appliedEl;
      },
      /**
       * @description If certain styles are applied to all child nodes of the list cell, the style of the list cell is also changed. (bold, color, size)
       * @param {Element} el List cell element. <li>
       * @param {Element|null} child Variable for recursive call. ("null" on the first call)
       * @private
       */
      _setCommonListStyle: function(el, child) {
        if (!util2.isListCell(el)) return;
        const children4 = util2.getArrayItem((child || el).childNodes, function(current) {
          return !util2.isBreak(current);
        }, true);
        child = children4[0];
        if (!child || children4.length > 1 || child.nodeType !== 1) return;
        const childStyle = child.style;
        const elStyle = el.style;
        const nodeName = child.nodeName.toLowerCase();
        let appliedEl = false;
        if (options._textTagsMap[nodeName] === options._defaultCommand.bold.toLowerCase()) elStyle.fontWeight = "bold";
        if (options._textTagsMap[nodeName] === options._defaultCommand.italic.toLowerCase()) elStyle.fontStyle = "italic";
        const cKeys = util2.getValues(childStyle);
        if (cKeys.length > 0) {
          for (let i = 0, len = this._listCamel.length; i < len; i++) {
            if (cKeys.indexOf(this._listKebab[i]) > -1) {
              elStyle[this._listCamel[i]] = childStyle[this._listCamel[i]];
              childStyle.removeProperty(this._listKebab[i]);
              appliedEl = true;
            }
          }
        }
        this._setCommonListStyle(el, child);
        if (!appliedEl) return;
        if (!childStyle.length) {
          const ch = child.childNodes;
          const p = child.parentNode;
          const n = child.nextSibling;
          while (ch.length > 0) {
            p.insertBefore(ch[0], n);
          }
          util2.removeItem(child);
        }
      },
      /**
       * @description Strip remove node
       * @param {Node} removeNode The remove node
       * @private
       */
      _stripRemoveNode: function(removeNode) {
        const element = removeNode.parentNode;
        if (!removeNode || removeNode.nodeType === 3 || !element) return;
        const children4 = removeNode.childNodes;
        while (children4[0]) {
          element.insertBefore(children4[0], removeNode);
        }
        element.removeChild(removeNode);
      },
      /**
       * @description Return the parent maintained tag. (bind and use a util object)
       * @param {Element} element Element
       * @returns {Element}
       * @private
       */
      _util_getMaintainedNode: function(_isRemove, _isSizeNode, element) {
        if (!element || _isRemove) return null;
        return this.getParentElement(element, this._isMaintainedNode.bind(this)) || (!_isSizeNode ? this.getParentElement(element, this._isSizeNode.bind(this)) : null);
      },
      /**
       * @description Check if element is a tag that should be persisted. (bind and use a util object)
       * @param {Element} element Element
       * @returns {Element}
       * @private
       */
      _util_isMaintainedNode: function(_isRemove, _isSizeNode, element) {
        if (!element || _isRemove || element.nodeType !== 1) return false;
        const anchor = this._isMaintainedNode(element);
        return this.getParentElement(element, this._isMaintainedNode.bind(this)) ? anchor : anchor || (!_isSizeNode ? this._isSizeNode(element) : false);
      },
      /**
       * @description wraps text nodes of line selected text.
       * @param {Element} element The node of the line that contains the selected text node.
       * @param {Element} newInnerNode The dom that will wrap the selected text area
       * @param {Function} validation Check if the node should be stripped.
       * @param {Node} startCon The startContainer property of the selection object.
       * @param {Number} startOff The startOffset property of the selection object.
       * @param {Node} endCon The endContainer property of the selection object.
       * @param {Number} endOff The endOffset property of the selection object.
       * @param {Boolean} isRemoveFormat Is the remove all formats command?
       * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
       * @param {Boolean} collapsed range.collapsed
       * @returns {{ancestor: *, startContainer: *, startOffset: *, endContainer: *, endOffset: *}}
       * @private
       */
      _nodeChange_oneLine: function(element, newInnerNode, validation, startCon, startOff, endCon, endOff, isRemoveFormat, isRemoveNode, collapsed, _removeCheck, _getMaintainedNode, _isMaintainedNode) {
        let parentCon = startCon.parentNode;
        while (!parentCon.nextSibling && !parentCon.previousSibling && !util2.isFormatElement(parentCon.parentNode) && !util2.isWysiwygDiv(parentCon.parentNode)) {
          if (parentCon.nodeName === newInnerNode.nodeName) break;
          parentCon = parentCon.parentNode;
        }
        if (!isRemoveNode && parentCon === endCon.parentNode && parentCon.nodeName === newInnerNode.nodeName) {
          if (util2.onlyZeroWidthSpace(startCon.textContent.slice(0, startOff)) && util2.onlyZeroWidthSpace(endCon.textContent.slice(endOff))) {
            const children4 = parentCon.childNodes;
            let sameTag = true;
            for (let i = 0, len = children4.length, c, s, e, z; i < len; i++) {
              c = children4[i];
              z = !util2.onlyZeroWidthSpace(c);
              if (c === startCon) {
                s = true;
                continue;
              }
              if (c === endCon) {
                e = true;
                continue;
              }
              if (!s && z || s && e && z) {
                sameTag = false;
                break;
              }
            }
            if (sameTag) {
              util2.copyTagAttributes(parentCon, newInnerNode);
              return {
                ancestor: element,
                startContainer: startCon,
                startOffset: startOff,
                endContainer: endCon,
                endOffset: endOff
              };
            }
          }
        }
        _removeCheck.v = false;
        const el = element;
        const nNodeArray = [newInnerNode];
        const pNode = element.cloneNode(false);
        const isSameNode = startCon === endCon;
        let startContainer = startCon;
        let startOffset = startOff;
        let endContainer = endCon;
        let endOffset = endOff;
        let startPass = false;
        let endPass = false;
        let pCurrent, newNode, appendNode, cssText, anchorNode;
        const wRegExp = _w.RegExp;
        function checkCss(vNode) {
          const regExp = new wRegExp("(?:;|^|\\s)(?:" + cssText + "null)\\s*:[^;]*\\s*(?:;|$)", "ig");
          let style = "";
          if (regExp && vNode.style.cssText.length > 0) {
            style = regExp.test(vNode.style.cssText);
          }
          return !style;
        }
        (function recursionFunc(current, ancestor) {
          const childNodes = current.childNodes;
          for (let i = 0, len = childNodes.length, vNode; i < len; i++) {
            let child = childNodes[i];
            if (!child) continue;
            let coverNode = ancestor;
            let cloneNode;
            if (!startPass && child === startContainer) {
              let line = pNode;
              anchorNode = _getMaintainedNode(child);
              const prevNode = util2.createTextNode(startContainer.nodeType === 1 ? "" : startContainer.substringData(0, startOffset));
              const textNode = util2.createTextNode(
                startContainer.nodeType === 1 ? "" : startContainer.substringData(
                  startOffset,
                  isSameNode ? endOffset >= startOffset ? endOffset - startOffset : startContainer.data.length - startOffset : startContainer.data.length - startOffset
                )
              );
              if (anchorNode) {
                const a = _getMaintainedNode(ancestor);
                if (a && a.parentNode !== line) {
                  let m = a;
                  let p = null;
                  while (m.parentNode !== line) {
                    ancestor = p = m.parentNode.cloneNode(false);
                    while (m.childNodes[0]) {
                      p.appendChild(m.childNodes[0]);
                    }
                    m.appendChild(p);
                    m = m.parentNode;
                  }
                  m.parentNode.appendChild(a);
                }
                anchorNode = anchorNode.cloneNode(false);
              }
              if (!util2.onlyZeroWidthSpace(prevNode)) {
                ancestor.appendChild(prevNode);
              }
              const prevAnchorNode = _getMaintainedNode(ancestor);
              if (!!prevAnchorNode) anchorNode = prevAnchorNode;
              if (anchorNode) line = anchorNode;
              newNode = child;
              pCurrent = [];
              cssText = "";
              while (newNode !== line && newNode !== el && newNode !== null) {
                vNode = _isMaintainedNode(newNode) ? null : validation(newNode);
                if (vNode && newNode.nodeType === 1 && checkCss(newNode)) {
                  pCurrent.push(vNode);
                  cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(":")) + "|";
                }
                newNode = newNode.parentNode;
              }
              const childNode = pCurrent.pop() || textNode;
              appendNode = newNode = childNode;
              while (pCurrent.length > 0) {
                newNode = pCurrent.pop();
                appendNode.appendChild(newNode);
                appendNode = newNode;
              }
              newInnerNode.appendChild(childNode);
              line.appendChild(newInnerNode);
              if (anchorNode && !_getMaintainedNode(endContainer)) {
                newInnerNode = newInnerNode.cloneNode(false);
                pNode.appendChild(newInnerNode);
                nNodeArray.push(newInnerNode);
              }
              startContainer = textNode;
              startOffset = 0;
              startPass = true;
              if (newNode !== textNode) newNode.appendChild(startContainer);
              if (!isSameNode) continue;
            }
            if (!endPass && child === endContainer) {
              anchorNode = _getMaintainedNode(child);
              const afterNode = util2.createTextNode(endContainer.nodeType === 1 ? "" : endContainer.substringData(endOffset, endContainer.length - endOffset));
              const textNode = util2.createTextNode(isSameNode || endContainer.nodeType === 1 ? "" : endContainer.substringData(0, endOffset));
              if (anchorNode) {
                anchorNode = anchorNode.cloneNode(false);
              } else if (_isMaintainedNode(newInnerNode.parentNode) && !anchorNode) {
                newInnerNode = newInnerNode.cloneNode(false);
                pNode.appendChild(newInnerNode);
                nNodeArray.push(newInnerNode);
              }
              if (!util2.onlyZeroWidthSpace(afterNode)) {
                newNode = child;
                cssText = "";
                pCurrent = [];
                const anchors = [];
                while (newNode !== pNode && newNode !== el && newNode !== null) {
                  if (newNode.nodeType === 1 && checkCss(newNode)) {
                    if (_isMaintainedNode(newNode)) anchors.push(newNode.cloneNode(false));
                    else pCurrent.push(newNode.cloneNode(false));
                    cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(":")) + "|";
                  }
                  newNode = newNode.parentNode;
                }
                pCurrent = pCurrent.concat(anchors);
                cloneNode = appendNode = newNode = pCurrent.pop() || afterNode;
                while (pCurrent.length > 0) {
                  newNode = pCurrent.pop();
                  appendNode.appendChild(newNode);
                  appendNode = newNode;
                }
                pNode.appendChild(cloneNode);
                newNode.textContent = afterNode.data;
              }
              if (anchorNode && cloneNode) {
                const afterAnchorNode = _getMaintainedNode(cloneNode);
                if (afterAnchorNode) {
                  anchorNode = afterAnchorNode;
                }
              }
              newNode = child;
              pCurrent = [];
              cssText = "";
              while (newNode !== pNode && newNode !== el && newNode !== null) {
                vNode = _isMaintainedNode(newNode) ? null : validation(newNode);
                if (vNode && newNode.nodeType === 1 && checkCss(newNode)) {
                  pCurrent.push(vNode);
                  cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(":")) + "|";
                }
                newNode = newNode.parentNode;
              }
              const childNode = pCurrent.pop() || textNode;
              appendNode = newNode = childNode;
              while (pCurrent.length > 0) {
                newNode = pCurrent.pop();
                appendNode.appendChild(newNode);
                appendNode = newNode;
              }
              if (anchorNode) {
                newInnerNode = newInnerNode.cloneNode(false);
                newInnerNode.appendChild(childNode);
                anchorNode.insertBefore(newInnerNode, anchorNode.firstChild);
                pNode.appendChild(anchorNode);
                nNodeArray.push(newInnerNode);
                anchorNode = null;
              } else {
                newInnerNode.appendChild(childNode);
              }
              endContainer = textNode;
              endOffset = textNode.data.length;
              endPass = true;
              if (!isRemoveFormat && collapsed) {
                newInnerNode = textNode;
                textNode.textContent = util2.zeroWidthSpace;
              }
              if (newNode !== textNode) newNode.appendChild(endContainer);
              continue;
            }
            if (startPass) {
              if (child.nodeType === 1 && !util2.isBreak(child)) {
                if (util2._isIgnoreNodeChange(child)) {
                  pNode.appendChild(child.cloneNode(true));
                  if (!collapsed) {
                    newInnerNode = newInnerNode.cloneNode(false);
                    pNode.appendChild(newInnerNode);
                    nNodeArray.push(newInnerNode);
                  }
                } else {
                  recursionFunc(child, child);
                }
                continue;
              }
              newNode = child;
              pCurrent = [];
              cssText = "";
              const anchors = [];
              while (newNode.parentNode !== null && newNode !== el && newNode !== newInnerNode) {
                vNode = endPass ? newNode.cloneNode(false) : validation(newNode);
                if (newNode.nodeType === 1 && !util2.isBreak(child) && vNode && checkCss(newNode)) {
                  if (_isMaintainedNode(newNode)) {
                    if (!anchorNode) anchors.push(vNode);
                  } else {
                    pCurrent.push(vNode);
                  }
                  cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(":")) + "|";
                }
                newNode = newNode.parentNode;
              }
              pCurrent = pCurrent.concat(anchors);
              const childNode = pCurrent.pop() || child;
              appendNode = newNode = childNode;
              while (pCurrent.length > 0) {
                newNode = pCurrent.pop();
                appendNode.appendChild(newNode);
                appendNode = newNode;
              }
              if (_isMaintainedNode(newInnerNode.parentNode) && !_isMaintainedNode(childNode) && !util2.onlyZeroWidthSpace(newInnerNode)) {
                newInnerNode = newInnerNode.cloneNode(false);
                pNode.appendChild(newInnerNode);
                nNodeArray.push(newInnerNode);
              }
              if (!endPass && !anchorNode && _isMaintainedNode(childNode)) {
                newInnerNode = newInnerNode.cloneNode(false);
                const aChildren = childNode.childNodes;
                for (let a = 0, aLen = aChildren.length; a < aLen; a++) {
                  newInnerNode.appendChild(aChildren[a]);
                }
                childNode.appendChild(newInnerNode);
                pNode.appendChild(childNode);
                nNodeArray.push(newInnerNode);
                if (newInnerNode.children.length > 0) ancestor = newNode;
                else ancestor = newInnerNode;
              } else if (childNode === child) {
                if (!endPass) ancestor = newInnerNode;
                else ancestor = pNode;
              } else if (endPass) {
                pNode.appendChild(childNode);
                ancestor = newNode;
              } else {
                newInnerNode.appendChild(childNode);
                ancestor = newNode;
              }
              if (anchorNode && child.nodeType === 3) {
                if (_getMaintainedNode(child)) {
                  const ancestorAnchorNode = util2.getParentElement(ancestor, function(current2) {
                    return this._isMaintainedNode(current2.parentNode) || current2.parentNode === pNode;
                  }.bind(util2));
                  anchorNode.appendChild(ancestorAnchorNode);
                  newInnerNode = ancestorAnchorNode.cloneNode(false);
                  nNodeArray.push(newInnerNode);
                  pNode.appendChild(newInnerNode);
                } else {
                  anchorNode = null;
                }
              }
            }
            cloneNode = child.cloneNode(false);
            ancestor.appendChild(cloneNode);
            if (child.nodeType === 1 && !util2.isBreak(child)) coverNode = cloneNode;
            recursionFunc(child, coverNode);
          }
        })(element, pNode);
        if (isRemoveNode && !isRemoveFormat && !_removeCheck.v) {
          return {
            ancestor: element,
            startContainer: startCon,
            startOffset: startOff,
            endContainer: endCon,
            endOffset: endOff
          };
        }
        isRemoveFormat = isRemoveFormat && isRemoveNode;
        if (isRemoveFormat) {
          for (let i = 0; i < nNodeArray.length; i++) {
            let removeNode = nNodeArray[i];
            let textNode, textNode_s, textNode_e;
            if (collapsed) {
              textNode = util2.createTextNode(util2.zeroWidthSpace);
              pNode.replaceChild(textNode, removeNode);
            } else {
              const rChildren = removeNode.childNodes;
              textNode_s = rChildren[0];
              while (rChildren[0]) {
                textNode_e = rChildren[0];
                pNode.insertBefore(textNode_e, removeNode);
              }
              util2.removeItem(removeNode);
            }
            if (i === 0) {
              if (collapsed) {
                startContainer = endContainer = textNode;
              } else {
                startContainer = textNode_s;
                endContainer = textNode_e;
              }
            }
          }
        } else {
          if (isRemoveNode) {
            for (let i = 0; i < nNodeArray.length; i++) {
              this._stripRemoveNode(nNodeArray[i]);
            }
          }
          if (collapsed) {
            startContainer = endContainer = newInnerNode;
          }
        }
        util2.removeEmptyNode(pNode, newInnerNode, false);
        if (collapsed) {
          startOffset = startContainer.textContent.length;
          endOffset = endContainer.textContent.length;
        }
        const endConReset = isRemoveFormat || endContainer.textContent.length === 0;
        if (!util2.isBreak(endContainer) && endContainer.textContent.length === 0) {
          util2.removeItem(endContainer);
          endContainer = startContainer;
        }
        endOffset = endConReset ? endContainer.textContent.length : endOffset;
        const newStartOffset = { s: 0, e: 0 };
        const startPath = util2.getNodePath(startContainer, pNode, newStartOffset);
        const mergeEndCon = !endContainer.parentNode;
        if (mergeEndCon) endContainer = startContainer;
        const newEndOffset = { s: 0, e: 0 };
        const endPath = util2.getNodePath(endContainer, pNode, !mergeEndCon && !endConReset ? newEndOffset : null);
        startOffset += newStartOffset.s;
        endOffset = collapsed ? startOffset : mergeEndCon ? startContainer.textContent.length : endConReset ? endOffset + newStartOffset.s : endOffset + newEndOffset.s;
        const newOffsets = util2.mergeSameTags(pNode, [startPath, endPath], true);
        element.parentNode.replaceChild(pNode, element);
        startContainer = util2.getNodeFromPath(startPath, pNode);
        endContainer = util2.getNodeFromPath(endPath, pNode);
        return {
          ancestor: pNode,
          startContainer,
          startOffset: startOffset + newOffsets[0],
          endContainer,
          endOffset: endOffset + newOffsets[1]
        };
      },
      /**
       * @description wraps first line selected text.
       * @param {Element} element The node of the line that contains the selected text node.
       * @param {Element} newInnerNode The dom that will wrap the selected text area
       * @param {Function} validation Check if the node should be stripped.
       * @param {Node} startCon The startContainer property of the selection object.
       * @param {Number} startOff The startOffset property of the selection object.
       * @param {Boolean} isRemoveFormat Is the remove all formats command?
       * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
       * @returns {null|Node} If end container is renewed, returned renewed node
       * @returns {Object} { ancestor, container, offset, endContainer }
       * @private
       */
      _nodeChange_startLine: function(element, newInnerNode, validation, startCon, startOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode, _endContainer) {
        let parentCon = startCon.parentNode;
        while (!parentCon.nextSibling && !parentCon.previousSibling && !util2.isFormatElement(parentCon.parentNode) && !util2.isWysiwygDiv(parentCon.parentNode)) {
          if (parentCon.nodeName === newInnerNode.nodeName) break;
          parentCon = parentCon.parentNode;
        }
        if (!isRemoveNode && parentCon.nodeName === newInnerNode.nodeName && !util2.isFormatElement(parentCon) && !parentCon.nextSibling && util2.onlyZeroWidthSpace(startCon.textContent.slice(0, startOff))) {
          let sameTag = true;
          let s = startCon.previousSibling;
          while (s) {
            if (!util2.onlyZeroWidthSpace(s)) {
              sameTag = false;
              break;
            }
            s = s.previousSibling;
          }
          if (sameTag) {
            util2.copyTagAttributes(parentCon, newInnerNode);
            return {
              ancestor: element,
              container: startCon,
              offset: startOff
            };
          }
        }
        _removeCheck.v = false;
        const el = element;
        const nNodeArray = [newInnerNode];
        const pNode = element.cloneNode(false);
        let container = startCon;
        let offset = startOff;
        let passNode = false;
        let pCurrent, newNode, appendNode, anchorNode;
        (function recursionFunc(current, ancestor) {
          const childNodes = current.childNodes;
          for (let i = 0, len = childNodes.length, vNode, cloneChild; i < len; i++) {
            const child = childNodes[i];
            if (!child) continue;
            let coverNode = ancestor;
            if (passNode && !util2.isBreak(child)) {
              if (child.nodeType === 1) {
                if (util2._isIgnoreNodeChange(child)) {
                  newInnerNode = newInnerNode.cloneNode(false);
                  cloneChild = child.cloneNode(true);
                  pNode.appendChild(cloneChild);
                  pNode.appendChild(newInnerNode);
                  nNodeArray.push(newInnerNode);
                  if (_endContainer && child.contains(_endContainer)) {
                    const endPath = util2.getNodePath(_endContainer, child);
                    _endContainer = util2.getNodeFromPath(endPath, cloneChild);
                  }
                } else {
                  recursionFunc(child, child);
                }
                continue;
              }
              newNode = child;
              pCurrent = [];
              const anchors = [];
              while (newNode.parentNode !== null && newNode !== el && newNode !== newInnerNode) {
                vNode = validation(newNode);
                if (newNode.nodeType === 1 && vNode) {
                  if (_isMaintainedNode(newNode)) {
                    if (!anchorNode) anchors.push(vNode);
                  } else {
                    pCurrent.push(vNode);
                  }
                }
                newNode = newNode.parentNode;
              }
              pCurrent = pCurrent.concat(anchors);
              const isTopNode = pCurrent.length > 0;
              const childNode = pCurrent.pop() || child;
              appendNode = newNode = childNode;
              while (pCurrent.length > 0) {
                newNode = pCurrent.pop();
                appendNode.appendChild(newNode);
                appendNode = newNode;
              }
              if (_isMaintainedNode(newInnerNode.parentNode) && !_isMaintainedNode(childNode)) {
                newInnerNode = newInnerNode.cloneNode(false);
                pNode.appendChild(newInnerNode);
                nNodeArray.push(newInnerNode);
              }
              if (!anchorNode && _isMaintainedNode(childNode)) {
                newInnerNode = newInnerNode.cloneNode(false);
                const aChildren = childNode.childNodes;
                for (let a = 0, aLen = aChildren.length; a < aLen; a++) {
                  newInnerNode.appendChild(aChildren[a]);
                }
                childNode.appendChild(newInnerNode);
                pNode.appendChild(childNode);
                ancestor = !_isMaintainedNode(newNode) ? newNode : newInnerNode;
                nNodeArray.push(newInnerNode);
              } else if (isTopNode) {
                newInnerNode.appendChild(childNode);
                ancestor = newNode;
              } else {
                ancestor = newInnerNode;
              }
              if (anchorNode && child.nodeType === 3) {
                if (_getMaintainedNode(child)) {
                  const ancestorAnchorNode = util2.getParentElement(ancestor, function(current2) {
                    return this._isMaintainedNode(current2.parentNode) || current2.parentNode === pNode;
                  }.bind(util2));
                  anchorNode.appendChild(ancestorAnchorNode);
                  newInnerNode = ancestorAnchorNode.cloneNode(false);
                  nNodeArray.push(newInnerNode);
                  pNode.appendChild(newInnerNode);
                } else {
                  anchorNode = null;
                }
              }
            }
            if (!passNode && child === container) {
              let line = pNode;
              anchorNode = _getMaintainedNode(child);
              const prevNode = util2.createTextNode(container.nodeType === 1 ? "" : container.substringData(0, offset));
              const textNode = util2.createTextNode(container.nodeType === 1 ? "" : container.substringData(offset, container.length - offset));
              if (anchorNode) {
                const a = _getMaintainedNode(ancestor);
                if (a && a.parentNode !== line) {
                  let m = a;
                  let p = null;
                  while (m.parentNode !== line) {
                    ancestor = p = m.parentNode.cloneNode(false);
                    while (m.childNodes[0]) {
                      p.appendChild(m.childNodes[0]);
                    }
                    m.appendChild(p);
                    m = m.parentNode;
                  }
                  m.parentNode.appendChild(a);
                }
                anchorNode = anchorNode.cloneNode(false);
              }
              if (!util2.onlyZeroWidthSpace(prevNode)) {
                ancestor.appendChild(prevNode);
              }
              const prevAnchorNode = _getMaintainedNode(ancestor);
              if (!!prevAnchorNode) anchorNode = prevAnchorNode;
              if (anchorNode) line = anchorNode;
              newNode = ancestor;
              pCurrent = [];
              while (newNode !== line && newNode !== null) {
                vNode = validation(newNode);
                if (newNode.nodeType === 1 && vNode) {
                  pCurrent.push(vNode);
                }
                newNode = newNode.parentNode;
              }
              const childNode = pCurrent.pop() || ancestor;
              appendNode = newNode = childNode;
              while (pCurrent.length > 0) {
                newNode = pCurrent.pop();
                appendNode.appendChild(newNode);
                appendNode = newNode;
              }
              if (childNode !== ancestor) {
                newInnerNode.appendChild(childNode);
                ancestor = newNode;
              } else {
                ancestor = newInnerNode;
              }
              if (util2.isBreak(child)) newInnerNode.appendChild(child.cloneNode(false));
              line.appendChild(newInnerNode);
              container = textNode;
              offset = 0;
              passNode = true;
              ancestor.appendChild(container);
              continue;
            }
            vNode = !passNode ? child.cloneNode(false) : validation(child);
            if (vNode) {
              ancestor.appendChild(vNode);
              if (child.nodeType === 1 && !util2.isBreak(child)) coverNode = vNode;
            }
            recursionFunc(child, coverNode);
          }
        })(element, pNode);
        if (isRemoveNode && !isRemoveFormat && !_removeCheck.v) {
          return {
            ancestor: element,
            container: startCon,
            offset: startOff,
            endContainer: _endContainer
          };
        }
        isRemoveFormat = isRemoveFormat && isRemoveNode;
        if (isRemoveFormat) {
          for (let i = 0; i < nNodeArray.length; i++) {
            let removeNode = nNodeArray[i];
            const rChildren = removeNode.childNodes;
            const textNode = rChildren[0];
            while (rChildren[0]) {
              pNode.insertBefore(rChildren[0], removeNode);
            }
            util2.removeItem(removeNode);
            if (i === 0) container = textNode;
          }
        } else if (isRemoveNode) {
          newInnerNode = newInnerNode.firstChild;
          for (let i = 0; i < nNodeArray.length; i++) {
            this._stripRemoveNode(nNodeArray[i]);
          }
        }
        if (!isRemoveFormat && pNode.childNodes.length === 0) {
          if (element.childNodes) {
            container = element.childNodes[0];
          } else {
            container = util2.createTextNode(util2.zeroWidthSpace);
            element.appendChild(container);
          }
        } else {
          util2.removeEmptyNode(pNode, newInnerNode, false);
          if (util2.onlyZeroWidthSpace(pNode.textContent)) {
            container = pNode.firstChild;
            offset = 0;
          }
          const offsets = { s: 0, e: 0 };
          const path = util2.getNodePath(container, pNode, offsets);
          offset += offsets.s;
          const newOffsets = util2.mergeSameTags(pNode, [path], true);
          element.parentNode.replaceChild(pNode, element);
          container = util2.getNodeFromPath(path, pNode);
          offset += newOffsets[0];
        }
        return {
          ancestor: pNode,
          container,
          offset,
          endContainer: _endContainer
        };
      },
      /**
       * @description wraps mid lines selected text.
       * @param {Element} element The node of the line that contains the selected text node.
       * @param {Element} newInnerNode The dom that will wrap the selected text area
       * @param {Function} validation Check if the node should be stripped.
       * @param {Boolean} isRemoveFormat Is the remove all formats command?
       * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
       * @param {Node} _endContainer Offset node of last line already modified (end.container)
       * @returns {Object} { ancestor, endContainer: "If end container is renewed, returned renewed node" }
       * @private
       */
      _nodeChange_middleLine: function(element, newInnerNode, validation, isRemoveFormat, isRemoveNode, _removeCheck, _endContainer) {
        if (!isRemoveNode) {
          let endPath = null;
          if (_endContainer && element.contains(_endContainer)) endPath = util2.getNodePath(_endContainer, element);
          const tempNode = element.cloneNode(true);
          const newNodeName = newInnerNode.nodeName;
          const newCssText = newInnerNode.style.cssText;
          const newClass = newInnerNode.className;
          let children4 = tempNode.childNodes;
          let i = 0, len = children4.length;
          for (let child; i < len; i++) {
            child = children4[i];
            if (child.nodeType === 3) break;
            if (child.nodeName === newNodeName) {
              child.style.cssText += newCssText;
              util2.addClass(child, newClass);
            } else if (!util2.isBreak(child) && util2._isIgnoreNodeChange(child)) {
              continue;
            } else if (len === 1) {
              children4 = child.childNodes;
              len = children4.length;
              i = -1;
              continue;
            } else {
              break;
            }
          }
          if (len > 0 && i === len) {
            element.innerHTML = tempNode.innerHTML;
            return {
              ancestor: element,
              endContainer: endPath ? util2.getNodeFromPath(endPath, element) : null
            };
          }
        }
        _removeCheck.v = false;
        const pNode = element.cloneNode(false);
        const nNodeArray = [newInnerNode];
        let noneChange = true;
        (function recursionFunc(current, ancestor) {
          const childNodes = current.childNodes;
          for (let i = 0, len = childNodes.length, vNode, cloneChild; i < len; i++) {
            let child = childNodes[i];
            if (!child) continue;
            let coverNode = ancestor;
            if (!util2.isBreak(child) && util2._isIgnoreNodeChange(child)) {
              if (newInnerNode.childNodes.length > 0) {
                pNode.appendChild(newInnerNode);
                newInnerNode = newInnerNode.cloneNode(false);
              }
              cloneChild = child.cloneNode(true);
              pNode.appendChild(cloneChild);
              pNode.appendChild(newInnerNode);
              nNodeArray.push(newInnerNode);
              ancestor = newInnerNode;
              if (_endContainer && child.contains(_endContainer)) {
                const endPath = util2.getNodePath(_endContainer, child);
                _endContainer = util2.getNodeFromPath(endPath, cloneChild);
              }
              continue;
            } else {
              vNode = validation(child);
              if (vNode) {
                noneChange = false;
                ancestor.appendChild(vNode);
                if (child.nodeType === 1) coverNode = vNode;
              }
            }
            if (!util2.isBreak(child)) recursionFunc(child, coverNode);
          }
        })(element, newInnerNode);
        if (noneChange || isRemoveNode && !isRemoveFormat && !_removeCheck.v) return { ancestor: element, endContainer: _endContainer };
        pNode.appendChild(newInnerNode);
        if (isRemoveFormat && isRemoveNode) {
          for (let i = 0; i < nNodeArray.length; i++) {
            let removeNode = nNodeArray[i];
            const rChildren = removeNode.childNodes;
            while (rChildren[0]) {
              pNode.insertBefore(rChildren[0], removeNode);
            }
            util2.removeItem(removeNode);
          }
        } else if (isRemoveNode) {
          newInnerNode = newInnerNode.firstChild;
          for (let i = 0; i < nNodeArray.length; i++) {
            this._stripRemoveNode(nNodeArray[i]);
          }
        }
        util2.removeEmptyNode(pNode, newInnerNode, false);
        util2.mergeSameTags(pNode, null, true);
        element.parentNode.replaceChild(pNode, element);
        return { ancestor: pNode, endContainer: _endContainer };
      },
      /**
       * @description wraps last line selected text.
       * @param {Element} element The node of the line that contains the selected text node.
       * @param {Element} newInnerNode The dom that will wrap the selected text area
       * @param {Function} validation Check if the node should be stripped.
       * @param {Node} endCon The endContainer property of the selection object.
       * @param {Number} endOff The endOffset property of the selection object.
       * @param {Boolean} isRemoveFormat Is the remove all formats command?
       * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
       * @returns {Object} { ancestor, container, offset }
       * @private
       */
      _nodeChange_endLine: function(element, newInnerNode, validation, endCon, endOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode) {
        let parentCon = endCon.parentNode;
        while (!parentCon.nextSibling && !parentCon.previousSibling && !util2.isFormatElement(parentCon.parentNode) && !util2.isWysiwygDiv(parentCon.parentNode)) {
          if (parentCon.nodeName === newInnerNode.nodeName) break;
          parentCon = parentCon.parentNode;
        }
        if (!isRemoveNode && parentCon.nodeName === newInnerNode.nodeName && !util2.isFormatElement(parentCon) && !parentCon.previousSibling && util2.onlyZeroWidthSpace(endCon.textContent.slice(endOff))) {
          let sameTag = true;
          let e = endCon.nextSibling;
          while (e) {
            if (!util2.onlyZeroWidthSpace(e)) {
              sameTag = false;
              break;
            }
            e = e.nextSibling;
          }
          if (sameTag) {
            util2.copyTagAttributes(parentCon, newInnerNode);
            return {
              ancestor: element,
              container: endCon,
              offset: endOff
            };
          }
        }
        _removeCheck.v = false;
        const el = element;
        const nNodeArray = [newInnerNode];
        const pNode = element.cloneNode(false);
        let container = endCon;
        let offset = endOff;
        let passNode = false;
        let pCurrent, newNode, appendNode, anchorNode;
        (function recursionFunc(current, ancestor) {
          const childNodes = current.childNodes;
          for (let i = childNodes.length - 1, vNode; 0 <= i; i--) {
            const child = childNodes[i];
            if (!child) continue;
            let coverNode = ancestor;
            if (passNode && !util2.isBreak(child)) {
              if (child.nodeType === 1) {
                if (util2._isIgnoreNodeChange(child)) {
                  newInnerNode = newInnerNode.cloneNode(false);
                  const cloneChild = child.cloneNode(true);
                  pNode.insertBefore(cloneChild, ancestor);
                  pNode.insertBefore(newInnerNode, cloneChild);
                  nNodeArray.push(newInnerNode);
                } else {
                  recursionFunc(child, child);
                }
                continue;
              }
              newNode = child;
              pCurrent = [];
              const anchors = [];
              while (newNode.parentNode !== null && newNode !== el && newNode !== newInnerNode) {
                vNode = validation(newNode);
                if (vNode && newNode.nodeType === 1) {
                  if (_isMaintainedNode(newNode)) {
                    if (!anchorNode) anchors.push(vNode);
                  } else {
                    pCurrent.push(vNode);
                  }
                }
                newNode = newNode.parentNode;
              }
              pCurrent = pCurrent.concat(anchors);
              const isTopNode = pCurrent.length > 0;
              const childNode = pCurrent.pop() || child;
              appendNode = newNode = childNode;
              while (pCurrent.length > 0) {
                newNode = pCurrent.pop();
                appendNode.appendChild(newNode);
                appendNode = newNode;
              }
              if (_isMaintainedNode(newInnerNode.parentNode) && !_isMaintainedNode(childNode)) {
                newInnerNode = newInnerNode.cloneNode(false);
                pNode.insertBefore(newInnerNode, pNode.firstChild);
                nNodeArray.push(newInnerNode);
              }
              if (!anchorNode && _isMaintainedNode(childNode)) {
                newInnerNode = newInnerNode.cloneNode(false);
                const aChildren = childNode.childNodes;
                for (let a = 0, aLen = aChildren.length; a < aLen; a++) {
                  newInnerNode.appendChild(aChildren[a]);
                }
                childNode.appendChild(newInnerNode);
                pNode.insertBefore(childNode, pNode.firstChild);
                nNodeArray.push(newInnerNode);
                if (newInnerNode.children.length > 0) ancestor = newNode;
                else ancestor = newInnerNode;
              } else if (isTopNode) {
                newInnerNode.insertBefore(childNode, newInnerNode.firstChild);
                ancestor = newNode;
              } else {
                ancestor = newInnerNode;
              }
              if (anchorNode && child.nodeType === 3) {
                if (_getMaintainedNode(child)) {
                  const ancestorAnchorNode = util2.getParentElement(ancestor, function(current2) {
                    return this._isMaintainedNode(current2.parentNode) || current2.parentNode === pNode;
                  }.bind(util2));
                  anchorNode.appendChild(ancestorAnchorNode);
                  newInnerNode = ancestorAnchorNode.cloneNode(false);
                  nNodeArray.push(newInnerNode);
                  pNode.insertBefore(newInnerNode, pNode.firstChild);
                } else {
                  anchorNode = null;
                }
              }
            }
            if (!passNode && child === container) {
              anchorNode = _getMaintainedNode(child);
              const afterNode = util2.createTextNode(container.nodeType === 1 ? "" : container.substringData(offset, container.length - offset));
              const textNode = util2.createTextNode(container.nodeType === 1 ? "" : container.substringData(0, offset));
              if (anchorNode) {
                anchorNode = anchorNode.cloneNode(false);
                const a = _getMaintainedNode(ancestor);
                if (a && a.parentNode !== pNode) {
                  let m = a;
                  let p = null;
                  while (m.parentNode !== pNode) {
                    ancestor = p = m.parentNode.cloneNode(false);
                    while (m.childNodes[0]) {
                      p.appendChild(m.childNodes[0]);
                    }
                    m.appendChild(p);
                    m = m.parentNode;
                  }
                  m.parentNode.insertBefore(a, m.parentNode.firstChild);
                }
                anchorNode = anchorNode.cloneNode(false);
              } else if (_isMaintainedNode(newInnerNode.parentNode) && !anchorNode) {
                newInnerNode = newInnerNode.cloneNode(false);
                pNode.appendChild(newInnerNode);
                nNodeArray.push(newInnerNode);
              }
              if (!util2.onlyZeroWidthSpace(afterNode)) {
                ancestor.insertBefore(afterNode, ancestor.firstChild);
              }
              newNode = ancestor;
              pCurrent = [];
              while (newNode !== pNode && newNode !== null) {
                vNode = _isMaintainedNode(newNode) ? null : validation(newNode);
                if (vNode && newNode.nodeType === 1) {
                  pCurrent.push(vNode);
                }
                newNode = newNode.parentNode;
              }
              const childNode = pCurrent.pop() || ancestor;
              appendNode = newNode = childNode;
              while (pCurrent.length > 0) {
                newNode = pCurrent.pop();
                appendNode.appendChild(newNode);
                appendNode = newNode;
              }
              if (childNode !== ancestor) {
                newInnerNode.insertBefore(childNode, newInnerNode.firstChild);
                ancestor = newNode;
              } else {
                ancestor = newInnerNode;
              }
              if (util2.isBreak(child)) newInnerNode.appendChild(child.cloneNode(false));
              if (anchorNode) {
                anchorNode.insertBefore(newInnerNode, anchorNode.firstChild);
                pNode.insertBefore(anchorNode, pNode.firstChild);
                anchorNode = null;
              } else {
                pNode.insertBefore(newInnerNode, pNode.firstChild);
              }
              container = textNode;
              offset = textNode.data.length;
              passNode = true;
              ancestor.insertBefore(container, ancestor.firstChild);
              continue;
            }
            vNode = !passNode ? child.cloneNode(false) : validation(child);
            if (vNode) {
              ancestor.insertBefore(vNode, ancestor.firstChild);
              if (child.nodeType === 1 && !util2.isBreak(child)) coverNode = vNode;
            }
            recursionFunc(child, coverNode);
          }
        })(element, pNode);
        if (isRemoveNode && !isRemoveFormat && !_removeCheck.v) {
          return {
            ancestor: element,
            container: endCon,
            offset: endOff
          };
        }
        isRemoveFormat = isRemoveFormat && isRemoveNode;
        if (isRemoveFormat) {
          for (let i = 0; i < nNodeArray.length; i++) {
            let removeNode = nNodeArray[i];
            const rChildren = removeNode.childNodes;
            let textNode = null;
            while (rChildren[0]) {
              textNode = rChildren[0];
              pNode.insertBefore(textNode, removeNode);
            }
            util2.removeItem(removeNode);
            if (i === nNodeArray.length - 1) {
              container = textNode;
              offset = textNode.textContent.length;
            }
          }
        } else if (isRemoveNode) {
          newInnerNode = newInnerNode.firstChild;
          for (let i = 0; i < nNodeArray.length; i++) {
            this._stripRemoveNode(nNodeArray[i]);
          }
        }
        if (!isRemoveFormat && pNode.childNodes.length === 0) {
          if (element.childNodes) {
            container = element.childNodes[0];
          } else {
            container = util2.createTextNode(util2.zeroWidthSpace);
            element.appendChild(container);
          }
        } else {
          if (!isRemoveNode && newInnerNode.textContent.length === 0) {
            util2.removeEmptyNode(pNode, null, false);
            return {
              ancestor: null,
              container: null,
              offset: 0
            };
          }
          util2.removeEmptyNode(pNode, newInnerNode, false);
          if (util2.onlyZeroWidthSpace(pNode.textContent)) {
            container = pNode.firstChild;
            offset = container.textContent.length;
          } else if (util2.onlyZeroWidthSpace(container)) {
            container = newInnerNode;
            offset = 1;
          }
          const offsets = { s: 0, e: 0 };
          const path = util2.getNodePath(container, pNode, offsets);
          offset += offsets.s;
          const newOffsets = util2.mergeSameTags(pNode, [path], true);
          element.parentNode.replaceChild(pNode, element);
          container = util2.getNodeFromPath(path, pNode);
          offset += newOffsets[0];
        }
        return {
          ancestor: pNode,
          container,
          offset: container.nodeType === 1 && offset === 1 ? container.childNodes.length : offset
        };
      },
      /**
       * @description Run plugin calls and basic commands.
       * @param {String} command Command string
       * @param {String} display Display type string ('command', 'submenu', 'dialog', 'container')
       * @param {Element} target The element of command button
       */
      actionCall: function(command, display, target) {
        if (display) {
          if (/more/i.test(display)) {
            if (target !== this._moreLayerActiveButton) {
              const layer = context.element.toolbar.querySelector("." + command);
              if (layer) {
                if (this._moreLayerActiveButton) this.moreLayerOff();
                this._moreLayerActiveButton = target;
                layer.style.display = "block";
                event._showToolbarBalloon();
                event._showToolbarInline();
              }
              util2.addClass(target, "on");
            } else {
              const layer = context.element.toolbar.querySelector("." + this._moreLayerActiveButton.getAttribute("data-command"));
              if (layer) {
                this.moreLayerOff();
                event._showToolbarBalloon();
                event._showToolbarInline();
              }
            }
            return;
          }
          if (/container/.test(display) && (this._menuTray[command] === null || target !== this.containerActiveButton)) {
            this.callPlugin(command, this.containerOn.bind(this, target), target);
            return;
          }
          if (this.isReadOnly && util2.arrayIncludes(this.resizingDisabledButtons, target)) return;
          if (/submenu/.test(display) && (this._menuTray[command] === null || target !== this.submenuActiveButton)) {
            this.callPlugin(command, this.submenuOn.bind(this, target), target);
            return;
          } else if (/dialog/.test(display)) {
            this.callPlugin(command, this.plugins[command].open.bind(this), target);
            return;
          } else if (/command/.test(display)) {
            this.callPlugin(command, this.plugins[command].action.bind(this), target);
          } else if (/fileBrowser/.test(display)) {
            this.callPlugin(command, this.plugins[command].open.bind(this, null), target);
          }
        } else if (command) {
          this.commandHandler(target, command);
        }
        if (/submenu/.test(display)) {
          this.submenuOff();
        } else if (!/command/.test(display)) {
          this.submenuOff();
          this.containerOff();
        }
      },
      /**
       * @description Execute command of command button(All Buttons except submenu and dialog)
       * (selectAll, codeView, fullScreen, indent, outdent, undo, redo, removeFormat, print, preview, showBlocks, save, bold, underline, italic, strike, subscript, superscript, copy, cut, paste)
       * @param {Element|null} target The element of command button
       * @param {String} command Property of command button (data-value)
       */
      commandHandler: function(target, command) {
        if (core.isReadOnly && !/copy|cut|selectAll|codeView|fullScreen|print|preview|showBlocks/.test(command)) return;
        switch (command) {
          case "copy":
          case "cut":
            this.execCommand(command);
            break;
          case "paste":
            break;
          case "selectAll":
            this.containerOff();
            const wysiwyg = context.element.wysiwyg;
            let first = util2.getChildElement(wysiwyg.firstChild, function(current) {
              return current.childNodes.length === 0 || current.nodeType === 3;
            }, false) || wysiwyg.firstChild;
            let last = util2.getChildElement(wysiwyg.lastChild, function(current) {
              return current.childNodes.length === 0 || current.nodeType === 3;
            }, true) || wysiwyg.lastChild;
            if (!first || !last) return;
            if (util2.isMedia(first)) {
              const info = this.getFileComponent(first);
              const br = util2.createElement("BR");
              const format = util2.createElement(options.defaultTag);
              format.appendChild(br);
              first = info ? info.component : first;
              first.parentNode.insertBefore(format, first);
              first = br;
            }
            if (util2.isMedia(last)) {
              const br = util2.createElement("BR");
              const format = util2.createElement(options.defaultTag);
              format.appendChild(br);
              wysiwyg.appendChild(format);
              last = br;
            }
            event._showToolbarBalloon(this.setRange(first, 0, last, last.textContent.length));
            break;
          case "codeView":
            this.toggleCodeView();
            break;
          case "fullScreen":
            this.toggleFullScreen(target);
            break;
          case "indent":
          case "outdent":
            this.indent(command);
            break;
          case "undo":
            this.history.undo();
            break;
          case "redo":
            this.history.redo();
            break;
          case "removeFormat":
            this.removeFormat();
            this.focus();
            break;
          case "print":
            this.print();
            break;
          case "preview":
            this.preview();
            break;
          case "showBlocks":
            this.toggleDisplayBlocks();
            break;
          case "dir":
            this.setDir(options.rtl ? "ltr" : "rtl");
            break;
          case "dir_ltr":
            this.setDir("ltr");
            break;
          case "dir_rtl":
            this.setDir("rtl");
            break;
          case "save":
            if (typeof options.callBackSave === "function") {
              options.callBackSave(this.getContents(false), this._variable.isChanged);
            } else if (this._variable.isChanged && typeof functions.save === "function") {
              functions.save();
            } else {
              throw Error("[SUNEDITOR.core.commandHandler.fail] Please register call back function in creation option. (callBackSave : Function)");
            }
            this._variable.isChanged = false;
            if (context.tool.save) context.tool.save.setAttribute("disabled", true);
            break;
          default:
            command = options._defaultCommand[command.toLowerCase()] || command;
            if (!this.commandMap[command]) this.commandMap[command] = target;
            const nodesMap = this._variable.currentNodesMap;
            const cmd = nodesMap.indexOf(command) > -1 ? null : util2.createElement(command);
            let removeNode = command;
            if (/^SUB$/i.test(command) && nodesMap.indexOf("SUP") > -1) {
              removeNode = "SUP";
            } else if (/^SUP$/i.test(command) && nodesMap.indexOf("SUB") > -1) {
              removeNode = "SUB";
            }
            this.nodeChange(cmd, this._commandMapStyles[command] || null, [removeNode], false);
            this.focus();
        }
      },
      /**
       * @description Remove format of the currently selected range
       */
      removeFormat: function() {
        this.nodeChange(null, null, null, null);
      },
      /**
       * @description This method implements indentation to selected range.
       * Setted "margin-left" to "25px" in the top "P" tag of the parameter node.
       * @param {String} command Separator ("indent" or "outdent")
       */
      indent: function(command) {
        const range = this.getRange();
        const rangeLines = this.getSelectedElements(null);
        const cells = [];
        const shift = "indent" !== command;
        const marginDir = options.rtl ? "marginRight" : "marginLeft";
        let sc = range.startContainer;
        let ec = range.endContainer;
        let so = range.startOffset;
        let eo = range.endOffset;
        for (let i = 0, len = rangeLines.length, f, margin; i < len; i++) {
          f = rangeLines[i];
          if (!util2.isListCell(f) || !this.plugins.list) {
            margin = /\d+/.test(f.style[marginDir]) ? util2.getNumber(f.style[marginDir], 0) : 0;
            if (shift) {
              margin -= 25;
            } else {
              margin += 25;
            }
            util2.setStyle(f, marginDir, margin <= 0 ? "" : margin + "px");
          } else {
            if (shift || f.previousElementSibling) {
              cells.push(f);
            }
          }
        }
        if (cells.length > 0) {
          this.plugins.list.editInsideList.call(this, shift, cells);
        }
        this.effectNode = null;
        this.setRange(sc, so, ec, eo);
        this.history.push(false);
      },
      /**
       * @description Add or remove the class name of "body" so that the code block is visible
       */
      toggleDisplayBlocks: function() {
        const wysiwyg = context.element.wysiwyg;
        util2.toggleClass(wysiwyg, "se-show-block");
        if (util2.hasClass(wysiwyg, "se-show-block")) {
          util2.addClass(this._styleCommandMap.showBlocks, "active");
        } else {
          util2.removeClass(this._styleCommandMap.showBlocks, "active");
        }
        this._resourcesStateChange();
      },
      /**
       * @description Changes to code view or wysiwyg view
       */
      toggleCodeView: function() {
        const isCodeView = this._variable.isCodeView;
        this.controllersOff();
        util2.setDisabledButtons(!isCodeView, this.codeViewDisabledButtons);
        if (isCodeView) {
          if (!util2.isNonEditable(context.element.wysiwygFrame)) this._setCodeDataToEditor();
          context.element.wysiwygFrame.scrollTop = 0;
          context.element.code.style.display = "none";
          context.element.wysiwygFrame.style.display = "block";
          this._variable._codeOriginCssText = this._variable._codeOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, "display: none");
          this._variable._wysiwygOriginCssText = this._variable._wysiwygOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, "display: block");
          if (options.height === "auto" && !options.codeMirrorEditor) context.element.code.style.height = "0px";
          this._variable.isCodeView = false;
          if (!this._variable.isFullScreen) {
            this._notHideToolbar = false;
            if (/balloon|balloon-always/i.test(options.mode)) {
              context.element._arrow.style.display = "";
              this._isInline = false;
              this._isBalloon = true;
              event._hideToolbar();
            }
          }
          this.nativeFocus();
          util2.removeClass(this._styleCommandMap.codeView, "active");
          if (!util2.isNonEditable(context.element.wysiwygFrame)) {
            this.history.push(false);
            this.history._resetCachingButton();
          }
        } else {
          this._setEditorDataToCodeView();
          this._variable._codeOriginCssText = this._variable._codeOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, "display: block");
          this._variable._wysiwygOriginCssText = this._variable._wysiwygOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, "display: none");
          if (this._variable.isFullScreen) context.element.code.style.height = "100%";
          else if (options.height === "auto" && !options.codeMirrorEditor) context.element.code.style.height = context.element.code.scrollHeight > 0 ? context.element.code.scrollHeight + "px" : "auto";
          if (options.codeMirrorEditor) options.codeMirrorEditor.refresh();
          this._variable.isCodeView = true;
          if (!this._variable.isFullScreen) {
            this._notHideToolbar = true;
            if (this._isBalloon) {
              context.element._arrow.style.display = "none";
              context.element.toolbar.style.left = "";
              this._isInline = true;
              this._isBalloon = false;
              event._showToolbarInline();
            }
          }
          this._variable._range = null;
          context.element.code.focus();
          util2.addClass(this._styleCommandMap.codeView, "active");
        }
        this._checkPlaceholder();
        if (this.isReadOnly) util2.setDisabledButtons(true, this.resizingDisabledButtons);
        if (typeof functions.toggleCodeView === "function") functions.toggleCodeView(this._variable.isCodeView, this);
      },
      /**
       * @description Convert the data of the code view and put it in the WYSIWYG area.
       * @private
       */
      _setCodeDataToEditor: function() {
        const code_html = this._getCodeView();
        if (options.fullPage) {
          const parseDocument = this._parser.parseFromString(code_html, "text/html");
          if (!this.options.__allowedScriptTag) {
            const headChildren = parseDocument.head.children;
            for (let i = 0, len = headChildren.length; i < len; i++) {
              if (/^script$/i.test(headChildren[i].tagName)) {
                parseDocument.head.removeChild(headChildren[i]);
                i--, len--;
              }
            }
          }
          let headers = parseDocument.head.innerHTML;
          if (!parseDocument.head.querySelector('link[rel="stylesheet"]') || this.options.height === "auto" && !parseDocument.head.querySelector("style")) {
            headers += util2._setIframeCssTags(this.options);
          }
          this._wd.head.innerHTML = headers;
          this._wd.body.innerHTML = this.convertContentsForEditor(parseDocument.body.innerHTML);
          const attrs = parseDocument.body.attributes;
          for (let i = 0, len = attrs.length; i < len; i++) {
            if (attrs[i].name === "contenteditable") continue;
            this._wd.body.setAttribute(attrs[i].name, attrs[i].value);
          }
          if (!util2.hasClass(this._wd.body, "sun-editor-editable")) {
            const editableClasses = options._editableClass.split(" ");
            for (let i = 0; i < editableClasses.length; i++) {
              util2.addClass(this._wd.body, options._editableClass[i]);
            }
          }
        } else {
          context.element.wysiwyg.innerHTML = code_html.length > 0 ? this.convertContentsForEditor(code_html) : "<" + options.defaultTag + "><br></" + options.defaultTag + ">";
        }
      },
      /**
       * @description Convert the data of the WYSIWYG area and put it in the code view area.
       * @private
       */
      _setEditorDataToCodeView: function() {
        const codeContents = this.convertHTMLForCodeView(context.element.wysiwyg, false);
        let codeValue = "";
        if (options.fullPage) {
          const attrs = util2.getAttributesToString(this._wd.body, null);
          codeValue = "<!DOCTYPE html>\n<html>\n" + this._wd.head.outerHTML.replace(/>(?!\n)/g, ">\n") + "<body " + attrs + ">\n" + codeContents + "</body>\n</html>";
        } else {
          codeValue = codeContents;
        }
        context.element.code.style.display = "block";
        context.element.wysiwygFrame.style.display = "none";
        this._setCodeView(codeValue);
      },
      /**
       * @description Changes to full screen or default screen
       * @param {Element|null} element full screen button
       */
      toggleFullScreen: function(element) {
        const topArea = context.element.topArea;
        const toolbar = context.element.toolbar;
        const editorArea = context.element.editorArea;
        const wysiwygFrame = context.element.wysiwygFrame;
        const code = context.element.code;
        const _var = this._variable;
        this.controllersOff();
        const wasToolbarHidden = toolbar.style.display === "none" || this._isInline && !this._inlineToolbarAttr.isShow;
        if (!_var.isFullScreen) {
          _var.isFullScreen = true;
          _var._fullScreenAttrs.inline = this._isInline;
          _var._fullScreenAttrs.balloon = this._isBalloon;
          if (this._isInline || this._isBalloon) {
            this._isInline = false;
            this._isBalloon = false;
          }
          if (!!options.toolbarContainer) context.element.relative.insertBefore(toolbar, editorArea);
          topArea.style.position = "fixed";
          topArea.style.top = "0";
          topArea.style.left = "0";
          topArea.style.width = "100%";
          topArea.style.maxWidth = "100%";
          topArea.style.height = "100%";
          topArea.style.zIndex = "2147483647";
          if (context.element._stickyDummy.style.display !== "") {
            _var._fullScreenAttrs.sticky = true;
            context.element._stickyDummy.style.display = "none";
            util2.removeClass(toolbar, "se-toolbar-sticky");
          }
          _var._bodyOverflow = _d.body.style.overflow;
          _d.body.style.overflow = "hidden";
          _var._editorAreaOriginCssText = editorArea.style.cssText;
          _var._wysiwygOriginCssText = wysiwygFrame.style.cssText;
          _var._codeOriginCssText = code.style.cssText;
          editorArea.style.cssText = toolbar.style.cssText = "";
          wysiwygFrame.style.cssText = (wysiwygFrame.style.cssText.match(/\s?display(\s+)?:(\s+)?[a-zA-Z]+;/) || [""])[0] + options._editorStyles.editor;
          code.style.cssText = (code.style.cssText.match(/\s?display(\s+)?:(\s+)?[a-zA-Z]+;/) || [""])[0];
          toolbar.style.width = wysiwygFrame.style.height = code.style.height = "100%";
          toolbar.style.position = "relative";
          toolbar.style.display = "block";
          _var.innerHeight_fullScreen = _w.innerHeight - toolbar.offsetHeight;
          editorArea.style.height = _var.innerHeight_fullScreen - options.fullScreenOffset + "px";
          if (element) util2.changeElement(element.firstElementChild, icons.reduction);
          if (options.iframe && options.height === "auto") {
            editorArea.style.overflow = "auto";
            this._iframeAutoHeight();
          }
          context.element.topArea.style.marginTop = options.fullScreenOffset + "px";
          util2.addClass(this._styleCommandMap.fullScreen, "active");
        } else {
          _var.isFullScreen = false;
          wysiwygFrame.style.cssText = _var._wysiwygOriginCssText;
          code.style.cssText = _var._codeOriginCssText;
          toolbar.style.cssText = "";
          editorArea.style.cssText = _var._editorAreaOriginCssText;
          topArea.style.cssText = _var._originCssText;
          _d.body.style.overflow = _var._bodyOverflow;
          if (options.height === "auto" && !options.codeMirrorEditor) event._codeViewAutoHeight();
          if (!!options.toolbarContainer) options.toolbarContainer.appendChild(toolbar);
          if (options.stickyToolbar > -1) {
            util2.removeClass(toolbar, "se-toolbar-sticky");
          }
          if (_var._fullScreenAttrs.sticky && !options.toolbarContainer) {
            _var._fullScreenAttrs.sticky = false;
            context.element._stickyDummy.style.display = "block";
            util2.addClass(toolbar, "se-toolbar-sticky");
          }
          this._isInline = _var._fullScreenAttrs.inline;
          this._isBalloon = _var._fullScreenAttrs.balloon;
          if (this._isInline) event._showToolbarInline();
          if (!!options.toolbarContainer) util2.removeClass(toolbar, "se-toolbar-balloon");
          event.onScroll_window();
          if (element) util2.changeElement(element.firstElementChild, icons.expansion);
          context.element.topArea.style.marginTop = "";
          util2.removeClass(this._styleCommandMap.fullScreen, "active");
        }
        if (wasToolbarHidden) functions.toolbar.hide();
        if (typeof functions.toggleFullScreen === "function") functions.toggleFullScreen(this._variable.isFullScreen, this);
      },
      /**
       * @description Prints the current contents of the editor.
       */
      print: function() {
        const iframe = util2.createElement("IFRAME");
        iframe.style.display = "none";
        _d.body.appendChild(iframe);
        const contentsHTML = options.printTemplate ? options.printTemplate.replace(/\{\{\s*contents\s*\}\}/i, this.getContents(true)) : this.getContents(true);
        const printDocument = util2.getIframeDocument(iframe);
        const wDoc = this._wd;
        if (options.iframe) {
          const arrts = options._printClass !== null ? 'class="' + options._printClass + '"' : options.fullPage ? util2.getAttributesToString(wDoc.body, ["contenteditable"]) : 'class="' + options._editableClass + '"';
          printDocument.write(
            "<!DOCTYPE html><html><head>" + wDoc.head.innerHTML + "</head><body " + arrts + ">" + contentsHTML + "</body></html>"
          );
        } else {
          const links = _d.head.getElementsByTagName("link");
          const styles = _d.head.getElementsByTagName("style");
          let linkHTML = "";
          for (let i = 0, len = links.length; i < len; i++) {
            linkHTML += links[i].outerHTML;
          }
          for (let i = 0, len = styles.length; i < len; i++) {
            linkHTML += styles[i].outerHTML;
          }
          printDocument.write(
            "<!DOCTYPE html><html><head>" + linkHTML + '</head><body class="' + (options._printClass !== null ? options._printClass : options._editableClass) + '">' + contentsHTML + "</body></html>"
          );
        }
        this.showLoading();
        _w.setTimeout(function() {
          try {
            iframe.focus();
            if (util2.isIE_Edge || util2.isChromium || !!_d.documentMode || !!_w.StyleMedia) {
              try {
                iframe.contentWindow.document.execCommand("print", false, null);
              } catch (e) {
                iframe.contentWindow.print();
              }
            } else {
              iframe.contentWindow.print();
            }
          } catch (error) {
            throw Error("[SUNEDITOR.core.print.fail] error: " + error);
          } finally {
            core.closeLoading();
            util2.removeItem(iframe);
          }
        }, 1e3);
      },
      /**
       * @description Open the preview window.
       */
      preview: function() {
        core.submenuOff();
        core.containerOff();
        core.controllersOff();
        const contentsHTML = options.previewTemplate ? options.previewTemplate.replace(/\{\{\s*contents\s*\}\}/i, this.getContents(true)) : this.getContents(true);
        const windowObject = _w.open("", "_blank");
        windowObject.mimeType = "text/html";
        const wDoc = this._wd;
        if (options.iframe) {
          const arrts = options._printClass !== null ? 'class="' + options._printClass + '"' : options.fullPage ? util2.getAttributesToString(wDoc.body, ["contenteditable"]) : 'class="' + options._editableClass + '"';
          windowObject.document.write(
            "<!DOCTYPE html><html><head>" + wDoc.head.innerHTML + "<style>body {overflow:auto !important; margin: 10px auto !important; height:auto !important; outline:1px dashed #ccc;}</style></head><body " + arrts + ">" + contentsHTML + "</body></html>"
          );
        } else {
          const links = _d.head.getElementsByTagName("link");
          const styles = _d.head.getElementsByTagName("style");
          let linkHTML = "";
          for (let i = 0, len = links.length; i < len; i++) {
            linkHTML += links[i].outerHTML;
          }
          for (let i = 0, len = styles.length; i < len; i++) {
            linkHTML += styles[i].outerHTML;
          }
          windowObject.document.write(
            '<!DOCTYPE html><html><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>' + lang.toolbar.preview + "</title>" + linkHTML + '</head><body class="' + (options._printClass !== null ? options._printClass : options._editableClass) + '" style="margin:10px auto !important; height:auto !important; outline:1px dashed #ccc;">' + contentsHTML + "</body></html>"
          );
        }
      },
      /**
       * @description Set direction to "rtl" or "ltr".
       * @param {String} dir "rtl" or "ltr"
       */
      setDir: function(dir) {
        const rtl = dir === "rtl";
        const changeDir = this._prevRtl !== rtl;
        this._prevRtl = options.rtl = rtl;
        if (changeDir) {
          if (this.plugins.align) {
            this.plugins.align.exchangeDir.call(this);
          }
          if (context.tool.indent) util2.changeElement(context.tool.indent.firstElementChild, icons.indent);
          if (context.tool.outdent) util2.changeElement(context.tool.outdent.firstElementChild, icons.outdent);
        }
        const el = context.element;
        if (rtl) {
          util2.addClass(el.topArea, "se-rtl");
          util2.addClass(el.wysiwygFrame, "se-rtl");
        } else {
          util2.removeClass(el.topArea, "se-rtl");
          util2.removeClass(el.wysiwygFrame, "se-rtl");
        }
        const lineNodes = util2.getListChildren(el.wysiwyg, function(current) {
          return util2.isFormatElement(current) && (current.style.marginRight || current.style.marginLeft || current.style.textAlign);
        });
        for (let i = 0, len = lineNodes.length, n, l, r; i < len; i++) {
          n = lineNodes[i];
          r = n.style.marginRight;
          l = n.style.marginLeft;
          if (r || l) {
            n.style.marginRight = l;
            n.style.marginLeft = r;
          }
          r = n.style.textAlign;
          if (r === "left") n.style.textAlign = "right";
          else if (r === "right") n.style.textAlign = "left";
        }
        const tool = context.tool;
        if (tool.dir) {
          util2.changeTxt(tool.dir.querySelector(".se-tooltip-text"), lang.toolbar[options.rtl ? "dir_ltr" : "dir_rtl"]);
          util2.changeElement(tool.dir.firstElementChild, icons[options.rtl ? "dir_ltr" : "dir_rtl"]);
        }
        if (tool.dir_ltr) {
          if (rtl) util2.removeClass(tool.dir_ltr, "active");
          else util2.addClass(tool.dir_ltr, "active");
        }
        if (tool.dir_rtl) {
          if (rtl) util2.addClass(tool.dir_rtl, "active");
          else util2.removeClass(tool.dir_rtl, "active");
        }
      },
      /**
       * @description Sets the HTML string
       * @param {String|undefined} html HTML string
       */
      setContents: function(html) {
        this.removeRange();
        const convertValue = html === null || html === void 0 ? "" : this.convertContentsForEditor(html, null, null);
        if (!this._variable.isCodeView) {
          context.element.wysiwyg.innerHTML = convertValue;
          this._resetComponents();
          this.history.push(false);
        } else {
          const value = this.convertHTMLForCodeView(convertValue, false);
          this._setCodeView(value);
        }
      },
      /**
       * @description Sets the contents of the iframe's head tag and body tag when using the "iframe" or "fullPage" option.
       * @param {Object} ctx { head: HTML string, body: HTML string}
       */
      setIframeContents: function(ctx) {
        if (!options.iframe) return false;
        if (ctx.head) this._wd.head.innerHTML = this.options.__allowedScriptTag ? ctx.head : ctx.head.replace(this.__scriptTagRegExp, "");
        if (ctx.body) this._wd.body.innerHTML = this.convertContentsForEditor(ctx.body);
        this._resetComponents();
      },
      /**
       * @description Gets the current contents
       * @param {Boolean} onlyContents Return only the contents of the body without headers when the "fullPage" option is true
       * @returns {Object}
       */
      getContents: function(onlyContents) {
        const contents = this.cleanHTML(context.element.wysiwyg.innerHTML, null, null);
        const renderHTML = util2.createElement("DIV");
        renderHTML.innerHTML = contents;
        const editableEls = util2.getListChildren(renderHTML, function(current) {
          return current.hasAttribute("contenteditable");
        });
        for (let i = 0, len = editableEls.length; i < len; i++) {
          editableEls[i].removeAttribute("contenteditable");
        }
        if (options.fullPage && !onlyContents) {
          const attrs = util2.getAttributesToString(this._wd.body, ["contenteditable"]);
          return "<!DOCTYPE html><html>" + this._wd.head.outerHTML + "<body " + attrs + ">" + renderHTML.innerHTML + "</body></html>";
        } else {
          return renderHTML.innerHTML;
        }
      },
      /**
       * @description Gets the current contents with containing parent div(div.sun-editor-editable).
       * <div class="sun-editor-editable">{contents}</div>
       * @param {Boolean} onlyContents Return only the contents of the body without headers when the "fullPage" option is true
       * @returns {String}
       */
      getFullContents: function(onlyContents) {
        return '<div class="sun-editor-editable' + (options.rtl ? " se-rtl" : "") + '">' + this.getContents(onlyContents) + "</div>";
      },
      /**
       * @description Returns HTML string according to tag type and configuration.
       * Use only "cleanHTML"
       * @param {Node} node Node
       * @param {Boolean} requireFormat If true, text nodes that do not have a format node is wrapped with the format tag.
       * @private
       */
      _makeLine: function(node, requireFormat) {
        const defaultTag = options.defaultTag;
        if (node.nodeType === 1) {
          if (this.__disallowedTagNameRegExp.test(node.nodeName)) return "";
          if (/__se__tag/.test(node.className)) return node.outerHTML;
          const ch = util2.getListChildNodes(node, function(current) {
            return util2.isSpanWithoutAttr(current) && !util2.getParentElement(current, util2.isNotCheckingNode);
          }) || [];
          for (let i = ch.length - 1; i >= 0; i--) {
            ch[i].outerHTML = ch[i].innerHTML;
          }
          if (!requireFormat || (util2.isFormatElement(node) || util2.isRangeFormatElement(node) || util2.isComponent(node) || util2.isFigures(node) || util2.isAnchor(node) && util2.isMedia(node.firstElementChild))) {
            return util2.isSpanWithoutAttr(node) ? node.innerHTML : node.outerHTML;
          } else {
            return "<" + defaultTag + ">" + (util2.isSpanWithoutAttr(node) ? node.innerHTML : node.outerHTML) + "</" + defaultTag + ">";
          }
        }
        if (node.nodeType === 3) {
          if (!requireFormat) return util2._HTMLConvertor(node.textContent);
          const textArray = node.textContent.split(/\n/g);
          let html = "";
          for (let i = 0, tLen = textArray.length, text; i < tLen; i++) {
            text = textArray[i].trim();
            if (text.length > 0) html += "<" + defaultTag + ">" + util2._HTMLConvertor(text) + "</" + defaultTag + ">";
          }
          return html;
        }
        if (node.nodeType === 8 && this._allowHTMLComments) {
          return "<!--" + node.textContent.trim() + "-->";
        }
        return "";
      },
      /**
       * @description Removes attribute values such as style and converts tags that do not conform to the "html5" standard.
       * @param {String} text 
       * @returns {String} HTML string
       * @private
       */
      _tagConvertor: function(text) {
        if (!this._disallowedTextTagsRegExp) return text;
        const ec = options._textTagsMap;
        return text.replace(this._disallowedTextTagsRegExp, function(m, t, n, p) {
          return t + (typeof ec[n] === "string" ? ec[n] : n) + (p ? " " + p : "");
        });
      },
      /**
       * @description Delete disallowed tags
       * @param {String} html HTML string
       * @returns {String}
       * @private
       */
      _deleteDisallowedTags: function(html) {
        html = html.replace(this.__disallowedTagsRegExp, "").replace(/<[a-z0-9]+\:[a-z0-9]+[^>^\/]*>[^>]*<\/[a-z0-9]+\:[a-z0-9]+>/gi, "");
        if (!/\bfont\b/i.test(this.options._editorTagsWhitelist)) {
          html = html.replace(/(<\/?)font(\s?)/gi, "$1span$2");
        }
        return html.replace(this.editorTagsWhitelistRegExp, "").replace(this.editorTagsBlacklistRegExp, "");
      },
      _convertFontSize: function(to, size) {
        const math = this._w.Math;
        const value = size.match(/(\d+(?:\.\d+)?)(.+)/);
        const sizeNum = value ? value[1] * 1 : util2.fontValueMap[size];
        const from = value ? value[2] : "rem";
        let pxSize = sizeNum;
        if (/em/.test(from)) {
          pxSize = math.round(sizeNum / 0.0625);
        } else if (from === "pt") {
          pxSize = math.round(sizeNum * 1.333);
        } else if (from === "%") {
          pxSize = sizeNum / 100;
        }
        switch (to) {
          case "em":
          case "rem":
          case "%":
            return (pxSize * 0.0625).toFixed(2) + to;
          case "pt":
            return math.floor(pxSize / 1.333) + to;
          default:
            return pxSize + to;
        }
      },
      _cleanStyle: function(m, v, name2) {
        let sv = (m.match(/style\s*=\s*(?:"|')[^"']*(?:"|')/) || [])[0];
        if (/span/i.test(name2) && !sv && (m.match(/<[^\s]+\s(.+)/) || [])[1]) {
          const size = (m.match(/\ssize="([^"]+)"/i) || [])[1];
          const face = (m.match(/\sface="([^"]+)"/i) || [])[1];
          const color = (m.match(/\scolor="([^"]+)"/i) || [])[1];
          if (size || face || color) {
            sv = 'style="' + (size ? "font-size:" + this.util.getNumber(size / 3.333, 1) + "rem;" : "") + (face ? "font-family:" + face + ";" : "") + (color ? "color:" + color + ";" : "") + '"';
          }
        }
        if (sv) {
          if (!v) v = [];
          const style = sv.replace(/&quot;/g, "").match(this._cleanStyleRegExp[name2]);
          if (style) {
            const allowedStyle = [];
            for (let i = 0, len = style.length, r; i < len; i++) {
              r = style[i].match(/([a-zA-Z0-9-]+)(:)([^"']+)/);
              if (r && !/inherit|initial|revert|unset/i.test(r[3])) {
                const k = util2.kebabToCamelCase(r[1].trim());
                const v2 = this.wwComputedStyle[k] ? this.wwComputedStyle[k].replace(/"/g, "") : "";
                const c = r[3].trim();
                switch (k) {
                  case "fontFamily":
                    if (!options.plugins.font || options.font.indexOf(c) === -1) continue;
                    break;
                  case "fontSize":
                    if (!options.plugins.fontSize) continue;
                    if (!this._cleanStyleRegExp.fontSizeUnit.test(r[0])) {
                      r[0] = r[0].replace((r[0].match(/:\s*([^;]+)/) || [])[1], this._convertFontSize.bind(this, options.fontSizeUnit));
                    }
                    break;
                  case "color":
                    if (!options.plugins.fontColor || /rgba\(([0-9]+\s*,\s*){3}0\)|windowtext/i.test(c)) continue;
                    break;
                  case "backgroundColor":
                    if (!options.plugins.hiliteColor || /rgba\(([0-9]+\s*,\s*){3}0\)|windowtext/i.test(c)) continue;
                    break;
                }
                if (v2 !== c) {
                  allowedStyle.push(r[0]);
                }
              }
            }
            if (allowedStyle.length > 0) v.push('style="' + allowedStyle.join(";") + '"');
          }
        }
        return v;
      },
      /**
       * @description Tag and tag attribute check RegExp function. (used by "cleanHTML" and "convertContentsForEditor")
       * @param {Boolean} lowLevelCheck Row level check
       * @param {String} m RegExp value
       * @param {String} t RegExp value
       * @returns {String}
       * @private
       */
      _cleanTags: function(lowLevelCheck, m, t) {
        if (/^<[a-z0-9]+\:[a-z0-9]+/i.test(m)) return m;
        let v = null;
        const tagName = t.match(/(?!<)[a-zA-Z0-9\-]+/)[0].toLowerCase();
        const bAttr = this._attributesTagsBlacklist[tagName];
        m = m.replace(/\s(?:on[a-z]+)\s*=\s*(")[^"]*\1/ig, "");
        if (bAttr) m = m.replace(bAttr, "");
        else m = m.replace(this._attributesBlacklistRegExp, "");
        const wAttr = this._attributesTagsWhitelist[tagName];
        if (wAttr) v = m.match(wAttr);
        else v = m.match(lowLevelCheck ? this._attributesWhitelistRegExp : this._attributesWhitelistRegExp_all_data);
        if (lowLevelCheck || tagName === "span" || tagName === "li" || this._cleanStyleRegExp[tagName]) {
          if (tagName === "a") {
            const sv = m.match(/(?:(?:id|name)\s*=\s*(?:"|')[^"']*(?:"|'))/g);
            if (sv) {
              if (!v) v = [];
              v.push(sv[0]);
            }
          } else if (!v || !/style=/i.test(v.toString())) {
            if (tagName === "span" || tagName === "li") {
              v = this._cleanStyle(m, v, "span");
            }
            if (this._cleanStyleRegExp[tagName]) {
              v = this._cleanStyle(m, v, tagName);
            } else if (/^(P|DIV|H[1-6]|PRE)$/i.test(tagName)) {
              v = this._cleanStyle(m, v, "format");
            }
          }
        } else {
          const sv = m.match(/style\s*=\s*(?:"|')[^"']*(?:"|')/);
          if (sv && !v) v = [sv[0]];
          else if (sv && !v.some(function(v2) {
            return /^style/.test(v2.trim());
          })) v.push(sv[0]);
        }
        if (util2.isFigures(tagName)) {
          const sv = m.match(/style\s*=\s*(?:"|')[^"']*(?:"|')/);
          if (!v) v = [];
          if (sv) v.push(sv[0]);
        }
        if (v) {
          for (let i = 0, len = v.length, a; i < len; i++) {
            a = /^(?:href|src)\s*=\s*('|"|\s)*javascript\s*\:/i.test(v[i].trim()) ? "" : v[i];
            t += (/^\s/.test(a) ? "" : " ") + a;
          }
        }
        return t;
      },
      /**
       * @description Determines if formatting is required and returns a domTree
       * @param {Element} dom documentFragment
       * @returns {Element}
       * @private
       */
      _editFormat: function(dom) {
        let value = "", f;
        const tempTree = dom.childNodes;
        for (let i = 0, len = tempTree.length, n; i < len; i++) {
          n = tempTree[i];
          if (n.nodeType === 8) {
            value += "<!-- " + n.textContent + " -->";
          } else if (!util2.isFormatElement(n) && !util2.isRangeFormatElement(n) && !util2.isComponent(n) && !/meta/i.test(n.nodeName)) {
            if (!f) f = util2.createElement(options.defaultTag);
            f.appendChild(n);
            i--;
            len--;
          } else {
            if (f) {
              value += f.outerHTML;
              f = null;
            }
            value += n.outerHTML;
          }
        }
        if (f) value += f.outerHTML;
        return _d.createRange().createContextualFragment(value);
      },
      _convertListCell: function(domTree) {
        let html = "";
        for (let i = 0, len = domTree.length, node; i < len; i++) {
          node = domTree[i];
          if (node.nodeType === 1) {
            if (util2.isList(node)) {
              html += node.innerHTML;
            } else if (util2.isListCell(node)) {
              html += node.outerHTML;
            } else if (util2.isFormatElement(node)) {
              html += "<li>" + (node.innerHTML.trim() || "<br>") + "</li>";
            } else if (util2.isRangeFormatElement(node) && !util2.isTable(node)) {
              html += this._convertListCell(node);
            } else {
              html += "<li>" + node.outerHTML + "</li>";
            }
          } else {
            html += "<li>" + (node.textContent || "<br>") + "</li>";
          }
        }
        return html;
      },
      _isFormatData: function(domTree) {
        let requireFormat = false;
        for (let i = 0, len = domTree.length, t; i < len; i++) {
          t = domTree[i];
          if (t.nodeType === 1 && !util2.isTextStyleElement(t) && !util2.isBreak(t) && !this.__disallowedTagNameRegExp.test(t.nodeName)) {
            requireFormat = true;
            break;
          }
        }
        return requireFormat;
      },
      /**
       * @description Gets the clean HTML code for editor
       * @param {String} html HTML string
       * @param {String|RegExp|null} whitelist Regular expression of allowed tags.
       * RegExp object is create by util.createTagsWhitelist method. (core.pasteTagsWhitelistRegExp)
       * @param {String|RegExp|null} blacklist Regular expression of disallowed tags.
       * RegExp object is create by util.createTagsBlacklist method. (core.pasteTagsBlacklistRegExp)
       * @returns {String}
       */
      cleanHTML: function(html, whitelist, blacklist) {
        if (!options.strictMode) return html;
        html = this._deleteDisallowedTags(this._parser.parseFromString(util2.htmlCompress(html), "text/html").body.innerHTML).replace(/(<[a-zA-Z0-9\-]+)[^>]*(?=>)/g, this._cleanTags.bind(this, true)).replace(/<br\/?>$/i, "");
        const dom = _d.createRange().createContextualFragment(html);
        try {
          util2._consistencyCheckOfHTML(dom, this._htmlCheckWhitelistRegExp, this._htmlCheckBlacklistRegExp, this._classNameFilter);
        } catch (error) {
          console.warn("[SUNEDITOR.cleanHTML.consistencyCheck.fail] " + error);
        }
        if (this.managedTagsInfo && this.managedTagsInfo.query) {
          const textCompList = dom.querySelectorAll(this.managedTagsInfo.query);
          for (let i = 0, len = textCompList.length, initMethod, classList; i < len; i++) {
            classList = [].slice.call(textCompList[i].classList);
            for (let c = 0, cLen = classList.length; c < cLen; c++) {
              initMethod = this.managedTagsInfo.map[classList[c]];
              if (initMethod) {
                initMethod(textCompList[i]);
                break;
              }
            }
          }
        }
        let domTree = dom.childNodes;
        let cleanHTML = "";
        const requireFormat = this._isFormatData(domTree);
        if (requireFormat) {
          domTree = this._editFormat(dom).childNodes;
        }
        for (let i = 0, len = domTree.length, t; i < len; i++) {
          t = domTree[i];
          if (this.__allowedScriptRegExp.test(t.nodeName)) {
            cleanHTML += t.outerHTML;
            continue;
          }
          cleanHTML += this._makeLine(t, requireFormat);
        }
        cleanHTML = util2.htmlRemoveWhiteSpace(cleanHTML);
        if (!cleanHTML) {
          cleanHTML = html;
        } else {
          if (whitelist) cleanHTML = cleanHTML.replace(typeof whitelist === "string" ? util2.createTagsWhitelist(whitelist) : whitelist, "");
          if (blacklist) cleanHTML = cleanHTML.replace(typeof blacklist === "string" ? util2.createTagsBlacklist(blacklist) : blacklist, "");
        }
        return this._tagConvertor(cleanHTML);
      },
      /**
       * @description Converts contents into a format that can be placed in an editor
       * @param {String} contents contents
       * @returns {String}
       */
      convertContentsForEditor: function(contents) {
        if (!options.strictMode) return contents;
        contents = this._deleteDisallowedTags(this._parser.parseFromString(util2.htmlCompress(contents), "text/html").body.innerHTML).replace(/(<[a-zA-Z0-9\-]+)[^>]*(?=>)/g, this._cleanTags.bind(this, true));
        const dom = _d.createRange().createContextualFragment(contents);
        try {
          util2._consistencyCheckOfHTML(dom, this._htmlCheckWhitelistRegExp, this._htmlCheckBlacklistRegExp, this._classNameFilter);
        } catch (error) {
          console.warn("[SUNEDITOR.convertContentsForEditor.consistencyCheck.fail] " + error);
        }
        if (this.managedTagsInfo && this.managedTagsInfo.query) {
          const textCompList = dom.querySelectorAll(this.managedTagsInfo.query);
          for (let i = 0, len = textCompList.length, initMethod, classList; i < len; i++) {
            classList = [].slice.call(textCompList[i].classList);
            for (let c = 0, cLen = classList.length; c < cLen; c++) {
              initMethod = this.managedTagsInfo.map[classList[c]];
              if (initMethod) {
                initMethod(textCompList[i]);
                break;
              }
            }
          }
        }
        const domTree = dom.childNodes;
        let cleanHTML = "", p = null;
        for (let i = 0, t; i < domTree.length; i++) {
          t = domTree[i];
          if (this.__allowedScriptRegExp.test(t.nodeName)) {
            cleanHTML += t.outerHTML;
            continue;
          }
          if (!util2.isFormatElement(t) && !util2.isRangeFormatElement(t) && !util2.isComponent(t) && !util2.isFigures(t) && t.nodeType !== 8 && !/__se__tag/.test(t.className)) {
            if (!p) p = util2.createElement(options.defaultTag);
            p.appendChild(t);
            i--;
            if (domTree[i + 1] && !util2.isFormatElement(domTree[i + 1])) {
              continue;
            } else {
              t = p;
              p = null;
            }
          }
          if (p) {
            cleanHTML += this._makeLine(p, true);
            p = null;
          }
          cleanHTML += this._makeLine(t, true);
        }
        if (p) cleanHTML += this._makeLine(p, true);
        if (cleanHTML.length === 0) return "<" + options.defaultTag + "><br></" + options.defaultTag + ">";
        cleanHTML = util2.htmlRemoveWhiteSpace(cleanHTML);
        return this._tagConvertor(cleanHTML);
      },
      /**
       * @description Converts wysiwyg area element into a format that can be placed in an editor of code view mode
       * @param {Element|String} html WYSIWYG element (context.element.wysiwyg) or HTML string.
       * @param {Boolean} comp If true, does not line break and indentation of tags.
       * @returns {String}
       */
      convertHTMLForCodeView: function(html, comp) {
        let returnHTML = "";
        const wRegExp = _w.RegExp;
        const brReg = new wRegExp("^(BLOCKQUOTE|PRE|TABLE|THEAD|TBODY|TR|TH|TD|OL|UL|IMG|IFRAME|VIDEO|AUDIO|FIGURE|FIGCAPTION|HR|BR|CANVAS|SELECT)$", "i");
        const wDoc = typeof html === "string" ? _d.createRange().createContextualFragment(html) : html;
        const isFormat = function(current) {
          return this.isFormatElement(current) || this.isComponent(current);
        }.bind(util2);
        const brChar = comp ? "" : "\n";
        let indentSize = comp ? 0 : this._variable.codeIndent * 1;
        indentSize = indentSize > 0 ? new _w.Array(indentSize + 1).join(" ") : "";
        (function recursionFunc(element, indent) {
          const children4 = element.childNodes;
          const elementRegTest = brReg.test(element.nodeName);
          const elementIndent = elementRegTest ? indent : "";
          for (let i = 0, len = children4.length, node, br, lineBR, nodeRegTest, tag, tagIndent; i < len; i++) {
            node = children4[i];
            nodeRegTest = brReg.test(node.nodeName);
            br = nodeRegTest ? brChar : "";
            lineBR = isFormat(node) && !elementRegTest && !/^(TH|TD)$/i.test(element.nodeName) ? brChar : "";
            if (node.nodeType === 8) {
              returnHTML += "\n<!-- " + node.textContent.trim() + " -->" + br;
              continue;
            }
            if (node.nodeType === 3) {
              if (!util2.isList(node.parentElement)) returnHTML += util2._HTMLConvertor(/^\n+$/.test(node.data) ? "" : node.data);
              continue;
            }
            if (node.childNodes.length === 0) {
              returnHTML += (/^HR$/i.test(node.nodeName) ? brChar : "") + (/^PRE$/i.test(node.parentElement.nodeName) && /^BR$/i.test(node.nodeName) ? "" : elementIndent) + node.outerHTML + br;
              continue;
            }
            if (!node.outerHTML) {
              returnHTML += new _w.XMLSerializer().serializeToString(node);
            } else {
              tag = node.nodeName.toLowerCase();
              tagIndent = elementIndent || nodeRegTest ? indent : "";
              returnHTML += (lineBR || (elementRegTest ? "" : br)) + tagIndent + node.outerHTML.match(wRegExp("<" + tag + "[^>]*>", "i"))[0] + br;
              recursionFunc(node, indent + indentSize, "");
              returnHTML += (/\n$/.test(returnHTML) ? tagIndent : "") + "</" + tag + ">" + (lineBR || br || elementRegTest ? brChar : /^(TH|TD)$/i.test(node.nodeName) ? brChar : "");
            }
          }
        })(wDoc, "");
        return returnHTML.trim() + brChar;
      },
      /**
       * @description Add an event to document.
       * When created as an Iframe, the same event is added to the document in the Iframe.
       * @param {String} type Event type
       * @param {Function} listener Event listener
       * @param {Boolean} useCapture Use event capture
       */
      addDocEvent: function(type, listener, useCapture) {
        _d.addEventListener(type, listener, useCapture);
        if (options.iframe) {
          this._wd.addEventListener(type, listener);
        }
      },
      /**
       * @description Remove events from document.
       * When created as an Iframe, the event of the document inside the Iframe is also removed.
       * @param {String} type Event type
       * @param {Function} listener Event listener
       */
      removeDocEvent: function(type, listener) {
        _d.removeEventListener(type, listener);
        if (options.iframe) {
          this._wd.removeEventListener(type, listener);
        }
      },
      /**
       * @description The current number of characters is counted and displayed.
       * @param {String} inputText Text added.
       * @returns {Boolean}
       * @private
       */
      _charCount: function(inputText) {
        const maxCharCount = options.maxCharCount;
        const countType = options.charCounterType;
        let nextCharCount = 0;
        if (!!inputText) nextCharCount = this.getCharLength(inputText, countType);
        this._setCharCount();
        if (maxCharCount > 0) {
          let over = false;
          const count = functions.getCharCount(countType);
          if (count > maxCharCount) {
            over = true;
            if (nextCharCount > 0) {
              this._editorRange();
              const range = this.getRange();
              const endOff = range.endOffset - 1;
              const text = this.getSelectionNode().textContent;
              const slicePosition = range.endOffset - (count - maxCharCount);
              this.getSelectionNode().textContent = text.slice(0, slicePosition < 0 ? 0 : slicePosition) + text.slice(range.endOffset, text.length);
              this.setRange(range.endContainer, endOff, range.endContainer, endOff);
            }
          } else if (count + nextCharCount > maxCharCount) {
            over = true;
          }
          if (over) {
            this._callCounterBlink();
            if (nextCharCount > 0) return false;
          }
        }
        return true;
      },
      /**
       * @description When "element" is added, if it is greater than "options.maxCharCount", false is returned.
       * @param {Node|String} element Element node or String.
       * @param {String|null} charCounterType charCounterType. If it is null, the options.charCounterType
       * @returns {Boolean}
       */
      checkCharCount: function(element, charCounterType) {
        if (options.maxCharCount) {
          const countType = charCounterType || options.charCounterType;
          const length = this.getCharLength(typeof element === "string" ? element : this._charTypeHTML && element.nodeType === 1 ? element.outerHTML : element.textContent, countType);
          if (length > 0 && length + functions.getCharCount(countType) > options.maxCharCount) {
            this._callCounterBlink();
            return false;
          }
        }
        return true;
      },
      /**
       * @description Get the length of the content.
       * Depending on the option, the length of the character is taken. (charCounterType)
       * @param {String} content Content to count
       * @param {String} charCounterType options.charCounterType
       * @returns {Number}
       */
      getCharLength: function(content, charCounterType) {
        return /byte/.test(charCounterType) ? util2.getByteLength(content) : content.length;
      },
      /**
       * @description Reset buttons of the responsive toolbar.
       */
      resetResponsiveToolbar: function() {
        core.controllersOff();
        const responsiveSize = event._responsiveButtonSize;
        if (responsiveSize) {
          let w = 0;
          if ((core._isBalloon || core._isInline) && options.toolbarWidth === "auto") {
            w = context.element.topArea.offsetWidth;
          } else {
            w = context.element.toolbar.offsetWidth;
          }
          let responsiveWidth = "default";
          for (let i = 1, len = responsiveSize.length; i < len; i++) {
            if (w < responsiveSize[i]) {
              responsiveWidth = responsiveSize[i] + "";
              break;
            }
          }
          if (event._responsiveCurrentSize !== responsiveWidth) {
            event._responsiveCurrentSize = responsiveWidth;
            functions.setToolbarButtons(event._responsiveButtons[responsiveWidth]);
          }
        }
      },
      /**
       * @description Set the char count to charCounter element textContent.
       * @private
       */
      _setCharCount: function() {
        if (context.element.charCounter) {
          _w.setTimeout(function(functions2, options2) {
            if (this.textContent && functions2) {
              this.textContent = functions2.getCharCount(options2.charCounterType);
            }
          }.bind(context.element.charCounter, functions, options), 0);
        }
      },
      /**
       * @description The character counter blinks.
       * @private
       */
      _callCounterBlink: function() {
        const charWrapper = context.element.charWrapper;
        if (charWrapper && !util2.hasClass(charWrapper, "se-blink")) {
          util2.addClass(charWrapper, "se-blink");
          _w.setTimeout(function() {
            util2.removeClass(charWrapper, "se-blink");
          }, 600);
        }
      },
      /**
       * @description Check the components such as image and video and modify them according to the format.
       * @private
       */
      _checkComponents: function() {
        for (let i = 0, len = this._fileInfoPluginsCheck.length; i < len; i++) {
          this._fileInfoPluginsCheck[i]();
        }
      },
      /**
       * @description Initialize the information of the components.
       * @private
       */
      _resetComponents: function() {
        for (let i = 0, len = this._fileInfoPluginsReset.length; i < len; i++) {
          this._fileInfoPluginsReset[i]();
        }
      },
      /**
       * @description Set method in the code view area
       * @param {String} value HTML string
       * @private
       */
      _setCodeView: function(value) {
        if (options.codeMirrorEditor) {
          options.codeMirrorEditor.getDoc().setValue(value);
        } else {
          context.element.code.value = value;
        }
      },
      /**
       * @description Get method in the code view area
       * @private
       */
      _getCodeView: function() {
        return options.codeMirrorEditor ? options.codeMirrorEditor.getDoc().getValue() : context.element.code.value;
      },
      /**
       * @description remove class, display text.
       * @param {Array|null} ignoredList Igonred button list
       */
      _setKeyEffect: function(ignoredList) {
        const commandMap = this.commandMap;
        const activePlugins = this.activePlugins;
        for (let key in commandMap) {
          if (ignoredList.indexOf(key) > -1 || !util2.hasOwn(commandMap, key)) continue;
          if (activePlugins.indexOf(key) > -1) {
            plugins[key].active.call(this, null);
          } else if (commandMap.OUTDENT && /^OUTDENT$/i.test(key)) {
            if (!util2.isImportantDisabled(commandMap.OUTDENT)) commandMap.OUTDENT.setAttribute("disabled", true);
          } else if (commandMap.INDENT && /^INDENT$/i.test(key)) {
            if (!util2.isImportantDisabled(commandMap.INDENT)) commandMap.INDENT.removeAttribute("disabled");
          } else {
            util2.removeClass(commandMap[key], "active");
          }
        }
      },
      /**
       * @description Initializ core variable
       * @param {Boolean} reload Is relooad?
       * @param {String} _initHTML initial html string
       * @private
       */
      _init: function(reload, _initHTML) {
        const wRegExp = _w.RegExp;
        this._ww = options.iframe ? context.element.wysiwygFrame.contentWindow : _w;
        this._wd = _d;
        this._charTypeHTML = options.charCounterType === "byte-html";
        this.wwComputedStyle = _w.getComputedStyle(context.element.wysiwyg);
        this._editorHeight = context.element.wysiwygFrame.offsetHeight;
        this._editorHeightPadding = util2.getNumber(this.wwComputedStyle.getPropertyValue("padding-top")) + util2.getNumber(this.wwComputedStyle.getPropertyValue("padding-bottom"));
        this._classNameFilter = function(v) {
          return this.test(v) ? v : "";
        }.bind(options.allowedClassNames);
        const sPrefix = options.__allowedScriptTag ? "" : "script|";
        this.__scriptTagRegExp = new wRegExp("<(script)[^>]*>([\\s\\S]*?)<\\/\\1>|<script[^>]*\\/?>", "gi");
        this.__disallowedTagsRegExp = new wRegExp("<(" + sPrefix + "style)[^>]*>([\\s\\S]*?)<\\/\\1>|<(" + sPrefix + "style)[^>]*\\/?>", "gi");
        this.__disallowedTagNameRegExp = new wRegExp("^(" + sPrefix + "meta|link|style|[a-z]+:[a-z]+)$", "i");
        this.__allowedScriptRegExp = new wRegExp("^" + (options.__allowedScriptTag ? "script" : "") + "$", "i");
        if (!options.iframe && typeof _w.ShadowRoot === "function") {
          let child = context.element.wysiwygFrame;
          while (child) {
            if (child.shadowRoot) {
              this._shadowRoot = child.shadowRoot;
              break;
            } else if (child instanceof _w.ShadowRoot) {
              this._shadowRoot = child;
              break;
            }
            child = child.parentNode;
          }
          if (this._shadowRoot) this._shadowRootControllerEventTarget = [];
        }
        const disallowTextTags = _w.Object.keys(options._textTagsMap);
        const allowTextTags = !options.addTagsWhitelist ? [] : options.addTagsWhitelist.split("|").filter(function(v) {
          return /b|i|ins|s|strike/i.test(v);
        });
        for (let i = 0; i < allowTextTags.length; i++) {
          disallowTextTags.splice(disallowTextTags.indexOf(allowTextTags[i].toLowerCase()), 1);
        }
        this._disallowedTextTagsRegExp = disallowTextTags.length === 0 ? null : new wRegExp("(<\\/?)(" + disallowTextTags.join("|") + ")\\b\\s*([^>^<]+)?\\s*(?=>)", "gi");
        const getRegList = function(str, str2) {
          return !str ? "^" : str === "*" ? "[a-z-]+" : !str2 ? str : str + "|" + str2;
        };
        const videoAttr = "|controls|autoplay|loop|muted|poster|preload|playsinline";
        const iframeAttr = "|allowfullscreen|sandbox|loading|allow|referrerpolicy|frameborder|scrolling";
        const defaultAttr = "contenteditable|colspan|rowspan|target|href|download|rel|src|alt|class|type|origin-size" + videoAttr + iframeAttr;
        const dataAttr = "data-format|data-size|data-file-size|data-file-name|data-origin|data-align|data-image-link|data-rotate|data-proportion|data-percentage|data-exp|data-font-size";
        this._allowHTMLComments = options._editorTagsWhitelist.indexOf("//") > -1 || options._editorTagsWhitelist === "*";
        this._htmlCheckWhitelistRegExp = new wRegExp("^(" + getRegList(options._editorTagsWhitelist.replace("|//", ""), "") + ")$", "i");
        this._htmlCheckBlacklistRegExp = new wRegExp("^(" + (options.tagsBlacklist || "^") + ")$", "i");
        this.editorTagsWhitelistRegExp = util2.createTagsWhitelist(getRegList(options._editorTagsWhitelist.replace("|//", "|<!--|-->"), ""));
        this.editorTagsBlacklistRegExp = util2.createTagsBlacklist(options.tagsBlacklist.replace("|//", "|<!--|-->"));
        this.pasteTagsWhitelistRegExp = util2.createTagsWhitelist(getRegList(options.pasteTagsWhitelist, ""));
        this.pasteTagsBlacklistRegExp = util2.createTagsBlacklist(options.pasteTagsBlacklist);
        const regEndStr = '\\s*=\\s*(")[^"]*\\1';
        const _wAttr = options.attributesWhitelist;
        let tagsAttr = {};
        let allAttr = "";
        if (!!_wAttr) {
          for (let k in _wAttr) {
            if (!util2.hasOwn(_wAttr, k) || /^on[a-z]+$/i.test(_wAttr[k])) continue;
            if (k === "all") {
              allAttr = getRegList(_wAttr[k], defaultAttr);
            } else {
              tagsAttr[k] = new wRegExp("\\s(?:" + getRegList(_wAttr[k], "") + ")" + regEndStr, "ig");
            }
          }
        }
        this._attributesWhitelistRegExp = new wRegExp("\\s(?:" + (allAttr || defaultAttr + "|" + dataAttr) + ")" + regEndStr, "ig");
        this._attributesWhitelistRegExp_all_data = new wRegExp("\\s(?:" + ((allAttr || defaultAttr) + "|data-[a-z0-9\\-]+") + ")" + regEndStr, "ig");
        this._attributesTagsWhitelist = tagsAttr;
        const _bAttr = options.attributesBlacklist;
        tagsAttr = {};
        allAttr = "";
        if (!!_bAttr) {
          for (let k in _bAttr) {
            if (!util2.hasOwn(_bAttr, k)) continue;
            if (k === "all") {
              allAttr = getRegList(_bAttr[k], "");
            } else {
              tagsAttr[k] = new wRegExp("\\s(?:" + getRegList(_bAttr[k], "") + ")" + regEndStr, "ig");
            }
          }
        }
        this._attributesBlacklistRegExp = new wRegExp("\\s(?:" + (allAttr || "^") + ")" + regEndStr, "ig");
        this._attributesTagsBlacklist = tagsAttr;
        this._isInline = /inline/i.test(options.mode);
        this._isBalloon = /balloon|balloon-always/i.test(options.mode);
        this._isBalloonAlways = /balloon-always/i.test(options.mode);
        this._cachingButtons();
        this._fileInfoPluginsCheck = [];
        this._fileInfoPluginsReset = [];
        this.managedTagsInfo = { query: "", map: {} };
        const managedClass = [];
        this.activePlugins = [];
        this._fileManager.tags = [];
        this._fileManager.pluginMap = {};
        let filePluginRegExp = [];
        let plugin, button;
        for (let key in plugins) {
          if (!util2.hasOwn(plugins, key)) continue;
          plugin = plugins[key];
          button = pluginCallButtons[key];
          if ((plugin.active || plugin.action) && button) {
            this.callPlugin(key, null, button);
          }
          if (typeof plugin.checkFileInfo === "function" && typeof plugin.resetFileInfo === "function") {
            this.callPlugin(key, null, button);
            this._fileInfoPluginsCheck.push(plugin.checkFileInfo.bind(this));
            this._fileInfoPluginsReset.push(plugin.resetFileInfo.bind(this));
          }
          if (_w.Array.isArray(plugin.fileTags)) {
            const fileTags = plugin.fileTags;
            this.callPlugin(key, null, button);
            this._fileManager.tags = this._fileManager.tags.concat(fileTags);
            filePluginRegExp.push(key);
            for (let tag = 0, tLen = fileTags.length; tag < tLen; tag++) {
              this._fileManager.pluginMap[fileTags[tag].toLowerCase()] = key;
            }
          }
          if (plugin.managedTags) {
            const info = plugin.managedTags();
            managedClass.push("." + info.className);
            this.managedTagsInfo.map[info.className] = info.method.bind(this);
          }
        }
        this.managedTagsInfo.query = managedClass.toString();
        this._fileManager.queryString = this._fileManager.tags.join(",");
        this._fileManager.regExp = new wRegExp("^(" + (this._fileManager.tags.join("|") || "^") + ")$", "i");
        this._fileManager.pluginRegExp = new wRegExp("^(" + (filePluginRegExp.length === 0 ? "^" : filePluginRegExp.join("|")) + ")$", "i");
        this._variable._originCssText = context.element.topArea.style.cssText;
        this._placeholder = context.element.placeholder;
        this._lineBreaker = context.element.lineBreaker;
        this._lineBreakerButton = this._lineBreaker.querySelector("button");
        this.history = history_default(this, this._onChange_historyStack.bind(this));
        this.addModule([notice_default]);
        if (options.iframe) {
          this._wd = context.element.wysiwygFrame.contentDocument;
          context.element.wysiwyg = this._wd.body;
          if (options._editorStyles.editor) context.element.wysiwyg.style.cssText = options._editorStyles.editor;
          if (options.height === "auto") this._iframeAuto = this._wd.body;
        }
        this._initWysiwygArea(reload, _initHTML);
      },
      /**
       * @description Caching basic buttons to use
       * @private
       */
      _cachingButtons: function() {
        this.codeViewDisabledButtons = context.element._buttonTray.querySelectorAll('.se-menu-list button[data-display]:not([class~="se-code-view-enabled"]):not([data-display="MORE"])');
        this.resizingDisabledButtons = context.element._buttonTray.querySelectorAll('.se-menu-list button[data-display]:not([class~="se-resizing-enabled"]):not([data-display="MORE"])');
        const tool = context.tool;
        const commandMap = this.commandMap;
        commandMap.INDENT = tool.indent;
        commandMap.OUTDENT = tool.outdent;
        commandMap[options.textTags.bold.toUpperCase()] = tool.bold;
        commandMap[options.textTags.underline.toUpperCase()] = tool.underline;
        commandMap[options.textTags.italic.toUpperCase()] = tool.italic;
        commandMap[options.textTags.strike.toUpperCase()] = tool.strike;
        commandMap[options.textTags.sub.toUpperCase()] = tool.subscript;
        commandMap[options.textTags.sup.toUpperCase()] = tool.superscript;
        this._styleCommandMap = {
          fullScreen: tool.fullScreen,
          showBlocks: tool.showBlocks,
          codeView: tool.codeView
        };
        this._saveButtonStates();
      },
      /**
       * @description Initializ wysiwyg area (Only called from core._init)
       * @param {Boolean} reload Is relooad?
       * @param {String} _initHTML initial html string
       * @private
       */
      _initWysiwygArea: function(reload, _initHTML) {
        context.element.wysiwyg.innerHTML = reload ? _initHTML : this.convertContentsForEditor((typeof _initHTML === "string" ? _initHTML : /^TEXTAREA$/i.test(context.element.originElement.nodeName) ? context.element.originElement.value : context.element.originElement.innerHTML) || "");
      },
      /**
       * @description Called when there are changes to tags in the wysiwyg region.
       * @private
       */
      _resourcesStateChange: function() {
        this._iframeAutoHeight();
        this._checkPlaceholder();
      },
      /**
       * @description Called when after execute "history.push"
       * @private
       */
      _onChange_historyStack: function() {
        if (this.hasFocus) event._applyTagEffects();
        this._variable.isChanged = true;
        if (context.tool.save) context.tool.save.removeAttribute("disabled");
        if (functions.onChange) functions.onChange(this.getContents(true), this);
        if (context.element.toolbar.style.display === "block") event._showToolbarBalloon();
      },
      /**
       * @description Modify the height value of the iframe when the height of the iframe is automatic.
       * @private
       */
      _iframeAutoHeight: function() {
        if (this._iframeAuto) {
          _w.setTimeout(function() {
            const h = core._iframeAuto.offsetHeight;
            context.element.wysiwygFrame.style.height = h + "px";
            if (!util2.isResizeObserverSupported) core.__callResizeFunction(h, null);
          });
        } else if (!util2.isResizeObserverSupported) {
          core.__callResizeFunction(context.element.wysiwygFrame.offsetHeight, null);
        }
      },
      __callResizeFunction: function(h, resizeObserverEntry) {
        h = h === -1 ? resizeObserverEntry.borderBoxSize && resizeObserverEntry.borderBoxSize[0] ? resizeObserverEntry.borderBoxSize[0].blockSize : resizeObserverEntry.contentRect.height + this._editorHeightPadding : h;
        if (this._editorHeight !== h) {
          if (typeof functions.onResizeEditor === "function") functions.onResizeEditor(h, this._editorHeight, core, resizeObserverEntry);
          this._editorHeight = h;
        }
      },
      /**
       * @description Set display property when there is placeholder.
       * @private
       */
      _checkPlaceholder: function() {
        if (this._placeholder) {
          if (this._variable.isCodeView) {
            this._placeholder.style.display = "none";
            return;
          }
          const wysiwyg = context.element.wysiwyg;
          if (!util2.onlyZeroWidthSpace(wysiwyg.textContent) || wysiwyg.querySelector(util2._allowedEmptyNodeList) || (wysiwyg.innerText.match(/\n/g) || "").length > 1) {
            this._placeholder.style.display = "none";
          } else {
            this._placeholder.style.display = "block";
          }
        }
      },
      /**
       * @description If there is no default format, add a format and move "selection".
       * @param {String|null} formatName Format tag name (default: 'P')
       * @returns {undefined|null}
       * @private
       */
      _setDefaultFormat: function(formatName) {
        if (this._fileManager.pluginRegExp.test(this.currentControllerName)) return;
        const range = this.getRange();
        const commonCon = range.commonAncestorContainer;
        const startCon = range.startContainer;
        const rangeEl = util2.getRangeFormatElement(commonCon, null);
        let focusNode, offset, format;
        const fileComponent = util2.getParentElement(commonCon, util2.isComponent);
        if (fileComponent && !util2.isTable(fileComponent)) {
          return;
        } else if (commonCon.nodeType === 1 && commonCon.getAttribute("data-se-embed") === "true") {
          let el = commonCon.nextElementSibling;
          if (!util2.isFormatElement(el)) el = this.appendFormatTag(commonCon, options.defaultTag);
          this.setRange(el.firstChild, 0, el.firstChild, 0);
          return;
        }
        if ((util2.isRangeFormatElement(startCon) || util2.isWysiwygDiv(startCon)) && (util2.isComponent(startCon.children[range.startOffset]) || util2.isComponent(startCon.children[range.startOffset - 1]))) return;
        if (util2.getParentElement(commonCon, util2.isNotCheckingNode)) return null;
        if (rangeEl) {
          format = util2.createElement(formatName || options.defaultTag);
          format.innerHTML = rangeEl.innerHTML;
          if (format.childNodes.length === 0) format.innerHTML = util2.zeroWidthSpace;
          rangeEl.innerHTML = format.outerHTML;
          format = rangeEl.firstChild;
          focusNode = util2.getEdgeChildNodes(format, null).sc;
          if (!focusNode) {
            focusNode = util2.createTextNode(util2.zeroWidthSpace);
            format.insertBefore(focusNode, format.firstChild);
          }
          offset = focusNode.textContent.length;
          this.setRange(focusNode, offset, focusNode, offset);
          return;
        }
        if (util2.isRangeFormatElement(commonCon) && commonCon.childNodes.length <= 1) {
          let br = null;
          if (commonCon.childNodes.length === 1 && util2.isBreak(commonCon.firstChild)) {
            br = commonCon.firstChild;
          } else {
            br = util2.createTextNode(util2.zeroWidthSpace);
            commonCon.appendChild(br);
          }
          this.setRange(br, 1, br, 1);
          return;
        }
        try {
          if (commonCon.nodeType === 3) {
            format = util2.createElement(formatName || options.defaultTag);
            commonCon.parentNode.insertBefore(format, commonCon);
            format.appendChild(commonCon);
          }
          if (util2.isBreak(format.nextSibling)) util2.removeItem(format.nextSibling);
          if (util2.isBreak(format.previousSibling)) util2.removeItem(format.previousSibling);
          if (util2.isBreak(focusNode)) {
            const zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
            focusNode.parentNode.insertBefore(zeroWidth, focusNode);
            focusNode = zeroWidth;
          }
        } catch (e) {
          this.execCommand("formatBlock", false, formatName || options.defaultTag);
          this.removeRange();
          this._editorRange();
        }
        if (format) {
          if (util2.isBreak(format.nextSibling)) util2.removeItem(format.nextSibling);
          if (util2.isBreak(format.previousSibling)) util2.removeItem(format.previousSibling);
          if (util2.isBreak(focusNode)) {
            const zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
            focusNode.parentNode.insertBefore(zeroWidth, focusNode);
            focusNode = zeroWidth;
          }
        }
        this.effectNode = null;
        this.nativeFocus();
      },
      /**
       * @description Initialization after "setOptions"
       * @param {Object} el context.element
       * @param {String} _initHTML Initial html string
       * @private
       */
      _setOptionsInit: function(el, _initHTML) {
        this.context = context = context_default(el.originElement, this._getConstructed(el), options);
        this._componentsInfoReset = true;
        this._editorInit(true, _initHTML);
      },
      /**
       * @description Initializ editor
       * @param {Boolean} reload Is relooad?
       * @param {String} _initHTML initial html string
       * @private
       */
      _editorInit: function(reload, _initHTML) {
        this._init(reload, _initHTML);
        event._addEvent();
        this._setCharCount();
        event._offStickyToolbar();
        event.onResize_window();
        context.element.toolbar.style.visibility = "";
        const attr = options.frameAttrbutes;
        for (let k in attr) {
          context.element.wysiwyg.setAttribute(k, attr[k]);
        }
        this._checkComponents();
        this._componentsInfoInit = false;
        this._componentsInfoReset = false;
        this.history.reset(true);
        _w.setTimeout(function() {
          if (typeof core._resourcesStateChange !== "function") return;
          if (event._resizeObserver) event._resizeObserver.observe(context.element.wysiwygFrame);
          if (event._toolbarObserver) event._toolbarObserver.observe(context.element._toolbarShadow);
          core._resourcesStateChange();
          if (typeof functions.onload === "function") functions.onload(core, reload);
        });
      },
      /**
       * @description Create and return an object to cache the new context.
       * @param {Element} contextEl context.element
       * @returns {Object}
       * @private
       */
      _getConstructed: function(contextEl2) {
        return {
          _top: contextEl2.topArea,
          _relative: contextEl2.relative,
          _toolBar: contextEl2.toolbar,
          _toolbarShadow: contextEl2._toolbarShadow,
          _menuTray: contextEl2._menuTray,
          _editorArea: contextEl2.editorArea,
          _wysiwygArea: contextEl2.wysiwygFrame,
          _codeArea: contextEl2.code,
          _placeholder: contextEl2.placeholder,
          _resizingBar: contextEl2.resizingBar,
          _navigation: contextEl2.navigation,
          _charCounter: contextEl2.charCounter,
          _charWrapper: contextEl2.charWrapper,
          _loading: contextEl2.loading,
          _lineBreaker: contextEl2.lineBreaker,
          _lineBreaker_t: contextEl2.lineBreaker_t,
          _lineBreaker_b: contextEl2.lineBreaker_b,
          _resizeBack: contextEl2.resizeBackground,
          _stickyDummy: contextEl2._stickyDummy,
          _arrow: contextEl2._arrow
        };
      }
    };
    const event = {
      _IEisComposing: false,
      // In IE, there is no "e.isComposing" in the key-up event.
      _lineBreakerBind: null,
      _responsiveCurrentSize: "default",
      _responsiveButtonSize: null,
      _responsiveButtons: null,
      _cursorMoveKeyCode: new _w.RegExp("^(8|3[2-9]|40|46)$"),
      _directionKeyCode: new _w.RegExp("^(8|13|3[2-9]|40|46)$"),
      _nonTextKeyCode: new _w.RegExp("^(8|13|1[6-9]|20|27|3[3-9]|40|45|46|11[2-9]|12[0-3]|144|145)$"),
      _historyIgnoreKeyCode: new _w.RegExp("^(1[6-9]|20|27|3[3-9]|40|45|11[2-9]|12[0-3]|144|145)$"),
      _onButtonsCheck: new _w.RegExp("^(" + _w.Object.keys(options._textTagsMap).join("|") + ")$", "i"),
      _frontZeroWidthReg: new _w.RegExp(util2.zeroWidthSpace + "+", ""),
      _keyCodeShortcut: {
        65: "A",
        66: "B",
        83: "S",
        85: "U",
        73: "I",
        89: "Y",
        90: "Z",
        219: "[",
        221: "]"
      },
      _shortcutCommand: function(keyCode, shift) {
        let command = null;
        const keyStr = event._keyCodeShortcut[keyCode];
        switch (keyStr) {
          case "A":
            command = "selectAll";
            break;
          case "B":
            if (options.shortcutsDisable.indexOf("bold") === -1) {
              command = "bold";
            }
            break;
          case "S":
            if (shift && options.shortcutsDisable.indexOf("strike") === -1) {
              command = "strike";
            } else if (!shift && options.shortcutsDisable.indexOf("save") === -1) {
              command = "save";
            }
            break;
          case "U":
            if (options.shortcutsDisable.indexOf("underline") === -1) {
              command = "underline";
            }
            break;
          case "I":
            if (options.shortcutsDisable.indexOf("italic") === -1) {
              command = "italic";
            }
            break;
          case "Z":
            if (options.shortcutsDisable.indexOf("undo") === -1) {
              if (shift) {
                command = "redo";
              } else {
                command = "undo";
              }
            }
            break;
          case "Y":
            if (options.shortcutsDisable.indexOf("undo") === -1) {
              command = "redo";
            }
            break;
          case "[":
            if (options.shortcutsDisable.indexOf("indent") === -1) {
              command = options.rtl ? "indent" : "outdent";
            }
            break;
          case "]":
            if (options.shortcutsDisable.indexOf("indent") === -1) {
              command = options.rtl ? "outdent" : "indent";
            }
            break;
        }
        if (!command) return !!keyStr;
        core.commandHandler(core.commandMap[command], command);
        return true;
      },
      _applyTagEffects: function() {
        if (util2.hasClass(context.element.wysiwyg, "se-read-only")) {
          return false;
        }
        let selectionNode = core.getSelectionNode();
        if (selectionNode === core.effectNode) return;
        core.effectNode = selectionNode;
        const marginDir = options.rtl ? "marginRight" : "marginLeft";
        const commandMap = core.commandMap;
        const classOnCheck = event._onButtonsCheck;
        const commandMapNodes = [];
        const currentNodes = [];
        const activePlugins = core.activePlugins;
        const cLen = activePlugins.length;
        let nodeName = "";
        while (selectionNode.firstChild) {
          selectionNode = selectionNode.firstChild;
        }
        for (let element = selectionNode; !util2.isWysiwygDiv(element); element = element.parentNode) {
          if (!element) break;
          if (element.nodeType !== 1 || util2.isBreak(element)) continue;
          nodeName = element.nodeName.toUpperCase();
          currentNodes.push(nodeName);
          if (!core.isReadOnly) {
            for (let c = 0, name2; c < cLen; c++) {
              name2 = activePlugins[c];
              if (commandMapNodes.indexOf(name2) === -1 && plugins[name2].active.call(core, element)) {
                commandMapNodes.push(name2);
              }
            }
          }
          if (util2.isFormatElement(element)) {
            if (commandMapNodes.indexOf("OUTDENT") === -1 && commandMap.OUTDENT && !util2.isImportantDisabled(commandMap.OUTDENT)) {
              if (util2.isListCell(element) || element.style[marginDir] && util2.getNumber(element.style[marginDir], 0) > 0) {
                commandMapNodes.push("OUTDENT");
                commandMap.OUTDENT.removeAttribute("disabled");
              }
            }
            if (commandMapNodes.indexOf("INDENT") === -1 && commandMap.INDENT && !util2.isImportantDisabled(commandMap.INDENT)) {
              commandMapNodes.push("INDENT");
              if (util2.isListCell(element) && !element.previousElementSibling) {
                commandMap.INDENT.setAttribute("disabled", true);
              } else {
                commandMap.INDENT.removeAttribute("disabled");
              }
            }
            continue;
          }
          if (classOnCheck && classOnCheck.test(nodeName)) {
            commandMapNodes.push(nodeName);
            util2.addClass(commandMap[nodeName], "active");
          }
        }
        core._setKeyEffect(commandMapNodes);
        core._variable.currentNodes = currentNodes.reverse();
        core._variable.currentNodesMap = commandMapNodes;
        if (options.showPathLabel) context.element.navigation.textContent = core._variable.currentNodes.join(" > ");
      },
      _buttonsEventHandler: function(e) {
        let target = e.target;
        if (core._bindControllersOff) e.stopPropagation();
        if (/^(input|textarea|select|option)$/i.test(target.nodeName)) {
          core._antiBlur = false;
        } else {
          e.preventDefault();
        }
        if (util2.getParentElement(target, ".se-submenu")) {
          e.stopPropagation();
          core._notHideToolbar = true;
        } else {
          let command = target.getAttribute("data-command");
          let className = target.className;
          while (!command && !/se-menu-list/.test(className) && !/sun-editor-common/.test(className)) {
            target = target.parentNode;
            command = target.getAttribute("data-command");
            className = target.className;
          }
          if (command === core._submenuName || command === core._containerName) {
            e.stopPropagation();
          }
        }
      },
      addGlobalEvent(type, listener, useCapture) {
        if (options.iframe) {
          core._ww.addEventListener(type, listener, useCapture);
        }
        core._w.addEventListener(type, listener, useCapture);
        return {
          type,
          listener,
          useCapture
        };
      },
      removeGlobalEvent(type, listener, useCapture) {
        if (!type) return;
        if (typeof type === "object") {
          listener = type.listener;
          useCapture = type.useCapture;
          type = type.type;
        }
        if (options.iframe) {
          core._ww.removeEventListener(type, listener, useCapture);
        }
        core._w.removeEventListener(type, listener, useCapture);
      },
      onClick_toolbar: function(e) {
        let target = e.target;
        let display = target.getAttribute("data-display");
        let command = target.getAttribute("data-command");
        let className = target.className;
        core.controllersOff();
        while (target.parentNode && !command && !/se-menu-list/.test(className) && !/se-toolbar/.test(className)) {
          target = target.parentNode;
          command = target.getAttribute("data-command");
          display = target.getAttribute("data-display");
          className = target.className;
        }
        if (!command && !display) return;
        if (target.disabled) return;
        core.actionCall(command, display, target);
      },
      __selectionSyncEvent: null,
      onMouseDown_wysiwyg: function(e) {
        if (core.isReadOnly || util2.isNonEditable(context.element.wysiwyg)) return;
        if (util2._isExcludeSelectionElement(e.target)) {
          e.preventDefault();
          return;
        }
        event.removeGlobalEvent(event.__selectionSyncEvent);
        event.__selectionSyncEvent = event.addGlobalEvent("mouseup", function() {
          core._editorRange();
          event.removeGlobalEvent(event.__selectionSyncEvent);
        });
        if (typeof functions.onMouseDown === "function" && functions.onMouseDown(e, core) === false) return;
        const tableCell = util2.getParentElement(e.target, util2.isCell);
        if (tableCell) {
          const tablePlugin = core.plugins.table;
          if (tablePlugin && tableCell !== tablePlugin._fixedCell && !tablePlugin._shift) {
            core.callPlugin("table", function() {
              tablePlugin.onTableCellMultiSelect.call(core, tableCell, false);
            }, null);
          }
        }
        if (core._isBalloon) {
          event._hideToolbar();
        }
      },
      onClick_wysiwyg: function(e) {
        const targetElement = e.target;
        if (core.isReadOnly) {
          e.preventDefault();
          if (util2.isAnchor(targetElement)) {
            _w.open(targetElement.href, targetElement.target);
          }
          return false;
        }
        if (util2.isNonEditable(context.element.wysiwyg)) return;
        if (typeof functions.onClick === "function" && functions.onClick(e, core) === false) return;
        const fileComponentInfo = core.getFileComponent(targetElement);
        if (fileComponentInfo) {
          e.preventDefault();
          core.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName);
          return;
        }
        const figcaption = util2.getParentElement(targetElement, "FIGCAPTION");
        if (figcaption && util2.isNonEditable(figcaption)) {
          e.preventDefault();
          figcaption.focus();
          if (core._isInline && !core._inlineToolbarAttr.isShow) {
            event._showToolbarInline();
            const hideToolbar = function() {
              event._hideToolbar();
              figcaption.removeEventListener("blur", hideToolbar);
            };
            figcaption.addEventListener("blur", hideToolbar);
          }
        }
        core._editorRange();
        if (e.detail === 3) {
          let range = core.getRange();
          if (util2.isFormatElement(range.endContainer) && range.endOffset === 0) {
            range = core.setRange(range.startContainer, range.startOffset, range.startContainer, range.startContainer.length);
            core._rangeInfo(range, core.getSelection());
          }
        }
        const selectionNode = core.getSelectionNode();
        const formatEl = util2.getFormatElement(selectionNode, null);
        const rangeEl = util2.getRangeFormatElement(selectionNode, null);
        let selectionNodeDeepestFirstChild = selectionNode;
        while (selectionNodeDeepestFirstChild.firstChild) selectionNodeDeepestFirstChild = selectionNodeDeepestFirstChild.firstChild;
        const selectedComponentInfo = core.getFileComponent(selectionNodeDeepestFirstChild);
        if (selectedComponentInfo) {
          const range = core.getRange();
          if (!rangeEl && range.startContainer === range.endContainer) core.selectComponent(selectedComponentInfo.target, selectedComponentInfo.pluginName);
        } else if (core.currentFileComponentInfo) core.controllersOff();
        if (!formatEl && !util2.isNonEditable(targetElement) && !util2.isList(rangeEl)) {
          const range = core.getRange();
          if (util2.getFormatElement(range.startContainer) === util2.getFormatElement(range.endContainer)) {
            if (util2.isList(rangeEl)) {
              e.preventDefault();
              const oLi = util2.createElement("LI");
              const prevLi = selectionNode.nextElementSibling;
              oLi.appendChild(selectionNode);
              rangeEl.insertBefore(oLi, prevLi);
              core.focus();
            } else if (!util2.isWysiwygDiv(selectionNode) && !util2.isComponent(selectionNode) && (!util2.isTable(selectionNode) || util2.isCell(selectionNode)) && core._setDefaultFormat(util2.isRangeFormatElement(rangeEl) ? "DIV" : options.defaultTag) !== null) {
              e.preventDefault();
              core.focus();
            } else {
              event._applyTagEffects();
            }
          }
        } else {
          event._applyTagEffects();
        }
        if (core._isBalloon) _w.setTimeout(event._toggleToolbarBalloon);
      },
      _balloonDelay: null,
      _showToolbarBalloonDelay: function() {
        if (event._balloonDelay) {
          _w.clearTimeout(event._balloonDelay);
        }
        event._balloonDelay = _w.setTimeout(function() {
          _w.clearTimeout(this._balloonDelay);
          this._balloonDelay = null;
          this._showToolbarBalloon();
        }.bind(event), 350);
      },
      _toggleToolbarBalloon: function() {
        core._editorRange();
        const range = core.getRange();
        if (core._bindControllersOff || !core._isBalloonAlways && range.collapsed) event._hideToolbar();
        else event._showToolbarBalloon(range);
      },
      _showToolbarBalloon: function(rangeObj) {
        if (!core._isBalloon) return;
        const range = rangeObj || core.getRange();
        const toolbar = context.element.toolbar;
        const topArea = context.element.topArea;
        const selection = core.getSelection();
        let isDirTop;
        if (core._isBalloonAlways && range.collapsed) {
          isDirTop = true;
        } else if (selection.focusNode === selection.anchorNode) {
          isDirTop = selection.focusOffset < selection.anchorOffset;
        } else {
          const childNodes = util2.getListChildNodes(range.commonAncestorContainer, null);
          isDirTop = util2.getArrayIndex(childNodes, selection.focusNode) < util2.getArrayIndex(childNodes, selection.anchorNode);
        }
        let rects = range.getClientRects();
        rects = rects[isDirTop ? 0 : rects.length - 1];
        const globalScroll = core.getGlobalScrollOffset();
        let scrollLeft = globalScroll.left;
        let scrollTop = globalScroll.top;
        const editorWidth = topArea.offsetWidth;
        const offsets = event._getEditorOffsets(null);
        const stickyTop = offsets.top;
        const editorLeft = offsets.left;
        toolbar.style.top = "-10000px";
        toolbar.style.visibility = "hidden";
        toolbar.style.display = "block";
        if (!rects) {
          const node = core.getSelectionNode();
          if (util2.isFormatElement(node)) {
            const zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
            core.insertNode(zeroWidth, null, false);
            core.setRange(zeroWidth, 1, zeroWidth, 1);
            core._editorRange();
            rects = core.getRange().getClientRects();
            rects = rects[isDirTop ? 0 : rects.length - 1];
          }
          if (!rects) {
            const nodeOffset = util2.getOffset(node, context.element.wysiwygFrame);
            rects = {
              left: nodeOffset.left,
              top: nodeOffset.top,
              right: nodeOffset.left,
              bottom: nodeOffset.top + node.offsetHeight,
              noText: true
            };
            scrollLeft = 0;
            scrollTop = 0;
          }
          isDirTop = true;
        }
        const arrowMargin = _w.Math.round(context.element._arrow.offsetWidth / 2);
        const toolbarWidth = toolbar.offsetWidth;
        const toolbarHeight = toolbar.offsetHeight;
        const iframeRects = /iframe/i.test(context.element.wysiwygFrame.nodeName) ? context.element.wysiwygFrame.getClientRects()[0] : null;
        if (iframeRects) {
          rects = {
            left: rects.left + iframeRects.left,
            top: rects.top + iframeRects.top,
            right: rects.right + iframeRects.right - iframeRects.width,
            bottom: rects.bottom + iframeRects.bottom - iframeRects.height
          };
        }
        event._setToolbarOffset(isDirTop, rects, toolbar, editorLeft, editorWidth, scrollLeft, scrollTop, stickyTop, arrowMargin);
        if (toolbarWidth !== toolbar.offsetWidth || toolbarHeight !== toolbar.offsetHeight) {
          event._setToolbarOffset(isDirTop, rects, toolbar, editorLeft, editorWidth, scrollLeft, scrollTop, stickyTop, arrowMargin);
        }
        if (options.toolbarContainer) {
          const editorParent = topArea.parentElement;
          let container = options.toolbarContainer;
          let left = container.offsetLeft;
          let top = container.offsetTop;
          while (!container.parentElement.contains(editorParent) || !/^(BODY|HTML)$/i.test(container.parentElement.nodeName)) {
            container = container.offsetParent;
            left += container.offsetLeft;
            top += container.offsetTop;
          }
          toolbar.style.left = toolbar.offsetLeft - left + topArea.offsetLeft + "px";
          toolbar.style.top = toolbar.offsetTop - top + topArea.offsetTop + "px";
        }
        toolbar.style.visibility = "";
      },
      _setToolbarOffset: function(isDirTop, rects, toolbar, editorLeft, editorWidth, scrollLeft, scrollTop, stickyTop, arrowMargin) {
        const padding = 1;
        const toolbarWidth = toolbar.offsetWidth;
        const toolbarHeight = rects.noText && !isDirTop ? 0 : toolbar.offsetHeight;
        const absoluteLeft = (isDirTop ? rects.left : rects.right) - editorLeft - toolbarWidth / 2 + scrollLeft;
        const overRight = absoluteLeft + toolbarWidth - editorWidth;
        let t = (isDirTop ? rects.top - toolbarHeight - arrowMargin : rects.bottom + arrowMargin) - (rects.noText ? 0 : stickyTop) + scrollTop;
        let l = absoluteLeft < 0 ? padding : overRight < 0 ? absoluteLeft : absoluteLeft - overRight - padding - 1;
        let resetTop = false;
        const space = t + (isDirTop ? event._getEditorOffsets(null).top : toolbar.offsetHeight - context.element.wysiwyg.offsetHeight);
        if (!isDirTop && space > 0 && event._getPageBottomSpace() < space) {
          isDirTop = true;
          resetTop = true;
        } else if (isDirTop && _d.documentElement.offsetTop > space) {
          isDirTop = false;
          resetTop = true;
        }
        if (resetTop) t = (isDirTop ? rects.top - toolbarHeight - arrowMargin : rects.bottom + arrowMargin) - (rects.noText ? 0 : stickyTop) + scrollTop;
        toolbar.style.left = _w.Math.floor(l) + "px";
        toolbar.style.top = _w.Math.floor(t) + "px";
        if (isDirTop) {
          util2.removeClass(context.element._arrow, "se-arrow-up");
          util2.addClass(context.element._arrow, "se-arrow-down");
          context.element._arrow.style.top = toolbarHeight + "px";
        } else {
          util2.removeClass(context.element._arrow, "se-arrow-down");
          util2.addClass(context.element._arrow, "se-arrow-up");
          context.element._arrow.style.top = -arrowMargin + "px";
        }
        const arrow_left = _w.Math.floor(toolbarWidth / 2 + (absoluteLeft - l));
        context.element._arrow.style.left = (arrow_left + arrowMargin > toolbar.offsetWidth ? toolbar.offsetWidth - arrowMargin : arrow_left < arrowMargin ? arrowMargin : arrow_left) + "px";
      },
      _showToolbarInline: function() {
        if (!core._isInline) return;
        const toolbar = context.element.toolbar;
        if (options.toolbarContainer) toolbar.style.position = "relative";
        else toolbar.style.position = "absolute";
        toolbar.style.visibility = "hidden";
        toolbar.style.display = "block";
        core._inlineToolbarAttr.width = toolbar.style.width = options.toolbarWidth;
        core._inlineToolbarAttr.top = toolbar.style.top = (options.toolbarContainer ? 0 : -1 - toolbar.offsetHeight) + "px";
        if (typeof functions.showInline === "function") functions.showInline(toolbar, context, core);
        event.onScroll_window();
        core._inlineToolbarAttr.isShow = true;
        toolbar.style.visibility = "";
      },
      _hideToolbar: function() {
        if (!core._notHideToolbar && !core._variable.isFullScreen) {
          context.element.toolbar.style.display = "none";
          core._inlineToolbarAttr.isShow = false;
        }
      },
      onInput_wysiwyg: function(e) {
        if (/AUDIO/.test(e.target.nodeName)) return false;
        if (core.isReadOnly || core.isDisabled) {
          e.preventDefault();
          e.stopPropagation();
          core.history.go(core.history.getCurrentIndex());
          return false;
        }
        core._editorRange();
        const data2 = (e.data === null ? "" : e.data === void 0 ? " " : e.data) || "";
        if (!core._charCount(data2)) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        if (typeof functions.onInput === "function" && functions.onInput(e, core) === false) return;
        core.history.push(true);
      },
      _isUneditableNode: function(range, isFront) {
        const container = isFront ? range.startContainer : range.endContainer;
        const offset = isFront ? range.startOffset : range.endOffset;
        const siblingKey = isFront ? "previousSibling" : "nextSibling";
        const isElement = container.nodeType === 1;
        let siblingNode;
        if (isElement) {
          siblingNode = event._isUneditableNode_getSibling(container.childNodes[offset], siblingKey, container);
          return siblingNode && siblingNode.nodeType === 1 && siblingNode.getAttribute("contenteditable") === "false";
        } else {
          siblingNode = event._isUneditableNode_getSibling(container, siblingKey, container);
          return core.isEdgePoint(container, offset, isFront ? "front" : "end") && (siblingNode && siblingNode.nodeType === 1 && siblingNode.getAttribute("contenteditable") === "false");
        }
      },
      _isUneditableNode_getSibling: function(selectNode, siblingKey, container) {
        if (!selectNode) return null;
        let siblingNode = selectNode[siblingKey];
        if (!siblingNode) {
          siblingNode = util2.getFormatElement(container);
          siblingNode = siblingNode ? siblingNode[siblingKey] : null;
          if (siblingNode && !util2.isComponent(siblingNode)) siblingNode = siblingKey === "previousSibling" ? siblingNode.firstChild : siblingNode.lastChild;
          else return null;
        }
        return siblingNode;
      },
      _onShortcutKey: false,
      onKeyDown_wysiwyg: function(e) {
        let selectionNode = core.getSelectionNode();
        if (util2.isInputElement(selectionNode)) return;
        const keyCode = e.keyCode;
        const shift = e.shiftKey;
        const ctrl = e.ctrlKey || e.metaKey || keyCode === 91 || keyCode === 92 || keyCode === 224;
        const alt = e.altKey;
        event._IEisComposing = keyCode === 229;
        if (!ctrl && core.isReadOnly && !event._cursorMoveKeyCode.test(keyCode)) {
          e.preventDefault();
          return false;
        }
        core.submenuOff();
        if (core._isBalloon) {
          event._hideToolbar();
        }
        if (typeof functions.onKeyDown === "function" && functions.onKeyDown(e, core) === false) return;
        if (ctrl && event._shortcutCommand(keyCode, shift)) {
          event._onShortcutKey = true;
          e.preventDefault();
          e.stopPropagation();
          return false;
        } else if (event._onShortcutKey) {
          event._onShortcutKey = false;
        }
        const range = core.getRange();
        const selectRange = !range.collapsed || range.startContainer !== range.endContainer;
        const fileComponentName = core._fileManager.pluginRegExp.test(core.currentControllerName) ? core.currentControllerName : "";
        let formatEl = util2.getFormatElement(selectionNode, null) || selectionNode;
        let rangeEl = util2.getRangeFormatElement(formatEl, null);
        const isArrowKey = /37|38|39|40/.test(e.keyCode);
        if (isArrowKey && event._onKeyDown_wysiwyg_arrowKey(e) === false) return;
        switch (keyCode) {
          case 8:
            if (!selectRange) {
              if (fileComponentName) {
                e.preventDefault();
                e.stopPropagation();
                core.plugins[fileComponentName].destroy.call(core);
                break;
              }
            }
            if (selectRange && event._hardDelete()) {
              e.preventDefault();
              e.stopPropagation();
              break;
            }
            if (!util2.isFormatElement(formatEl) && !context.element.wysiwyg.firstElementChild && !util2.isComponent(selectionNode) && core._setDefaultFormat(options.defaultTag) !== null) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }
            if (!selectRange && !formatEl.previousElementSibling && (range.startOffset === 0 && !selectionNode.previousSibling && !util2.isListCell(formatEl) && (util2.isFormatElement(formatEl) && (!util2.isFreeFormatElement(formatEl) || util2.isClosureFreeFormatElement(formatEl))))) {
              if (util2.isClosureRangeFormatElement(formatEl.parentNode)) {
                e.preventDefault();
                e.stopPropagation();
                return false;
              }
              if (util2.isWysiwygDiv(formatEl.parentNode) && formatEl.childNodes.length <= 1 && (!formatEl.firstChild || util2.onlyZeroWidthSpace(formatEl.textContent))) {
                e.preventDefault();
                e.stopPropagation();
                if (formatEl.nodeName.toUpperCase() === options.defaultTag.toUpperCase()) {
                  formatEl.innerHTML = "<br>";
                  const attrs = formatEl.attributes;
                  while (attrs[0]) {
                    formatEl.removeAttribute(attrs[0].name);
                  }
                } else {
                  const defaultFormat = util2.createElement(options.defaultTag);
                  defaultFormat.innerHTML = "<br>";
                  formatEl.parentElement.replaceChild(defaultFormat, formatEl);
                }
                core.nativeFocus();
                return false;
              }
            }
            const startCon = range.startContainer;
            if (formatEl && !formatEl.previousElementSibling && range.startOffset === 0 && startCon.nodeType === 3 && !util2.isFormatElement(startCon.parentNode)) {
              let prev = startCon.parentNode.previousSibling;
              const next = startCon.parentNode.nextSibling;
              if (!prev) {
                if (!next) {
                  prev = util2.createElement("BR");
                  formatEl.appendChild(prev);
                } else {
                  prev = next;
                }
              }
              let con = startCon;
              while (formatEl.contains(con) && !con.previousSibling) {
                con = con.parentNode;
              }
              if (!formatEl.contains(con)) {
                startCon.textContent = "";
                util2.removeItemAllParents(startCon, null, formatEl);
                break;
              }
            }
            if (event._isUneditableNode(range, true)) {
              e.preventDefault();
              e.stopPropagation();
              break;
            }
            if (!selectRange && core._isEdgeFormat(range.startContainer, range.startOffset, "start")) {
              if (util2.isFormatElement(formatEl.previousElementSibling)) {
                core._formatAttrsTemp = formatEl.previousElementSibling.attributes;
              }
            }
            const commonCon = range.commonAncestorContainer;
            formatEl = util2.getFormatElement(range.startContainer, null);
            rangeEl = util2.getRangeFormatElement(formatEl, null);
            if (rangeEl && formatEl && !util2.isCell(rangeEl) && !/^FIGCAPTION$/i.test(rangeEl.nodeName)) {
              if (util2.isListCell(formatEl) && util2.isList(rangeEl) && (util2.isListCell(rangeEl.parentNode) || formatEl.previousElementSibling) && (selectionNode === formatEl || selectionNode.nodeType === 3 && (!selectionNode.previousSibling || util2.isList(selectionNode.previousSibling))) && (util2.getFormatElement(range.startContainer, null) !== util2.getFormatElement(range.endContainer, null) ? rangeEl.contains(range.startContainer) : range.startOffset === 0 && range.collapsed)) {
                if (range.startContainer !== range.endContainer) {
                  e.preventDefault();
                  core.removeNode();
                  if (range.startContainer.nodeType === 3) {
                    core.setRange(range.startContainer, range.startContainer.textContent.length, range.startContainer, range.startContainer.textContent.length);
                  }
                  core.history.push(true);
                } else {
                  let prev = formatEl.previousElementSibling || rangeEl.parentNode;
                  if (util2.isListCell(prev)) {
                    e.preventDefault();
                    let prevLast = prev;
                    if (!prev.contains(formatEl) && util2.isListCell(prevLast) && util2.isList(prevLast.lastElementChild)) {
                      prevLast = prevLast.lastElementChild.lastElementChild;
                      while (util2.isListCell(prevLast) && util2.isList(prevLast.lastElementChild)) {
                        prevLast = prevLast.lastElementChild && prevLast.lastElementChild.lastElementChild;
                      }
                      prev = prevLast;
                    }
                    let con = prev === rangeEl.parentNode ? rangeEl.previousSibling : prev.lastChild;
                    if (!con) {
                      con = util2.createTextNode(util2.zeroWidthSpace);
                      rangeEl.parentNode.insertBefore(con, rangeEl.parentNode.firstChild);
                    }
                    const offset = con.nodeType === 3 ? con.textContent.length : 1;
                    const children4 = formatEl.childNodes;
                    let after = con;
                    let child = children4[0];
                    while (child = children4[0]) {
                      prev.insertBefore(child, after.nextSibling);
                      after = child;
                    }
                    util2.removeItem(formatEl);
                    if (rangeEl.children.length === 0) util2.removeItem(rangeEl);
                    core.setRange(con, offset, con, offset);
                    core.history.push(true);
                  }
                }
                break;
              }
              if (!selectRange && range.startOffset === 0) {
                let detach = true;
                let comm = commonCon;
                while (comm && comm !== rangeEl && !util2.isWysiwygDiv(comm)) {
                  if (comm.previousSibling) {
                    if (comm.previousSibling.nodeType === 1 || !util2.onlyZeroWidthSpace(comm.previousSibling.textContent.trim())) {
                      detach = false;
                      break;
                    }
                  }
                  comm = comm.parentNode;
                }
                if (detach && rangeEl.parentNode) {
                  e.preventDefault();
                  core.detachRangeFormatElement(rangeEl, util2.isListCell(formatEl) ? [formatEl] : null, null, false, false);
                  core.history.push(true);
                  break;
                }
              }
            }
            if (!selectRange && formatEl && (range.startOffset === 0 || (selectionNode === formatEl ? !!formatEl.childNodes[range.startOffset] : false))) {
              const sel = selectionNode === formatEl ? formatEl.childNodes[range.startOffset] : selectionNode;
              const prev = formatEl.previousSibling;
              const ignoreZWS = (commonCon.nodeType === 3 || util2.isBreak(commonCon)) && !commonCon.previousSibling && range.startOffset === 0;
              if (sel && !sel.previousSibling && (commonCon && util2.isComponent(commonCon.previousSibling) || ignoreZWS && util2.isComponent(prev))) {
                const fileComponentInfo = core.getFileComponent(prev);
                if (fileComponentInfo) {
                  e.preventDefault();
                  e.stopPropagation();
                  if (formatEl.textContent.length === 0) util2.removeItem(formatEl);
                  if (core.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName) === false) core.blur();
                } else if (util2.isComponent(prev)) {
                  e.preventDefault();
                  e.stopPropagation();
                  util2.removeItem(prev);
                }
                break;
              }
              if (sel && util2.isNonEditable(sel.previousSibling)) {
                e.preventDefault();
                e.stopPropagation();
                util2.removeItem(sel.previousSibling);
                break;
              }
            }
            break;
          case 46:
            if (fileComponentName) {
              e.preventDefault();
              e.stopPropagation();
              core.plugins[fileComponentName].destroy.call(core);
              break;
            }
            if (selectRange && event._hardDelete()) {
              e.preventDefault();
              e.stopPropagation();
              break;
            }
            if (event._isUneditableNode(range, false)) {
              e.preventDefault();
              e.stopPropagation();
              break;
            }
            if ((util2.isFormatElement(selectionNode) || selectionNode.nextSibling === null || util2.onlyZeroWidthSpace(selectionNode.nextSibling) && selectionNode.nextSibling.nextSibling === null) && range.startOffset === selectionNode.textContent.length) {
              const nextEl = formatEl.nextElementSibling;
              if (!nextEl) break;
              if (util2.isComponent(nextEl)) {
                e.preventDefault();
                if (util2.onlyZeroWidthSpace(formatEl)) {
                  util2.removeItem(formatEl);
                  if (util2.isTable(nextEl)) {
                    let cell = util2.getChildElement(nextEl, util2.isCell, false);
                    cell = cell.firstElementChild || cell;
                    core.setRange(cell, 0, cell, 0);
                    break;
                  }
                }
                const fileComponentInfo = core.getFileComponent(nextEl);
                if (fileComponentInfo) {
                  e.stopPropagation();
                  if (core.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName) === false) core.blur();
                } else if (util2.isComponent(nextEl)) {
                  e.stopPropagation();
                  util2.removeItem(nextEl);
                }
                break;
              }
            }
            if (!selectRange && (core.isEdgePoint(range.endContainer, range.endOffset) || (selectionNode === formatEl ? !!formatEl.childNodes[range.startOffset] : false))) {
              const sel = selectionNode === formatEl ? formatEl.childNodes[range.startOffset] || selectionNode : selectionNode;
              if (sel && util2.isNonEditable(sel.nextSibling)) {
                e.preventDefault();
                e.stopPropagation();
                util2.removeItem(sel.nextSibling);
                break;
              } else if (util2.isComponent(sel)) {
                e.preventDefault();
                e.stopPropagation();
                util2.removeItem(sel);
                break;
              }
            }
            if (!selectRange && core._isEdgeFormat(range.endContainer, range.endOffset, "end")) {
              if (util2.isFormatElement(formatEl.nextElementSibling)) {
                core._formatAttrsTemp = formatEl.attributes;
              }
            }
            formatEl = util2.getFormatElement(range.startContainer, null);
            rangeEl = util2.getRangeFormatElement(formatEl, null);
            if (util2.isListCell(formatEl) && util2.isList(rangeEl) && (selectionNode === formatEl || selectionNode.nodeType === 3 && (!selectionNode.nextSibling || util2.isList(selectionNode.nextSibling)) && (util2.getFormatElement(range.startContainer, null) !== util2.getFormatElement(range.endContainer, null) ? rangeEl.contains(range.endContainer) : range.endOffset === selectionNode.textContent.length && range.collapsed))) {
              if (range.startContainer !== range.endContainer) core.removeNode();
              let next = util2.getArrayItem(formatEl.children, util2.isList, false);
              next = next || formatEl.nextElementSibling || rangeEl.parentNode.nextElementSibling;
              if (next && (util2.isList(next) || util2.getArrayItem(next.children, util2.isList, false))) {
                e.preventDefault();
                let con, children4;
                if (util2.isList(next)) {
                  const child = next.firstElementChild;
                  children4 = child.childNodes;
                  con = children4[0];
                  while (children4[0]) {
                    formatEl.insertBefore(children4[0], next);
                  }
                  util2.removeItem(child);
                } else {
                  con = next.firstChild;
                  children4 = next.childNodes;
                  while (children4[0]) {
                    formatEl.appendChild(children4[0]);
                  }
                  util2.removeItem(next);
                }
                core.setRange(con, 0, con, 0);
                core.history.push(true);
              }
              break;
            }
            break;
          case 9:
            if (fileComponentName || options.tabDisable) break;
            e.preventDefault();
            if (ctrl || alt || util2.isWysiwygDiv(selectionNode)) break;
            const isEdge = !range.collapsed || core.isEdgePoint(range.startContainer, range.startOffset);
            const selectedFormats = core.getSelectedElements(null);
            selectionNode = core.getSelectionNode();
            const cells = [];
            let lines = [];
            let fc = util2.isListCell(selectedFormats[0]), lc = util2.isListCell(selectedFormats[selectedFormats.length - 1]);
            let r = { sc: range.startContainer, so: range.startOffset, ec: range.endContainer, eo: range.endOffset };
            for (let i = 0, len = selectedFormats.length, f; i < len; i++) {
              f = selectedFormats[i];
              if (util2.isListCell(f)) {
                if (!f.previousElementSibling && !shift) {
                  continue;
                } else {
                  cells.push(f);
                }
              } else {
                lines.push(f);
              }
            }
            if (cells.length > 0 && isEdge && core.plugins.list) {
              r = core.plugins.list.editInsideList.call(core, shift, cells);
            } else {
              const tableCell = util2.getParentElement(selectionNode, util2.isCell);
              if (tableCell && isEdge) {
                const table = util2.getParentElement(tableCell, "table");
                const cells2 = util2.getListChildren(table, util2.isCell);
                let idx = shift ? util2.prevIdx(cells2, tableCell) : util2.nextIdx(cells2, tableCell);
                if (idx === cells2.length && !shift) idx = 0;
                if (idx === -1 && shift) idx = cells2.length - 1;
                let moveCell = cells2[idx];
                if (!moveCell) break;
                moveCell = moveCell.firstElementChild || moveCell;
                core.setRange(moveCell, 0, moveCell, 0);
                break;
              }
              lines = lines.concat(cells);
              fc = lc = null;
            }
            if (lines.length > 0) {
              if (!shift) {
                const tabText = util2.createTextNode(new _w.Array(core._variable.tabSize + 1).join("\xA0"));
                if (lines.length === 1) {
                  const textRange = core.insertNode(tabText, null, true);
                  if (!textRange) return false;
                  if (!fc) {
                    r.sc = tabText;
                    r.so = textRange.endOffset;
                  }
                  if (!lc) {
                    r.ec = tabText;
                    r.eo = textRange.endOffset;
                  }
                } else {
                  const len = lines.length - 1;
                  for (let i = 0, child; i <= len; i++) {
                    child = lines[i].firstChild;
                    if (!child) continue;
                    if (util2.isBreak(child)) {
                      lines[i].insertBefore(tabText.cloneNode(false), child);
                    } else {
                      child.textContent = tabText.textContent + child.textContent;
                    }
                  }
                  const firstChild = util2.getChildElement(lines[0], "text", false);
                  const endChild = util2.getChildElement(lines[len], "text", true);
                  if (!fc && firstChild) {
                    r.sc = firstChild;
                    r.so = 0;
                  }
                  if (!lc && endChild) {
                    r.ec = endChild;
                    r.eo = endChild.textContent.length;
                  }
                }
              } else {
                const len = lines.length - 1;
                for (let i = 0, line; i <= len; i++) {
                  line = lines[i].childNodes;
                  for (let c = 0, cLen = line.length, child; c < cLen; c++) {
                    child = line[c];
                    if (!child) break;
                    if (util2.onlyZeroWidthSpace(child)) continue;
                    if (/^\s{1,4}$/.test(child.textContent)) {
                      util2.removeItem(child);
                    } else if (/^\s{1,4}/.test(child.textContent)) {
                      child.textContent = child.textContent.replace(/^\s{1,4}/, "");
                    }
                    break;
                  }
                }
                const firstChild = util2.getChildElement(lines[0], "text", false);
                const endChild = util2.getChildElement(lines[len], "text", true);
                if (!fc && firstChild) {
                  r.sc = firstChild;
                  r.so = 0;
                }
                if (!lc && endChild) {
                  r.ec = endChild;
                  r.eo = endChild.textContent.length;
                }
              }
            }
            core.setRange(r.sc, r.so, r.ec, r.eo);
            core.history.push(false);
            break;
          case 13:
            const freeFormatEl = util2.getFreeFormatElement(selectionNode, null);
            if (core._charTypeHTML) {
              let enterHTML = "";
              if (!shift && freeFormatEl || shift) {
                enterHTML = "<br>";
              } else {
                enterHTML = "<" + formatEl.nodeName + "><br></" + formatEl.nodeName + ">";
              }
              if (!core.checkCharCount(enterHTML, "byte-html")) {
                e.preventDefault();
                return false;
              }
            }
            if (!shift && !fileComponentName) {
              const formatEndEdge = core._isEdgeFormat(range.endContainer, range.endOffset, "end");
              const formatStartEdge = core._isEdgeFormat(range.startContainer, range.startOffset, "start");
              if (formatEndEdge && (/^H[1-6]$/i.test(formatEl.nodeName) || /^HR$/i.test(formatEl.nodeName))) {
                event._enterPrevent(e);
                let temp = null;
                const newFormat = core.appendFormatTag(formatEl, options.defaultTag);
                if (formatEndEdge && formatEndEdge.length > 0) {
                  temp = formatEndEdge.pop();
                  const innerNode = temp;
                  while (formatEndEdge.length > 0) {
                    temp = temp.appendChild(formatEndEdge.pop());
                  }
                  newFormat.appendChild(innerNode);
                }
                temp = !temp ? newFormat.firstChild : temp.appendChild(newFormat.firstChild);
                if (util2.isBreak(temp)) {
                  const zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
                  temp.parentNode.insertBefore(zeroWidth, temp);
                  core.setRange(zeroWidth, 1, zeroWidth, 1);
                } else {
                  core.setRange(temp, 0, temp, 0);
                }
                break;
              } else if (rangeEl && formatEl && !util2.isCell(rangeEl) && !/^FIGCAPTION$/i.test(rangeEl.nodeName)) {
                const range2 = core.getRange();
                if (core.isEdgePoint(range2.endContainer, range2.endOffset) && util2.isList(selectionNode.nextSibling)) {
                  event._enterPrevent(e);
                  const newEl = util2.createElement("LI");
                  const br = util2.createElement("BR");
                  newEl.appendChild(br);
                  formatEl.parentNode.insertBefore(newEl, formatEl.nextElementSibling);
                  newEl.appendChild(selectionNode.nextSibling);
                  core.setRange(br, 1, br, 1);
                  break;
                }
                if ((range2.commonAncestorContainer.nodeType === 3 ? !range2.commonAncestorContainer.nextElementSibling : true) && util2.onlyZeroWidthSpace(formatEl.innerText.trim()) && !util2.isListCell(formatEl.nextElementSibling)) {
                  event._enterPrevent(e);
                  let newEl = null;
                  if (util2.isListCell(rangeEl.parentNode)) {
                    const parentLi = formatEl.parentNode.parentNode;
                    rangeEl = parentLi.parentNode;
                    const newListCell = util2.createElement("LI");
                    newListCell.innerHTML = "<br>";
                    util2.copyTagAttributes(newListCell, formatEl, options.lineAttrReset);
                    newEl = newListCell;
                    rangeEl.insertBefore(newEl, parentLi.nextElementSibling);
                  } else {
                    const newFormat = util2.isCell(rangeEl.parentNode) ? "DIV" : util2.isList(rangeEl.parentNode) ? "LI" : util2.isFormatElement(rangeEl.nextElementSibling) && !util2.isRangeFormatElement(rangeEl.nextElementSibling) ? rangeEl.nextElementSibling.nodeName : util2.isFormatElement(rangeEl.previousElementSibling) && !util2.isRangeFormatElement(rangeEl.previousElementSibling) ? rangeEl.previousElementSibling.nodeName : options.defaultTag;
                    newEl = util2.createElement(newFormat);
                    util2.copyTagAttributes(newEl, formatEl, options.lineAttrReset);
                    const edge = core.detachRangeFormatElement(rangeEl, [formatEl], null, true, true);
                    edge.cc.insertBefore(newEl, edge.ec);
                  }
                  newEl.innerHTML = "<br>";
                  util2.removeItemAllParents(formatEl, null, null);
                  core.setRange(newEl, 1, newEl, 1);
                  break;
                }
              }
              if (freeFormatEl) {
                event._enterPrevent(e);
                const selectionFormat = selectionNode === freeFormatEl;
                const wSelection = core.getSelection();
                const children4 = selectionNode.childNodes, offset = wSelection.focusOffset, prev = selectionNode.previousElementSibling, next = selectionNode.nextSibling;
                if (!util2.isClosureFreeFormatElement(freeFormatEl) && !!children4 && (selectionFormat && range.collapsed && children4.length - 1 <= offset + 1 && util2.isBreak(children4[offset]) && (!children4[offset + 1] || (!children4[offset + 2] || util2.onlyZeroWidthSpace(children4[offset + 2].textContent)) && children4[offset + 1].nodeType === 3 && util2.onlyZeroWidthSpace(children4[offset + 1].textContent)) && offset > 0 && util2.isBreak(children4[offset - 1]) || !selectionFormat && util2.onlyZeroWidthSpace(selectionNode.textContent) && util2.isBreak(prev) && (util2.isBreak(prev.previousSibling) || !util2.onlyZeroWidthSpace(prev.previousSibling.textContent)) && (!next || !util2.isBreak(next) && util2.onlyZeroWidthSpace(next.textContent)))) {
                  if (selectionFormat) util2.removeItem(children4[offset - 1]);
                  else util2.removeItem(selectionNode);
                  const newEl = core.appendFormatTag(freeFormatEl, util2.isFormatElement(freeFormatEl.nextElementSibling) && !util2.isRangeFormatElement(freeFormatEl.nextElementSibling) ? freeFormatEl.nextElementSibling : null);
                  util2.copyFormatAttributes(newEl, freeFormatEl);
                  core.setRange(newEl, 1, newEl, 1);
                  break;
                }
                if (selectionFormat) {
                  functions.insertHTML(range.collapsed && util2.isBreak(range.startContainer.childNodes[range.startOffset - 1]) ? "<br>" : "<br><br>", true, false);
                  let focusNode = wSelection.focusNode;
                  const wOffset = wSelection.focusOffset;
                  if (freeFormatEl === focusNode) {
                    focusNode = focusNode.childNodes[wOffset - offset > 1 ? wOffset - 1 : wOffset];
                  }
                  core.setRange(focusNode, 1, focusNode, 1);
                } else {
                  const focusNext = wSelection.focusNode.nextSibling;
                  const br = util2.createElement("BR");
                  core.insertNode(br, null, false);
                  const brPrev = br.previousSibling, brNext = br.nextSibling;
                  if (!util2.isBreak(focusNext) && !util2.isBreak(brPrev) && (!brNext || util2.onlyZeroWidthSpace(brNext))) {
                    br.parentNode.insertBefore(br.cloneNode(false), br);
                    core.setRange(br, 1, br, 1);
                  } else {
                    core.setRange(brNext, 0, brNext, 0);
                  }
                }
                event._onShortcutKey = true;
                break;
              }
              if (range.collapsed && (formatStartEdge || formatEndEdge)) {
                event._enterPrevent(e);
                const focusBR = util2.createElement("BR");
                const newFormat = util2.createElement(formatEl.nodeName);
                util2.copyTagAttributes(newFormat, formatEl, options.lineAttrReset);
                let child = focusBR;
                do {
                  if (!util2.isBreak(selectionNode) && selectionNode.nodeType === 1) {
                    const f = selectionNode.cloneNode(false);
                    f.appendChild(child);
                    child = f;
                  }
                  selectionNode = selectionNode.parentNode;
                } while (formatEl !== selectionNode && formatEl.contains(selectionNode));
                newFormat.appendChild(child);
                formatEl.parentNode.insertBefore(newFormat, formatStartEdge && !formatEndEdge ? formatEl : formatEl.nextElementSibling);
                if (formatEndEdge) {
                  core.setRange(focusBR, 1, focusBR, 1);
                }
                break;
              }
              if (formatEl) {
                e.stopPropagation();
                let newEl;
                let offset = 0;
                if (!range.collapsed) {
                  const isMultiLine = util2.getFormatElement(range.startContainer, null) !== util2.getFormatElement(range.endContainer, null);
                  const newFormat = formatEl.cloneNode(false);
                  newFormat.innerHTML = "<br>";
                  const r2 = core.removeNode();
                  newEl = util2.getFormatElement(r2.container, null);
                  if (!newEl) {
                    if (util2.isWysiwygDiv(r2.container)) {
                      event._enterPrevent(e);
                      context.element.wysiwyg.appendChild(newFormat);
                      newEl = newFormat;
                      util2.copyTagAttributes(newEl, formatEl, options.lineAttrReset);
                      core.setRange(newEl, offset, newEl, offset);
                    }
                    break;
                  }
                  const innerRange = util2.getRangeFormatElement(r2.container);
                  newEl = newEl.contains(innerRange) ? util2.getChildElement(innerRange, util2.getFormatElement.bind(util2)) : newEl;
                  if (isMultiLine) {
                    if (formatEndEdge && !formatStartEdge) {
                      newEl.parentNode.insertBefore(newFormat, !r2.prevContainer || r2.container === r2.prevContainer ? newEl.nextElementSibling : newEl);
                      newEl = newFormat;
                      offset = 0;
                    } else {
                      offset = r2.offset;
                      if (formatStartEdge) {
                        const tempEl = newEl.parentNode.insertBefore(newFormat, newEl);
                        if (formatEndEdge) {
                          newEl = tempEl;
                          offset = 0;
                        }
                      }
                    }
                  } else {
                    if (formatEndEdge && formatStartEdge) {
                      newEl.parentNode.insertBefore(newFormat, r2.prevContainer && r2.container === r2.prevContainer ? newEl.nextElementSibling : newEl);
                      newEl = newFormat;
                      offset = 0;
                    } else {
                      newEl = util2.splitElement(r2.container, r2.offset, util2.getElementDepth(formatEl));
                    }
                  }
                } else {
                  if (util2.onlyZeroWidthSpace(formatEl)) {
                    newEl = core.appendFormatTag(formatEl, formatEl.cloneNode(false));
                  } else {
                    newEl = util2.splitElement(range.endContainer, range.endOffset, util2.getElementDepth(formatEl));
                  }
                }
                event._enterPrevent(e);
                util2.copyTagAttributes(newEl, formatEl, options.lineAttrReset);
                core.setRange(newEl, offset, newEl, offset);
                break;
              }
            }
            if (selectRange) break;
            if (rangeEl && util2.getParentElement(rangeEl, "FIGCAPTION") && util2.getParentElement(rangeEl, util2.isList)) {
              event._enterPrevent(e);
              formatEl = core.appendFormatTag(formatEl, null);
              core.setRange(formatEl, 0, formatEl, 0);
            }
            if (fileComponentName) {
              e.preventDefault();
              e.stopPropagation();
              core.containerOff();
              core.controllersOff();
              const compContext = context[fileComponentName];
              const container = compContext._container;
              const sibling = container.previousElementSibling || container.nextElementSibling;
              let newEl = null;
              if (util2.isListCell(container.parentNode)) {
                newEl = util2.createElement("BR");
              } else {
                newEl = util2.createElement(util2.isFormatElement(sibling) && !util2.isRangeFormatElement(sibling) ? sibling.nodeName : options.defaultTag);
                newEl.innerHTML = "<br>";
              }
              if (shift) container.parentNode.insertBefore(newEl, container);
              else container.parentNode.insertBefore(newEl, container.nextElementSibling);
              core.callPlugin(fileComponentName, function() {
                if (core.selectComponent(compContext._element, fileComponentName) === false) core.blur();
              }, null);
            }
            break;
          case 27:
            if (fileComponentName) {
              e.preventDefault();
              e.stopPropagation();
              core.controllersOff();
              return false;
            }
            break;
        }
        if (shift && keyCode === 16) {
          e.preventDefault();
          e.stopPropagation();
          const tablePlugin = core.plugins.table;
          if (tablePlugin && !tablePlugin._shift && !tablePlugin._ref) {
            const cell = util2.getParentElement(formatEl, util2.isCell);
            if (cell) {
              tablePlugin.onTableCellMultiSelect.call(core, cell, true);
              return;
            }
          }
        } else if (shift && (util2.isOSX_IOS ? alt : ctrl) && keyCode === 32) {
          e.preventDefault();
          e.stopPropagation();
          const nbsp = core.insertNode(util2.createTextNode("\xA0"));
          if (nbsp && nbsp.container) {
            core.setRange(nbsp.container, nbsp.endOffset, nbsp.container, nbsp.endOffset);
            return;
          }
        }
        if (util2.isIE && !ctrl && !alt && !selectRange && !event._nonTextKeyCode.test(keyCode) && util2.isBreak(range.commonAncestorContainer)) {
          const zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
          core.insertNode(zeroWidth, null, false);
          core.setRange(zeroWidth, 1, zeroWidth, 1);
        }
        if (event._directionKeyCode.test(keyCode)) {
          core._editorRange();
          event._applyTagEffects();
        }
      },
      _onKeyDown_wysiwyg_arrowKey: function(e) {
        if (e.shiftKey) return;
        let selectionNode = core.getSelectionNode();
        const selectNode = function(node, offset = 0) {
          e.preventDefault();
          e.stopPropagation();
          if (!node) return;
          let componentInfo2 = core.getFileComponent(node);
          if (componentInfo2) {
            core.selectComponent(componentInfo2.target, componentInfo2.pluginName);
          } else {
            core.setRange(node, offset, node, offset);
            core.controllersOff();
          }
        };
        const table = util2.getParentElement(selectionNode, "table");
        if (table) {
          const currentRow = util2.getParentElement(selectionNode, "tr");
          const currentCell = util2.getParentElement(selectionNode, "td");
          let currentCellFirstNode = currentCell;
          let currentCellLastNode = currentCell;
          if (currentCell) {
            while (currentCellFirstNode.firstChild) currentCellFirstNode = currentCellFirstNode.firstChild;
            while (currentCellLastNode.lastChild) currentCellLastNode = currentCellLastNode.lastChild;
          }
          let selectionNodeDeepestFirstChild = selectionNode;
          while (selectionNodeDeepestFirstChild.firstChild) selectionNodeDeepestFirstChild = selectionNodeDeepestFirstChild.firstChild;
          const isCellFirstNode = selectionNodeDeepestFirstChild === currentCellFirstNode;
          const isCellLastNode = selectionNodeDeepestFirstChild === currentCellLastNode;
          let siblingToSet = null;
          let offset = 0;
          if (e.keyCode === 38 && isCellFirstNode) {
            const previousRow = currentRow && currentRow.previousElementSibling;
            if (previousRow) siblingToSet = previousRow.children[currentCell.cellIndex];
            else siblingToSet = util2.getPreviousDeepestNode(table, core.context.element.wysiwyg);
            while (siblingToSet.lastChild) siblingToSet = siblingToSet.lastChild;
            if (siblingToSet) offset = siblingToSet.textContent.length;
          } else if (e.keyCode === 40 && isCellLastNode) {
            const nextRow = currentRow && currentRow.nextElementSibling;
            if (nextRow) siblingToSet = nextRow.children[currentCell.cellIndex];
            else siblingToSet = util2.getNextDeepestNode(table, core.context.element.wysiwyg);
            while (siblingToSet.firstChild) siblingToSet = siblingToSet.firstChild;
          }
          if (siblingToSet) {
            selectNode(siblingToSet, offset);
            return false;
          }
        }
        const componentInfo = core.getFileComponent(selectionNode);
        if (componentInfo) {
          const selectPrevious = /37|38/.test(e.keyCode);
          const selectNext = /39|40/.test(e.keyCode);
          if (selectPrevious) {
            const previousDeepestNode = util2.getPreviousDeepestNode(componentInfo.target, core.context.element.wysiwyg);
            selectNode(previousDeepestNode, previousDeepestNode && previousDeepestNode.textContent.length);
          } else if (selectNext) {
            const nextDeepestNode = util2.getNextDeepestNode(componentInfo.target, core.context.element.wysiwyg);
            selectNode(nextDeepestNode);
          }
        }
      },
      onKeyUp_wysiwyg: function(e) {
        if (event._onShortcutKey) return;
        core._editorRange();
        const keyCode = e.keyCode;
        const ctrl = e.ctrlKey || e.metaKey || keyCode === 91 || keyCode === 92 || keyCode === 224;
        const alt = e.altKey;
        if (core.isReadOnly) {
          if (!ctrl && event._cursorMoveKeyCode.test(keyCode)) event._applyTagEffects();
          return;
        }
        const range = core.getRange();
        let selectionNode = core.getSelectionNode();
        if (core._isBalloon && (core._isBalloonAlways && keyCode !== 27 || !range.collapsed)) {
          if (core._isBalloonAlways) {
            if (keyCode !== 27) event._showToolbarBalloonDelay();
          } else {
            event._showToolbarBalloon();
            return;
          }
        }
        let selectionNodeDeepestFirstChild = selectionNode;
        while (selectionNodeDeepestFirstChild.firstChild) selectionNodeDeepestFirstChild = selectionNodeDeepestFirstChild.firstChild;
        const selectedComponentInfo = core.getFileComponent(selectionNodeDeepestFirstChild);
        if (!(e.keyCode === 16 || e.shiftKey) && selectedComponentInfo) core.selectComponent(selectedComponentInfo.target, selectedComponentInfo.pluginName);
        else if (core.currentFileComponentInfo) core.controllersOff();
        if (keyCode === 8 && util2.isWysiwygDiv(selectionNode) && selectionNode.textContent === "" && selectionNode.children.length === 0) {
          e.preventDefault();
          e.stopPropagation();
          selectionNode.innerHTML = "";
          const oFormatTag = util2.createElement(util2.isFormatElement(core._variable.currentNodes[0]) ? core._variable.currentNodes[0] : options.defaultTag);
          oFormatTag.innerHTML = "<br>";
          selectionNode.appendChild(oFormatTag);
          core.setRange(oFormatTag, 0, oFormatTag, 0);
          event._applyTagEffects();
          core.history.push(false);
          return;
        }
        const formatEl = util2.getFormatElement(selectionNode, null);
        const rangeEl = util2.getRangeFormatElement(selectionNode, null);
        const attrs = core._formatAttrsTemp;
        if (attrs) {
          for (let i = 0, len = attrs.length; i < len; i++) {
            if (keyCode === 13 && /^id$/i.test(attrs[i].name)) {
              formatEl.removeAttribute("id");
              continue;
            }
            formatEl.setAttribute(attrs[i].name, attrs[i].value);
          }
          core._formatAttrsTemp = null;
        }
        if (!formatEl && range.collapsed && !util2.isComponent(selectionNode) && !util2.isList(selectionNode) && core._setDefaultFormat(util2.isRangeFormatElement(rangeEl) ? "DIV" : options.defaultTag) !== null) {
          selectionNode = core.getSelectionNode();
        }
        const textKey = !ctrl && !alt && !event._nonTextKeyCode.test(keyCode);
        if (textKey && selectionNode.nodeType === 3 && util2.zeroWidthRegExp.test(selectionNode.textContent) && !(e.isComposing !== void 0 ? e.isComposing : event._IEisComposing)) {
          let so = range.startOffset, eo = range.endOffset;
          const frontZeroWidthCnt = (selectionNode.textContent.substring(0, eo).match(event._frontZeroWidthReg) || "").length;
          so = range.startOffset - frontZeroWidthCnt;
          eo = range.endOffset - frontZeroWidthCnt;
          selectionNode.textContent = selectionNode.textContent.replace(util2.zeroWidthRegExp, "");
          core.setRange(selectionNode, so < 0 ? 0 : so, selectionNode, eo < 0 ? 0 : eo);
        }
        core._charCount("");
        if (typeof functions.onKeyUp === "function" && functions.onKeyUp(e, core) === false) return;
        if (!ctrl && !alt && !event._historyIgnoreKeyCode.test(keyCode)) {
          core.history.push(true);
        }
      },
      onScroll_wysiwyg: function(e) {
        core.controllersOff();
        if (core._isBalloon) event._hideToolbar();
        if (typeof functions.onScroll === "function") functions.onScroll(e, core);
      },
      onFocus_wysiwyg: function(e) {
        if (core._antiBlur) return;
        core.hasFocus = true;
        _w.setTimeout(event._applyTagEffects);
        if (core._isInline) event._showToolbarInline();
        if (typeof functions.onFocus === "function") functions.onFocus(e, core);
      },
      onBlur_wysiwyg: function(e) {
        if (core._antiBlur || core._variable.isCodeView) return;
        core.hasFocus = false;
        core.effectNode = null;
        core.controllersOff();
        if (core._isInline || core._isBalloon) event._hideToolbar();
        core._setKeyEffect([]);
        core._variable.currentNodes = [];
        core._variable.currentNodesMap = [];
        if (options.showPathLabel) context.element.navigation.textContent = "";
        if (typeof functions.onBlur === "function") functions.onBlur(e, core, this);
      },
      onMouseDown_resizingBar: function(e) {
        e.stopPropagation();
        core.submenuOff();
        core.controllersOff();
        core._variable.resizeClientY = e.clientY;
        context.element.resizeBackground.style.display = "block";
        function closureFunc() {
          context.element.resizeBackground.style.display = "none";
          _d.removeEventListener("mousemove", event._resize_editor);
          _d.removeEventListener("mouseup", closureFunc);
        }
        _d.addEventListener("mousemove", event._resize_editor);
        _d.addEventListener("mouseup", closureFunc);
      },
      _resize_editor: function(e) {
        const resizeInterval = context.element.editorArea.offsetHeight + (e.clientY - core._variable.resizeClientY);
        const h = resizeInterval < core._variable.minResizingSize ? core._variable.minResizingSize : resizeInterval;
        context.element.wysiwygFrame.style.height = context.element.code.style.height = h + "px";
        core._variable.resizeClientY = e.clientY;
        if (!util2.isResizeObserverSupported) core.__callResizeFunction(h, null);
      },
      onResize_window: function() {
        if (!util2.isResizeObserverSupported) core.resetResponsiveToolbar();
        const toolbar = context.element.toolbar;
        const isToolbarHidden = toolbar.style.display === "none" || core._isInline && !core._inlineToolbarAttr.isShow;
        if (toolbar.offsetWidth === 0 && !isToolbarHidden) return;
        if (context.fileBrowser && context.fileBrowser.area.style.display === "block") {
          context.fileBrowser.body.style.maxHeight = _w.innerHeight - context.fileBrowser.header.offsetHeight - 50 + "px";
        }
        if (core.submenuActiveButton && core.submenu) {
          core._setMenuPosition(core.submenuActiveButton, core.submenu);
        }
        if (core._variable.isFullScreen) {
          core._variable.innerHeight_fullScreen += _w.innerHeight - toolbar.offsetHeight - core._variable.innerHeight_fullScreen;
          context.element.editorArea.style.height = core._variable.innerHeight_fullScreen + "px";
          return;
        }
        if (core._variable.isCodeView && core._isInline) {
          event._showToolbarInline();
          return;
        }
        core._iframeAutoHeight();
        if (core._sticky) {
          toolbar.style.width = context.element.topArea.offsetWidth - 2 + "px";
          event.onScroll_window();
        }
      },
      onScroll_window: function() {
        if (core._variable.isFullScreen || context.element.toolbar.offsetWidth === 0 || options.stickyToolbar < 0) return;
        const element = context.element;
        const editorHeight = element.editorArea.offsetHeight;
        const y = (this.scrollY || _d.documentElement.scrollTop) + options.stickyToolbar;
        const editorTop = event._getEditorOffsets(options.toolbarContainer).top - (core._isInline ? element.toolbar.offsetHeight : 0);
        const inlineOffset = core._isInline && y - editorTop > 0 ? y - editorTop - context.element.toolbar.offsetHeight : 0;
        if (y < editorTop) {
          event._offStickyToolbar();
        } else if (y + core._variable.minResizingSize >= editorHeight + editorTop) {
          if (!core._sticky) event._onStickyToolbar(inlineOffset);
          element.toolbar.style.top = inlineOffset + editorHeight + editorTop + options.stickyToolbar - y - core._variable.minResizingSize + "px";
        } else if (y >= editorTop) {
          event._onStickyToolbar(inlineOffset);
        }
      },
      _getEditorOffsets: function(container) {
        let offsetEl = container || context.element.topArea;
        let t = 0, l = 0, s = 0;
        while (offsetEl) {
          t += offsetEl.offsetTop;
          l += offsetEl.offsetLeft;
          s += offsetEl.scrollTop;
          offsetEl = offsetEl.offsetParent;
        }
        return {
          top: t,
          left: l,
          scroll: s
        };
      },
      _getPageBottomSpace: function() {
        return _d.documentElement.scrollHeight - (event._getEditorOffsets(null).top + context.element.topArea.offsetHeight);
      },
      _onStickyToolbar: function(inlineOffset) {
        const element = context.element;
        if (!core._isInline && !options.toolbarContainer) {
          element._stickyDummy.style.height = element.toolbar.offsetHeight + "px";
          element._stickyDummy.style.display = "block";
        }
        element.toolbar.style.top = options.stickyToolbar + inlineOffset + "px";
        element.toolbar.style.width = core._isInline ? core._inlineToolbarAttr.width : element.toolbar.offsetWidth + "px";
        util2.addClass(element.toolbar, "se-toolbar-sticky");
        core._sticky = true;
      },
      _offStickyToolbar: function() {
        const element = context.element;
        element._stickyDummy.style.display = "none";
        element.toolbar.style.top = core._isInline ? core._inlineToolbarAttr.top : "";
        element.toolbar.style.width = core._isInline ? core._inlineToolbarAttr.width : "";
        element.editorArea.style.marginTop = "";
        util2.removeClass(element.toolbar, "se-toolbar-sticky");
        core._sticky = false;
      },
      _codeViewAutoHeight: function() {
        if (core._variable.isFullScreen) return;
        context.element.code.style.height = context.element.code.scrollHeight + "px";
      },
      // FireFox - table delete, Chrome - image, video, audio
      _hardDelete: function() {
        const range = core.getRange();
        const sc = range.startContainer;
        const ec = range.endContainer;
        const sCell = util2.getRangeFormatElement(sc);
        const eCell = util2.getRangeFormatElement(ec);
        const sIsCell = util2.isCell(sCell);
        const eIsCell = util2.isCell(eCell);
        const ancestor = range.commonAncestorContainer;
        if ((sIsCell && !sCell.previousElementSibling && !sCell.parentElement.previousElementSibling || eIsCell && !eCell.nextElementSibling && !eCell.parentElement.nextElementSibling) && sCell !== eCell) {
          if (!sIsCell) {
            util2.removeItem(util2.getParentElement(eCell, function(current) {
              return ancestor === current.parentNode;
            }));
          } else if (!eIsCell) {
            util2.removeItem(util2.getParentElement(sCell, function(current) {
              return ancestor === current.parentNode;
            }));
          } else {
            util2.removeItem(util2.getParentElement(sCell, function(current) {
              return ancestor === current.parentNode;
            }));
            core.nativeFocus();
            return true;
          }
        }
        const sComp = sc.nodeType === 1 ? util2.getParentElement(sc, ".se-component") : null;
        const eComp = ec.nodeType === 1 ? util2.getParentElement(ec, ".se-component") : null;
        if (sComp) util2.removeItem(sComp);
        if (eComp) util2.removeItem(eComp);
        return false;
      },
      onPaste_wysiwyg: function(e) {
        const clipboardData = util2.isIE ? _w.clipboardData : e.clipboardData;
        if (!clipboardData) return true;
        return event._dataTransferAction("paste", e, clipboardData);
      },
      _setClipboardComponent: function(e, info, clipboardData) {
        e.preventDefault();
        e.stopPropagation();
        clipboardData.setData("text/html", info.component.outerHTML);
      },
      onCopy_wysiwyg: function(e) {
        const clipboardData = util2.isIE ? _w.clipboardData : e.clipboardData;
        if (typeof functions.onCopy === "function" && functions.onCopy(e, clipboardData, core) === false) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        const info = core.currentFileComponentInfo;
        if (info && !util2.isIE) {
          event._setClipboardComponent(e, info, clipboardData);
          util2.addClass(info.component, "se-component-copy");
          _w.setTimeout(function() {
            util2.removeClass(info.component, "se-component-copy");
          }, 150);
        }
      },
      onSave_wysiwyg: function(content) {
        if (typeof functions.onSave === "function") {
          functions.onSave(content, core);
          return;
        }
      },
      onCut_wysiwyg: function(e) {
        const clipboardData = util2.isIE ? _w.clipboardData : e.clipboardData;
        if (typeof functions.onCut === "function" && functions.onCut(e, clipboardData, core) === false) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        const info = core.currentFileComponentInfo;
        if (info && !util2.isIE) {
          event._setClipboardComponent(e, info, clipboardData);
          util2.removeItem(info.component);
          core.controllersOff();
        }
        _w.setTimeout(function() {
          core.history.push(false);
        });
      },
      onDrop_wysiwyg: function(e) {
        if (core.isReadOnly || util2.isIE) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        const dataTransfer = e.dataTransfer;
        if (!dataTransfer) return true;
        event._setDropLocationSelection(e);
        core.removeNode();
        if (!document.body.contains(core.currentControllerTarget)) core.controllersOff();
        return event._dataTransferAction("drop", e, dataTransfer);
      },
      _setDropLocationSelection: function(e) {
        const range = { startContainer: null, startOffset: null, endContainer: null, endOffset: null };
        let r = null;
        if (e.rangeParent) {
          range.startContainer = e.rangeParent;
          range.startOffset = e.rangeOffset;
          range.endContainer = e.rangeParent;
          range.endOffset = e.rangeOffset;
        } else if (core._wd.caretRangeFromPoint) {
          r = core._wd.caretRangeFromPoint(e.clientX, e.clientY);
        } else {
          r = core.getRange();
        }
        if (r) {
          range.startContainer = r.startContainer;
          range.startOffset = r.startOffset;
          range.endContainer = r.endContainer;
          range.endOffset = r.endOffset;
        }
        if (range.startContainer === range.endContainer) {
          const component4 = util2.getParentElement(range.startContainer, util2.isComponent);
          if (component4) {
            range.startContainer = component4;
            range.startOffset = 0;
            range.endContainer = component4;
            range.endOffset = 0;
          }
        }
        core.setRange(range.startContainer, range.startOffset, range.endContainer, range.endOffset);
      },
      _dataTransferAction: function(type, e, data2) {
        let plainText, cleanData;
        if (util2.isIE) {
          plainText = data2.getData("Text");
          const range = core.getRange();
          const tempDiv = util2.createElement("DIV");
          const tempRange = {
            sc: range.startContainer,
            so: range.startOffset,
            ec: range.endContainer,
            eo: range.endOffset
          };
          tempDiv.setAttribute("contenteditable", true);
          tempDiv.style.cssText = "position:absolute; top:0; left:0; width:1px; height:1px; overflow:hidden;";
          context.element.relative.appendChild(tempDiv);
          tempDiv.focus();
          _w.setTimeout(function() {
            cleanData = tempDiv.innerHTML;
            util2.removeItem(tempDiv);
            core.setRange(tempRange.sc, tempRange.so, tempRange.ec, tempRange.eo);
            event._setClipboardData(type, e, plainText, cleanData, data2);
          });
          return true;
        } else {
          plainText = data2.getData("text/plain");
          cleanData = data2.getData("text/html");
          if (event._setClipboardData(type, e, plainText, cleanData, data2) === false) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        }
      },
      _setClipboardData: function(type, e, plainText, cleanData, data2) {
        const MSData = /class=["']*Mso(Normal|List)/i.test(cleanData) || /content=["']*Word.Document/i.test(cleanData) || /content=["']*OneNote.File/i.test(cleanData) || /content=["']*Excel.Sheet/i.test(cleanData);
        const onlyText = !cleanData;
        if (!onlyText) {
          cleanData = cleanData.replace(/^<html>\r?\n?<body>\r?\n?\x3C!--StartFragment--\>|\x3C!--EndFragment-->\r?\n?<\/body\>\r?\n?<\/html>$/g, "");
          if (MSData) {
            cleanData = cleanData.replace(/\n/g, " ");
            plainText = plainText.replace(/\n/g, " ");
          }
          cleanData = core.cleanHTML(cleanData, core.pasteTagsWhitelistRegExp, core.pasteTagsBlacklistRegExp);
        } else {
          cleanData = util2._HTMLConvertor(plainText).replace(/\n/g, "<br>");
        }
        const maxCharCount = core._charCount(core._charTypeHTML ? cleanData : plainText);
        if (type === "paste" && typeof functions.onPaste === "function") {
          const value = functions.onPaste(e, cleanData, maxCharCount, core);
          if (value === false) {
            return false;
          } else if (typeof value === "string") {
            if (!value) return false;
            cleanData = value;
          }
        }
        if (type === "drop" && typeof functions.onDrop === "function") {
          const value = functions.onDrop(e, cleanData, maxCharCount, core);
          if (value === false) {
            return false;
          } else if (typeof value === "string") {
            if (!value) return false;
            cleanData = value;
          }
        }
        const files = data2.files;
        if (files.length > 0 && !MSData) {
          if (/^image/.test(files[0].type) && core.plugins.image) {
            functions.insertImage(files);
          }
          return false;
        }
        if (!maxCharCount) {
          return false;
        }
        if (cleanData) {
          functions.insertHTML(cleanData, true, false);
          return false;
        }
      },
      onMouseMove_wysiwyg: function(e) {
        if (core.isDisabled || core.isReadOnly) return false;
        const component4 = util2.getParentElement(e.target, util2.isComponent);
        const lineBreakerStyle = core._lineBreaker.style;
        if (component4 && !core.currentControllerName) {
          const ctxEl = context.element;
          let scrollTop = 0;
          let el = ctxEl.wysiwyg;
          do {
            scrollTop += el.scrollTop;
            el = el.parentElement;
          } while (el && !/^(BODY|HTML)$/i.test(el.nodeName));
          const wScroll = ctxEl.wysiwyg.scrollTop;
          const offsets = event._getEditorOffsets(null);
          const componentTop = util2.getOffset(component4, ctxEl.wysiwygFrame).top + wScroll;
          const y = e.pageY + scrollTop + (options.iframe && !options.toolbarContainer ? ctxEl.toolbar.offsetHeight : 0);
          const c = componentTop + (options.iframe ? scrollTop : offsets.top);
          const isList = util2.isListCell(component4.parentNode);
          let dir = "", top = "";
          if ((isList ? !component4.previousSibling : !util2.isFormatElement(component4.previousElementSibling)) && y < c + 20) {
            top = componentTop;
            dir = "t";
          } else if ((isList ? !component4.nextSibling : !util2.isFormatElement(component4.nextElementSibling)) && y > c + component4.offsetHeight - 20) {
            top = componentTop + component4.offsetHeight;
            dir = "b";
          } else {
            lineBreakerStyle.display = "none";
            return;
          }
          core._variable._lineBreakComp = component4;
          core._variable._lineBreakDir = dir;
          lineBreakerStyle.top = top - wScroll + "px";
          core._lineBreakerButton.style.left = util2.getOffset(component4).left + component4.offsetWidth / 2 - 15 + "px";
          lineBreakerStyle.display = "block";
        } else if (lineBreakerStyle.display !== "none") {
          lineBreakerStyle.display = "none";
        }
      },
      _enterPrevent(e) {
        e.preventDefault();
        if (!util2.isMobile) return;
        core.__focusTemp.focus();
      },
      _onMouseDown_lineBreak: function(e) {
        e.preventDefault();
      },
      _onLineBreak: function(e) {
        e.preventDefault();
        const component4 = core._variable._lineBreakComp;
        const dir = !this ? core._variable._lineBreakDir : this;
        const isList = util2.isListCell(component4.parentNode);
        const format = util2.createElement(isList ? "BR" : util2.isCell(component4.parentNode) ? "DIV" : options.defaultTag);
        if (!isList) format.innerHTML = "<br>";
        if (core._charTypeHTML && !core.checkCharCount(format.outerHTML, "byte-html")) return;
        component4.parentNode.insertBefore(format, dir === "t" ? component4 : component4.nextSibling);
        core._lineBreaker.style.display = "none";
        core._variable._lineBreakComp = null;
        const focusEl = isList ? format : format.firstChild;
        core.setRange(focusEl, 1, focusEl, 1);
        core.history.push(false);
      },
      _resizeObserver: null,
      _toolbarObserver: null,
      _addEvent: function() {
        const eventWysiwyg = options.iframe ? core._ww : context.element.wysiwyg;
        if (util2.isResizeObserverSupported) {
          this._resizeObserver = new _w.ResizeObserver(function(entries) {
            core.__callResizeFunction(-1, entries[0]);
          });
        }
        context.element.toolbar.addEventListener("mousedown", event._buttonsEventHandler, false);
        context.element._menuTray.addEventListener("mousedown", event._buttonsEventHandler, false);
        context.element.toolbar.addEventListener("click", event.onClick_toolbar, false);
        eventWysiwyg.addEventListener("mousedown", event.onMouseDown_wysiwyg, false);
        eventWysiwyg.addEventListener("click", event.onClick_wysiwyg, false);
        eventWysiwyg.addEventListener(util2.isIE ? "textinput" : "input", event.onInput_wysiwyg, false);
        eventWysiwyg.addEventListener("keydown", event.onKeyDown_wysiwyg, false);
        eventWysiwyg.addEventListener("keyup", event.onKeyUp_wysiwyg, false);
        eventWysiwyg.addEventListener("paste", event.onPaste_wysiwyg, false);
        eventWysiwyg.addEventListener("copy", event.onCopy_wysiwyg, false);
        eventWysiwyg.addEventListener("cut", event.onCut_wysiwyg, false);
        eventWysiwyg.addEventListener("drop", event.onDrop_wysiwyg, false);
        eventWysiwyg.addEventListener("scroll", event.onScroll_wysiwyg, false);
        eventWysiwyg.addEventListener("focus", event.onFocus_wysiwyg, false);
        eventWysiwyg.addEventListener("blur", event.onBlur_wysiwyg, false);
        event._lineBreakerBind = { a: event._onLineBreak.bind(""), t: event._onLineBreak.bind("t"), b: event._onLineBreak.bind("b") };
        eventWysiwyg.addEventListener("mousemove", event.onMouseMove_wysiwyg, false);
        core._lineBreakerButton.addEventListener("mousedown", event._onMouseDown_lineBreak, false);
        core._lineBreakerButton.addEventListener("click", event._lineBreakerBind.a, false);
        context.element.lineBreaker_t.addEventListener("mousedown", event._lineBreakerBind.t, false);
        context.element.lineBreaker_b.addEventListener("mousedown", event._lineBreakerBind.b, false);
        eventWysiwyg.addEventListener("touchstart", event.onMouseDown_wysiwyg, { passive: true, useCapture: false });
        eventWysiwyg.addEventListener("touchend", event.onClick_wysiwyg, { passive: true, useCapture: false });
        if (options.height === "auto" && !options.codeMirrorEditor) {
          context.element.code.addEventListener("keydown", event._codeViewAutoHeight, false);
          context.element.code.addEventListener("keyup", event._codeViewAutoHeight, false);
          context.element.code.addEventListener("paste", event._codeViewAutoHeight, false);
        }
        if (context.element.resizingBar) {
          if (/\d+/.test(options.height) && options.resizeEnable) {
            context.element.resizingBar.addEventListener("mousedown", event.onMouseDown_resizingBar, false);
          } else {
            util2.addClass(context.element.resizingBar, "se-resizing-none");
          }
        }
        event._setResponsiveToolbar();
        if (util2.isResizeObserverSupported) this._toolbarObserver = new _w.ResizeObserver(core.resetResponsiveToolbar);
        _w.addEventListener("resize", event.onResize_window, false);
        if (options.stickyToolbar > -1) {
          _w.addEventListener("scroll", event.onScroll_window, false);
        }
      },
      _removeEvent: function() {
        const eventWysiwyg = options.iframe ? core._ww : context.element.wysiwyg;
        context.element.toolbar.removeEventListener("mousedown", event._buttonsEventHandler);
        context.element._menuTray.removeEventListener("mousedown", event._buttonsEventHandler);
        context.element.toolbar.removeEventListener("click", event.onClick_toolbar);
        eventWysiwyg.removeEventListener("mousedown", event.onMouseDown_wysiwyg);
        eventWysiwyg.removeEventListener("click", event.onClick_wysiwyg);
        eventWysiwyg.removeEventListener(util2.isIE ? "textinput" : "input", event.onInput_wysiwyg);
        eventWysiwyg.removeEventListener("keydown", event.onKeyDown_wysiwyg);
        eventWysiwyg.removeEventListener("keyup", event.onKeyUp_wysiwyg);
        eventWysiwyg.removeEventListener("paste", event.onPaste_wysiwyg);
        eventWysiwyg.removeEventListener("copy", event.onCopy_wysiwyg);
        eventWysiwyg.removeEventListener("cut", event.onCut_wysiwyg);
        eventWysiwyg.removeEventListener("drop", event.onDrop_wysiwyg);
        eventWysiwyg.removeEventListener("scroll", event.onScroll_wysiwyg);
        eventWysiwyg.removeEventListener("mousemove", event.onMouseMove_wysiwyg);
        core._lineBreakerButton.removeEventListener("mousedown", event._onMouseDown_lineBreak);
        core._lineBreakerButton.removeEventListener("click", event._lineBreakerBind.a);
        context.element.lineBreaker_t.removeEventListener("mousedown", event._lineBreakerBind.t);
        context.element.lineBreaker_b.removeEventListener("mousedown", event._lineBreakerBind.b);
        event._lineBreakerBind = null;
        eventWysiwyg.removeEventListener("touchstart", event.onMouseDown_wysiwyg, { passive: true, useCapture: false });
        eventWysiwyg.removeEventListener("touchend", event.onClick_wysiwyg, { passive: true, useCapture: false });
        eventWysiwyg.removeEventListener("focus", event.onFocus_wysiwyg);
        eventWysiwyg.removeEventListener("blur", event.onBlur_wysiwyg);
        context.element.code.removeEventListener("keydown", event._codeViewAutoHeight);
        context.element.code.removeEventListener("keyup", event._codeViewAutoHeight);
        context.element.code.removeEventListener("paste", event._codeViewAutoHeight);
        if (context.element.resizingBar) {
          context.element.resizingBar.removeEventListener("mousedown", event.onMouseDown_resizingBar);
        }
        if (event._resizeObserver) {
          event._resizeObserver.unobserve(context.element.wysiwygFrame);
          event._resizeObserver = null;
        }
        if (event._toolbarObserver) {
          event._toolbarObserver.unobserve(context.element._toolbarShadow);
          event._toolbarObserver = null;
        }
        _w.removeEventListener("resize", event.onResize_window);
        _w.removeEventListener("scroll", event.onScroll_window);
      },
      _setResponsiveToolbar: function() {
        if (_responsiveButtons.length === 0) {
          _responsiveButtons = null;
          return;
        }
        event._responsiveCurrentSize = "default";
        const sizeArray = event._responsiveButtonSize = [];
        const buttonsObj = event._responsiveButtons = { default: _responsiveButtons[0] };
        for (let i = 1, len = _responsiveButtons.length, size, buttonGroup; i < len; i++) {
          buttonGroup = _responsiveButtons[i];
          size = buttonGroup[0] * 1;
          sizeArray.push(size);
          buttonsObj[size] = buttonGroup[1];
        }
        sizeArray.sort(function(a, b) {
          return a - b;
        }).unshift("default");
      }
    };
    const functions = {
      /**
       * @description Core, Util object
       */
      core,
      util: util2,
      /**
       * @description Event functions
       * @param {Object} e Event Object
       * @param {Object} core Core object
       */
      onload: null,
      onScroll: null,
      onMouseDown: null,
      onClick: null,
      onInput: null,
      onKeyDown: null,
      onKeyUp: null,
      onCopy: null,
      onCut: null,
      onFocus: null,
      /**
       * @description Event functions
       * @param {Object} e Event Object
       * @param {Object} core Core object
       * @param {String} contents Current contents
       */
      onBlur: null,
      /**
       * @description Event functions
       * @param {String} contents Current contents
       * @param {Object} core Core object
       */
      onChange: null,
      /**
       * @description Event functions
       * @param {String} contents Current contents
       * @param {Object} core Core object
       */
      onSave: null,
      /**
       * @description Event functions (drop, paste)
       * When false is returned, the default behavior is stopped.
       * If the string is returned, the cleanData value is modified to the return value.
       * @param {Object} e Event object.
       * @param {String} cleanData HTML string modified for editor format.
       * @param {Boolean} maxChartCount option (true if max character is exceeded)
       * @param {Object} core Core object
       * @returns {Boolean|String}
       */
      onDrop: null,
      onPaste: null,
      /**
       * @description Called just before the inline toolbar is positioned and displayed on the screen.
       * @param {Element} toolbar Toolbar Element
       * @param {Object} context The editor's context object (editor.getContext())
       * @param {Object} core Core object
       */
      showInline: null,
      /**
       * @description Called just after the controller is positioned and displayed on the screen.
       * controller - editing elements displayed on the screen [image resizing, table editor, link editor..]]
       * @param {String} name The name of the plugin that called the controller
       * @param {Array} controllers Array of Controller elements
       * @param {Object} core Core object
       */
      showController: null,
      /**
       * @description An event when toggling between code view and wysiwyg view.
       * @param {Boolean} isCodeView Whether the current code view mode
       * @param {Object} core Core object
       */
      toggleCodeView: null,
      /**
       * @description An event when toggling full screen.
       * @param {Boolean} isFullScreen Whether the current full screen mode
       * @param {Object} core Core object
       */
      toggleFullScreen: null,
      /**
       * @description It replaces the default callback function of the image upload
       * @param {Object} response Response object
       * @param {Object} info Input information
       * - linkValue: Link url value
       * - linkNewWindow: Open in new window Check Value
       * - inputWidth: Value of width input
       * - inputHeight: Value of height input
       * - align: Align Check Value
       * - isUpdate: Update image if true, create image if false
       * - element: If isUpdate is true, the currently selected image.
       * @param {Object} core Core object
       */
      imageUploadHandler: null,
      /**
       * @description It replaces the default callback function of the video upload
       * @param xmlHttp xmlHttpRequest object
       * @param info Input information
       * - inputWidth: Value of width input
       * - inputHeight: Value of height input
       * - align: Align Check Value
       * - isUpdate: Update video if true, create video if false
       * - element: If isUpdate is true, the currently selected video.
       * @param core Core object
       */
      videoUploadHandler: null,
      /**
       * @description It replaces the default callback function of the audio upload
       * @param xmlHttp xmlHttpRequest object
       * @param info Input information
       * - isUpdate: Update audio if true, create audio if false
       * - element: If isUpdate is true, the currently selected audio.
       * @param core Core object
       */
      audioUploadHandler: null,
      /**
       * @description Called before the image is uploaded
       * If true is returned, the internal upload process runs normally.
       * If false is returned, no image upload is performed.
       * If new fileList are returned,  replaced the previous fileList
       * If undefined is returned, it waits until "uploadHandler" is executed.
       * @param {Array} files Files array
       * @param {Object} info info: {
       * - linkValue: Link url value
       * - linkNewWindow: Open in new window Check Value
       * - inputWidth: Value of width input
       * - inputHeight: Value of height input
       * - align: Align Check Value
       * - isUpdate: Update image if true, create image if false
       * - element: If isUpdate is true, the currently selected image.
       * }
       * @param {Object} core Core object
       * @param {Function} uploadHandler If undefined is returned, it waits until "uploadHandler" is executed.
       *                "uploadHandler" is an upload function with "core" and "info" bound.
       *                [upload files] : uploadHandler(files or [new File(...),])
       *                [error]        : uploadHandler("Error message")
       *                [Just finish]  : uploadHandler()
       *                [directly register] : uploadHandler(response) // Same format as "imageUploadUrl" response
       *                                   ex) {
       *                                      // "errorMessage": "insert error message",
       *                                      "result": [ { "url": "...", "name": "...", "size": "999" }, ]
       *                                   }
       * @returns {Boolean|Array|undefined}
       */
      onImageUploadBefore: null,
      /**
       * @description Called before the video is uploaded
       * If true is returned, the internal upload process runs normally.
       * If false is returned, no video(iframe, video) upload is performed.
       * If new fileList are returned,  replaced the previous fileList
       * If undefined is returned, it waits until "uploadHandler" is executed.
       * @param {Array} files Files array
       * @param {Object} info info: {
       * - inputWidth: Value of width input
       * - inputHeight: Value of height input
       * - align: Align Check Value
       * - isUpdate: Update video if true, create video if false
       * - element: If isUpdate is true, the currently selected video.
       * }
       * @param {Object} core Core object
       * @param {Function} uploadHandler If undefined is returned, it waits until "uploadHandler" is executed.
       *                "uploadHandler" is an upload function with "core" and "info" bound.
       *                [upload files] : uploadHandler(files or [new File(...),])
       *                [error]        : uploadHandler("Error message")
       *                [Just finish]  : uploadHandler()
       *                [directly register] : uploadHandler(response) // Same format as "videoUploadUrl" response
       *                                   ex) {
       *                                      // "errorMessage": "insert error message",
       *                                      "result": [ { "url": "...", "name": "...", "size": "999" }, ]
       *                                   }
       * @returns {Boolean|Array|undefined}
       */
      onVideoUploadBefore: null,
      /**
       * @description Called before the audio is uploaded
       * If true is returned, the internal upload process runs normally.
       * If false is returned, no audio upload is performed.
       * If new fileList are returned,  replaced the previous fileList
       * If undefined is returned, it waits until "uploadHandler" is executed.
       * @param {Array} files Files array
       * @param {Object} info info: {
       * - isUpdate: Update audio if true, create audio if false
       * - element: If isUpdate is true, the currently selected audio.
       * }
       * @param {Object} core Core object
       * @param {Function} uploadHandler If undefined is returned, it waits until "uploadHandler" is executed.
       *                "uploadHandler" is an upload function with "core" and "info" bound.
       *                [upload files] : uploadHandler(files or [new File(...),])
       *                [error]        : uploadHandler("Error message")
       *                [Just finish]  : uploadHandler()
       *                [directly register] : uploadHandler(response) // Same format as "audioUploadUrl" response
       *                                   ex) {
       *                                      // "errorMessage": "insert error message",
       *                                      "result": [ { "url": "...", "name": "...", "size": "999" }, ]
       *                                   }
       * @returns {Boolean|Array|undefined}
       */
      onAudioUploadBefore: null,
      /**
       * @description Called when the image is uploaded, updated, deleted
       * @param {Element} targetElement Target element
       * @param {Number} index Uploaded index
       * @param {String} state Upload status ('create', 'update', 'delete')
       * @param {Object} info Image info object
       * - index: data index
       * - name: file name
       * - size: file size
       * - select: select function
       * - delete: delete function
       * - element: target element
       * - src: src attribute of tag
       * @param {Number} remainingFilesCount Count of remaining files to upload (0 when added as a url)
       * @param {Object} core Core object
       */
      onImageUpload: null,
      /**
      * @description Called when the video(iframe, video) is is uploaded, updated, deleted
      * -- arguments is same "onImageUpload" --
      */
      onVideoUpload: null,
      /**
      * @description Called when the audio is is uploaded, updated, deleted
      * -- arguments is same "onImageUpload" --
      */
      onAudioUpload: null,
      /**
       * @description Called when the image is upload failed
       * @param {String} errorMessage Error message
       * @param {Object} result Response Object
       * @param {Object} core Core object
       * @returns {Boolean}
       */
      onImageUploadError: null,
      /**
       * @description Called when the video(iframe, video) upload failed
       * -- arguments is same "onImageUploadError" --
       */
      onVideoUploadError: null,
      /**
       * @description Called when the audio upload failed
       * -- arguments is same "onImageUploadError" --
       */
      onAudioUploadError: null,
      /**
       * @description Called when the editor is resized using the bottom bar
       */
      onResizeEditor: null,
      /**
       * @description Called after the "setToolbarButtons" invocation.
       * Can be used to tweak buttons properties (useful for custom buttons)
       * @param {Array} buttonList Button list 
       * @param {Object} core Core object
       */
      onSetToolbarButtons: null,
      /**
       * @description Reset the buttons on the toolbar. (Editor is not reloaded)
       * You cannot set a new plugin for the button.
       * @param {Array} buttonList Button list 
       */
      setToolbarButtons: function(buttonList) {
        core.submenuOff();
        core.containerOff();
        core.moreLayerOff();
        const newToolbar = constructor_default._createToolBar(_d, buttonList, core.plugins, options);
        _responsiveButtons = newToolbar.responsiveButtons;
        event._setResponsiveToolbar();
        context.element.toolbar.replaceChild(newToolbar._buttonTray, context.element._buttonTray);
        const newContext = context_default(context.element.originElement, core._getConstructed(context.element), options);
        context.element = newContext.element;
        context.tool = newContext.tool;
        if (options.iframe) context.element.wysiwyg = core._wd.body;
        core._recoverButtonStates();
        core._cachingButtons();
        core.history._resetCachingButton();
        core.effectNode = null;
        if (core.hasFocus) event._applyTagEffects();
        if (core.isReadOnly) util2.setDisabledButtons(true, core.resizingDisabledButtons);
        if (typeof functions.onSetToolbarButtons === "function") functions.onSetToolbarButtons(newToolbar._buttonTray.querySelectorAll("button"), core);
      },
      /**
       * @description Add or reset option property (Editor is reloaded)
       * @param {Object} _options Options
       */
      setOptions: function(_options) {
        event._removeEvent();
        core._resetComponents();
        util2.removeClass(core._styleCommandMap.showBlocks, "active");
        util2.removeClass(core._styleCommandMap.codeView, "active");
        core._variable.isCodeView = false;
        core._iframeAuto = null;
        core.plugins = _options.plugins || core.plugins;
        const mergeOptions = [options, _options].reduce(function(init, option) {
          for (let key in option) {
            if (!util2.hasOwn(option, key)) continue;
            if (key === "plugins" && option[key] && init[key]) {
              let i = init[key], o = option[key];
              i = i.length ? i : _w.Object.keys(i).map(function(name2) {
                return i[name2];
              });
              o = o.length ? o : _w.Object.keys(o).map(function(name2) {
                return o[name2];
              });
              init[key] = o.filter(function(val) {
                return i.indexOf(val) === -1;
              }).concat(i);
            } else {
              init[key] = option[key];
            }
          }
          return init;
        }, {});
        const el = context.element;
        const _initHTML = el.wysiwyg.innerHTML;
        const cons = constructor_default._setOptions(mergeOptions, context, options);
        if (cons.callButtons) {
          pluginCallButtons = cons.callButtons;
          core.initPlugins = {};
        }
        if (cons.plugins) {
          core.plugins = plugins = cons.plugins;
        }
        if (el._menuTray.children.length === 0) this._menuTray = {};
        _responsiveButtons = cons.toolbar.responsiveButtons;
        core.options = options = mergeOptions;
        core.lang = lang = options.lang;
        if (options.iframe) {
          el.wysiwygFrame.addEventListener("load", function() {
            util2._setIframeDocument(this, options);
            core._setOptionsInit(el, _initHTML);
          });
        }
        el.editorArea.appendChild(el.wysiwygFrame);
        if (!options.iframe) {
          core._setOptionsInit(el, _initHTML);
        }
      },
      /**
       * @description Set "options.defaultStyle" style.
       * Define the style of the edit area
       * It can also be defined with the "setOptions" method, but the "setDefaultStyle" method does not render the editor again.
       * @param {String} style Style string
       */
      setDefaultStyle: function(style) {
        const newStyles = options._editorStyles = util2._setDefaultOptionStyle(options, style);
        const el = context.element;
        el.topArea.style.cssText = newStyles.top;
        el.code.style.cssText = options._editorStyles.frame;
        el.code.style.display = "none";
        if (options.height === "auto") {
          el.code.style.overflow = "hidden";
        } else {
          el.code.style.overflow = "";
        }
        if (!options.iframe) {
          el.wysiwygFrame.style.cssText = newStyles.frame + newStyles.editor;
        } else {
          el.wysiwygFrame.style.cssText = newStyles.frame;
          el.wysiwyg.style.cssText = newStyles.editor;
        }
      },
      /**
       * @description Open a notice area
       * @param {String} message Notice message
       */
      noticeOpen: function(message) {
        core.notice.open.call(core, message);
      },
      /**
       * @description Close a notice area
       */
      noticeClose: function() {
        core.notice.close.call(core);
      },
      /**
       * @description Copying the contents of the editor to the original textarea and execute onSave callback
       * * not working during enabled codeView mode
       */
      save: function() {
        const contents = core.getContents(false);
        context.element.originElement.value = contents;
        event.onSave_wysiwyg(contents, core);
      },
      /**
       * @description Gets the suneditor's context object. Contains settings, plugins, and cached element objects
       * @returns {Object}
       */
      getContext: function() {
        return context;
      },
      /**
       * @description Gets the contents of the suneditor
       * * not working during enabled codeView mode
       * @param {Boolean} onlyContents - Return only the contents of the body without headers when the "fullPage" option is true
       * @returns {String}
       */
      getContents: function(onlyContents) {
        return core.getContents(onlyContents);
      },
      /**
       * @description Gets only the text of the suneditor contents
       * * not working during enabled codeView mode
       * @returns {String}
       */
      getText: function() {
        return context.element.wysiwyg.textContent;
      },
      /**
       * @description Get the editor's number of characters or binary data size.
       * You can use the "charCounterType" option format.
       * @param {String|null} charCounterType options - charCounterType ('char', 'byte', 'byte-html')
       * If argument is no value, the currently set "charCounterType" option is used.
       * @returns {Number}
       */
      getCharCount: function(charCounterType) {
        charCounterType = typeof charCounterType === "string" ? charCounterType : options.charCounterType;
        return core.getCharLength(core._charTypeHTML ? context.element.wysiwyg.innerHTML : context.element.wysiwyg.textContent, charCounterType);
      },
      /**
       * @description Gets uploaded images informations
       * - index: data index
       * - name: file name
       * - size: file size
       * - select: select function
       * - delete: delete function
       * - element: target element
       * - src: src attribute of tag
       * @returns {Array}
       */
      getImagesInfo: function() {
        return context.image ? context.image._infoList : [];
      },
      /**
       * @description Gets uploaded files(plugin using fileManager) information list.
       * image: [img], video: [video, iframe], audio: [audio]
       * When the argument value is 'image', it is the same function as "getImagesInfo".
       * - index: data index
       * - name: file name
       * - size: file size
       * - select: select function
       * - delete: delete function
       * - element: target element
       * - src: src attribute of tag
       * @param {String} pluginName Plugin name (image, video, audio)
       * @returns {Array}
       */
      getFilesInfo: function(pluginName) {
        return context[pluginName] ? context[pluginName]._infoList : [];
      },
      /**
       * @description Upload images using image plugin
       * @param {FileList} files FileList
       */
      insertImage: function(files) {
        if (!core.plugins.image || !files) return;
        if (!core.initPlugins.image) core.callPlugin("image", core.plugins.image.submitAction.bind(core, files), null);
        else core.plugins.image.submitAction.call(core, files);
        core.focus();
      },
      /**
       * @description Inserts an HTML element or HTML string or plain string at the current cursor position
       * @param {Element|String} html HTML Element or HTML string or plain string
       * @param {Boolean} notCleaningData If true, inserts the HTML string without refining it with core.cleanHTML.
       * @param {Boolean} checkCharCount If true, if "options.maxCharCount" is exceeded when "element" is added, null is returned without addition.
       * @param {Boolean} rangeSelection If true, range select the inserted node.
       */
      insertHTML: function(html, notCleaningData, checkCharCount, rangeSelection) {
        if (!context.element.wysiwygFrame.contains(core.getSelection().focusNode)) core.focus();
        if (typeof html === "string") {
          if (!notCleaningData) html = core.cleanHTML(html, null, null);
          try {
            if (util2.isListCell(util2.getFormatElement(core.getSelectionNode(), null))) {
              const dom2 = _d.createRange().createContextualFragment(html);
              const domTree2 = dom2.childNodes;
              if (core._isFormatData(domTree2)) html = core._convertListCell(domTree2);
            }
            const dom = _d.createRange().createContextualFragment(html);
            const domTree = dom.childNodes;
            if (checkCharCount) {
              const type = core._charTypeHTML ? "outerHTML" : "textContent";
              let checkHTML = "";
              for (let i = 0, len = domTree.length; i < len; i++) {
                checkHTML += domTree[i][type];
              }
              if (!core.checkCharCount(checkHTML, null)) return;
            }
            let c, a, t, prev, firstCon;
            while (c = domTree[0]) {
              if (prev && prev.nodeType === 3 && a && a.nodeType === 1 && util2.isBreak(c)) {
                prev = c;
                util2.removeItem(c);
                continue;
              }
              t = core.insertNode(c, a, false);
              a = t.container || t;
              if (!firstCon) firstCon = t;
              prev = c;
            }
            if (prev.nodeType === 3 && a.nodeType === 1) a = prev;
            const offset = a.nodeType === 3 ? t.endOffset || a.textContent.length : a.childNodes.length;
            if (rangeSelection) core.setRange(firstCon.container || firstCon, firstCon.startOffset || 0, a, offset);
            else core.setRange(a, offset, a, offset);
          } catch (error) {
            if (core.isDisabled || core.isReadOnly) return;
            console.warn("[SUNEDITOR.insertHTML.fail] " + error);
            core.execCommand("insertHTML", false, html);
          }
        } else {
          if (util2.isComponent(html)) {
            core.insertComponent(html, false, checkCharCount, false);
          } else {
            let afterNode = null;
            if (util2.isFormatElement(html) || util2.isMedia(html)) {
              afterNode = util2.getFormatElement(core.getSelectionNode(), null);
            }
            core.insertNode(html, afterNode, checkCharCount);
          }
        }
        core.effectNode = null;
        core.focus();
        core.history.push(false);
      },
      /**
       * @description Change the contents of the suneditor
       * @param {String|undefined} contents Contents to Input
       */
      setContents: function(contents) {
        core.setContents(contents);
      },
      /**
       * @description Add contents to the suneditor
       * @param {String} contents Contents to Input
       */
      appendContents: function(contents) {
        const convertValue = core.convertContentsForEditor(contents);
        if (!core._variable.isCodeView) {
          const temp = util2.createElement("DIV");
          temp.innerHTML = convertValue;
          const wysiwyg = context.element.wysiwyg;
          const children4 = temp.children;
          for (let i = 0, len = children4.length; i < len; i++) {
            if (children4[i]) {
              wysiwyg.appendChild(children4[i]);
            }
          }
        } else {
          core._setCodeView(core._getCodeView() + "\n" + core.convertHTMLForCodeView(convertValue, false));
        }
        core.history.push(false);
      },
      /**
       * @description Switch to or off "ReadOnly" mode.
       * @param {Boolean} value "readOnly" boolean value.
       */
      readOnly: function(value) {
        core.isReadOnly = value;
        util2.setDisabledButtons(!!value, core.resizingDisabledButtons);
        if (value) {
          core.controllersOff();
          if (core.submenuActiveButton && core.submenuActiveButton.disabled) core.submenuOff();
          if (core._moreLayerActiveButton && core._moreLayerActiveButton.disabled) core.moreLayerOff();
          if (core.containerActiveButton && core.containerActiveButton.disabled) core.containerOff();
          if (core.modalForm) core.plugins.dialog.close.call(core);
          context.element.code.setAttribute("readOnly", "true");
          util2.addClass(context.element.wysiwygFrame, "se-read-only");
        } else {
          context.element.code.removeAttribute("readOnly");
          util2.removeClass(context.element.wysiwygFrame, "se-read-only");
        }
        if (options.codeMirrorEditor) options.codeMirrorEditor.setOption("readOnly", !!value);
      },
      /**
       * @description Disable the suneditor
       */
      disable: function() {
        this.toolbar.disable();
        this.wysiwyg.disable();
      },
      /**
       * @description Provided for backward compatibility and will be removed in 3.0.0 version
       */
      disabled: function() {
        this.disable();
      },
      /**
       * @description Enable the suneditor
       */
      enable: function() {
        this.toolbar.enable();
        this.wysiwyg.enable();
      },
      /**
       * @description Provided for backward compatibility and will be removed in 3.0.0 version
       */
      enabled: function() {
        this.enable();
      },
      /**
       * @description Show the suneditor
       */
      show: function() {
        const topAreaStyle = context.element.topArea.style;
        if (topAreaStyle.display === "none") topAreaStyle.display = options.display;
      },
      /**
       * @description Hide the suneditor
       */
      hide: function() {
        context.element.topArea.style.display = "none";
      },
      /**
       * @description Destroy the suneditor
       */
      destroy: function() {
        core.submenuOff();
        core.containerOff();
        core.controllersOff();
        if (core.notice) core.notice.close.call(core);
        if (core.modalForm) core.plugins.dialog.close.call(core);
        core.history._destroy();
        event._removeEvent();
        util2.removeItem(context.element.toolbar);
        util2.removeItem(context.element.topArea);
        for (let k in core.functions) {
          if (util2.hasOwn(core, k)) delete core.functions[k];
        }
        for (let k in core) {
          if (util2.hasOwn(core, k)) delete core[k];
        }
        for (let k in event) {
          if (util2.hasOwn(event, k)) delete event[k];
        }
        for (let k in context) {
          if (util2.hasOwn(context, k)) delete context[k];
        }
        for (let k in pluginCallButtons) {
          if (util2.hasOwn(pluginCallButtons, k)) delete pluginCallButtons[k];
        }
        for (let k in this) {
          if (util2.hasOwn(this, k)) delete this[k];
        }
      },
      /**
       * @description Toolbar methods
       */
      toolbar: {
        /**
         * @description Disable the toolbar
         */
        disable: function() {
          core.submenuOff();
          core.moreLayerOff();
          core.containerOff();
          context.tool.cover.style.display = "block";
        },
        /**
         * @description Provided for backward compatibility and will be removed in 3.0.0 version
         */
        disabled: function() {
          this.disable();
        },
        /**
         * @description Enable the toolbar
         */
        enable: function() {
          context.tool.cover.style.display = "none";
        },
        /**
         * @description Provided for backward compatibility and will be removed in 3.0.0 version
         */
        enabled: function() {
          this.enable();
        },
        /**
         * @description Show the toolbar
         */
        show: function() {
          if (core._isInline) {
            event._showToolbarInline();
          } else {
            context.element.toolbar.style.display = "";
            context.element._stickyDummy.style.display = "";
          }
          event.onResize_window();
        },
        /**
         * @description Hide the toolbar
         */
        hide: function() {
          if (core._isInline) {
            event._hideToolbar();
          } else {
            context.element.toolbar.style.display = "none";
            context.element._stickyDummy.style.display = "none";
          }
          event.onResize_window();
        }
      },
      /**
       * @description Wysiwyg methods
       */
      wysiwyg: {
        /**
         * @description Disable the wysiwyg area
         */
        disable: function() {
          core.controllersOff();
          if (core.modalForm) core.plugins.dialog.close.call(core);
          context.element.wysiwyg.setAttribute("contenteditable", false);
          core.isDisabled = true;
          if (options.codeMirrorEditor) {
            options.codeMirrorEditor.setOption("readOnly", true);
          } else {
            context.element.code.setAttribute("disabled", "disabled");
          }
        },
        /**
         * @description Enable the wysiwyg area
         */
        enable: function() {
          context.element.wysiwyg.setAttribute("contenteditable", true);
          core.isDisabled = false;
          if (options.codeMirrorEditor) {
            options.codeMirrorEditor.setOption("readOnly", false);
          } else {
            context.element.code.removeAttribute("disabled");
          }
        }
      }
    };
    core.functions = functions;
    core.options = options;
    let contextEl = context.element;
    let originEl = contextEl.originElement;
    let topEl = contextEl.topArea;
    originEl.style.display = "none";
    topEl.style.display = "block";
    if (options.iframe) {
      contextEl.wysiwygFrame.addEventListener("load", function() {
        util2._setIframeDocument(this, options);
        core._editorInit(false, options.value);
        options.value = null;
      });
    }
    if (typeof originEl.nextElementSibling === "object") {
      originEl.parentNode.insertBefore(topEl, originEl.nextElementSibling);
    } else {
      originEl.parentNode.appendChild(topEl);
    }
    contextEl.editorArea.appendChild(contextEl.wysiwygFrame);
    contextEl = originEl = topEl = null;
    if (!options.iframe) {
      core._editorInit(false, options.value);
      options.value = null;
    }
    return functions;
  }

  // ../../node_modules/suneditor/src/suneditor.js
  var suneditor_default = {
    /**
     * @description Returns the create function with preset options.
     * If the options overlap, the options of the 'create' function take precedence.
     * @param {Json} options Initialization options
     * @returns {Object}
     */
    init: function(init_options) {
      return {
        create: function(idOrElement, options) {
          return this.create(idOrElement, options, init_options);
        }.bind(this)
      };
    },
    /**
     * @description Create the suneditor
     * @param {String|Element} idOrElement textarea Id or textarea element
     * @param {JSON|Object} options user options
     * @returns {Object}
     */
    create: function(idOrElement, options, _init_options) {
      util_default._propertiesInit();
      if (typeof options !== "object") options = {};
      if (_init_options) {
        options = [_init_options, options].reduce(function(init, option) {
          for (let key in option) {
            if (!util_default.hasOwn(option, key)) continue;
            if (key === "plugins" && option[key] && init[key]) {
              let i = init[key], o = option[key];
              i = i.length ? i : Object.keys(i).map(function(name2) {
                return i[name2];
              });
              o = o.length ? o : Object.keys(o).map(function(name2) {
                return o[name2];
              });
              init[key] = o.filter(function(val) {
                return i.indexOf(val) === -1;
              }).concat(i);
            } else {
              init[key] = option[key];
            }
          }
          return init;
        }, {});
      }
      const element = typeof idOrElement === "string" ? document.getElementById(idOrElement) : idOrElement;
      if (!element) {
        if (typeof idOrElement === "string") {
          throw Error('[SUNEDITOR.create.fail] The element for that id was not found (ID:"' + idOrElement + '")');
        }
        throw Error("[SUNEDITOR.create.fail] suneditor requires textarea's element or id value");
      }
      const cons = constructor_default.init(element, options);
      if (cons.constructed._top.id && document.getElementById(cons.constructed._top.id)) {
        throw Error('[SUNEDITOR.create.fail] The ID of the suneditor you are trying to create already exists (ID:"' + cons.constructed._top.id + '")');
      }
      return core_default(context_default(element, cons.constructed, cons.options), cons.pluginCallButtons, cons.plugins, cons.options.lang, options, cons._responsiveButtons);
    }
  };

  // ../../node_modules/suneditor/src/plugins/command/blockquote.js
  var blockquote_default = {
    name: "blockquote",
    display: "command",
    add: function(core, targetElement) {
      const context = core.context;
      context.blockquote = {
        targetButton: targetElement,
        tag: core.util.createElement("BLOCKQUOTE")
      };
    },
    /**
     * @Override core
     */
    active: function(element) {
      if (!element) {
        this.util.removeClass(this.context.blockquote.targetButton, "active");
      } else if (/blockquote/i.test(element.nodeName)) {
        this.util.addClass(this.context.blockquote.targetButton, "active");
        return true;
      }
      return false;
    },
    /**
     * @Override core
     */
    action: function() {
      const currentBlockquote = this.util.getParentElement(this.getSelectionNode(), "blockquote");
      if (currentBlockquote) {
        this.detachRangeFormatElement(currentBlockquote, null, null, false, false);
      } else {
        this.applyRangeFormatElement(this.context.blockquote.tag.cloneNode(false));
      }
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/align.js
  var align_default = {
    name: "align",
    display: "submenu",
    add: function(core, targetElement) {
      const icons = core.icons;
      const context = core.context;
      context.align = {
        targetButton: targetElement,
        _itemMenu: null,
        _alignList: null,
        currentAlign: "",
        defaultDir: core.options.rtl ? "right" : "left",
        icons: {
          justify: icons.align_justify,
          left: icons.align_left,
          right: icons.align_right,
          center: icons.align_center
        }
      };
      let listDiv = this.setSubmenu(core);
      let listUl = context.align._itemMenu = listDiv.querySelector("ul");
      listUl.addEventListener("click", this.pickup.bind(core));
      context.align._alignList = listUl.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null, listUl = null;
    },
    setSubmenu: function(core) {
      const lang = core.lang;
      const icons = core.icons;
      const listDiv = core.util.createElement("DIV");
      const alignItems = core.options.alignItems;
      let html = "";
      for (let i = 0, item, text; i < alignItems.length; i++) {
        item = alignItems[i];
        text = lang.toolbar["align" + item.charAt(0).toUpperCase() + item.slice(1)];
        html += '<li><button type="button" class="se-btn-list se-btn-align" data-value="' + item + '" title="' + text + '" aria-label="' + text + '"><span class="se-list-icon">' + icons["align_" + item] + "</span>" + text + "</button></li>";
      }
      listDiv.className = "se-submenu se-list-layer se-list-align";
      listDiv.innerHTML = '<div class="se-list-inner"><ul class="se-list-basic">' + html + "</ul></div>";
      return listDiv;
    },
    /**
     * @Override core
     */
    active: function(element) {
      const alignContext = this.context.align;
      const targetButton = alignContext.targetButton;
      const target = targetButton.firstElementChild;
      if (!element) {
        this.util.changeElement(target, alignContext.icons[alignContext.defaultDir]);
        targetButton.removeAttribute("data-focus");
      } else if (this.util.isFormatElement(element)) {
        const textAlign = element.style.textAlign;
        if (textAlign) {
          this.util.changeElement(target, alignContext.icons[textAlign] || alignContext.icons[alignContext.defaultDir]);
          targetButton.setAttribute("data-focus", textAlign);
          return true;
        }
      }
      return false;
    },
    /**
     * @Override submenu
     */
    on: function() {
      const alignContext = this.context.align;
      const alignList = alignContext._alignList;
      const currentAlign = alignContext.targetButton.getAttribute("data-focus") || alignContext.defaultDir;
      if (currentAlign !== alignContext.currentAlign) {
        for (let i = 0, len = alignList.length; i < len; i++) {
          if (currentAlign === alignList[i].getAttribute("data-value")) {
            this.util.addClass(alignList[i], "active");
          } else {
            this.util.removeClass(alignList[i], "active");
          }
        }
        alignContext.currentAlign = currentAlign;
      }
    },
    exchangeDir: function() {
      const dir = this.options.rtl ? "right" : "left";
      if (!this.context.align || this.context.align.defaultDir === dir) return;
      this.context.align.defaultDir = dir;
      let menu = this.context.align._itemMenu;
      let leftBtn = menu.querySelector('[data-value="left"]');
      let rightBtn = menu.querySelector('[data-value="right"]');
      if (leftBtn && rightBtn) {
        const lp = leftBtn.parentElement;
        const rp = rightBtn.parentElement;
        lp.appendChild(rightBtn);
        rp.appendChild(leftBtn);
      }
    },
    pickup: function(e) {
      e.preventDefault();
      e.stopPropagation();
      let target = e.target;
      let value = null;
      while (!value && !/UL/i.test(target.tagName)) {
        value = target.getAttribute("data-value");
        target = target.parentNode;
      }
      if (!value) return;
      const defaultDir = this.context.align.defaultDir;
      const selectedFormsts = this.getSelectedElements();
      for (let i = 0, len = selectedFormsts.length; i < len; i++) {
        this.util.setStyle(selectedFormsts[i], "textAlign", value === defaultDir ? "" : value);
      }
      this.effectNode = null;
      this.submenuOff();
      this.focus();
      this.history.push(false);
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/font.js
  var font_default = {
    name: "font",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.font = {
        targetText: targetElement.querySelector(".txt"),
        targetTooltip: targetElement.parentNode.querySelector(".se-tooltip-text"),
        _fontList: null,
        currentFont: ""
      };
      let listDiv = this.setSubmenu(core);
      listDiv.querySelector(".se-list-inner").addEventListener("click", this.pickup.bind(core));
      context.font._fontList = listDiv.querySelectorAll("ul li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null;
    },
    setSubmenu: function(core) {
      const lang = core.lang;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer se-list-font-family";
      let font, text, i, len;
      let fontList = core.options.font;
      let list = '<div class="se-list-inner"><ul class="se-list-basic"><li><button type="button" class="default_value se-btn-list" title="' + lang.toolbar.default + '" aria-label="' + lang.toolbar.default + '">(' + lang.toolbar.default + ")</button></li>";
      for (i = 0, len = fontList.length; i < len; i++) {
        font = fontList[i];
        text = font.split(",")[0];
        list += '<li><button type="button" class="se-btn-list" data-value="' + font + '" data-txt="' + text + '" title="' + text + '" aria-label="' + text + '" style="font-family:' + font + ';">' + text + "</button></li>";
      }
      list += "</ul></div>";
      listDiv.innerHTML = list;
      return listDiv;
    },
    /**
    * @Override core
    */
    active: function(element) {
      const target = this.context.font.targetText;
      const tooltip = this.context.font.targetTooltip;
      if (!element) {
        const font = this.hasFocus ? this.wwComputedStyle.fontFamily : this.lang.toolbar.font;
        this.util.changeTxt(target, font);
        this.util.changeTxt(tooltip, this.hasFocus ? this.lang.toolbar.font + (font ? " (" + font + ")" : "") : font);
      } else if (element.style && element.style.fontFamily.length > 0) {
        const selectFont = element.style.fontFamily.replace(/["']/g, "");
        this.util.changeTxt(target, selectFont);
        this.util.changeTxt(tooltip, this.lang.toolbar.font + " (" + selectFont + ")");
        return true;
      }
      return false;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const fontContext = this.context.font;
      const fontList = fontContext._fontList;
      const currentFont = fontContext.targetText.textContent;
      if (currentFont !== fontContext.currentFont) {
        for (let i = 0, len = fontList.length; i < len; i++) {
          if (currentFont === (fontList[i].getAttribute("data-value") || "").replace(/'|"/g, "")) {
            this.util.addClass(fontList[i], "active");
          } else {
            this.util.removeClass(fontList[i], "active");
          }
        }
        fontContext.currentFont = currentFont;
      }
    },
    pickup: function(e) {
      if (!/^BUTTON$/i.test(e.target.tagName)) return false;
      e.preventDefault();
      e.stopPropagation();
      let value = e.target.getAttribute("data-value");
      if (value) {
        const newNode = this.util.createElement("SPAN");
        if (/[\s\d\W]/.test(value) && !/^['"].*['"]$/.test(value)) {
          value = '"' + value + '"';
        }
        newNode.style.fontFamily = value;
        this.nodeChange(newNode, ["font-family"], null, null);
      } else {
        this.nodeChange(null, ["font-family"], ["span"], true);
      }
      this.submenuOff();
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/fontSize.js
  var fontSize_default = {
    name: "fontSize",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.fontSize = {
        targetText: targetElement.querySelector(".txt"),
        _sizeList: null,
        currentSize: ""
      };
      let listDiv = this.setSubmenu(core);
      let listUl = listDiv.querySelector("ul");
      listUl.addEventListener("click", this.pickup.bind(core));
      context.fontSize._sizeList = listUl.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null, listUl = null;
    },
    setSubmenu: function(core) {
      const option = core.options;
      const lang = core.lang;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer se-list-font-size";
      const sizeList = !option.fontSize ? [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72] : option.fontSize;
      let list = '<div class="se-list-inner"><ul class="se-list-basic"><li><button type="button" class="default_value se-btn-list" title="' + lang.toolbar.default + '" aria-label="' + lang.toolbar.default + '">(' + lang.toolbar.default + ")</button></li>";
      for (let i = 0, unit = option.fontSizeUnit, len = sizeList.length, size; i < len; i++) {
        size = sizeList[i];
        list += '<li><button type="button" class="se-btn-list" data-value="' + size + unit + '" title="' + size + unit + '" aria-label="' + size + unit + '" style="font-size:' + size + unit + ';">' + size + "</button></li>";
      }
      list += "</ul></div>";
      listDiv.innerHTML = list;
      return listDiv;
    },
    /**
    * @Override core
    */
    active: function(element) {
      if (!element) {
        this.util.changeTxt(this.context.fontSize.targetText, this.hasFocus ? this._convertFontSize.call(this, this.options.fontSizeUnit, this.wwComputedStyle.fontSize) : this.lang.toolbar.fontSize);
      } else if (element.style && element.style.fontSize.length > 0) {
        this.util.changeTxt(this.context.fontSize.targetText, this._convertFontSize.call(this, this.options.fontSizeUnit, element.style.fontSize));
        return true;
      }
      return false;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const fontSizeContext = this.context.fontSize;
      const sizeList = fontSizeContext._sizeList;
      const currentSize = fontSizeContext.targetText.textContent;
      if (currentSize !== fontSizeContext.currentSize) {
        for (let i = 0, len = sizeList.length; i < len; i++) {
          if (currentSize === sizeList[i].getAttribute("data-value")) {
            this.util.addClass(sizeList[i], "active");
          } else {
            this.util.removeClass(sizeList[i], "active");
          }
        }
        fontSizeContext.currentSize = currentSize;
      }
    },
    pickup: function(e) {
      if (!/^BUTTON$/i.test(e.target.tagName)) return false;
      e.preventDefault();
      e.stopPropagation();
      const value = e.target.getAttribute("data-value");
      if (value) {
        const newNode = this.util.createElement("SPAN");
        newNode.style.fontSize = value;
        this.nodeChange(newNode, ["font-size"], null, null);
      } else {
        this.nodeChange(null, ["font-size"], ["span"], true);
      }
      this.submenuOff();
    }
  };

  // ../../node_modules/suneditor/src/plugins/modules/_colorPicker.js
  var colorPicker_default = {
    name: "colorPicker",
    /**
     * @description Constructor
     * @param {Object} core Core object 
     */
    add: function(core) {
      const context = core.context;
      context.colorPicker = {
        colorListHTML: "",
        _colorInput: "",
        _defaultColor: "#000",
        _styleProperty: "color",
        _currentColor: "",
        _colorList: []
      };
      context.colorPicker.colorListHTML = this.createColorList(core, this._makeColorList);
    },
    /**
     * @description Create color list
     * @param {Object} core Core object 
     * @param {Function} makeColor this._makeColorList
     * @returns {String} HTML string
     */
    createColorList: function(core, makeColor) {
      const option = core.options;
      const lang = core.lang;
      const colorList = !option.colorList || option.colorList.length === 0 ? [
        "#ff0000",
        "#ff5e00",
        "#ffe400",
        "#abf200",
        "#00d8ff",
        "#0055ff",
        "#6600ff",
        "#ff00dd",
        "#000000",
        "#ffd8d8",
        "#fae0d4",
        "#faf4c0",
        "#e4f7ba",
        "#d4f4fa",
        "#d9e5ff",
        "#e8d9ff",
        "#ffd9fa",
        "#f1f1f1",
        "#ffa7a7",
        "#ffc19e",
        "#faed7d",
        "#cef279",
        "#b2ebf4",
        "#b2ccff",
        "#d1b2ff",
        "#ffb2f5",
        "#bdbdbd",
        "#f15f5f",
        "#f29661",
        "#e5d85c",
        "#bce55c",
        "#5cd1e5",
        "#6699ff",
        "#a366ff",
        "#f261df",
        "#8c8c8c",
        "#980000",
        "#993800",
        "#998a00",
        "#6b9900",
        "#008299",
        "#003399",
        "#3d0099",
        "#990085",
        "#353535",
        "#670000",
        "#662500",
        "#665c00",
        "#476600",
        "#005766",
        "#002266",
        "#290066",
        "#660058",
        "#222222"
      ] : option.colorList;
      let colorArr = [];
      let list = '<div class="se-list-inner">';
      for (let i = 0, len = colorList.length, color; i < len; i++) {
        color = colorList[i];
        if (!color) continue;
        if (typeof color === "string") {
          colorArr.push(color);
          if (i < len - 1) continue;
        }
        if (colorArr.length > 0) {
          list += '<div class="se-selector-color">' + makeColor(colorArr) + "</div>";
          colorArr = [];
        }
        if (typeof color === "object") {
          list += '<div class="se-selector-color">' + makeColor(color) + "</div>";
        }
      }
      list += '<form class="se-form-group"><input type="text" maxlength="9" class="_se_color_picker_input se-color-input"/><button type="submit" class="se-btn-primary _se_color_picker_submit" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '">' + core.icons.checked + '</button><button type="button" class="se-btn _se_color_picker_remove" title="' + lang.toolbar.removeFormat + '" aria-label="' + lang.toolbar.removeFormat + '">' + core.icons.erase + "</button></form></div>";
      return list;
    },
    /**
     * @description Internal function used by this.createColorList
     * @param {Array} colorList Color list
     * @private
     */
    _makeColorList: function(colorList) {
      let list = "";
      list += '<ul class="se-color-pallet">';
      for (let i = 0, len = colorList.length, color; i < len; i++) {
        color = colorList[i];
        if (typeof color === "string") {
          list += '<li><button type="button" data-value="' + color + '" title="' + color + '" aria-label="' + color + '" style="background-color:' + color + ';"></button></li>';
        }
      }
      list += "</ul>";
      return list;
    },
    /**
     * @description Displays or resets the currently selected color at color list.
     * @param {Node} node Current Selected node
     * @param {String|null} color Color value
     */
    init: function(node, color) {
      const colorPicker = this.plugins.colorPicker;
      let fillColor = color ? color : colorPicker.getColorInNode.call(this, node) || this.context.colorPicker._defaultColor;
      fillColor = colorPicker.isHexColor(fillColor) ? fillColor : colorPicker.rgb2hex(fillColor) || fillColor;
      const colorList = this.context.colorPicker._colorList;
      if (colorList) {
        for (let i = 0, len = colorList.length; i < len; i++) {
          if (fillColor.toLowerCase() === colorList[i].getAttribute("data-value").toLowerCase()) {
            this.util.addClass(colorList[i], "active");
          } else {
            this.util.removeClass(colorList[i], "active");
          }
        }
      }
      colorPicker.setInputText.call(this, colorPicker.colorName2hex.call(this, fillColor));
    },
    /**
     * @description Store color values
     * @param {String} hexColorStr Hax color value
     */
    setCurrentColor: function(hexColorStr) {
      this.context.colorPicker._currentColor = hexColorStr;
      this.context.colorPicker._colorInput.style.borderColor = hexColorStr;
    },
    /**
     * @description Set color at input element
     * @param {String} hexColorStr Hax color value
     */
    setInputText: function(hexColorStr) {
      hexColorStr = /^#/.test(hexColorStr) ? hexColorStr : "#" + hexColorStr;
      this.context.colorPicker._colorInput.value = hexColorStr;
      this.plugins.colorPicker.setCurrentColor.call(this, hexColorStr);
    },
    /**
     * @description Gets color value at color property of node
     * @param {Node} node Selected node 
     * @returns {String}
     */
    getColorInNode: function(node) {
      let findColor = "";
      const styleProperty = this.context.colorPicker._styleProperty;
      while (node && !this.util.isWysiwygDiv(node) && findColor.length === 0) {
        if (node.nodeType === 1 && node.style[styleProperty]) findColor = node.style[styleProperty];
        node = node.parentNode;
      }
      return findColor;
    },
    /**
     * @description Function to check hex format color
     * @param {String} str Color value
     */
    isHexColor: function(str) {
      return /^#[0-9a-f]{3}(?:[0-9a-f]{3})?$/i.test(str);
    },
    /**
     * @description Function to convert hex format to a rgb color
     * @param {String} rgb RGB color format
     * @returns {String}
     */
    rgb2hex: function(rgb) {
      const rgbMatch = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
      return rgbMatch && rgbMatch.length === 4 ? "#" + ("0" + parseInt(rgbMatch[1], 10).toString(16)).slice(-2) + ("0" + parseInt(rgbMatch[2], 10).toString(16)).slice(-2) + ("0" + parseInt(rgbMatch[3], 10).toString(16)).slice(-2) : "";
    },
    /**
     * @description Converts color values of other formats to hex color values and returns.
     * @param {String} colorName Color value
     * @returns {String}
     */
    colorName2hex: function(colorName) {
      if (/^#/.test(colorName)) return colorName;
      var temp = this.util.createElement("div");
      temp.style.display = "none";
      temp.style.color = colorName;
      var colors = this._w.getComputedStyle(this._d.body.appendChild(temp)).color.match(/\d+/g).map(function(a) {
        return parseInt(a, 10);
      });
      this.util.removeItem(temp);
      return colors.length >= 3 ? "#" + ((1 << 24) + (colors[0] << 16) + (colors[1] << 8) + colors[2]).toString(16).substr(1) : false;
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/fontColor.js
  var fontColor_default = {
    name: "fontColor",
    display: "submenu",
    add: function(core, targetElement) {
      core.addModule([colorPicker_default]);
      const context = core.context;
      context.fontColor = {
        previewEl: null,
        colorInput: null,
        colorList: null
      };
      let listDiv = this.setSubmenu(core);
      context.fontColor.colorInput = listDiv.querySelector("._se_color_picker_input");
      context.fontColor.colorInput.addEventListener("keyup", this.onChangeInput.bind(core));
      listDiv.querySelector("._se_color_picker_submit").addEventListener("click", this.submit.bind(core));
      listDiv.querySelector("._se_color_picker_remove").addEventListener("click", this.remove.bind(core));
      listDiv.addEventListener("click", this.pickup.bind(core));
      context.fontColor.colorList = listDiv.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null;
    },
    setSubmenu: function(core) {
      const colorArea = core.context.colorPicker.colorListHTML;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer";
      listDiv.innerHTML = colorArea;
      return listDiv;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const contextPicker = this.context.colorPicker;
      const contextFontColor = this.context.fontColor;
      contextPicker._colorInput = contextFontColor.colorInput;
      const color = this.wwComputedStyle.color;
      contextPicker._defaultColor = color ? this.plugins.colorPicker.isHexColor(color) ? color : this.plugins.colorPicker.rgb2hex(color) : "#333333";
      contextPicker._styleProperty = "color";
      contextPicker._colorList = contextFontColor.colorList;
      this.plugins.colorPicker.init.call(this, this.getSelectionNode(), null);
    },
    /**
    * @Override _colorPicker
    */
    onChangeInput: function(e) {
      this.plugins.colorPicker.setCurrentColor.call(this, e.target.value);
    },
    submit: function() {
      this.plugins.fontColor.applyColor.call(this, this.context.colorPicker._currentColor);
    },
    pickup: function(e) {
      e.preventDefault();
      e.stopPropagation();
      this.plugins.fontColor.applyColor.call(this, e.target.getAttribute("data-value"));
    },
    remove: function() {
      this.nodeChange(null, ["color"], ["span"], true);
      this.submenuOff();
    },
    applyColor: function(color) {
      if (!color) return;
      const newNode = this.util.createElement("SPAN");
      newNode.style.color = color;
      this.nodeChange(newNode, ["color"], null, null);
      this.submenuOff();
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/hiliteColor.js
  var hiliteColor_default = {
    name: "hiliteColor",
    display: "submenu",
    add: function(core, targetElement) {
      core.addModule([colorPicker_default]);
      const context = core.context;
      context.hiliteColor = {
        previewEl: null,
        colorInput: null,
        colorList: null
      };
      let listDiv = this.setSubmenu(core);
      context.hiliteColor.colorInput = listDiv.querySelector("._se_color_picker_input");
      context.hiliteColor.colorInput.addEventListener("keyup", this.onChangeInput.bind(core));
      listDiv.querySelector("._se_color_picker_submit").addEventListener("click", this.submit.bind(core));
      listDiv.querySelector("._se_color_picker_remove").addEventListener("click", this.remove.bind(core));
      listDiv.addEventListener("click", this.pickup.bind(core));
      context.hiliteColor.colorList = listDiv.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null;
    },
    setSubmenu: function(core) {
      const colorArea = core.context.colorPicker.colorListHTML;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer";
      listDiv.innerHTML = colorArea;
      return listDiv;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const contextPicker = this.context.colorPicker;
      const contextHiliteColor = this.context.hiliteColor;
      contextPicker._colorInput = contextHiliteColor.colorInput;
      const color = this.wwComputedStyle.backgroundColor;
      contextPicker._defaultColor = color ? this.plugins.colorPicker.isHexColor(color) ? color : this.plugins.colorPicker.rgb2hex(color) : "#ffffff";
      contextPicker._styleProperty = "backgroundColor";
      contextPicker._colorList = contextHiliteColor.colorList;
      this.plugins.colorPicker.init.call(this, this.getSelectionNode(), null);
    },
    /**
    * @Override _colorPicker
    */
    onChangeInput: function(e) {
      this.plugins.colorPicker.setCurrentColor.call(this, e.target.value);
    },
    submit: function() {
      this.plugins.hiliteColor.applyColor.call(this, this.context.colorPicker._currentColor);
    },
    pickup: function(e) {
      e.preventDefault();
      e.stopPropagation();
      this.plugins.hiliteColor.applyColor.call(this, e.target.getAttribute("data-value"));
    },
    remove: function() {
      this.nodeChange(null, ["background-color"], ["span"], true);
      this.submenuOff();
    },
    applyColor: function(color) {
      if (!color) return;
      const newNode = this.util.createElement("SPAN");
      newNode.style.backgroundColor = color;
      this.nodeChange(newNode, ["background-color"], null, null);
      this.submenuOff();
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/horizontalRule.js
  var horizontalRule_default = {
    name: "horizontalRule",
    display: "submenu",
    add: function(core, targetElement) {
      core.context.horizontalRule = {
        currentHR: null
      };
      let listDiv = this.setSubmenu(core);
      listDiv.querySelector("ul").addEventListener("click", this.horizontalRulePick.bind(core));
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null;
    },
    setSubmenu: function(core) {
      const lang = core.lang;
      const listDiv = core.util.createElement("DIV");
      const items = core.options.hrItems || [{ name: lang.toolbar.hr_solid, class: "__se__solid" }, { name: lang.toolbar.hr_dashed, class: "__se__dashed" }, { name: lang.toolbar.hr_dotted, class: "__se__dotted" }];
      let list = "";
      for (let i = 0, len = items.length; i < len; i++) {
        list += '<li><button type="button" class="se-btn-list btn_line" data-command="horizontalRule" data-value="' + items[i].class + '" title="' + items[i].name + '" aria-label="' + items[i].name + '"><hr' + (items[i].class ? ' class="' + items[i].class + '"' : "") + (items[i].style ? ' style="' + items[i].style + '"' : "") + "/></button></li>";
      }
      listDiv.className = "se-submenu se-list-layer se-list-line";
      listDiv.innerHTML = '<div class="se-list-inner"><ul class="se-list-basic">' + list + "</ul></div>";
      return listDiv;
    },
    active: function(element) {
      if (!element) {
        if (this.util.hasClass(this.context.horizontalRule.currentHR, "on")) {
          this.controllersOff();
        }
      } else if (/HR/i.test(element.nodeName)) {
        this.context.horizontalRule.currentHR = element;
        if (!this.util.hasClass(element, "on")) {
          this.util.addClass(element, "on");
          this.controllersOn("hr", this.util.removeClass.bind(this.util, element, "on"));
        }
        return true;
      }
      return false;
    },
    appendHr: function(hrTemp) {
      this.focus();
      return this.insertComponent(hrTemp.cloneNode(false), false, true, false);
    },
    horizontalRulePick: function(e) {
      e.preventDefault();
      e.stopPropagation();
      let target = e.target;
      let command = target.getAttribute("data-command");
      while (!command && !/UL/i.test(target.tagName)) {
        target = target.parentNode;
        command = target.getAttribute("data-command");
      }
      if (!command) return;
      const oNode = this.plugins.horizontalRule.appendHr.call(this, target.firstElementChild);
      if (oNode) {
        this.setRange(oNode, 0, oNode, 0);
        this.submenuOff();
      }
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/list.js
  var list_default = {
    name: "list",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.list = {
        targetButton: targetElement,
        _list: null,
        currentList: "",
        icons: {
          bullets: core.icons.list_bullets,
          number: core.icons.list_number
        }
      };
      let listDiv = this.setSubmenu(core);
      let listUl = listDiv.querySelector("ul");
      listUl.addEventListener("click", this.pickup.bind(core));
      context.list._list = listUl.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null, listUl = null;
    },
    setSubmenu: function(core) {
      const lang = core.lang;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer";
      listDiv.innerHTML = '<div class="se-list-inner"><ul class="se-list-basic"><li><button type="button" class="se-btn-list se-tooltip" data-command="OL" title="' + lang.toolbar.orderList + '" aria-label="' + lang.toolbar.orderList + '">' + core.icons.list_number + '</button></li><li><button type="button" class="se-btn-list se-tooltip" data-command="UL" title="' + lang.toolbar.unorderList + '" aria-label="' + lang.toolbar.unorderList + '">' + core.icons.list_bullets + "</button></li></ul></div>";
      return listDiv;
    },
    /**
    * @Override core
    */
    active: function(element) {
      const button = this.context.list.targetButton;
      const icon = button.firstElementChild;
      const util2 = this.util;
      if (util2.isList(element)) {
        const nodeName = element.nodeName;
        button.setAttribute("data-focus", nodeName);
        util2.addClass(button, "active");
        if (/UL/i.test(nodeName)) {
          util2.changeElement(icon, this.context.list.icons.bullets);
        } else {
          util2.changeElement(icon, this.context.list.icons.number);
        }
        return true;
      } else {
        button.removeAttribute("data-focus");
        util2.changeElement(icon, this.context.list.icons.number);
        util2.removeClass(button, "active");
      }
      return false;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const listContext = this.context.list;
      const list = listContext._list;
      const currentList = listContext.targetButton.getAttribute("data-focus") || "";
      if (currentList !== listContext.currentList) {
        for (let i = 0, len = list.length; i < len; i++) {
          if (currentList === list[i].getAttribute("data-command")) {
            this.util.addClass(list[i], "active");
          } else {
            this.util.removeClass(list[i], "active");
          }
        }
        listContext.currentList = currentList;
      }
    },
    editList: function(command, selectedCells, detach) {
      let range = this.getRange();
      let selectedFormats = !selectedCells ? this.getSelectedElementsAndComponents(false) : selectedCells;
      if (selectedFormats.length === 0) {
        if (selectedCells) return;
        range = this.getRange_addLine(range, null);
        selectedFormats = this.getSelectedElementsAndComponents(false);
        if (selectedFormats.length === 0) return;
      }
      const util2 = this.util;
      util2.sortByDepth(selectedFormats, true);
      let firstSel = selectedFormats[0];
      let lastSel = selectedFormats[selectedFormats.length - 1];
      let topEl = (util2.isListCell(firstSel) || util2.isComponent(firstSel)) && !firstSel.previousElementSibling ? firstSel.parentNode.previousElementSibling : firstSel.previousElementSibling;
      let bottomEl = (util2.isListCell(lastSel) || util2.isComponent(lastSel)) && !lastSel.nextElementSibling ? lastSel.parentNode.nextElementSibling : lastSel.nextElementSibling;
      const isCollapsed = range.collapsed;
      const originRange = {
        sc: range.startContainer,
        so: range.startContainer === range.endContainer && util2.onlyZeroWidthSpace(range.startContainer) && range.startOffset === 0 && range.endOffset === 1 ? range.endOffset : range.startOffset,
        ec: range.endContainer,
        eo: range.endOffset
      };
      let afterRange = null;
      let isRemove = true;
      for (let i = 0, len = selectedFormats.length; i < len; i++) {
        if (!util2.isList(util2.getRangeFormatElement(selectedFormats[i], function(current) {
          return this.getRangeFormatElement(current) && current !== selectedFormats[i];
        }.bind(util2)))) {
          isRemove = false;
          break;
        }
      }
      if (isRemove && (!topEl || (firstSel.tagName !== topEl.tagName || command !== topEl.tagName.toUpperCase())) && (!bottomEl || (lastSel.tagName !== bottomEl.tagName || command !== bottomEl.tagName.toUpperCase()))) {
        if (detach) {
          for (let i = 0, len = selectedFormats.length; i < len; i++) {
            for (let j = i - 1; j >= 0; j--) {
              if (selectedFormats[j].contains(selectedFormats[i])) {
                selectedFormats.splice(i, 1);
                i--;
                len--;
                break;
              }
            }
          }
        }
        const currentFormat = util2.getRangeFormatElement(firstSel);
        const cancel = currentFormat && currentFormat.tagName === command;
        let rangeArr, tempList;
        const passComponent = function(current) {
          return !this.isComponent(current);
        }.bind(util2);
        if (!cancel) tempList = util2.createElement(command);
        for (let i = 0, len = selectedFormats.length, r, o; i < len; i++) {
          o = util2.getRangeFormatElement(selectedFormats[i], passComponent);
          if (!o || !util2.isList(o)) continue;
          if (!r) {
            r = o;
            rangeArr = { r, f: [util2.getParentElement(selectedFormats[i], "LI")] };
          } else {
            if (r !== o) {
              if (detach && util2.isListCell(o.parentNode)) {
                this.plugins.list._detachNested.call(this, rangeArr.f);
              } else {
                afterRange = this.detachRangeFormatElement(rangeArr.f[0].parentNode, rangeArr.f, tempList, false, true);
              }
              o = selectedFormats[i].parentNode;
              if (!cancel) tempList = util2.createElement(command);
              r = o;
              rangeArr = { r, f: [util2.getParentElement(selectedFormats[i], "LI")] };
            } else {
              rangeArr.f.push(util2.getParentElement(selectedFormats[i], "LI"));
            }
          }
          if (i === len - 1) {
            if (detach && util2.isListCell(o.parentNode)) {
              this.plugins.list._detachNested.call(this, rangeArr.f);
            } else {
              afterRange = this.detachRangeFormatElement(rangeArr.f[0].parentNode, rangeArr.f, tempList, false, true);
            }
          }
        }
      } else {
        const topElParent = topEl ? topEl.parentNode : topEl;
        const bottomElParent = bottomEl ? bottomEl.parentNode : bottomEl;
        topEl = topElParent && !util2.isWysiwygDiv(topElParent) && topElParent.nodeName === command ? topElParent : topEl;
        bottomEl = bottomElParent && !util2.isWysiwygDiv(bottomElParent) && bottomElParent.nodeName === command ? bottomElParent : bottomEl;
        const mergeTop = topEl && topEl.tagName === command;
        const mergeBottom = bottomEl && bottomEl.tagName === command;
        let list = mergeTop ? topEl : util2.createElement(command);
        let firstList = null;
        let lastList = null;
        let topNumber = null;
        let bottomNumber = null;
        const passComponent = function(current) {
          return !this.isComponent(current) && !this.isList(current);
        }.bind(util2);
        for (let i = 0, len = selectedFormats.length, newCell, fTag, isCell, next, originParent, nextParent, parentTag, siblingTag, rangeTag; i < len; i++) {
          fTag = selectedFormats[i];
          if (fTag.childNodes.length === 0 && !util2._isIgnoreNodeChange(fTag)) {
            util2.removeItem(fTag);
            continue;
          }
          next = selectedFormats[i + 1];
          originParent = fTag.parentNode;
          nextParent = next ? next.parentNode : null;
          isCell = util2.isListCell(fTag);
          rangeTag = util2.isRangeFormatElement(originParent) ? originParent : null;
          parentTag = isCell && !util2.isWysiwygDiv(originParent) ? originParent.parentNode : originParent;
          siblingTag = isCell && !util2.isWysiwygDiv(originParent) ? !next || util2.isListCell(parentTag) ? originParent : originParent.nextSibling : fTag.nextSibling;
          newCell = util2.createElement("LI");
          util2.copyFormatAttributes(newCell, fTag);
          if (i === 0 && originRange.sc === fTag) {
            originRange.sc = newCell;
          }
          if (i === len - 1 && originRange.ec === fTag) {
            originRange.ec = newCell;
          }
          if (util2.isComponent(fTag)) {
            const isHR = /^HR$/i.test(fTag.nodeName);
            if (!isHR) newCell.innerHTML = "<br>";
            newCell.innerHTML += fTag.outerHTML;
            if (isHR) newCell.innerHTML += "<br>";
          } else {
            const fChildren = fTag.childNodes;
            while (fChildren[0]) {
              newCell.appendChild(fChildren[0]);
            }
          }
          list.appendChild(newCell);
          if (!next) lastList = list;
          if (!next || parentTag !== nextParent || util2.isRangeFormatElement(siblingTag)) {
            if (!firstList) firstList = list;
            if ((!mergeTop || !next || parentTag !== nextParent) && !(next && util2.isList(nextParent) && nextParent === originParent)) {
              if (list.parentNode !== parentTag) parentTag.insertBefore(list, siblingTag);
            }
          }
          util2.removeItem(fTag);
          if (mergeTop && topNumber === null) topNumber = list.children.length - 1;
          if (next && (util2.getRangeFormatElement(nextParent, passComponent) !== util2.getRangeFormatElement(originParent, passComponent) || util2.isList(nextParent) && util2.isList(originParent) && util2.getElementDepth(nextParent) !== util2.getElementDepth(originParent))) {
            list = util2.createElement(command);
          }
          if (rangeTag && rangeTag.children.length === 0) util2.removeItem(rangeTag);
        }
        if (topNumber) {
          firstList = firstList.children[topNumber];
        }
        if (mergeBottom) {
          bottomNumber = list.children.length - 1;
          list.innerHTML += bottomEl.innerHTML;
          lastList = list.children[bottomNumber];
          util2.removeItem(bottomEl);
        }
      }
      this.effectNode = null;
      return !isCollapsed ? originRange : afterRange;
    },
    _detachNested: function(cells) {
      const first = cells[0];
      const last = cells[cells.length - 1];
      const next = last.nextElementSibling;
      const originList = first.parentNode;
      const sibling = originList.parentNode.nextElementSibling;
      const parentNode = originList.parentNode.parentNode;
      for (let c = 0, cLen = cells.length; c < cLen; c++) {
        parentNode.insertBefore(cells[c], sibling);
      }
      if (next && originList.children.length > 0) {
        const newList = originList.cloneNode(false);
        const children4 = originList.childNodes;
        const index = this.util.getPositionIndex(next);
        while (children4[index]) {
          newList.appendChild(children4[index]);
        }
        last.appendChild(newList);
      }
      if (originList.children.length === 0) this.util.removeItem(originList);
      this.util.mergeSameTags(parentNode);
      const edge = this.util.getEdgeChildNodes(first, last);
      return {
        cc: first.parentNode,
        sc: edge.sc,
        ec: edge.ec
      };
    },
    editInsideList: function(remove, selectedCells) {
      selectedCells = !selectedCells ? this.getSelectedElements().filter(function(el) {
        return this.isListCell(el);
      }.bind(this.util)) : selectedCells;
      const cellsLen = selectedCells.length;
      if (cellsLen === 0 || !remove && (!this.util.isListCell(selectedCells[0].previousElementSibling) && !this.util.isListCell(selectedCells[cellsLen - 1].nextElementSibling))) {
        return {
          sc: selectedCells[0],
          so: 0,
          ec: selectedCells[cellsLen - 1],
          eo: 1
        };
      }
      let originList = selectedCells[0].parentNode;
      let lastCell = selectedCells[cellsLen - 1];
      let range = null;
      if (remove) {
        if (originList !== lastCell.parentNode && this.util.isList(lastCell.parentNode.parentNode) && lastCell.nextElementSibling) {
          lastCell = lastCell.nextElementSibling;
          while (lastCell) {
            selectedCells.push(lastCell);
            lastCell = lastCell.nextElementSibling;
          }
        }
        range = this.plugins.list.editList.call(this, originList.nodeName.toUpperCase(), selectedCells, true);
      } else {
        let innerList = this.util.createElement(originList.nodeName);
        let prev = selectedCells[0].previousElementSibling;
        let next = lastCell.nextElementSibling;
        const nodePath = { s: null, e: null, sl: originList, el: originList };
        for (let i = 0, len = cellsLen, c; i < len; i++) {
          c = selectedCells[i];
          if (c.parentNode !== originList) {
            this.plugins.list._insiedList.call(this, originList, innerList, prev, next, nodePath);
            originList = c.parentNode;
            innerList = this.util.createElement(originList.nodeName);
          }
          prev = c.previousElementSibling;
          next = c.nextElementSibling;
          innerList.appendChild(c);
        }
        this.plugins.list._insiedList.call(this, originList, innerList, prev, next, nodePath);
        const sc = this.util.getNodeFromPath(nodePath.s, nodePath.sl);
        const ec = this.util.getNodeFromPath(nodePath.e, nodePath.el);
        range = {
          sc,
          so: 0,
          ec,
          eo: ec.textContent.length
        };
      }
      return range;
    },
    _insiedList: function(originList, innerList, prev, next, nodePath) {
      let insertPrev = false;
      if (prev && innerList.tagName === prev.tagName) {
        const children4 = innerList.children;
        while (children4[0]) {
          prev.appendChild(children4[0]);
        }
        innerList = prev;
        insertPrev = true;
      }
      if (next && innerList.tagName === next.tagName) {
        const children4 = next.children;
        while (children4[0]) {
          innerList.appendChild(children4[0]);
        }
        const temp = next.nextElementSibling;
        next.parentNode.removeChild(next);
        next = temp;
      }
      if (!insertPrev) {
        if (this.util.isListCell(prev)) {
          originList = prev;
          next = null;
        }
        originList.insertBefore(innerList, next);
        if (!nodePath.s) {
          nodePath.s = this.util.getNodePath(innerList.firstElementChild.firstChild, originList, null);
          nodePath.sl = originList;
        }
        const slPath = originList.contains(nodePath.sl) ? this.util.getNodePath(nodePath.sl, originList) : null;
        nodePath.e = this.util.getNodePath(innerList.lastElementChild.firstChild, originList, null);
        nodePath.el = originList;
        this.util.mergeSameTags(originList, [nodePath.s, nodePath.e, slPath], false);
        this.util.mergeNestedTags(originList);
        if (slPath) nodePath.sl = this.util.getNodeFromPath(slPath, originList);
      }
      return innerList;
    },
    pickup: function(e) {
      e.preventDefault();
      e.stopPropagation();
      let target = e.target;
      let command = "";
      while (!command && !/^UL$/i.test(target.tagName)) {
        command = target.getAttribute("data-command");
        target = target.parentNode;
      }
      if (!command) return;
      const range = this.plugins.list.editList.call(this, command, null, false);
      if (range) this.setRange(range.sc, range.so, range.ec, range.eo);
      this.submenuOff();
      this.history.push(false);
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/table.js
  var table_default = {
    name: "table",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      let contextTable = context.table = {
        _element: null,
        _tdElement: null,
        _trElement: null,
        _trElements: null,
        _tableXY: [],
        _maxWidth: true,
        _fixedColumn: false,
        _rtl: core.options.rtl,
        cellControllerTop: core.options.tableCellControllerPosition === "top",
        resizeText: null,
        headerButton: null,
        mergeButton: null,
        splitButton: null,
        splitMenu: null,
        maxText: core.lang.controller.maxSize,
        minText: core.lang.controller.minSize,
        _physical_cellCnt: 0,
        _logical_cellCnt: 0,
        _rowCnt: 0,
        _rowIndex: 0,
        _physical_cellIndex: 0,
        _logical_cellIndex: 0,
        _current_colSpan: 0,
        _current_rowSpan: 0,
        icons: {
          expansion: core.icons.expansion,
          reduction: core.icons.reduction
        }
      };
      let listDiv = this.setSubmenu(core);
      let tablePicker = listDiv.querySelector(".se-controller-table-picker");
      contextTable.tableHighlight = listDiv.querySelector(".se-table-size-highlighted");
      contextTable.tableUnHighlight = listDiv.querySelector(".se-table-size-unhighlighted");
      contextTable.tableDisplay = listDiv.querySelector(".se-table-size-display");
      if (core.options.rtl) contextTable.tableHighlight.style.left = 10 * 18 - 13 + "px";
      let tableController = this.setController_table(core);
      contextTable.tableController = tableController;
      contextTable.resizeButton = tableController.querySelector("._se_table_resize");
      contextTable.resizeText = tableController.querySelector("._se_table_resize > span > span");
      contextTable.columnFixedButton = tableController.querySelector("._se_table_fixed_column");
      contextTable.headerButton = tableController.querySelector("._se_table_header");
      let resizeDiv = this.setController_tableEditor(core, contextTable.cellControllerTop);
      contextTable.resizeDiv = resizeDiv;
      contextTable.splitMenu = resizeDiv.querySelector(".se-btn-group-sub");
      contextTable.mergeButton = resizeDiv.querySelector("._se_table_merge_button");
      contextTable.splitButton = resizeDiv.querySelector("._se_table_split_button");
      contextTable.insertRowAboveButton = resizeDiv.querySelector("._se_table_insert_row_a");
      contextTable.insertRowBelowButton = resizeDiv.querySelector("._se_table_insert_row_b");
      tablePicker.addEventListener("mousemove", this.onMouseMove_tablePicker.bind(core, contextTable));
      tablePicker.addEventListener("click", this.appendTable.bind(core));
      resizeDiv.addEventListener("click", this.onClick_tableController.bind(core));
      tableController.addEventListener("click", this.onClick_tableController.bind(core));
      core.initMenuTarget(this.name, targetElement, listDiv);
      context.element.relative.appendChild(resizeDiv);
      context.element.relative.appendChild(tableController);
      listDiv = null, tablePicker = null, resizeDiv = null, tableController = null, contextTable = null;
    },
    setSubmenu: function(core) {
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-selector-table";
      listDiv.innerHTML = '<div class="se-table-size"><div class="se-table-size-picker se-controller-table-picker"></div><div class="se-table-size-highlighted"></div><div class="se-table-size-unhighlighted"></div></div><div class="se-table-size-display">1 x 1</div>';
      return listDiv;
    },
    setController_table: function(core) {
      const lang = core.lang;
      const icons = core.icons;
      const tableResize = core.util.createElement("DIV");
      tableResize.className = "se-controller se-controller-table";
      tableResize.innerHTML = '<div><div class="se-btn-group"><button type="button" data-command="resize" class="se-btn se-tooltip _se_table_resize">' + icons.expansion + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.maxSize + '</span></span></button><button type="button" data-command="layout" class="se-btn se-tooltip _se_table_fixed_column">' + icons.fixed_column_width + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.fixedColumnWidth + '</span></span></button><button type="button" data-command="header" class="se-btn se-tooltip _se_table_header">' + icons.table_header + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.tableHeader + '</span></span></button><button type="button" data-command="remove" class="se-btn se-tooltip">' + icons.delete + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.remove + "</span></span></button></div></div>";
      return tableResize;
    },
    setController_tableEditor: function(core, cellControllerTop) {
      const lang = core.lang;
      const icons = core.icons;
      const tableResize = core.util.createElement("DIV");
      tableResize.className = "se-controller se-controller-table-cell";
      tableResize.innerHTML = (cellControllerTop ? "" : '<div class="se-arrow se-arrow-up"></div>') + '<div class="se-btn-group"><button type="button" data-command="insert" data-value="row" data-option="up" class="se-btn se-tooltip _se_table_insert_row_a">' + icons.insert_row_above + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.insertRowAbove + '</span></span></button><button type="button" data-command="insert" data-value="row" data-option="down" class="se-btn se-tooltip _se_table_insert_row_b">' + icons.insert_row_below + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.insertRowBelow + '</span></span></button><button type="button" data-command="delete" data-value="row" class="se-btn se-tooltip">' + icons.delete_row + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.deleteRow + '</span></span></button><button type="button" data-command="merge" class="_se_table_merge_button se-btn se-tooltip" disabled>' + icons.merge_cell + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.mergeCells + '</span></span></button></div><div class="se-btn-group" style="padding-top: 0;"><button type="button" data-command="insert" data-value="cell" data-option="left" class="se-btn se-tooltip">' + icons.insert_column_left + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.insertColumnBefore + '</span></span></button><button type="button" data-command="insert" data-value="cell" data-option="right" class="se-btn se-tooltip">' + icons.insert_column_right + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.insertColumnAfter + '</span></span></button><button type="button" data-command="delete" data-value="cell" class="se-btn se-tooltip">' + icons.delete_column + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.deleteColumn + '</span></span></button><button type="button" data-command="onsplit" class="_se_table_split_button se-btn se-tooltip">' + icons.split_cell + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.splitCells + '</span></span></button><div class="se-btn-group-sub sun-editor-common se-list-layer se-table-split"><div class="se-list-inner"><ul class="se-list-basic"><li class="se-btn-list" data-command="split" data-value="vertical" style="line-height:32px;" title="' + lang.controller.VerticalSplit + '" aria-label="' + lang.controller.VerticalSplit + '">' + lang.controller.VerticalSplit + '</li><li class="se-btn-list" data-command="split" data-value="horizontal" style="line-height:32px;" title="' + lang.controller.HorizontalSplit + '" aria-label="' + lang.controller.HorizontalSplit + '">' + lang.controller.HorizontalSplit + "</li></ul></div></div></div>";
      return tableResize;
    },
    appendTable: function() {
      const oTable = this.util.createElement("TABLE");
      const createCells = this.plugins.table.createCells;
      const x = this.context.table._tableXY[0];
      let y = this.context.table._tableXY[1];
      let tableHTML = "<tbody>";
      while (y > 0) {
        tableHTML += "<tr>" + createCells.call(this, "td", x) + "</tr>";
        --y;
      }
      tableHTML += "</tbody>";
      oTable.innerHTML = tableHTML;
      const changed = this.insertComponent(oTable, false, true, false);
      if (changed) {
        const firstTd = oTable.querySelector("td div");
        this.setRange(firstTd, 0, firstTd, 0);
        this.plugins.table.reset_table_picker.call(this);
      }
    },
    createCells: function(nodeName, cnt, returnElement) {
      nodeName = nodeName.toLowerCase();
      if (!returnElement) {
        let cellsHTML = "";
        while (cnt > 0) {
          cellsHTML += "<" + nodeName + "><div><br></div></" + nodeName + ">";
          cnt--;
        }
        return cellsHTML;
      } else {
        const cell = this.util.createElement(nodeName);
        cell.innerHTML = "<div><br></div>";
        return cell;
      }
    },
    onMouseMove_tablePicker: function(contextTable, e) {
      e.stopPropagation();
      let x = this._w.Math.ceil(e.offsetX / 18);
      let y = this._w.Math.ceil(e.offsetY / 18);
      x = x < 1 ? 1 : x;
      y = y < 1 ? 1 : y;
      if (contextTable._rtl) {
        contextTable.tableHighlight.style.left = x * 18 - 13 + "px";
        x = 11 - x;
      }
      contextTable.tableHighlight.style.width = x + "em";
      contextTable.tableHighlight.style.height = y + "em";
      this.util.changeTxt(contextTable.tableDisplay, x + " x " + y);
      contextTable._tableXY = [x, y];
    },
    reset_table_picker: function() {
      if (!this.context.table.tableHighlight) return;
      const highlight = this.context.table.tableHighlight.style;
      const unHighlight = this.context.table.tableUnHighlight.style;
      highlight.width = "1em";
      highlight.height = "1em";
      unHighlight.width = "10em";
      unHighlight.height = "10em";
      this.util.changeTxt(this.context.table.tableDisplay, "1 x 1");
      this.submenuOff();
    },
    init: function() {
      const contextTable = this.context.table;
      const tablePlugin = this.plugins.table;
      tablePlugin._removeEvents.call(this);
      if (tablePlugin._selectedTable) {
        const selectedCells = tablePlugin._selectedTable.querySelectorAll(".se-table-selected-cell");
        for (let i = 0, len = selectedCells.length; i < len; i++) {
          this.util.removeClass(selectedCells[i], "se-table-selected-cell");
        }
      }
      tablePlugin._toggleEditor.call(this, true);
      contextTable._element = null;
      contextTable._tdElement = null;
      contextTable._trElement = null;
      contextTable._trElements = null;
      contextTable._tableXY = [];
      contextTable._maxWidth = true;
      contextTable._fixedColumn = false;
      contextTable._physical_cellCnt = 0;
      contextTable._logical_cellCnt = 0;
      contextTable._rowCnt = 0;
      contextTable._rowIndex = 0;
      contextTable._physical_cellIndex = 0;
      contextTable._logical_cellIndex = 0;
      contextTable._current_colSpan = 0;
      contextTable._current_rowSpan = 0;
      tablePlugin._shift = false;
      tablePlugin._selectedCells = null;
      tablePlugin._selectedTable = null;
      tablePlugin._ref = null;
      tablePlugin._fixedCell = null;
      tablePlugin._selectedCell = null;
      tablePlugin._fixedCellName = null;
    },
    /** table edit controller */
    call_controller_tableEdit: function(tdElement) {
      const tablePlugin = this.plugins.table;
      const contextTable = this.context.table;
      if (!this.getSelection().isCollapsed && !tablePlugin._selectedCell) {
        this.controllersOff();
        this.util.removeClass(tdElement, "se-table-selected-cell");
        return;
      }
      const tableElement = contextTable._element || this.plugins.table._selectedTable || this.util.getParentElement(tdElement, "TABLE");
      contextTable._maxWidth = this.util.hasClass(tableElement, "se-table-size-100") || tableElement.style.width === "100%" || !tableElement.style.width && !this.util.hasClass(tableElement, "se-table-size-auto");
      contextTable._fixedColumn = this.util.hasClass(tableElement, "se-table-layout-fixed") || tableElement.style.tableLayout === "fixed";
      tablePlugin.setTableStyle.call(this, contextTable._maxWidth ? "width|column" : "width");
      tablePlugin.setPositionControllerTop.call(this, tableElement);
      tablePlugin.setPositionControllerDiv.call(this, tdElement, tablePlugin._shift);
      if (!tablePlugin._shift) this.controllersOn(contextTable.resizeDiv, contextTable.tableController, tablePlugin.init.bind(this), tdElement, "table");
    },
    setPositionControllerTop: function(tableElement) {
      this.setControllerPosition(this.context.table.tableController, tableElement, "top", { left: 0, top: 0 });
    },
    setPositionControllerDiv: function(tdElement, reset) {
      const contextTable = this.context.table;
      const resizeDiv = contextTable.resizeDiv;
      this.plugins.table.setCellInfo.call(this, tdElement, reset);
      if (contextTable.cellControllerTop) {
        this.setControllerPosition(resizeDiv, contextTable._element, "top", { left: contextTable.tableController.offsetWidth, top: 0 });
      } else {
        this.setControllerPosition(resizeDiv, tdElement, "bottom", { left: 0, top: 0 });
      }
    },
    setCellInfo: function(tdElement, reset) {
      const contextTable = this.context.table;
      const table = contextTable._element = this.plugins.table._selectedTable || this.util.getParentElement(tdElement, "TABLE");
      if (/THEAD/i.test(table.firstElementChild.nodeName)) {
        this.util.addClass(contextTable.headerButton, "active");
      } else {
        this.util.removeClass(contextTable.headerButton, "active");
      }
      if (reset || contextTable._physical_cellCnt === 0) {
        if (contextTable._tdElement !== tdElement) {
          contextTable._tdElement = tdElement;
          contextTable._trElement = tdElement.parentNode;
        }
        const rows = contextTable._trElements = table.rows;
        const cellIndex = tdElement.cellIndex;
        let cellCnt = 0;
        for (let i = 0, cells = rows[0].cells, len = rows[0].cells.length; i < len; i++) {
          cellCnt += cells[i].colSpan;
        }
        const rowIndex = contextTable._rowIndex = contextTable._trElement.rowIndex;
        contextTable._rowCnt = rows.length;
        contextTable._physical_cellCnt = contextTable._trElement.cells.length;
        contextTable._logical_cellCnt = cellCnt;
        contextTable._physical_cellIndex = cellIndex;
        contextTable._current_colSpan = contextTable._tdElement.colSpan - 1;
        contextTable._current_rowSpan - contextTable._trElement.cells[cellIndex].rowSpan - 1;
        let rowSpanArr = [];
        let spanIndex = [];
        for (let i = 0, cells, colSpan; i <= rowIndex; i++) {
          cells = rows[i].cells;
          colSpan = 0;
          for (let c = 0, cLen = cells.length, cell, cs, rs, logcalIndex; c < cLen; c++) {
            cell = cells[c];
            cs = cell.colSpan - 1;
            rs = cell.rowSpan - 1;
            logcalIndex = c + colSpan;
            if (spanIndex.length > 0) {
              for (let r = 0, arr; r < spanIndex.length; r++) {
                arr = spanIndex[r];
                if (arr.row > i) continue;
                if (logcalIndex >= arr.index) {
                  colSpan += arr.cs;
                  logcalIndex += arr.cs;
                  arr.rs -= 1;
                  arr.row = i + 1;
                  if (arr.rs < 1) {
                    spanIndex.splice(r, 1);
                    r--;
                  }
                } else if (c === cLen - 1) {
                  arr.rs -= 1;
                  arr.row = i + 1;
                  if (arr.rs < 1) {
                    spanIndex.splice(r, 1);
                    r--;
                  }
                }
              }
            }
            if (i === rowIndex && c === cellIndex) {
              contextTable._logical_cellIndex = logcalIndex;
              break;
            }
            if (rs > 0) {
              rowSpanArr.push({
                index: logcalIndex,
                cs: cs + 1,
                rs,
                row: -1
              });
            }
            colSpan += cs;
          }
          spanIndex = spanIndex.concat(rowSpanArr).sort(function(a, b) {
            return a.index - b.index;
          });
          rowSpanArr = [];
        }
        rowSpanArr = null;
        spanIndex = null;
      }
    },
    editTable: function(type, option) {
      const tablePlugin = this.plugins.table;
      const contextTable = this.context.table;
      const table = contextTable._element;
      const isRow = type === "row";
      if (isRow) {
        const tableAttr = contextTable._trElement.parentNode;
        if (/^THEAD$/i.test(tableAttr.nodeName)) {
          if (option === "up") {
            return;
          } else if (!tableAttr.nextElementSibling || !/^TBODY$/i.test(tableAttr.nextElementSibling.nodeName)) {
            table.innerHTML += "<tbody><tr>" + tablePlugin.createCells.call(this, "td", contextTable._logical_cellCnt, false) + "</tr></tbody>";
            return;
          }
        }
      }
      if (tablePlugin._ref) {
        const positionCell = contextTable._tdElement;
        const selectedCells = tablePlugin._selectedCells;
        if (isRow) {
          if (!option) {
            let row = selectedCells[0].parentNode;
            const removeCells = [selectedCells[0]];
            for (let i = 1, len = selectedCells.length, cell; i < len; i++) {
              cell = selectedCells[i];
              if (row !== cell.parentNode) {
                removeCells.push(cell);
                row = cell.parentNode;
              }
            }
            for (let i = 0, len = removeCells.length; i < len; i++) {
              tablePlugin.setCellInfo.call(this, removeCells[i], true);
              tablePlugin.editRow.call(this, option);
            }
          } else {
            tablePlugin.setCellInfo.call(this, option === "up" ? selectedCells[0] : selectedCells[selectedCells.length - 1], true);
            tablePlugin.editRow.call(this, option, positionCell);
          }
        } else {
          const firstRow = selectedCells[0].parentNode;
          if (!option) {
            const removeCells = [selectedCells[0]];
            for (let i = 1, len = selectedCells.length, cell; i < len; i++) {
              cell = selectedCells[i];
              if (firstRow === cell.parentNode) {
                removeCells.push(cell);
              } else {
                break;
              }
            }
            for (let i = 0, len = removeCells.length; i < len; i++) {
              tablePlugin.setCellInfo.call(this, removeCells[i], true);
              tablePlugin.editCell.call(this, option);
            }
          } else {
            let rightCell = null;
            for (let i = 0, len = selectedCells.length - 1; i < len; i++) {
              if (firstRow !== selectedCells[i + 1].parentNode) {
                rightCell = selectedCells[i];
                break;
              }
            }
            tablePlugin.setCellInfo.call(this, option === "left" ? selectedCells[0] : rightCell || selectedCells[0], true);
            tablePlugin.editCell.call(this, option, positionCell);
          }
        }
        if (!option) tablePlugin.init.call(this);
      } else {
        tablePlugin[isRow ? "editRow" : "editCell"].call(this, option);
      }
      if (!option) {
        const children4 = table.children;
        for (let i = 0; i < children4.length; i++) {
          if (children4[i].children.length === 0) {
            this.util.removeItem(children4[i]);
            i--;
          }
        }
        if (table.children.length === 0) this.util.removeItem(table);
      }
    },
    editRow: function(option, positionResetElement) {
      const contextTable = this.context.table;
      const remove = !option;
      const up = option === "up";
      const originRowIndex = contextTable._rowIndex;
      const rowIndex = remove || up ? originRowIndex : originRowIndex + contextTable._current_rowSpan + 1;
      const sign = remove ? -1 : 1;
      const rows = contextTable._trElements;
      let cellCnt = contextTable._logical_cellCnt;
      for (let i = 0, len = originRowIndex + (remove ? -1 : 0), cell; i <= len; i++) {
        cell = rows[i].cells;
        if (cell.length === 0) return;
        for (let c = 0, cLen = cell.length, rs, cs; c < cLen; c++) {
          rs = cell[c].rowSpan;
          cs = cell[c].colSpan;
          if (rs < 2 && cs < 2) continue;
          if (rs + i > rowIndex && rowIndex > i) {
            cell[c].rowSpan = rs + sign;
            cellCnt -= cs;
          }
        }
      }
      if (remove) {
        const next = rows[originRowIndex + 1];
        if (next) {
          const spanCells = [];
          let cells = rows[originRowIndex].cells;
          let colSpan = 0;
          for (let i = 0, len = cells.length, cell, logcalIndex; i < len; i++) {
            cell = cells[i];
            logcalIndex = i + colSpan;
            colSpan += cell.colSpan - 1;
            if (cell.rowSpan > 1) {
              cell.rowSpan -= 1;
              spanCells.push({ cell: cell.cloneNode(false), index: logcalIndex });
            }
          }
          if (spanCells.length > 0) {
            let spanCell = spanCells.shift();
            cells = next.cells;
            colSpan = 0;
            for (let i = 0, len = cells.length, cell, logcalIndex; i < len; i++) {
              cell = cells[i];
              logcalIndex = i + colSpan;
              colSpan += cell.colSpan - 1;
              if (logcalIndex >= spanCell.index) {
                i--, colSpan--;
                colSpan += spanCell.cell.colSpan - 1;
                next.insertBefore(spanCell.cell, cell);
                spanCell = spanCells.shift();
                if (!spanCell) break;
              }
            }
            if (spanCell) {
              next.appendChild(spanCell.cell);
              for (let i = 0, len = spanCells.length; i < len; i++) {
                next.appendChild(spanCells[i].cell);
              }
            }
          }
        }
        contextTable._element.deleteRow(rowIndex);
      } else {
        const newRow = contextTable._element.insertRow(rowIndex);
        newRow.innerHTML = this.plugins.table.createCells.call(this, "td", cellCnt, false);
      }
      if (!remove) {
        this.plugins.table.setPositionControllerDiv.call(this, positionResetElement || contextTable._tdElement, true);
      } else {
        this.controllersOff();
      }
    },
    editCell: function(option, positionResetElement) {
      const contextTable = this.context.table;
      const util2 = this.util;
      const remove = !option;
      const left = option === "left";
      const colSpan = contextTable._current_colSpan;
      const cellIndex = remove || left ? contextTable._logical_cellIndex : contextTable._logical_cellIndex + colSpan + 1;
      const rows = contextTable._trElements;
      let rowSpanArr = [];
      let spanIndex = [];
      let passCell = 0;
      const removeCell = [];
      const removeSpanArr = [];
      for (let i = 0, len = contextTable._rowCnt, row, insertIndex, cells, newCell, applySpan, cellColSpan; i < len; i++) {
        row = rows[i];
        insertIndex = cellIndex;
        applySpan = false;
        cells = row.cells;
        cellColSpan = 0;
        for (let c = 0, cell, cLen = cells.length, rs, cs, removeIndex; c < cLen; c++) {
          cell = cells[c];
          if (!cell) break;
          rs = cell.rowSpan - 1;
          cs = cell.colSpan - 1;
          if (!remove) {
            if (c >= insertIndex) break;
            if (cs > 0) {
              if (passCell < 1 && cs + c >= insertIndex) {
                cell.colSpan += 1;
                insertIndex = null;
                passCell = rs + 1;
                break;
              }
              insertIndex -= cs;
            }
            if (!applySpan) {
              for (let r = 0, arr; r < spanIndex.length; r++) {
                arr = spanIndex[r];
                insertIndex -= arr.cs;
                arr.rs -= 1;
                if (arr.rs < 1) {
                  spanIndex.splice(r, 1);
                  r--;
                }
              }
              applySpan = true;
            }
          } else {
            removeIndex = c + cellColSpan;
            if (spanIndex.length > 0) {
              const lastCell = !cells[c + 1];
              for (let r = 0, arr; r < spanIndex.length; r++) {
                arr = spanIndex[r];
                if (arr.row > i) continue;
                if (removeIndex >= arr.index) {
                  cellColSpan += arr.cs;
                  removeIndex = c + cellColSpan;
                  arr.rs -= 1;
                  arr.row = i + 1;
                  if (arr.rs < 1) {
                    spanIndex.splice(r, 1);
                    r--;
                  }
                } else if (lastCell) {
                  arr.rs -= 1;
                  arr.row = i + 1;
                  if (arr.rs < 1) {
                    spanIndex.splice(r, 1);
                    r--;
                  }
                }
              }
            }
            if (rs > 0) {
              rowSpanArr.push({
                rs,
                cs: cs + 1,
                index: removeIndex,
                row: -1
              });
            }
            if (removeIndex >= insertIndex && removeIndex + cs <= insertIndex + colSpan) {
              removeCell.push(cell);
            } else if (removeIndex <= insertIndex + colSpan && removeIndex + cs >= insertIndex) {
              cell.colSpan -= util2.getOverlapRangeAtIndex(cellIndex, cellIndex + colSpan, removeIndex, removeIndex + cs);
            } else if (rs > 0 && (removeIndex < insertIndex || removeIndex + cs > insertIndex + colSpan)) {
              removeSpanArr.push({
                cell,
                i,
                rs: i + rs
              });
            }
            cellColSpan += cs;
          }
        }
        spanIndex = spanIndex.concat(rowSpanArr).sort(function(a, b) {
          return a.index - b.index;
        });
        rowSpanArr = [];
        if (!remove) {
          if (passCell > 0) {
            passCell -= 1;
            continue;
          }
          if (insertIndex !== null && cells.length > 0) {
            newCell = this.plugins.table.createCells.call(this, cells[0].nodeName, 0, true);
            newCell = row.insertBefore(newCell, cells[insertIndex]);
          }
        }
      }
      if (remove) {
        let removeFirst, removeEnd;
        for (let r = 0, rLen = removeCell.length, row; r < rLen; r++) {
          row = removeCell[r].parentNode;
          util2.removeItem(removeCell[r]);
          if (row.cells.length === 0) {
            if (!removeFirst) removeFirst = util2.getArrayIndex(rows, row);
            removeEnd = util2.getArrayIndex(rows, row);
            util2.removeItem(row);
          }
        }
        for (let c = 0, cLen = removeSpanArr.length, rowSpanCell; c < cLen; c++) {
          rowSpanCell = removeSpanArr[c];
          rowSpanCell.cell.rowSpan = util2.getOverlapRangeAtIndex(removeFirst, removeEnd, rowSpanCell.i, rowSpanCell.rs);
        }
        this.controllersOff();
      } else {
        this.plugins.table.setPositionControllerDiv.call(this, positionResetElement || contextTable._tdElement, true);
      }
    },
    _closeSplitMenu: null,
    openSplitMenu: function() {
      this.util.addClass(this.context.table.splitButton, "on");
      this.context.table.splitMenu.style.display = "inline-table";
      this.plugins.table._closeSplitMenu = function() {
        this.util.removeClass(this.context.table.splitButton, "on");
        this.context.table.splitMenu.style.display = "none";
        this.removeDocEvent("click", this.plugins.table._closeSplitMenu);
        this.plugins.table._closeSplitMenu = null;
      }.bind(this);
      this.addDocEvent("click", this.plugins.table._closeSplitMenu);
    },
    splitCells: function(direction) {
      const util2 = this.util;
      const vertical = direction === "vertical";
      const contextTable = this.context.table;
      const currentCell = contextTable._tdElement;
      const rows = contextTable._trElements;
      const currentRow = contextTable._trElement;
      const index = contextTable._logical_cellIndex;
      const rowIndex = contextTable._rowIndex;
      const newCell = this.plugins.table.createCells.call(this, currentCell.nodeName, 0, true);
      if (vertical) {
        const currentColSpan = currentCell.colSpan;
        newCell.rowSpan = currentCell.rowSpan;
        if (currentColSpan > 1) {
          newCell.colSpan = this._w.Math.floor(currentColSpan / 2);
          currentCell.colSpan = currentColSpan - newCell.colSpan;
          currentRow.insertBefore(newCell, currentCell.nextElementSibling);
        } else {
          let rowSpanArr = [];
          let spanIndex = [];
          for (let i = 0, len = contextTable._rowCnt, cells, colSpan; i < len; i++) {
            cells = rows[i].cells;
            colSpan = 0;
            for (let c = 0, cLen = cells.length, cell, cs, rs, logcalIndex; c < cLen; c++) {
              cell = cells[c];
              cs = cell.colSpan - 1;
              rs = cell.rowSpan - 1;
              logcalIndex = c + colSpan;
              if (spanIndex.length > 0) {
                for (let r = 0, arr; r < spanIndex.length; r++) {
                  arr = spanIndex[r];
                  if (arr.row > i) continue;
                  if (logcalIndex >= arr.index) {
                    colSpan += arr.cs;
                    logcalIndex += arr.cs;
                    arr.rs -= 1;
                    arr.row = i + 1;
                    if (arr.rs < 1) {
                      spanIndex.splice(r, 1);
                      r--;
                    }
                  } else if (c === cLen - 1) {
                    arr.rs -= 1;
                    arr.row = i + 1;
                    if (arr.rs < 1) {
                      spanIndex.splice(r, 1);
                      r--;
                    }
                  }
                }
              }
              if (logcalIndex <= index && rs > 0) {
                rowSpanArr.push({
                  index: logcalIndex,
                  cs: cs + 1,
                  rs,
                  row: -1
                });
              }
              if (cell !== currentCell && logcalIndex <= index && logcalIndex + cs >= index + currentColSpan - 1) {
                cell.colSpan += 1;
                break;
              }
              if (logcalIndex > index) break;
              colSpan += cs;
            }
            spanIndex = spanIndex.concat(rowSpanArr).sort(function(a, b) {
              return a.index - b.index;
            });
            rowSpanArr = [];
          }
          currentRow.insertBefore(newCell, currentCell.nextElementSibling);
        }
      } else {
        const currentRowSpan = currentCell.rowSpan;
        newCell.colSpan = currentCell.colSpan;
        if (currentRowSpan > 1) {
          newCell.rowSpan = this._w.Math.floor(currentRowSpan / 2);
          const newRowSpan = currentRowSpan - newCell.rowSpan;
          const rowSpanArr = [];
          const nextRowIndex = util2.getArrayIndex(rows, currentRow) + newRowSpan;
          for (let i = 0, cells, colSpan; i < nextRowIndex; i++) {
            cells = rows[i].cells;
            colSpan = 0;
            for (let c = 0, cLen = cells.length, cell, cs, logcalIndex; c < cLen; c++) {
              logcalIndex = c + colSpan;
              if (logcalIndex >= index) break;
              cell = cells[c];
              cs = cell.rowSpan - 1;
              if (cs > 0 && cs + i >= nextRowIndex && logcalIndex < index) {
                rowSpanArr.push({
                  index: logcalIndex,
                  cs: cell.colSpan
                });
              }
              colSpan += cell.colSpan - 1;
            }
          }
          const nextRow = rows[nextRowIndex];
          const nextCells = nextRow.cells;
          let rs = rowSpanArr.shift();
          for (let c = 0, cLen = nextCells.length, colSpan = 0, cell, cs, logcalIndex, insertIndex; c < cLen; c++) {
            logcalIndex = c + colSpan;
            cell = nextCells[c];
            cs = cell.colSpan - 1;
            insertIndex = logcalIndex + cs + 1;
            if (rs && insertIndex >= rs.index) {
              colSpan += rs.cs;
              insertIndex += rs.cs;
              rs = rowSpanArr.shift();
            }
            if (insertIndex >= index || c === cLen - 1) {
              nextRow.insertBefore(newCell, cell.nextElementSibling);
              break;
            }
            colSpan += cs;
          }
          currentCell.rowSpan = newRowSpan;
        } else {
          newCell.rowSpan = currentCell.rowSpan;
          const newRow = util2.createElement("TR");
          newRow.appendChild(newCell);
          for (let i = 0, cells2; i < rowIndex; i++) {
            cells2 = rows[i].cells;
            if (cells2.length === 0) return;
            for (let c = 0, cLen = cells2.length; c < cLen; c++) {
              if (i + cells2[c].rowSpan - 1 >= rowIndex) {
                cells2[c].rowSpan += 1;
              }
            }
          }
          const physicalIndex = contextTable._physical_cellIndex;
          const cells = currentRow.cells;
          for (let c = 0, cLen = cells.length; c < cLen; c++) {
            if (c === physicalIndex) continue;
            cells[c].rowSpan += 1;
          }
          currentRow.parentNode.insertBefore(newRow, currentRow.nextElementSibling);
        }
      }
      this.focusEdge(currentCell);
      this.plugins.table.setPositionControllerDiv.call(this, currentCell, true);
    },
    mergeCells: function() {
      const tablePlugin = this.plugins.table;
      const contextTable = this.context.table;
      const util2 = this.util;
      const ref = tablePlugin._ref;
      const selectedCells = tablePlugin._selectedCells;
      const mergeCell = selectedCells[0];
      let emptyRowFirst = null;
      let emptyRowLast = null;
      let cs = ref.ce - ref.cs + 1;
      let rs = ref.re - ref.rs + 1;
      let mergeHTML = "";
      let row = null;
      for (let i = 1, len = selectedCells.length, cell, ch; i < len; i++) {
        cell = selectedCells[i];
        if (row !== cell.parentNode) row = cell.parentNode;
        ch = cell.children;
        for (let c = 0, cLen = ch.length; c < cLen; c++) {
          if (util2.isFormatElement(ch[c]) && util2.onlyZeroWidthSpace(ch[c].textContent)) {
            util2.removeItem(ch[c]);
          }
        }
        mergeHTML += cell.innerHTML;
        util2.removeItem(cell);
        if (row.cells.length === 0) {
          if (!emptyRowFirst) emptyRowFirst = row;
          else emptyRowLast = row;
          rs -= 1;
        }
      }
      if (emptyRowFirst) {
        const rows = contextTable._trElements;
        const rowIndexFirst = util2.getArrayIndex(rows, emptyRowFirst);
        const rowIndexLast = util2.getArrayIndex(rows, emptyRowLast || emptyRowFirst);
        const removeRows = [];
        for (let i = 0, cells; i <= rowIndexLast; i++) {
          cells = rows[i].cells;
          if (cells.length === 0) {
            removeRows.push(rows[i]);
            continue;
          }
          for (let c = 0, cLen = cells.length, cell, rs2; c < cLen; c++) {
            cell = cells[c];
            rs2 = cell.rowSpan - 1;
            if (rs2 > 0 && i + rs2 >= rowIndexFirst) {
              cell.rowSpan -= util2.getOverlapRangeAtIndex(rowIndexFirst, rowIndexLast, i, i + rs2);
            }
          }
        }
        for (let i = 0, len = removeRows.length; i < len; i++) {
          util2.removeItem(removeRows[i]);
        }
      }
      mergeCell.innerHTML += mergeHTML;
      mergeCell.colSpan = cs;
      mergeCell.rowSpan = rs;
      this.controllersOff();
      tablePlugin.setActiveButton.call(this, true, false);
      tablePlugin.call_controller_tableEdit.call(this, mergeCell);
      util2.addClass(mergeCell, "se-table-selected-cell");
      this.focusEdge(mergeCell);
    },
    toggleHeader: function() {
      const util2 = this.util;
      const headerButton = this.context.table.headerButton;
      const active = util2.hasClass(headerButton, "active");
      const table = this.context.table._element;
      if (!active) {
        const header = util2.createElement("THEAD");
        header.innerHTML = "<tr>" + this.plugins.table.createCells.call(this, "th", this.context.table._logical_cellCnt, false) + "</tr>";
        table.insertBefore(header, table.firstElementChild);
      } else {
        util2.removeItem(table.querySelector("thead"));
      }
      util2.toggleClass(headerButton, "active");
      if (/TH/i.test(this.context.table._tdElement.nodeName)) {
        this.controllersOff();
      } else {
        this.plugins.table.setPositionControllerDiv.call(this, this.context.table._tdElement, false);
      }
    },
    setTableStyle: function(styles) {
      const contextTable = this.context.table;
      const tableElement = contextTable._element;
      let icon, span, sizeIcon, text;
      if (styles.indexOf("width") > -1) {
        icon = contextTable.resizeButton.firstElementChild;
        span = contextTable.resizeText;
        if (!contextTable._maxWidth) {
          sizeIcon = contextTable.icons.expansion;
          text = contextTable.maxText;
          contextTable.columnFixedButton.style.display = "none";
          this.util.removeClass(tableElement, "se-table-size-100");
          this.util.addClass(tableElement, "se-table-size-auto");
        } else {
          sizeIcon = contextTable.icons.reduction;
          text = contextTable.minText;
          contextTable.columnFixedButton.style.display = "block";
          this.util.removeClass(tableElement, "se-table-size-auto");
          this.util.addClass(tableElement, "se-table-size-100");
        }
        this.util.changeElement(icon, sizeIcon);
        this.util.changeTxt(span, text);
      }
      if (styles.indexOf("column") > -1) {
        if (!contextTable._fixedColumn) {
          this.util.removeClass(tableElement, "se-table-layout-fixed");
          this.util.addClass(tableElement, "se-table-layout-auto");
          this.util.removeClass(contextTable.columnFixedButton, "active");
        } else {
          this.util.removeClass(tableElement, "se-table-layout-auto");
          this.util.addClass(tableElement, "se-table-layout-fixed");
          this.util.addClass(contextTable.columnFixedButton, "active");
        }
      }
    },
    setActiveButton: function(fixedCell, selectedCell) {
      const contextTable = this.context.table;
      if (/^TH$/i.test(fixedCell.nodeName)) {
        contextTable.insertRowAboveButton.setAttribute("disabled", true);
        contextTable.insertRowBelowButton.setAttribute("disabled", true);
      } else {
        contextTable.insertRowAboveButton.removeAttribute("disabled");
        contextTable.insertRowBelowButton.removeAttribute("disabled");
      }
      if (!selectedCell || fixedCell === selectedCell) {
        contextTable.splitButton.removeAttribute("disabled");
        contextTable.mergeButton.setAttribute("disabled", true);
      } else {
        contextTable.splitButton.setAttribute("disabled", true);
        contextTable.mergeButton.removeAttribute("disabled");
      }
    },
    // multi selecte
    _bindOnSelect: null,
    _bindOffSelect: null,
    _bindOffShift: null,
    _selectedCells: null,
    _shift: false,
    _fixedCell: null,
    _fixedCellName: null,
    _selectedCell: null,
    _selectedTable: null,
    _ref: null,
    _toggleEditor: function(enabled) {
      this.context.element.wysiwyg.setAttribute("contenteditable", enabled);
      if (enabled) this.util.removeClass(this.context.element.wysiwyg, "se-disabled");
      else this.util.addClass(this.context.element.wysiwyg, "se-disabled");
    },
    _offCellMultiSelect: function(e) {
      e.stopPropagation();
      const tablePlugin = this.plugins.table;
      if (!tablePlugin._shift) {
        tablePlugin._removeEvents.call(this);
        tablePlugin._toggleEditor.call(this, true);
      } else if (tablePlugin._initBind) {
        this._wd.removeEventListener("touchmove", tablePlugin._initBind);
        tablePlugin._initBind = null;
      }
      if (!tablePlugin._fixedCell || !tablePlugin._selectedTable) return;
      tablePlugin.setActiveButton.call(this, tablePlugin._fixedCell, tablePlugin._selectedCell);
      tablePlugin.call_controller_tableEdit.call(this, tablePlugin._selectedCell || tablePlugin._fixedCell);
      tablePlugin._selectedCells = tablePlugin._selectedTable.querySelectorAll(".se-table-selected-cell");
      if (tablePlugin._selectedCell && tablePlugin._fixedCell) this.focusEdge(tablePlugin._selectedCell);
      if (!tablePlugin._shift) {
        tablePlugin._fixedCell = null;
        tablePlugin._selectedCell = null;
        tablePlugin._fixedCellName = null;
      }
    },
    _onCellMultiSelect: function(e) {
      this._antiBlur = true;
      const tablePlugin = this.plugins.table;
      const target = this.util.getParentElement(e.target, this.util.isCell);
      if (tablePlugin._shift) {
        if (target === tablePlugin._fixedCell) tablePlugin._toggleEditor.call(this, true);
        else tablePlugin._toggleEditor.call(this, false);
      } else if (!tablePlugin._ref) {
        if (target === tablePlugin._fixedCell) return;
        else tablePlugin._toggleEditor.call(this, false);
      }
      if (!target || target === tablePlugin._selectedCell || tablePlugin._fixedCellName !== target.nodeName || tablePlugin._selectedTable !== this.util.getParentElement(target, "TABLE")) {
        return;
      }
      tablePlugin._selectedCell = target;
      tablePlugin._setMultiCells.call(this, tablePlugin._fixedCell, target);
    },
    _setMultiCells: function(startCell, endCell) {
      const tablePlugin = this.plugins.table;
      const rows = tablePlugin._selectedTable.rows;
      const util2 = this.util;
      const selectedCells = tablePlugin._selectedTable.querySelectorAll(".se-table-selected-cell");
      for (let i = 0, len = selectedCells.length; i < len; i++) {
        util2.removeClass(selectedCells[i], "se-table-selected-cell");
      }
      if (startCell === endCell) {
        util2.addClass(startCell, "se-table-selected-cell");
        if (!tablePlugin._shift) return;
      }
      let findSelectedCell = true;
      let spanIndex = [];
      let rowSpanArr = [];
      const ref = tablePlugin._ref = { _i: 0, cs: null, ce: null, rs: null, re: null };
      for (let i = 0, len = rows.length, cells, colSpan; i < len; i++) {
        cells = rows[i].cells;
        colSpan = 0;
        for (let c = 0, cLen = cells.length, cell, logcalIndex, cs, rs; c < cLen; c++) {
          cell = cells[c];
          cs = cell.colSpan - 1;
          rs = cell.rowSpan - 1;
          logcalIndex = c + colSpan;
          if (spanIndex.length > 0) {
            for (let r = 0, arr; r < spanIndex.length; r++) {
              arr = spanIndex[r];
              if (arr.row > i) continue;
              if (logcalIndex >= arr.index) {
                colSpan += arr.cs;
                logcalIndex += arr.cs;
                arr.rs -= 1;
                arr.row = i + 1;
                if (arr.rs < 1) {
                  spanIndex.splice(r, 1);
                  r--;
                }
              } else if (c === cLen - 1) {
                arr.rs -= 1;
                arr.row = i + 1;
                if (arr.rs < 1) {
                  spanIndex.splice(r, 1);
                  r--;
                }
              }
            }
          }
          if (findSelectedCell) {
            if (cell === startCell || cell === endCell) {
              ref.cs = ref.cs !== null && ref.cs < logcalIndex ? ref.cs : logcalIndex;
              ref.ce = ref.ce !== null && ref.ce > logcalIndex + cs ? ref.ce : logcalIndex + cs;
              ref.rs = ref.rs !== null && ref.rs < i ? ref.rs : i;
              ref.re = ref.re !== null && ref.re > i + rs ? ref.re : i + rs;
              ref._i += 1;
            }
            if (ref._i === 2) {
              findSelectedCell = false;
              spanIndex = [];
              rowSpanArr = [];
              i = -1;
              break;
            }
          } else if (util2.getOverlapRangeAtIndex(ref.cs, ref.ce, logcalIndex, logcalIndex + cs) && util2.getOverlapRangeAtIndex(ref.rs, ref.re, i, i + rs)) {
            const newCs = ref.cs < logcalIndex ? ref.cs : logcalIndex;
            const newCe = ref.ce > logcalIndex + cs ? ref.ce : logcalIndex + cs;
            const newRs = ref.rs < i ? ref.rs : i;
            const newRe = ref.re > i + rs ? ref.re : i + rs;
            if (ref.cs !== newCs || ref.ce !== newCe || ref.rs !== newRs || ref.re !== newRe) {
              ref.cs = newCs;
              ref.ce = newCe;
              ref.rs = newRs;
              ref.re = newRe;
              i = -1;
              spanIndex = [];
              rowSpanArr = [];
              break;
            }
            util2.addClass(cell, "se-table-selected-cell");
          }
          if (rs > 0) {
            rowSpanArr.push({
              index: logcalIndex,
              cs: cs + 1,
              rs,
              row: -1
            });
          }
          colSpan += cell.colSpan - 1;
        }
        spanIndex = spanIndex.concat(rowSpanArr).sort(function(a, b) {
          return a.index - b.index;
        });
        rowSpanArr = [];
      }
    },
    _removeEvents: function() {
      const tablePlugin = this.plugins.table;
      if (tablePlugin._initBind) {
        this._wd.removeEventListener("touchmove", tablePlugin._initBind);
        tablePlugin._initBind = null;
      }
      if (tablePlugin._bindOnSelect) {
        this._wd.removeEventListener("mousedown", tablePlugin._bindOnSelect);
        this._wd.removeEventListener("mousemove", tablePlugin._bindOnSelect);
        tablePlugin._bindOnSelect = null;
      }
      if (tablePlugin._bindOffSelect) {
        this._wd.removeEventListener("mouseup", tablePlugin._bindOffSelect);
        tablePlugin._bindOffSelect = null;
      }
      if (tablePlugin._bindOffShift) {
        this._wd.removeEventListener("keyup", tablePlugin._bindOffShift);
        tablePlugin._bindOffShift = null;
      }
    },
    _initBind: null,
    onTableCellMultiSelect: function(tdElement, shift) {
      const tablePlugin = this.plugins.table;
      tablePlugin._removeEvents.call(this);
      this.controllersOff();
      tablePlugin._shift = shift;
      tablePlugin._fixedCell = tdElement;
      tablePlugin._fixedCellName = tdElement.nodeName;
      tablePlugin._selectedTable = this.util.getParentElement(tdElement, "TABLE");
      const selectedCells = tablePlugin._selectedTable.querySelectorAll(".se-table-selected-cell");
      for (let i = 0, len = selectedCells.length; i < len; i++) {
        this.util.removeClass(selectedCells[i], "se-table-selected-cell");
      }
      this.util.addClass(tdElement, "se-table-selected-cell");
      tablePlugin._bindOnSelect = tablePlugin._onCellMultiSelect.bind(this);
      tablePlugin._bindOffSelect = tablePlugin._offCellMultiSelect.bind(this);
      if (!shift) {
        this._wd.addEventListener("mousemove", tablePlugin._bindOnSelect, false);
      } else {
        tablePlugin._bindOffShift = function() {
          this.controllersOn(this.context.table.resizeDiv, this.context.table.tableController, this.plugins.table.init.bind(this), tdElement, "table");
          if (!tablePlugin._ref) this.controllersOff();
        }.bind(this);
        this._wd.addEventListener("keyup", tablePlugin._bindOffShift, false);
        this._wd.addEventListener("mousedown", tablePlugin._bindOnSelect, false);
      }
      this._wd.addEventListener("mouseup", tablePlugin._bindOffSelect, false);
      tablePlugin._initBind = tablePlugin.init.bind(this);
      this._wd.addEventListener("touchmove", tablePlugin._initBind, false);
    },
    onClick_tableController: function(e) {
      e.stopPropagation();
      const target = e.target.getAttribute("data-command") ? e.target : e.target.parentNode;
      if (target.getAttribute("disabled")) return;
      const command = target.getAttribute("data-command");
      const value = target.getAttribute("data-value");
      const option = target.getAttribute("data-option");
      const tablePlugin = this.plugins.table;
      if (typeof tablePlugin._closeSplitMenu === "function") {
        tablePlugin._closeSplitMenu();
        if (command === "onsplit") return;
      }
      if (!command) return;
      e.preventDefault();
      const contextTable = this.context.table;
      switch (command) {
        case "insert":
        case "delete":
          tablePlugin.editTable.call(this, value, option);
          break;
        case "header":
          tablePlugin.toggleHeader.call(this);
          break;
        case "onsplit":
          tablePlugin.openSplitMenu.call(this);
          break;
        case "split":
          tablePlugin.splitCells.call(this, value);
          break;
        case "merge":
          tablePlugin.mergeCells.call(this);
          break;
        case "resize":
          contextTable._maxWidth = !contextTable._maxWidth;
          tablePlugin.setTableStyle.call(this, "width");
          tablePlugin.setPositionControllerTop.call(this, contextTable._element);
          tablePlugin.setPositionControllerDiv.call(this, contextTable._tdElement, tablePlugin._shift);
          break;
        case "layout":
          contextTable._fixedColumn = !contextTable._fixedColumn;
          tablePlugin.setTableStyle.call(this, "column");
          tablePlugin.setPositionControllerTop.call(this, contextTable._element);
          tablePlugin.setPositionControllerDiv.call(this, contextTable._tdElement, tablePlugin._shift);
          break;
        case "remove":
          const emptyDiv = contextTable._element.parentNode;
          this.util.removeItem(contextTable._element);
          this.controllersOff();
          if (emptyDiv !== this.context.element.wysiwyg) this.util.removeItemAllParents(emptyDiv, function(current) {
            return current.childNodes.length === 0;
          }, null);
          this.focus();
      }
      this.history.push(false);
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/formatBlock.js
  var formatBlock_default = {
    name: "formatBlock",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.formatBlock = {
        targetText: targetElement.querySelector(".txt"),
        targetTooltip: targetElement.parentNode.querySelector(".se-tooltip-text"),
        _formatList: null,
        currentFormat: ""
      };
      let listDiv = this.setSubmenu(core);
      listDiv.querySelector("ul").addEventListener("click", this.pickUp.bind(core));
      context.formatBlock._formatList = listDiv.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null;
    },
    setSubmenu: function(core) {
      const option = core.options;
      const lang_toolbar = core.lang.toolbar;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer se-list-format";
      const defaultFormats = ["p", "div", "blockquote", "pre", "h1", "h2", "h3", "h4", "h5", "h6"];
      const formatList = !option.formats || option.formats.length === 0 ? defaultFormats : option.formats;
      let list = '<div class="se-list-inner"><ul class="se-list-basic">';
      for (let i = 0, len = formatList.length, format, tagName, command, name2, h, attrs, className; i < len; i++) {
        format = formatList[i];
        if (typeof format === "string" && defaultFormats.indexOf(format) > -1) {
          tagName = format.toLowerCase();
          command = tagName === "blockquote" ? "range" : tagName === "pre" ? "free" : "replace";
          h = /^h/.test(tagName) ? tagName.match(/\d+/)[0] : "";
          name2 = lang_toolbar["tag_" + (h ? "h" : tagName)] + h;
          className = "";
          attrs = "";
        } else {
          tagName = format.tag.toLowerCase();
          command = format.command;
          name2 = format.name || tagName;
          className = format.class;
          attrs = className ? ' class="' + className + '"' : "";
        }
        list += '<li><button type="button" class="se-btn-list" data-command="' + command + '" data-value="' + tagName + '" data-class="' + className + '" title="' + name2 + '" aria-label="' + name2 + '"><' + tagName + attrs + ">" + name2 + "</" + tagName + "></button></li>";
      }
      list += "</ul></div>";
      listDiv.innerHTML = list;
      return listDiv;
    },
    /**
    * @Override core
    */
    active: function(element) {
      let formatTitle = this.lang.toolbar.formats;
      const target = this.context.formatBlock.targetText;
      if (!element) {
        this.util.changeTxt(target, formatTitle);
      } else if (this.util.isFormatElement(element)) {
        const formatContext = this.context.formatBlock;
        const formatList = formatContext._formatList;
        const nodeName = element.nodeName.toLowerCase();
        const className = (element.className.match(/(\s|^)__se__format__[^\s]+/) || [""])[0].trim();
        for (let i = 0, len = formatList.length, f; i < len; i++) {
          f = formatList[i];
          if (nodeName === f.getAttribute("data-value") && className === f.getAttribute("data-class")) {
            formatTitle = f.title;
            break;
          }
        }
        this.util.changeTxt(target, formatTitle);
        target.setAttribute("data-value", nodeName);
        target.setAttribute("data-class", className);
        return true;
      }
      return false;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const formatContext = this.context.formatBlock;
      const formatList = formatContext._formatList;
      const target = formatContext.targetText;
      const currentFormat = (target.getAttribute("data-value") || "") + (target.getAttribute("data-class") || "");
      if (currentFormat !== formatContext.currentFormat) {
        for (let i = 0, len = formatList.length, f; i < len; i++) {
          f = formatList[i];
          if (currentFormat === f.getAttribute("data-value") + f.getAttribute("data-class")) {
            this.util.addClass(f, "active");
          } else {
            this.util.removeClass(f, "active");
          }
        }
        formatContext.currentFormat = currentFormat;
      }
    },
    pickUp: function(e) {
      e.preventDefault();
      e.stopPropagation();
      let target = e.target;
      let command = null, value = null, tag = null, className = "";
      while (!command && !/UL/i.test(target.tagName)) {
        command = target.getAttribute("data-command");
        value = target.getAttribute("data-value");
        className = target.getAttribute("data-class");
        if (command) {
          tag = target.firstChild;
          break;
        }
        target = target.parentNode;
      }
      if (!command) return;
      if (command === "range") {
        const rangeElement = tag.cloneNode(false);
        this.applyRangeFormatElement(rangeElement);
      } else {
        let range = this.getRange();
        let selectedFormsts = this.getSelectedElementsAndComponents(false);
        if (selectedFormsts.length === 0) {
          range = this.getRange_addLine(range, null);
          selectedFormsts = this.getSelectedElementsAndComponents(false);
          if (selectedFormsts.length === 0) return;
        }
        const startOffset = range.startOffset;
        const endOffset = range.endOffset;
        const util2 = this.util;
        let first = selectedFormsts[0];
        let last = selectedFormsts[selectedFormsts.length - 1];
        const firstPath = util2.getNodePath(range.startContainer, first, null, null);
        const lastPath = util2.getNodePath(range.endContainer, last, null, null);
        const rlist = this.detachList(selectedFormsts, false);
        if (rlist.sc) first = rlist.sc;
        if (rlist.ec) last = rlist.ec;
        this.setRange(util2.getNodeFromPath(firstPath, first), startOffset, util2.getNodeFromPath(lastPath, last), endOffset);
        const modifiedFormsts = this.getSelectedElementsAndComponents(false);
        if (command === "free") {
          const len = modifiedFormsts.length - 1;
          let parentNode = modifiedFormsts[len].parentNode;
          let freeElement = tag.cloneNode(false);
          const focusElement = freeElement;
          for (let i = len, f, html, before, next, inner, isComp, first2 = true; i >= 0; i--) {
            f = modifiedFormsts[i];
            if (f === (!modifiedFormsts[i + 1] ? null : modifiedFormsts[i + 1].parentNode)) continue;
            isComp = util2.isComponent(f);
            html = isComp ? "" : f.innerHTML.replace(/(?!>)\s+(?=<)|\n/g, " ");
            before = util2.getParentElement(f, function(current) {
              return current.parentNode === parentNode;
            });
            if (parentNode !== f.parentNode || isComp) {
              if (util2.isFormatElement(parentNode)) {
                parentNode.parentNode.insertBefore(freeElement, parentNode.nextSibling);
                parentNode = parentNode.parentNode;
              } else {
                parentNode.insertBefore(freeElement, before ? before.nextSibling : null);
                parentNode = f.parentNode;
              }
              next = freeElement.nextSibling;
              if (next && freeElement.nodeName === next.nodeName && util2.isSameAttributes(freeElement, next)) {
                freeElement.innerHTML += "<BR>" + next.innerHTML;
                util2.removeItem(next);
              }
              freeElement = tag.cloneNode(false);
              first2 = true;
            }
            inner = freeElement.innerHTML;
            freeElement.innerHTML = (first2 || !html || !inner || /<br>$/i.test(html) ? html : html + "<BR>") + inner;
            if (i === 0) {
              parentNode.insertBefore(freeElement, f);
              next = f.nextSibling;
              if (next && freeElement.nodeName === next.nodeName && util2.isSameAttributes(freeElement, next)) {
                freeElement.innerHTML += "<BR>" + next.innerHTML;
                util2.removeItem(next);
              }
              const prev = freeElement.previousSibling;
              if (prev && freeElement.nodeName === prev.nodeName && util2.isSameAttributes(freeElement, prev)) {
                prev.innerHTML += "<BR>" + freeElement.innerHTML;
                util2.removeItem(freeElement);
              }
            }
            if (!isComp) util2.removeItem(f);
            if (!!html) first2 = false;
          }
          this.setRange(focusElement, 0, focusElement, 0);
        } else {
          for (let i = 0, len = modifiedFormsts.length, node, newFormat; i < len; i++) {
            node = modifiedFormsts[i];
            if ((node.nodeName.toLowerCase() !== value.toLowerCase() || (node.className.match(/(\s|^)__se__format__[^\s]+/) || [""])[0].trim() !== className) && !util2.isComponent(node)) {
              newFormat = tag.cloneNode(false);
              util2.copyFormatAttributes(newFormat, node);
              newFormat.innerHTML = node.innerHTML;
              node.parentNode.replaceChild(newFormat, node);
            }
            if (i === 0) first = newFormat || node;
            if (i === len - 1) last = newFormat || node;
            newFormat = null;
          }
          this.setRange(util2.getNodeFromPath(firstPath, first), startOffset, util2.getNodeFromPath(lastPath, last), endOffset);
        }
        this.history.push(false);
      }
      this.submenuOff();
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/lineHeight.js
  var lineHeight_default = {
    name: "lineHeight",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.lineHeight = {
        _sizeList: null,
        currentSize: -1
      };
      let listDiv = this.setSubmenu(core);
      let listUl = listDiv.querySelector("ul");
      listUl.addEventListener("click", this.pickup.bind(core));
      context.lineHeight._sizeList = listUl.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null, listUl = null;
    },
    setSubmenu: function(core) {
      const option = core.options;
      const lang = core.lang;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer";
      const sizeList = !option.lineHeights ? [
        { text: "1", value: 1 },
        { text: "1.15", value: 1.15 },
        { text: "1.5", value: 1.5 },
        { text: "2", value: 2 }
      ] : option.lineHeights;
      let list = '<div class="se-list-inner"><ul class="se-list-basic"><li><button type="button" class="default_value se-btn-list" title="' + lang.toolbar.default + '" aria-label="' + lang.toolbar.default + '">(' + lang.toolbar.default + ")</button></li>";
      for (let i = 0, len = sizeList.length, size; i < len; i++) {
        size = sizeList[i];
        list += '<li><button type="button" class="se-btn-list" data-value="' + size.value + '" title="' + size.text + '" aria-label="' + size.text + '">' + size.text + "</button></li>";
      }
      list += "</ul></div>";
      listDiv.innerHTML = list;
      return listDiv;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const lineHeightContext = this.context.lineHeight;
      const sizeList = lineHeightContext._sizeList;
      const format = this.util.getFormatElement(this.getSelectionNode());
      const currentSize = !format ? "" : format.style.lineHeight + "";
      if (currentSize !== lineHeightContext.currentSize) {
        for (let i = 0, len = sizeList.length; i < len; i++) {
          if (currentSize === sizeList[i].getAttribute("data-value")) {
            this.util.addClass(sizeList[i], "active");
          } else {
            this.util.removeClass(sizeList[i], "active");
          }
        }
        lineHeightContext.currentSize = currentSize;
      }
    },
    pickup: function(e) {
      if (!/^BUTTON$/i.test(e.target.tagName)) return false;
      e.preventDefault();
      e.stopPropagation();
      const value = e.target.getAttribute("data-value") || "";
      const formats = this.getSelectedElements();
      for (let i = 0, len = formats.length; i < len; i++) {
        formats[i].style.lineHeight = value;
      }
      this.submenuOff();
      this.history.push(false);
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/template.js
  var template_default = {
    name: "template",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.template = {
        selectedIndex: -1
      };
      let templateDiv = this.setSubmenu(core);
      templateDiv.querySelector("ul").addEventListener("click", this.pickup.bind(core));
      core.initMenuTarget(this.name, targetElement, templateDiv);
      templateDiv = null;
    },
    setSubmenu: function(core) {
      const templateList = core.options.templates;
      if (!templateList || templateList.length === 0) {
        throw Error('[SUNEDITOR.plugins.template.fail] To use the "template" plugin, please define the "templates" option.');
      }
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-list-layer";
      let list = '<div class="se-submenu se-list-inner"><ul class="se-list-basic">';
      for (let i = 0, len = templateList.length, t; i < len; i++) {
        t = templateList[i];
        list += '<li><button type="button" class="se-btn-list" data-value="' + i + '" title="' + t.name + '" aria-label="' + t.name + '">' + t.name + "</button></li>";
      }
      list += "</ul></div>";
      listDiv.innerHTML = list;
      return listDiv;
    },
    pickup: function(e) {
      if (!/^BUTTON$/i.test(e.target.tagName)) return false;
      e.preventDefault();
      e.stopPropagation();
      this.context.template.selectedIndex = e.target.getAttribute("data-value") * 1;
      const temp = this.options.templates[this.context.template.selectedIndex];
      if (temp.html) {
        this.setContents(temp.html);
      } else {
        this.submenuOff();
        throw Error('[SUNEDITOR.template.fail] cause : "templates[i].html not found"');
      }
      this.submenuOff();
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/paragraphStyle.js
  var paragraphStyle_default = {
    name: "paragraphStyle",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.paragraphStyle = {
        _classList: null
      };
      let listDiv = this.setSubmenu(core);
      listDiv.querySelector("ul").addEventListener("click", this.pickUp.bind(core));
      context.paragraphStyle._classList = listDiv.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null;
    },
    setSubmenu: function(core) {
      const option = core.options;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer se-list-format";
      const menuLang = core.lang.menu;
      const defaultList = {
        spaced: {
          name: menuLang.spaced,
          class: "__se__p-spaced",
          _class: ""
        },
        bordered: {
          name: menuLang.bordered,
          class: "__se__p-bordered",
          _class: ""
        },
        neon: {
          name: menuLang.neon,
          class: "__se__p-neon",
          _class: ""
        }
      };
      const paragraphStyles = !option.paragraphStyles || option.paragraphStyles.length === 0 ? ["spaced", "bordered", "neon"] : option.paragraphStyles;
      let list = '<div class="se-list-inner"><ul class="se-list-basic">';
      for (let i = 0, len = paragraphStyles.length, p, name2, attrs, _class; i < len; i++) {
        p = paragraphStyles[i];
        if (typeof p === "string") {
          const defaultStyle = defaultList[p.toLowerCase()];
          if (!defaultStyle) continue;
          p = defaultStyle;
        }
        name2 = p.name;
        attrs = p.class ? ' class="' + p.class + '"' : "";
        _class = p._class;
        list += '<li><button type="button" class="se-btn-list' + (_class ? " " + _class : "") + '" data-value="' + p.class + '" title="' + name2 + '" aria-label="' + name2 + '"><div' + attrs + ">" + name2 + "</div></button></li>";
      }
      list += "</ul></div>";
      listDiv.innerHTML = list;
      return listDiv;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const paragraphContext = this.context.paragraphStyle;
      const paragraphList = paragraphContext._classList;
      const currentFormat = this.util.getFormatElement(this.getSelectionNode());
      for (let i = 0, len = paragraphList.length; i < len; i++) {
        if (this.util.hasClass(currentFormat, paragraphList[i].getAttribute("data-value"))) {
          this.util.addClass(paragraphList[i], "active");
        } else {
          this.util.removeClass(paragraphList[i], "active");
        }
      }
    },
    pickUp: function(e) {
      e.preventDefault();
      e.stopPropagation();
      let target = e.target;
      let value = null;
      while (!/^UL$/i.test(target.tagName)) {
        value = target.getAttribute("data-value");
        if (value) break;
        target = target.parentNode;
      }
      if (!value) return;
      let selectedFormsts = this.getSelectedElements();
      if (selectedFormsts.length === 0) {
        this.getRange_addLine(this.getRange(), null);
        selectedFormsts = this.getSelectedElements();
        if (selectedFormsts.length === 0) return;
      }
      const toggleClass = this.util.hasClass(target, "active") ? this.util.removeClass.bind(this.util) : this.util.addClass.bind(this.util);
      for (let i = 0, len = selectedFormsts.length; i < len; i++) {
        toggleClass(selectedFormsts[i], value);
      }
      this.submenuOff();
      this.history.push(false);
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/textStyle.js
  var textStyle_default = {
    name: "textStyle",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.textStyle = {
        _styleList: null
      };
      let listDiv = this.setSubmenu(core);
      let listUl = listDiv.querySelector("ul");
      listUl.addEventListener("click", this.pickup.bind(core));
      context.textStyle._styleList = listDiv.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null, listUl = null;
    },
    setSubmenu: function(core) {
      const option = core.options;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer se-list-format";
      const defaultList = {
        code: {
          name: core.lang.menu.code,
          class: "__se__t-code",
          tag: "code"
        },
        translucent: {
          name: core.lang.menu.translucent,
          style: "opacity: 0.5;",
          tag: "span"
        },
        shadow: {
          name: core.lang.menu.shadow,
          class: "__se__t-shadow",
          tag: "span"
        }
      };
      const styleList = !option.textStyles ? core._w.Object.keys(defaultList) : option.textStyles;
      let list = '<div class="se-list-inner"><ul class="se-list-basic">';
      for (let i = 0, len = styleList.length, t, tag, name2, attrs, command, value, _class; i < len; i++) {
        t = styleList[i];
        attrs = "", value = "", command = [];
        if (typeof t === "string") {
          const defaultStyle = defaultList[t.toLowerCase()];
          if (!defaultStyle) continue;
          t = defaultStyle;
        }
        name2 = t.name;
        tag = t.tag || "span";
        _class = t._class;
        if (t.style) {
          attrs += ' style="' + t.style + '"';
          value += t.style.replace(/:[^;]+(;|$)\s*/g, ",");
          command.push("style");
        }
        if (t.class) {
          attrs += ' class="' + t.class + '"';
          value += "." + t.class.trim().replace(/\s+/g, ",.");
          command.push("class");
        }
        value = value.replace(/,$/, "");
        list += '<li><button type="button" class="se-btn-list' + (_class ? " " + _class : "") + '" data-command="' + tag + '" data-value="' + value + '" title="' + name2 + '" aria-label="' + name2 + '"><' + tag + attrs + ">" + name2 + "</" + tag + "></button></li>";
      }
      list += "</ul></div>";
      listDiv.innerHTML = list;
      return listDiv;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const util2 = this.util;
      const textStyleContext = this.context.textStyle;
      const styleButtonList = textStyleContext._styleList;
      const selectionNode = this.getSelectionNode();
      for (let i = 0, len = styleButtonList.length, btn, data2, active; i < len; i++) {
        btn = styleButtonList[i];
        data2 = btn.getAttribute("data-value").split(",");
        for (let v = 0, node, value; v < data2.length; v++) {
          node = selectionNode;
          active = false;
          while (node && !util2.isFormatElement(node) && !util2.isComponent(node)) {
            if (node.nodeName.toLowerCase() === btn.getAttribute("data-command").toLowerCase()) {
              value = data2[v];
              if (/^\./.test(value) ? util2.hasClass(node, value.replace(/^\./, "")) : !!node.style[value]) {
                active = true;
                break;
              }
            }
            node = node.parentNode;
          }
          if (!active) break;
        }
        active ? util2.addClass(btn, "active") : util2.removeClass(btn, "active");
      }
    },
    pickup: function(e) {
      e.preventDefault();
      e.stopPropagation();
      let target = e.target;
      let command = null, tag = null;
      while (!command && !/UL/i.test(target.tagName)) {
        command = target.getAttribute("data-command");
        if (command) {
          tag = target.firstChild;
          break;
        }
        target = target.parentNode;
      }
      if (!command) return;
      const checkStyles = tag.style.cssText.replace(/:.+(;|$)/g, ",").split(",");
      checkStyles.pop();
      const classes = tag.classList;
      for (let i = 0, len = classes.length; i < len; i++) {
        checkStyles.push("." + classes[i]);
      }
      const newNode = this.util.hasClass(target, "active") ? null : tag.cloneNode(false);
      const removeNodes = newNode ? null : [tag.nodeName];
      this.nodeChange(newNode, checkStyles, removeNodes, true);
      this.submenuOff();
    }
  };

  // ../../node_modules/suneditor/src/plugins/dialog/link.js
  var import_dialog = __toESM(require_dialog());

  // ../../node_modules/suneditor/src/plugins/modules/_selectMenu.js
  var selectMenu_default = {
    name: "selectMenu",
    add: function(core) {
      core.context.selectMenu = {
        caller: {},
        callerContext: null
      };
    },
    setForm: function() {
      return '<div class="se-select-list"></div>';
    },
    createList: function(listContext, items, html) {
      listContext.form.innerHTML = "<ul>" + html + "</ul>";
      listContext.items = items;
      listContext.menus = listContext.form.querySelectorAll("li");
    },
    initEvent: function(pluginName, forms) {
      const form = forms.querySelector(".se-select-list");
      const context = this.context.selectMenu.caller[pluginName] = {
        form,
        items: [],
        menus: [],
        index: -1,
        item: null,
        clickMethod: null,
        callerName: pluginName
      };
      form.addEventListener("mousedown", this.plugins.selectMenu.onMousedown_list);
      form.addEventListener("mousemove", this.plugins.selectMenu.onMouseMove_list.bind(this, context));
      form.addEventListener("click", this.plugins.selectMenu.onClick_list.bind(this, context));
    },
    onMousedown_list: function(e) {
      e.preventDefault();
      e.stopPropagation();
    },
    onMouseMove_list: function(context, e) {
      this.util.addClass(context.form, "__se_select-menu-mouse-move");
      const index = e.target.getAttribute("data-index");
      if (!index) return;
      context.index = index * 1;
    },
    onClick_list: function(context, e) {
      const index = e.target.getAttribute("data-index");
      if (!index) return;
      context.clickMethod.call(this, context.items[index]);
    },
    moveItem: function(listContext, num) {
      this.util.removeClass(listContext.form, "__se_select-menu-mouse-move");
      num = listContext.index + num;
      const menus = listContext.menus;
      const len = menus.length;
      const selectIndex = listContext.index = num >= len ? 0 : num < 0 ? len - 1 : num;
      for (let i = 0; i < len; i++) {
        if (i === selectIndex) {
          this.util.addClass(menus[i], "active");
        } else {
          this.util.removeClass(menus[i], "active");
        }
      }
      listContext.item = listContext.items[selectIndex];
    },
    getItem: function(listContext, index) {
      index = !index || index < 0 ? listContext.index : index;
      return listContext.items[index];
    },
    on: function(callerName, clickMethod) {
      const listContext = this.context.selectMenu.caller[callerName];
      this.context.selectMenu.callerContext = listContext;
      listContext.clickMethod = clickMethod;
      listContext.callerName = callerName;
    },
    open: function(listContext, positionHandler) {
      const form = listContext.form;
      form.style.visibility = "hidden";
      form.style.display = "block";
      positionHandler(form);
      form.style.visibility = "";
    },
    close: function(listContext) {
      listContext.form.style.display = "none";
      listContext.items = [];
      listContext.menus = [];
      listContext.index = -1;
      listContext.item = null;
    },
    init: function(listContext) {
      if (!listContext) return;
      listContext.items = [];
      listContext.menus = [];
      listContext.index = -1;
      listContext.item = null;
      listContext.callerName = "";
      this.context.selectMenu.callerContext = null;
    }
  };

  // ../../node_modules/suneditor/src/plugins/modules/_anchor.js
  var anchor_default = {
    name: "anchor",
    add: function(core) {
      core.addModule([selectMenu_default]);
      core.context.anchor = {
        caller: {},
        forms: this.setDialogForm(core),
        host: (core._w.location.origin + core._w.location.pathname).replace(/\/$/, ""),
        callerContext: null
      };
    },
    /** dialog */
    setDialogForm: function(core) {
      const lang = core.lang;
      const relList = core.options.linkRel;
      const defaultRel = (core.options.linkRelDefault.default || "").split(" ");
      const icons = core.icons;
      const forms = core.util.createElement("DIV");
      let html = '<div class="se-dialog-body"><div class="se-dialog-form"><label>' + lang.dialogBox.linkBox.url + '</label><div class="se-dialog-form-files"><input class="se-input-form se-input-url" type="text" placeholder="' + (core.options.protocol || "") + '" /><button type="button" class="se-btn se-dialog-files-edge-button _se_bookmark_button" title="' + lang.dialogBox.linkBox.bookmark + '" aria-label="' + lang.dialogBox.linkBox.bookmark + '">' + icons.bookmark + "</button>" + core.plugins.selectMenu.setForm() + '</div><div class="se-anchor-preview-form"><span class="se-svg se-anchor-preview-icon _se_anchor_bookmark_icon">' + icons.bookmark + '</span><span class="se-svg se-anchor-preview-icon _se_anchor_download_icon">' + icons.download + '</span><pre class="se-link-preview"></pre></div></div><div class="se-dialog-form"><label>' + lang.dialogBox.linkBox.text + '</label><input class="se-input-form _se_anchor_text" type="text" /></div><div class="se-dialog-form-footer"><label><input type="checkbox" class="se-dialog-btn-check _se_anchor_check" />&nbsp;' + lang.dialogBox.linkBox.newWindowCheck + '</label><label><input type="checkbox" class="se-dialog-btn-check _se_anchor_download" />&nbsp;' + lang.dialogBox.linkBox.downloadLinkCheck + "</label>";
      if (relList.length > 0) {
        html += '<div class="se-anchor-rel"><button type="button" class="se-btn se-btn-select se-anchor-rel-btn">&lt;rel&gt;</button><div class="se-anchor-rel-wrapper"><pre class="se-link-preview se-anchor-rel-preview"></pre></div><div class="se-list-layer"><div class="se-list-inner"><ul class="se-list-basic se-list-checked">';
        for (let i = 0, len = relList.length, rel; i < len; i++) {
          rel = relList[i];
          html += '<li><button type="button" class="se-btn-list' + (defaultRel.indexOf(rel) > -1 ? " se-checked" : "") + '" data-command="' + rel + '" title="' + rel + '" aria-label="' + rel + '"><span class="se-svg">' + icons.checked + "</span>" + rel + "</button></li>";
        }
        html += "</ul></div></div></div>";
      }
      html += "</div></div>";
      forms.innerHTML = html;
      return forms;
    },
    initEvent: function(pluginName, forms) {
      const anchorPlugin = this.plugins.anchor;
      const context = this.context.anchor.caller[pluginName] = {
        modal: forms,
        urlInput: null,
        linkDefaultRel: this.options.linkRelDefault,
        defaultRel: this.options.linkRelDefault.default || "",
        currentRel: [],
        linkAnchor: null,
        linkValue: "",
        _change: false,
        callerName: pluginName
      };
      if (typeof context.linkDefaultRel.default === "string") context.linkDefaultRel.default = context.linkDefaultRel.default.trim();
      if (typeof context.linkDefaultRel.check_new_window === "string") context.linkDefaultRel.check_new_window = context.linkDefaultRel.check_new_window.trim();
      if (typeof context.linkDefaultRel.check_bookmark === "string") context.linkDefaultRel.check_bookmark = context.linkDefaultRel.check_bookmark.trim();
      context.urlInput = forms.querySelector(".se-input-url");
      context.anchorText = forms.querySelector("._se_anchor_text");
      context.newWindowCheck = forms.querySelector("._se_anchor_check");
      context.downloadCheck = forms.querySelector("._se_anchor_download");
      context.download = forms.querySelector("._se_anchor_download_icon");
      context.preview = forms.querySelector(".se-link-preview");
      context.bookmark = forms.querySelector("._se_anchor_bookmark_icon");
      context.bookmarkButton = forms.querySelector("._se_bookmark_button");
      this.plugins.selectMenu.initEvent.call(this, pluginName, forms);
      const listContext = this.context.selectMenu.caller[pluginName];
      if (this.options.linkRel.length > 0) {
        context.relButton = forms.querySelector(".se-anchor-rel-btn");
        context.relList = forms.querySelector(".se-list-layer");
        context.relPreview = forms.querySelector(".se-anchor-rel-preview");
        context.relButton.addEventListener("click", anchorPlugin.onClick_relButton.bind(this, context));
        context.relList.addEventListener("click", anchorPlugin.onClick_relList.bind(this, context));
      }
      context.newWindowCheck.addEventListener("change", anchorPlugin.onChange_newWindowCheck.bind(this, context));
      context.downloadCheck.addEventListener("change", anchorPlugin.onChange_downloadCheck.bind(this, context));
      context.anchorText.addEventListener("input", anchorPlugin.onChangeAnchorText.bind(this, context));
      context.urlInput.addEventListener("input", anchorPlugin.onChangeUrlInput.bind(this, context));
      context.urlInput.addEventListener("keydown", anchorPlugin.onKeyDownUrlInput.bind(this, listContext));
      context.urlInput.addEventListener("focus", anchorPlugin.onFocusUrlInput.bind(this, context, listContext));
      context.urlInput.addEventListener("blur", anchorPlugin.onBlurUrlInput.bind(this, listContext));
      context.bookmarkButton.addEventListener("click", anchorPlugin.onClick_bookmarkButton.bind(this, context));
    },
    on: function(contextAnchor, update) {
      const anchorPlugin = this.plugins.anchor;
      if (!update) {
        anchorPlugin.init.call(this, contextAnchor);
        contextAnchor.anchorText.value = this.getSelection().toString().trim();
        contextAnchor.newWindowCheck.checked = this.options.linkTargetNewWindow;
      } else if (contextAnchor.linkAnchor) {
        this.context.dialog.updateModal = true;
        const href = contextAnchor.linkAnchor.getAttribute("href");
        contextAnchor.linkValue = contextAnchor.preview.textContent = contextAnchor.urlInput.value = anchorPlugin.selfPathBookmark.call(this, href) ? href.substr(href.lastIndexOf("#")) : href;
        contextAnchor.anchorText.value = contextAnchor.linkAnchor.textContent;
        contextAnchor.newWindowCheck.checked = /_blank/i.test(contextAnchor.linkAnchor.target) ? true : false;
        contextAnchor.downloadCheck.checked = contextAnchor.linkAnchor.download;
      }
      this.context.anchor.callerContext = contextAnchor;
      anchorPlugin.setRel.call(this, contextAnchor, update && contextAnchor.linkAnchor ? contextAnchor.linkAnchor.rel : contextAnchor.defaultRel);
      anchorPlugin.setLinkPreview.call(this, contextAnchor, contextAnchor.linkValue);
      this.plugins.selectMenu.on.call(this, contextAnchor.callerName, this.plugins.anchor.setHeaderBookmark);
    },
    selfPathBookmark: function(path) {
      const href = this._w.location.href.replace(/\/$/, "");
      return path.indexOf("#") === 0 || path.indexOf(href) === 0 && path.indexOf("#") === (href.indexOf("#") === -1 ? href.length : href.substr(0, href.indexOf("#")).length);
    },
    _closeRelMenu: null,
    toggleRelList: function(contextAnchor, show) {
      if (!show) {
        if (this.plugins.anchor._closeRelMenu) this.plugins.anchor._closeRelMenu();
      } else {
        const target = contextAnchor.relButton;
        const relList = contextAnchor.relList;
        this.util.addClass(target, "active");
        relList.style.visibility = "hidden";
        relList.style.display = "block";
        if (!this.options.rtl) relList.style.left = target.offsetLeft + target.offsetWidth + 1 + "px";
        else relList.style.left = target.offsetLeft - relList.offsetWidth - 1 + "px";
        relList.style.top = target.offsetTop + target.offsetHeight / 2 - relList.offsetHeight / 2 + "px";
        relList.style.visibility = "";
        this.plugins.anchor._closeRelMenu = function(context, target2, e) {
          if (e && (context.relButton.contains(e.target) || context.relList.contains(e.target))) return;
          this.util.removeClass(target2, "active");
          context.relList.style.display = "none";
          this.modalForm.removeEventListener("click", this.plugins.anchor._closeRelMenu);
          this.plugins.anchor._closeRelMenu = null;
        }.bind(this, contextAnchor, target);
        this.modalForm.addEventListener("click", this.plugins.anchor._closeRelMenu);
      }
    },
    onClick_relButton: function(contextAnchor, e) {
      this.plugins.anchor.toggleRelList.call(this, contextAnchor, !this.util.hasClass(e.target, "active"));
    },
    onClick_relList: function(contextAnchor, e) {
      const target = e.target;
      const cmd = target.getAttribute("data-command");
      if (!cmd) return;
      const current = contextAnchor.currentRel;
      const checked = this.util.toggleClass(target, "se-checked");
      const index = current.indexOf(cmd);
      if (checked) {
        if (index === -1) current.push(cmd);
      } else {
        if (index > -1) current.splice(index, 1);
      }
      contextAnchor.relPreview.title = contextAnchor.relPreview.textContent = current.join(" ");
    },
    setRel: function(contextAnchor, relAttr) {
      const relListEl = contextAnchor.relList;
      const rels = contextAnchor.currentRel = !relAttr ? [] : relAttr.split(" ");
      if (!relListEl) return;
      const checkedRel = relListEl.querySelectorAll("button");
      for (let i = 0, len = checkedRel.length, cmd; i < len; i++) {
        cmd = checkedRel[i].getAttribute("data-command");
        if (rels.indexOf(cmd) > -1) {
          this.util.addClass(checkedRel[i], "se-checked");
        } else {
          this.util.removeClass(checkedRel[i], "se-checked");
        }
      }
      contextAnchor.relPreview.title = contextAnchor.relPreview.textContent = rels.join(" ");
    },
    createHeaderList: function(contextAnchor, contextList, urlValue) {
      const headers = this.util.getListChildren(this.context.element.wysiwyg, function(current) {
        return /h[1-6]/i.test(current.nodeName);
      });
      if (headers.length === 0) return;
      const valueRegExp = new this._w.RegExp("^" + urlValue.replace(/^#/, ""), "i");
      const list = [];
      let html = "";
      for (let i = 0, len = headers.length, h; i < len; i++) {
        h = headers[i];
        if (!valueRegExp.test(h.textContent)) continue;
        list.push(h);
        html += '<li class="se-select-item" data-index="' + i + '">' + h.textContent + "</li>";
      }
      if (list.length === 0) {
        this.plugins.selectMenu.close.call(this, contextList);
      } else {
        this.plugins.selectMenu.createList(contextList, list, html);
        this.plugins.selectMenu.open.call(this, contextList, this.plugins.anchor._setMenuListPosition.bind(this, contextAnchor));
      }
    },
    _setMenuListPosition: function(contextAnchor, list) {
      list.style.top = contextAnchor.urlInput.offsetHeight + 1 + "px";
    },
    onKeyDownUrlInput: function(contextList, e) {
      const keyCode = e.keyCode;
      switch (keyCode) {
        case 38:
          e.preventDefault();
          e.stopPropagation();
          this.plugins.selectMenu.moveItem.call(this, contextList, -1);
          break;
        case 40:
          e.preventDefault();
          e.stopPropagation();
          this.plugins.selectMenu.moveItem.call(this, contextList, 1);
          break;
        case 13:
          if (contextList.index > -1) {
            e.preventDefault();
            e.stopPropagation();
            this.plugins.anchor.setHeaderBookmark.call(this, this.plugins.selectMenu.getItem(contextList, null));
          }
          break;
      }
    },
    setHeaderBookmark: function(header) {
      const contextAnchor = this.context.anchor.callerContext;
      const id = header.id || "h_" + this._w.Math.random().toString().replace(/.+\./, "");
      header.id = id;
      contextAnchor.urlInput.value = "#" + id;
      if (!contextAnchor.anchorText.value.trim() || !contextAnchor._change) {
        contextAnchor.anchorText.value = header.textContent;
      }
      this.plugins.anchor.setLinkPreview.call(this, contextAnchor, contextAnchor.urlInput.value);
      this.plugins.selectMenu.close.call(this, this.context.selectMenu.callerContext);
      this.context.anchor.callerContext.urlInput.focus();
    },
    onChangeAnchorText: function(contextAnchor, e) {
      contextAnchor._change = !!e.target.value.trim();
    },
    onChangeUrlInput: function(contextAnchor, e) {
      const value = e.target.value.trim();
      this.plugins.anchor.setLinkPreview.call(this, contextAnchor, value);
      if (this.plugins.anchor.selfPathBookmark.call(this, value)) this.plugins.anchor.createHeaderList.call(this, contextAnchor, this.context.selectMenu.callerContext, value);
      else this.plugins.selectMenu.close.call(this, this.context.selectMenu.callerContext);
    },
    onFocusUrlInput: function(contextAnchor, contextLink) {
      const value = contextAnchor.urlInput.value;
      if (this.plugins.anchor.selfPathBookmark.call(this, value)) this.plugins.anchor.createHeaderList.call(this, contextAnchor, contextLink, value);
    },
    onBlurUrlInput: function(contextList) {
      this.plugins.selectMenu.close.call(this, contextList);
    },
    setLinkPreview: function(context, value) {
      const preview = context.preview;
      const protocol = this.options.linkProtocol;
      const noPrefix = this.options.linkNoPrefix;
      const reservedProtocol = /^(mailto\:|tel\:|sms\:|https*\:\/\/|#)/.test(value) || value.indexOf(protocol) === 0;
      const sameProtocol = !protocol ? false : this._w.RegExp("^" + this.util.escapeStringRegexp(value.substr(0, protocol.length))).test(protocol);
      value = context.linkValue = preview.textContent = !value ? "" : noPrefix ? value : protocol && !reservedProtocol && !sameProtocol ? protocol + value : reservedProtocol ? value : /^www\./.test(value) ? "http://" + value : this.context.anchor.host + (/^\//.test(value) ? "" : "/") + value;
      if (this.plugins.anchor.selfPathBookmark.call(this, value)) {
        context.bookmark.style.display = "block";
        this.util.addClass(context.bookmarkButton, "active");
      } else {
        context.bookmark.style.display = "none";
        this.util.removeClass(context.bookmarkButton, "active");
      }
      if (!this.plugins.anchor.selfPathBookmark.call(this, value) && context.downloadCheck.checked) {
        context.download.style.display = "block";
      } else {
        context.download.style.display = "none";
      }
    },
    setCtx: function(anchor, contextAnchor) {
      if (!anchor) return;
      contextAnchor.linkAnchor = anchor;
      contextAnchor.linkValue = anchor.href;
      contextAnchor.currentRel = anchor.rel.split(" ");
    },
    updateAnchor: function(anchor, url, displayText, contextAnchor, notText) {
      if (!this.plugins.anchor.selfPathBookmark.call(this, url) && contextAnchor.downloadCheck.checked) {
        anchor.setAttribute("download", displayText || url);
      } else {
        anchor.removeAttribute("download");
      }
      if (contextAnchor.newWindowCheck.checked) anchor.target = "_blank";
      else anchor.removeAttribute("target");
      const rel = contextAnchor.currentRel.join(" ");
      if (!rel) anchor.removeAttribute("rel");
      else anchor.rel = rel;
      anchor.href = url;
      if (notText) {
        if (anchor.children.length === 0) anchor.textContent = "";
      } else {
        anchor.textContent = displayText;
      }
    },
    createAnchor: function(contextAnchor, notText) {
      if (contextAnchor.linkValue.length === 0) return null;
      const url = contextAnchor.linkValue;
      const anchor = contextAnchor.anchorText;
      const displayText = anchor.value.length === 0 ? url : anchor.value;
      const oA = contextAnchor.linkAnchor || this.util.createElement("A");
      this.plugins.anchor.updateAnchor.call(this, oA, url, displayText, contextAnchor, notText);
      contextAnchor.linkValue = contextAnchor.preview.textContent = contextAnchor.urlInput.value = contextAnchor.anchorText.value = "";
      return oA;
    },
    onClick_bookmarkButton: function(contextAnchor) {
      let url = contextAnchor.urlInput.value;
      if (this.plugins.anchor.selfPathBookmark.call(this, url)) {
        url = url.substr(1);
        contextAnchor.bookmark.style.display = "none";
        this.util.removeClass(contextAnchor.bookmarkButton, "active");
        this.plugins.selectMenu.close.call(this, this.context.selectMenu.callerContext);
      } else {
        url = "#" + url;
        contextAnchor.bookmark.style.display = "block";
        this.util.addClass(contextAnchor.bookmarkButton, "active");
        contextAnchor.downloadCheck.checked = false;
        contextAnchor.download.style.display = "none";
        this.plugins.anchor.createHeaderList.call(this, contextAnchor, this.context.selectMenu.callerContext, url);
      }
      contextAnchor.urlInput.value = url;
      this.plugins.anchor.setLinkPreview.call(this, contextAnchor, url);
      contextAnchor.urlInput.focus();
    },
    onChange_newWindowCheck: function(contextAnchor, e) {
      if (typeof contextAnchor.linkDefaultRel.check_new_window !== "string") return;
      if (e.target.checked) {
        this.plugins.anchor.setRel.call(this, contextAnchor, this.plugins.anchor._relMerge.call(this, contextAnchor, contextAnchor.linkDefaultRel.check_new_window));
      } else {
        this.plugins.anchor.setRel.call(this, contextAnchor, this.plugins.anchor._relDelete.call(this, contextAnchor, contextAnchor.linkDefaultRel.check_new_window));
      }
    },
    onChange_downloadCheck: function(contextAnchor, e) {
      if (e.target.checked) {
        contextAnchor.download.style.display = "block";
        contextAnchor.bookmark.style.display = "none";
        this.util.removeClass(contextAnchor.bookmarkButton, "active");
        contextAnchor.linkValue = contextAnchor.preview.textContent = contextAnchor.urlInput.value = contextAnchor.urlInput.value.replace(/^\#+/, "");
        if (typeof contextAnchor.linkDefaultRel.check_bookmark === "string") {
          this.plugins.anchor.setRel.call(this, contextAnchor, this.plugins.anchor._relMerge.call(this, contextAnchor, contextAnchor.linkDefaultRel.check_bookmark));
        }
      } else {
        contextAnchor.download.style.display = "none";
        if (typeof contextAnchor.linkDefaultRel.check_bookmark === "string") {
          this.plugins.anchor.setRel.call(this, contextAnchor, this.plugins.anchor._relDelete.call(this, contextAnchor, contextAnchor.linkDefaultRel.check_bookmark));
        }
      }
    },
    _relMerge: function(contextAnchor, relAttr) {
      const current = contextAnchor.currentRel;
      if (!relAttr) return current.join(" ");
      if (/^only\:/.test(relAttr)) {
        relAttr = relAttr.replace(/^only\:/, "").trim();
        contextAnchor.currentRel = relAttr.split(" ");
        return relAttr;
      }
      const rels = relAttr.split(" ");
      for (let i = 0, len = rels.length, index; i < len; i++) {
        index = current.indexOf(rels[i]);
        if (index === -1) current.push(rels[i]);
      }
      return current.join(" ");
    },
    _relDelete: function(contextAnchor, relAttr) {
      if (!relAttr) return contextAnchor.currentRel.join(" ");
      if (/^only\:/.test(relAttr)) relAttr = relAttr.replace(/^only\:/, "").trim();
      const rels = contextAnchor.currentRel.join(" ").replace(this._w.RegExp(relAttr + "\\s*"), "");
      contextAnchor.currentRel = rels.split(" ");
      return rels;
    },
    init: function(contextAnchor) {
      contextAnchor.linkAnchor = null;
      contextAnchor.linkValue = contextAnchor.preview.textContent = contextAnchor.urlInput.value = "";
      contextAnchor.anchorText.value = "";
      contextAnchor.newWindowCheck.checked = false;
      contextAnchor.downloadCheck.checked = false;
      contextAnchor._change = false;
      this.plugins.anchor.setRel.call(this, contextAnchor, contextAnchor.defaultRel);
      if (contextAnchor.relList) {
        this.plugins.anchor.toggleRelList.call(this, contextAnchor, false);
      }
      this.context.anchor.callerContext = null;
      this.plugins.selectMenu.init.call(this, this.context.selectMenu.callerContext);
    }
  };

  // ../../node_modules/suneditor/src/plugins/dialog/link.js
  var link_default = {
    name: "link",
    display: "dialog",
    add: function(core) {
      core.addModule([import_dialog.default, anchor_default]);
      const context = core.context;
      const contextLink = context.link = {
        focusElement: null,
        // @Override dialog // This element has focus when the dialog is opened.
        _linkAnchor: null,
        anchorCtx: null
      };
      let link_dialog = this.setDialog(core);
      contextLink.modal = link_dialog;
      let link_controller = this.setController_LinkButton(core);
      contextLink.linkController = link_controller;
      link_dialog.querySelector("form").addEventListener("submit", this.submit.bind(core));
      link_controller.addEventListener("click", this.onClick_linkController.bind(core));
      context.dialog.modal.appendChild(link_dialog);
      context.element.relative.appendChild(link_controller);
      core.plugins.anchor.initEvent.call(core, "link", link_dialog);
      contextLink.focusElement = context.anchor.caller.link.urlInput;
      link_dialog = null, link_controller = null;
    },
    /** dialog */
    setDialog: function(core) {
      const lang = core.lang;
      const dialog6 = core.util.createElement("DIV");
      const icons = core.icons;
      dialog6.className = "se-dialog-content";
      dialog6.style.display = "none";
      let html = '<form><div class="se-dialog-header"><button type="button" data-command="close" class="se-btn se-dialog-close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + icons.cancel + '</button><span class="se-modal-title">' + lang.dialogBox.linkBox.title + "</span></div>" + core.context.anchor.forms.innerHTML + '<div class="se-dialog-footer"><button type="submit" class="se-btn-primary" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '"><span>' + lang.dialogBox.submitButton + "</span></button></div></form>";
      dialog6.innerHTML = html;
      return dialog6;
    },
    /** modify controller button */
    setController_LinkButton: function(core) {
      const lang = core.lang;
      const icons = core.icons;
      const link_btn = core.util.createElement("DIV");
      link_btn.className = "se-controller se-controller-link";
      link_btn.innerHTML = '<div class="se-arrow se-arrow-up"></div><div class="link-content"><span><a target="_blank" href=""></a>&nbsp;</span><div class="se-btn-group"><button type="button" data-command="update" tabindex="-1" class="se-btn se-tooltip">' + icons.edit + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.edit + '</span></span></button><button type="button" data-command="unlink" tabindex="-1" class="se-btn se-tooltip">' + icons.unlink + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.unlink + '</span></span></button><button type="button" data-command="delete" tabindex="-1" class="se-btn se-tooltip">' + icons.delete + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.remove + "</span></span></button></div></div>";
      return link_btn;
    },
    /**
     * @Override dialog
     */
    open: function() {
      this.plugins.dialog.open.call(this, "link", "link" === this.currentControllerName);
    },
    submit: function(e) {
      this.showLoading();
      e.preventDefault();
      e.stopPropagation();
      try {
        const oA = this.plugins.anchor.createAnchor.call(this, this.context.anchor.caller.link, false);
        if (oA === null) return;
        if (!this.context.dialog.updateModal) {
          const selectedFormats = this.getSelectedElements();
          if (selectedFormats.length > 1) {
            const oFormat = this.util.createElement(selectedFormats[0].nodeName);
            oFormat.appendChild(oA);
            if (!this.insertNode(oFormat, null, true)) return;
          } else {
            if (!this.insertNode(oA, null, true)) return;
          }
          this.setRange(oA.childNodes[0], 0, oA.childNodes[0], oA.textContent.length);
        } else {
          const textNode = this.context.link._linkAnchor.childNodes[0];
          this.setRange(textNode, 0, textNode, textNode.textContent.length);
        }
      } finally {
        this.plugins.dialog.close.call(this);
        this.closeLoading();
        this.history.push(false);
      }
      return false;
    },
    /**
     * @Override core
     */
    active: function(element) {
      if (!element) {
        if (this.controllerArray.indexOf(this.context.link.linkController) > -1) {
          this.controllersOff();
        }
      } else if (this.util.isAnchor(element) && element.getAttribute("data-image-link") === null) {
        if (this.controllerArray.indexOf(this.context.link.linkController) < 0) {
          this.plugins.link.call_controller.call(this, element);
        }
        return true;
      }
      return false;
    },
    /**
     * @Override dialog
     */
    on: function(update) {
      this.plugins.anchor.on.call(this, this.context.anchor.caller.link, update);
    },
    call_controller: function(selectionATag) {
      this.editLink = this.context.link._linkAnchor = this.context.anchor.caller.link.linkAnchor = selectionATag;
      const linkBtn = this.context.link.linkController;
      const link = linkBtn.querySelector("a");
      link.href = selectionATag.href;
      link.title = selectionATag.textContent;
      link.textContent = selectionATag.textContent;
      this.util.addClass(selectionATag, "on");
      this.setControllerPosition(linkBtn, selectionATag, "bottom", { left: 0, top: 0 });
      this.controllersOn(linkBtn, selectionATag, "link", this.util.removeClass.bind(this.util, this.context.link._linkAnchor, "on"));
    },
    onClick_linkController: function(e) {
      e.stopPropagation();
      const command = e.target.getAttribute("data-command") || e.target.parentNode.getAttribute("data-command");
      if (!command) return;
      e.preventDefault();
      if (/update/.test(command)) {
        this.plugins.dialog.open.call(this, "link", true);
      } else if (/unlink/.test(command)) {
        const sc = this.util.getChildElement(this.context.link._linkAnchor, function(current) {
          return current.childNodes.length === 0 || current.nodeType === 3;
        }, false);
        const ec = this.util.getChildElement(this.context.link._linkAnchor, function(current) {
          return current.childNodes.length === 0 || current.nodeType === 3;
        }, true);
        this.setRange(sc, 0, ec, ec.textContent.length);
        this.nodeChange(null, null, ["A"], false);
      } else {
        this.util.removeItem(this.context.link._linkAnchor);
        this.context.anchor.caller.link.linkAnchor = null;
        this.focus();
        this.history.push(false);
      }
      this.controllersOff();
    },
    /**
     * @Override dialog
     */
    init: function() {
      this.context.link.linkController.style.display = "none";
      this.plugins.anchor.init.call(this, this.context.anchor.caller.link);
    }
  };

  // ../../node_modules/suneditor/src/plugins/dialog/image.js
  var import_dialog2 = __toESM(require_dialog());
  var import_component = __toESM(require_component2());
  var import_resizing = __toESM(require_resizing());
  var import_fileManager = __toESM(require_fileManager());
  var image_default = {
    name: "image",
    display: "dialog",
    add: function(core) {
      core.addModule([import_dialog2.default, anchor_default, import_component.default, import_resizing.default, import_fileManager.default]);
      const options = core.options;
      const context = core.context;
      const contextImage = context.image = {
        _infoList: [],
        // @Override fileManager
        _infoIndex: 0,
        // @Override fileManager
        _uploadFileLength: 0,
        // @Override fileManager
        focusElement: null,
        // @Override dialog // This element has focus when the dialog is opened.
        sizeUnit: options._imageSizeUnit,
        _linkElement: "",
        _altText: "",
        _align: "none",
        _floatClassRegExp: "__se__float\\-[a-z]+",
        _v_src: { _linkValue: "" },
        svgDefaultSize: "30%",
        base64RenderIndex: 0,
        // @require @Override component
        _element: null,
        _cover: null,
        _container: null,
        // @Override resizing properties
        inputX: null,
        inputY: null,
        _element_w: 1,
        _element_h: 1,
        _element_l: 0,
        _element_t: 0,
        _defaultSizeX: "auto",
        _defaultSizeY: "auto",
        _origin_w: options.imageWidth === "auto" ? "" : options.imageWidth,
        _origin_h: options.imageHeight === "auto" ? "" : options.imageHeight,
        _proportionChecked: true,
        _resizing: options.imageResizing,
        _resizeDotHide: !options.imageHeightShow,
        _rotation: options.imageRotation,
        _alignHide: !options.imageAlignShow,
        _onlyPercentage: options.imageSizeOnlyPercentage,
        _ratio: false,
        _ratioX: 1,
        _ratioY: 1,
        _captionShow: true,
        _captionChecked: false,
        _caption: null,
        captionCheckEl: null
      };
      let image_dialog = this.setDialog(core);
      contextImage.modal = image_dialog;
      contextImage.imgInputFile = image_dialog.querySelector("._se_image_file");
      contextImage.imgUrlFile = image_dialog.querySelector("._se_image_url");
      contextImage.focusElement = contextImage.imgInputFile || contextImage.imgUrlFile;
      contextImage.altText = image_dialog.querySelector("._se_image_alt");
      contextImage.captionCheckEl = image_dialog.querySelector("._se_image_check_caption");
      contextImage.previewSrc = image_dialog.querySelector("._se_tab_content_image .se-link-preview");
      image_dialog.querySelector(".se-dialog-tabs").addEventListener("click", this.openTab.bind(core));
      image_dialog.querySelector("form").addEventListener("submit", this.submit.bind(core));
      if (contextImage.imgInputFile) image_dialog.querySelector(".se-file-remove").addEventListener("click", this._removeSelectedFiles.bind(contextImage.imgInputFile, contextImage.imgUrlFile, contextImage.previewSrc));
      if (contextImage.imgUrlFile) contextImage.imgUrlFile.addEventListener("input", this._onLinkPreview.bind(contextImage.previewSrc, contextImage._v_src, options.linkProtocol));
      if (contextImage.imgInputFile && contextImage.imgUrlFile) contextImage.imgInputFile.addEventListener("change", this._fileInputChange.bind(contextImage));
      const imageGalleryButton = image_dialog.querySelector(".__se__gallery");
      if (imageGalleryButton) imageGalleryButton.addEventListener("click", this._openGallery.bind(core));
      contextImage.proportion = {};
      contextImage.inputX = {};
      contextImage.inputY = {};
      if (options.imageResizing) {
        contextImage.proportion = image_dialog.querySelector("._se_image_check_proportion");
        contextImage.inputX = image_dialog.querySelector("._se_image_size_x");
        contextImage.inputY = image_dialog.querySelector("._se_image_size_y");
        contextImage.inputX.value = options.imageWidth;
        contextImage.inputY.value = options.imageHeight;
        contextImage.inputX.addEventListener("keyup", this.setInputSize.bind(core, "x"));
        contextImage.inputY.addEventListener("keyup", this.setInputSize.bind(core, "y"));
        contextImage.inputX.addEventListener("change", this.setRatio.bind(core));
        contextImage.inputY.addEventListener("change", this.setRatio.bind(core));
        contextImage.proportion.addEventListener("change", this.setRatio.bind(core));
        image_dialog.querySelector(".se-dialog-btn-revert").addEventListener("click", this.sizeRevert.bind(core));
      }
      context.dialog.modal.appendChild(image_dialog);
      core.plugins.anchor.initEvent.call(core, "image", image_dialog.querySelector("._se_tab_content_url"));
      contextImage.anchorCtx = core.context.anchor.caller.image;
      image_dialog = null;
    },
    /** dialog */
    setDialog: function(core) {
      const option = core.options;
      const lang = core.lang;
      const dialog6 = core.util.createElement("DIV");
      dialog6.className = "se-dialog-content se-dialog-image";
      dialog6.style.display = "none";
      let html = '<div class="se-dialog-header"><button type="button" data-command="close" class="se-btn se-dialog-close" class="close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + core.icons.cancel + '</button><span class="se-modal-title">' + lang.dialogBox.imageBox.title + '</span></div><div class="se-dialog-tabs"><button type="button" class="_se_tab_link active" data-tab-link="image">' + lang.toolbar.image + '</button><button type="button" class="_se_tab_link" data-tab-link="url">' + lang.toolbar.link + '</button></div><form method="post" enctype="multipart/form-data"><div class="_se_tab_content _se_tab_content_image"><div class="se-dialog-body"><div style="border-bottom: 1px dashed #ccc;">';
      if (option.imageFileInput) {
        html += '<div class="se-dialog-form"><label>' + lang.dialogBox.imageBox.file + '</label><div class="se-dialog-form-files"><input class="se-input-form _se_image_file" type="file" accept="' + option.imageAccept + '"' + (option.imageMultipleFile ? ' multiple="multiple"' : "") + '/><button type="button" class="se-btn se-dialog-files-edge-button se-file-remove" title="' + lang.controller.remove + '" aria-label="' + lang.controller.remove + '">' + core.icons.cancel + "</button></div></div>";
      }
      if (option.imageUrlInput) {
        html += '<div class="se-dialog-form"><label>' + lang.dialogBox.imageBox.url + '</label><div class="se-dialog-form-files"><input class="se-input-form se-input-url _se_image_url" type="text" />' + (option.imageGalleryUrl && core.plugins.imageGallery ? '<button type="button" class="se-btn se-dialog-files-edge-button __se__gallery" title="' + lang.toolbar.imageGallery + '" aria-label="' + lang.toolbar.imageGallery + '">' + core.icons.image_gallery + "</button>" : "") + '</div><pre class="se-link-preview"></pre></div>';
      }
      html += '</div><div class="se-dialog-form"><label>' + lang.dialogBox.imageBox.altText + '</label><input class="se-input-form _se_image_alt" type="text" /></div>';
      if (option.imageResizing) {
        const onlyPercentage = option.imageSizeOnlyPercentage;
        const onlyPercentDisplay = onlyPercentage ? ' style="display: none !important;"' : "";
        const heightDisplay = !option.imageHeightShow ? ' style="display: none !important;"' : "";
        html += '<div class="se-dialog-form">';
        if (onlyPercentage || !option.imageHeightShow) {
          html += '<div class="se-dialog-size-text"><label class="size-w">' + lang.dialogBox.size + "</label></div>";
        } else {
          html += '<div class="se-dialog-size-text"><label class="size-w">' + lang.dialogBox.width + '</label><label class="se-dialog-size-x">&nbsp;</label><label class="size-h">' + lang.dialogBox.height + "</label></div>";
        }
        html += '<input class="se-input-control _se_image_size_x" placeholder="auto"' + (onlyPercentage ? ' type="number" min="1"' : 'type="text"') + (onlyPercentage ? ' max="100"' : "") + ' /><label class="se-dialog-size-x"' + heightDisplay + ">" + (onlyPercentage ? "%" : "x") + '</label><input type="text" class="se-input-control _se_image_size_y" placeholder="auto"' + onlyPercentDisplay + (onlyPercentage ? ' max="100"' : "") + heightDisplay + "/><label" + onlyPercentDisplay + heightDisplay + '><input type="checkbox" class="se-dialog-btn-check _se_image_check_proportion" checked/>&nbsp;' + lang.dialogBox.proportion + '</label><button type="button" title="' + lang.dialogBox.revertButton + '" aria-label="' + lang.dialogBox.revertButton + '" class="se-btn se-dialog-btn-revert" style="float: right;">' + core.icons.revert + "</button></div>";
      }
      html += '<div class="se-dialog-form se-dialog-form-footer"><label><input type="checkbox" class="se-dialog-btn-check _se_image_check_caption" />&nbsp;' + lang.dialogBox.caption + '</label></div></div></div><div class="_se_tab_content _se_tab_content_url" style="display: none">' + core.context.anchor.forms.innerHTML + '</div><div class="se-dialog-footer"><div' + (option.imageAlignShow ? "" : ' style="display: none"') + '><label><input type="radio" name="suneditor_image_radio" class="se-dialog-btn-radio" value="none" checked>' + lang.dialogBox.basic + '</label><label><input type="radio" name="suneditor_image_radio" class="se-dialog-btn-radio" value="left">' + lang.dialogBox.left + '</label><label><input type="radio" name="suneditor_image_radio" class="se-dialog-btn-radio" value="center">' + lang.dialogBox.center + '</label><label><input type="radio" name="suneditor_image_radio" class="se-dialog-btn-radio" value="right">' + lang.dialogBox.right + '</label></div><button type="submit" class="se-btn-primary" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '"><span>' + lang.dialogBox.submitButton + "</span></button></div></form>";
      dialog6.innerHTML = html;
      return dialog6;
    },
    _fileInputChange: function() {
      if (!this.imgInputFile.value) {
        this.imgUrlFile.removeAttribute("disabled");
        this.previewSrc.style.textDecoration = "";
      } else {
        this.imgUrlFile.setAttribute("disabled", true);
        this.previewSrc.style.textDecoration = "line-through";
      }
    },
    _removeSelectedFiles: function(urlInput, previewSrc) {
      this.value = "";
      if (urlInput) {
        urlInput.removeAttribute("disabled");
        previewSrc.style.textDecoration = "";
      }
    },
    _openGallery: function() {
      this.callPlugin("imageGallery", this.plugins.imageGallery.open.bind(this, this.plugins.image._setUrlInput.bind(this.context.image)), null);
    },
    _setUrlInput: function(target) {
      this.altText.value = target.alt;
      this._v_src._linkValue = this.previewSrc.textContent = this.imgUrlFile.value = target.getAttribute("data-value") || target.src;
      this.imgUrlFile.focus();
    },
    _onLinkPreview: function(context, protocol, e) {
      const value = e.target.value.trim();
      context._linkValue = this.textContent = !value ? "" : protocol && value.indexOf("://") === -1 && value.indexOf("#") !== 0 ? protocol + value : value.indexOf("://") === -1 ? "/" + value : value;
    },
    /**
     * @Override @Required fileManager
     */
    fileTags: ["img"],
    /**
     * @Override core, fileManager, resizing
     * @description It is called from core.selectComponent.
     * @param {Element} element Target element
     */
    select: function(element) {
      this.plugins.image.onModifyMode.call(this, element, this.plugins.resizing.call_controller_resize.call(this, element, "image"));
    },
    /**
     * @Override fileManager, resizing
     */
    destroy: function(element) {
      const imageEl = element || this.context.image._element;
      const imageContainer = this.util.getParentElement(imageEl, this.util.isMediaComponent) || imageEl;
      const dataIndex = imageEl.getAttribute("data-index") * 1;
      if (typeof this.functions.onImageDeleteBefore === "function" && this.functions.onImageDeleteBefore(imageEl, imageContainer, dataIndex, this) === false) return;
      let focusEl = imageContainer.previousElementSibling || imageContainer.nextElementSibling;
      const emptyDiv = imageContainer.parentNode;
      this.util.removeItem(imageContainer);
      this.plugins.image.init.call(this);
      this.controllersOff();
      if (emptyDiv !== this.context.element.wysiwyg) this.util.removeItemAllParents(emptyDiv, function(current) {
        return current.childNodes.length === 0;
      }, null);
      this.focusEdge(focusEl);
      this.plugins.fileManager.deleteInfo.call(this, "image", dataIndex, this.functions.onImageUpload);
      this.history.push(false);
    },
    /**
     * @Required @Override dialog
     */
    on: function(update) {
      const contextImage = this.context.image;
      if (!update) {
        contextImage.inputX.value = contextImage._origin_w = this.options.imageWidth === contextImage._defaultSizeX ? "" : this.options.imageWidth;
        contextImage.inputY.value = contextImage._origin_h = this.options.imageHeight === contextImage._defaultSizeY ? "" : this.options.imageHeight;
        if (contextImage.imgInputFile && this.options.imageMultipleFile) contextImage.imgInputFile.setAttribute("multiple", "multiple");
      } else {
        if (contextImage.imgInputFile && this.options.imageMultipleFile) contextImage.imgInputFile.removeAttribute("multiple");
      }
      this.plugins.anchor.on.call(this, contextImage.anchorCtx, update);
    },
    /**
     * @Required @Override dialog
     */
    open: function() {
      this.plugins.dialog.open.call(this, "image", "image" === this.currentControllerName);
    },
    openTab: function(e) {
      const modal = this.context.image.modal;
      const targetElement = e === "init" ? modal.querySelector("._se_tab_link") : e.target;
      if (!/^BUTTON$/i.test(targetElement.tagName)) {
        return false;
      }
      const tabName = targetElement.getAttribute("data-tab-link");
      const contentClassName = "_se_tab_content";
      let i, tabContent, tabLinks;
      tabContent = modal.getElementsByClassName(contentClassName);
      for (i = 0; i < tabContent.length; i++) {
        tabContent[i].style.display = "none";
      }
      tabLinks = modal.getElementsByClassName("_se_tab_link");
      for (i = 0; i < tabLinks.length; i++) {
        this.util.removeClass(tabLinks[i], "active");
      }
      modal.querySelector("." + contentClassName + "_" + tabName).style.display = "block";
      this.util.addClass(targetElement, "active");
      if (tabName === "image" && this.context.image.focusElement) {
        this.context.image.focusElement.focus();
      } else if (tabName === "url") {
        this.context.anchor.caller.image.urlInput.focus();
      }
      return false;
    },
    submit: function(e) {
      const contextImage = this.context.image;
      const imagePlugin = this.plugins.image;
      e.preventDefault();
      e.stopPropagation();
      contextImage._altText = contextImage.altText.value;
      contextImage._align = contextImage.modal.querySelector('input[name="suneditor_image_radio"]:checked').value;
      contextImage._captionChecked = contextImage.captionCheckEl.checked;
      if (contextImage._resizing) contextImage._proportionChecked = contextImage.proportion.checked;
      try {
        if (this.context.dialog.updateModal) {
          imagePlugin.update_image.call(this, false, true, false);
        }
        if (contextImage.imgInputFile && contextImage.imgInputFile.files.length > 0) {
          this.showLoading();
          imagePlugin.submitAction.call(this, this.context.image.imgInputFile.files);
        } else if (contextImage.imgUrlFile && contextImage._v_src._linkValue.length > 0) {
          this.showLoading();
          imagePlugin.onRender_imgUrl.call(this, contextImage._v_src._linkValue);
        }
      } catch (error) {
        this.closeLoading();
        throw Error('[SUNEDITOR.image.submit.fail] cause : "' + error.message + '"');
      } finally {
        this.plugins.dialog.close.call(this);
      }
      return false;
    },
    submitAction: function(fileList) {
      if (fileList.length === 0) return;
      let fileSize = 0;
      let files = [];
      for (let i = 0, len = fileList.length; i < len; i++) {
        if (/image/i.test(fileList[i].type)) {
          files.push(fileList[i]);
          fileSize += fileList[i].size;
        }
      }
      const limitSize = this.options.imageUploadSizeLimit;
      if (limitSize > 0) {
        let infoSize = 0;
        const imagesInfo = this.context.image._infoList;
        for (let i = 0, len = imagesInfo.length; i < len; i++) {
          infoSize += imagesInfo[i].size * 1;
        }
        if (fileSize + infoSize > limitSize) {
          this.closeLoading();
          const err = "[SUNEDITOR.imageUpload.fail] Size of uploadable total images: " + limitSize / 1e3 + "KB";
          if (typeof this.functions.onImageUploadError !== "function" || this.functions.onImageUploadError(err, { "limitSize": limitSize, "currentSize": infoSize, "uploadSize": fileSize }, this)) {
            this.functions.noticeOpen(err);
          }
          return;
        }
      }
      const contextImage = this.context.image;
      contextImage._uploadFileLength = files.length;
      const anchor = this.plugins.anchor.createAnchor.call(this, contextImage.anchorCtx, true);
      const info = {
        anchor,
        inputWidth: contextImage.inputX.value,
        inputHeight: contextImage.inputY.value,
        align: contextImage._align,
        isUpdate: this.context.dialog.updateModal,
        alt: contextImage._altText,
        element: contextImage._element
      };
      if (typeof this.functions.onImageUploadBefore === "function") {
        const result = this.functions.onImageUploadBefore(files, info, this, function(data2) {
          if (data2 && this._w.Array.isArray(data2.result)) {
            this.plugins.image.register.call(this, info, data2);
          } else {
            this.plugins.image.upload.call(this, info, data2);
          }
        }.bind(this));
        if (typeof result === "undefined") return;
        if (!result) {
          this.closeLoading();
          return;
        }
        if (this._w.Array.isArray(result) && result.length > 0) files = result;
      }
      this.plugins.image.upload.call(this, info, files);
    },
    error: function(message, response) {
      this.closeLoading();
      if (typeof this.functions.onImageUploadError !== "function" || this.functions.onImageUploadError(message, response, this)) {
        this.functions.noticeOpen(message);
        throw Error("[SUNEDITOR.plugin.image.error] response: " + message);
      }
    },
    upload: function(info, files) {
      if (!files) {
        this.closeLoading();
        return;
      }
      if (typeof files === "string") {
        this.plugins.image.error.call(this, files, null);
        return;
      }
      const imageUploadUrl = this.options.imageUploadUrl;
      const filesLen = this.context.dialog.updateModal ? 1 : files.length;
      if (typeof imageUploadUrl === "string" && imageUploadUrl.length > 0) {
        const formData = new FormData();
        for (let i = 0; i < filesLen; i++) {
          formData.append("file-" + i, files[i]);
        }
        this.plugins.fileManager.upload.call(this, imageUploadUrl, this.options.imageUploadHeader, formData, this.plugins.image.callBack_imgUpload.bind(this, info), this.functions.onImageUploadError);
      } else {
        this.plugins.image.setup_reader.call(this, files, info.anchor, info.inputWidth, info.inputHeight, info.align, info.alt, filesLen, info.isUpdate);
      }
    },
    callBack_imgUpload: function(info, xmlHttp) {
      if (typeof this.functions.imageUploadHandler === "function") {
        this.functions.imageUploadHandler(xmlHttp, info, this);
      } else {
        const response = JSON.parse(xmlHttp.responseText);
        if (response.errorMessage) {
          this.plugins.image.error.call(this, response.errorMessage, response);
        } else {
          this.plugins.image.register.call(this, info, response);
        }
      }
    },
    register: function(info, response) {
      const fileList = response.result;
      for (let i = 0, len = fileList.length, file; i < len; i++) {
        file = { name: fileList[i].name, size: fileList[i].size };
        if (info.isUpdate) {
          this.plugins.image.update_src.call(this, fileList[i].url, info.element, file);
          break;
        } else {
          this.plugins.image.create_image.call(this, fileList[i].url, info.anchor, info.inputWidth, info.inputHeight, info.align, file, info.alt);
        }
      }
      this.closeLoading();
    },
    setup_reader: function(files, anchor, width, height, align, alt, filesLen, isUpdate) {
      try {
        if (filesLen === 0) {
          this.closeLoading();
          console.warn("[SUNEDITOR.image.base64.fail] cause : No applicable files");
          return;
        }
        this.context.image.base64RenderIndex = filesLen;
        const wFileReader = this._w.FileReader;
        const filesStack = [filesLen];
        this.context.image.inputX.value = width;
        this.context.image.inputY.value = height;
        for (let i = 0, reader, file; i < filesLen; i++) {
          reader = new wFileReader();
          file = files[i];
          reader.onload = function(reader2, update, updateElement, file2, index) {
            filesStack[index] = { result: reader2.result, file: file2 };
            if (--this.context.image.base64RenderIndex === 0) {
              this.plugins.image.onRender_imgBase64.call(this, update, filesStack, updateElement, anchor, width, height, align, alt);
              this.closeLoading();
            }
          }.bind(this, reader, isUpdate, this.context.image._element, file, i);
          reader.readAsDataURL(file);
        }
      } catch (e) {
        this.closeLoading();
        throw Error('[SUNEDITOR.image.setup_reader.fail] cause : "' + e.message + '"');
      }
    },
    onRender_imgBase64: function(update, filesStack, updateElement, anchor, width, height, align, alt) {
      const updateMethod = this.plugins.image.update_src;
      const createMethod = this.plugins.image.create_image;
      for (let i = 0, len = filesStack.length; i < len; i++) {
        if (update) {
          this.context.image._element.setAttribute("data-file-name", filesStack[i].file.name);
          this.context.image._element.setAttribute("data-file-size", filesStack[i].file.size);
          updateMethod.call(this, filesStack[i].result, updateElement, filesStack[i].file);
        } else {
          createMethod.call(this, filesStack[i].result, anchor, width, height, align, filesStack[i].file, alt);
        }
      }
    },
    onRender_imgUrl: function(url) {
      if (!url) url = this.context.image._v_src._linkValue;
      if (!url) return false;
      const contextImage = this.context.image;
      try {
        const file = { name: url.split("/").pop(), size: 0 };
        if (this.context.dialog.updateModal) this.plugins.image.update_src.call(this, url, contextImage._element, file);
        else this.plugins.image.create_image.call(this, url, this.plugins.anchor.createAnchor.call(this, contextImage.anchorCtx, true), contextImage.inputX.value, contextImage.inputY.value, contextImage._align, file, contextImage._altText);
      } catch (e) {
        throw Error('[SUNEDITOR.image.URLRendering.fail] cause : "' + e.message + '"');
      } finally {
        this.closeLoading();
      }
    },
    onRender_link: function(imgTag, anchor) {
      if (anchor) {
        anchor.setAttribute("data-image-link", "image");
        imgTag.setAttribute("data-image-link", anchor.href);
        anchor.appendChild(imgTag);
        return anchor;
      }
      return imgTag;
    },
    /**
     * @Override resizing
     * @param {String} xy 'x': width, 'y': height
     * @param {KeyboardEvent} e Event object
     */
    setInputSize: function(xy, e) {
      if (e && e.keyCode === 32) {
        e.preventDefault();
        return;
      }
      this.plugins.resizing._module_setInputSize.call(this, this.context.image, xy);
    },
    /**
     * @Override resizing
     */
    setRatio: function() {
      this.plugins.resizing._module_setRatio.call(this, this.context.image);
    },
    /**
     * @Override fileManager
     */
    checkFileInfo: function() {
      const imagePlugin = this.plugins.image;
      const contextImage = this.context.image;
      const modifyHandler = function(tag) {
        imagePlugin.onModifyMode.call(this, tag, null);
        imagePlugin.openModify.call(this, true);
        contextImage.inputX.value = contextImage._origin_w;
        contextImage.inputY.value = contextImage._origin_h;
        const format = this.util.getFormatElement(tag);
        if (format) contextImage._align = format.style.textAlign || format.style.float;
        if (this.util.isAnchor(tag.parentNode) && !contextImage.anchorCtx.linkValue) contextImage.anchorCtx.linkValue = " ";
        imagePlugin.update_image.call(this, true, false, true);
        imagePlugin.init.call(this);
      }.bind(this);
      this.plugins.fileManager.checkInfo.call(this, "image", ["img"], this.functions.onImageUpload, modifyHandler, true);
    },
    /**
     * @Override fileManager
     */
    resetFileInfo: function() {
      this.plugins.fileManager.resetInfo.call(this, "image", this.functions.onImageUpload);
    },
    create_image: function(src, anchor, width, height, align, file, alt) {
      const imagePlugin = this.plugins.image;
      const contextImage = this.context.image;
      this.context.resizing._resize_plugin = "image";
      let oImg = this.util.createElement("IMG");
      oImg.src = src;
      oImg.alt = alt;
      oImg.setAttribute("data-rotate", "0");
      anchor = imagePlugin.onRender_link.call(this, oImg, anchor ? anchor.cloneNode(false) : null);
      if (contextImage._resizing) {
        oImg.setAttribute("data-proportion", contextImage._proportionChecked);
      }
      const cover = this.plugins.component.set_cover.call(this, anchor);
      const container = this.plugins.component.set_container.call(this, cover, "se-image-container");
      if (contextImage._captionChecked) {
        contextImage._caption = this.plugins.component.create_caption.call(this);
        cover.appendChild(contextImage._caption);
      }
      contextImage._element = oImg;
      contextImage._cover = cover;
      contextImage._container = container;
      imagePlugin.applySize.call(this, width, height);
      imagePlugin.setAlign.call(this, align, oImg, cover, container);
      oImg.onload = imagePlugin._image_create_onload.bind(this, oImg, contextImage.svgDefaultSize, container);
      if (this.insertComponent(container, true, true, true)) this.plugins.fileManager.setInfo.call(this, "image", oImg, this.functions.onImageUpload, file, true);
      this.context.resizing._resize_plugin = "";
    },
    _image_create_onload: function(oImg, svgDefaultSize, container) {
      if (oImg.offsetWidth === 0) this.plugins.image.applySize.call(this, svgDefaultSize, "");
      if (this.options.mediaAutoSelect) {
        this.selectComponent(oImg, "image");
      } else {
        const line = this.appendFormatTag(container, null);
        if (line) this.setRange(line, 0, line, 0);
      }
    },
    update_image: function(init, openController, notHistoryPush) {
      const contextImage = this.context.image;
      let imageEl = contextImage._element;
      let cover = contextImage._cover;
      let container = contextImage._container;
      let isNewContainer = false;
      if (cover === null) {
        isNewContainer = true;
        imageEl = contextImage._element.cloneNode(true);
        cover = this.plugins.component.set_cover.call(this, imageEl);
      }
      if (container === null) {
        cover = cover.cloneNode(true);
        imageEl = cover.querySelector("img");
        isNewContainer = true;
        container = this.plugins.component.set_container.call(this, cover, "se-image-container");
      } else if (isNewContainer) {
        container.innerHTML = "";
        container.appendChild(cover);
        contextImage._cover = cover;
        contextImage._element = imageEl;
        isNewContainer = false;
      }
      let changeSize;
      const x = this.util.isNumber(contextImage.inputX.value) ? contextImage.inputX.value + contextImage.sizeUnit : contextImage.inputX.value;
      const y = this.util.isNumber(contextImage.inputY.value) ? contextImage.inputY.value + contextImage.sizeUnit : contextImage.inputY.value;
      if (/%$/.test(imageEl.style.width)) {
        changeSize = x !== container.style.width || y !== container.style.height;
      } else {
        changeSize = x !== imageEl.style.width || y !== imageEl.style.height;
      }
      imageEl.alt = contextImage._altText;
      let modifiedCaption = false;
      if (contextImage._captionChecked) {
        if (!contextImage._caption) {
          contextImage._caption = this.plugins.component.create_caption.call(this);
          cover.appendChild(contextImage._caption);
          modifiedCaption = true;
        }
      } else {
        if (contextImage._caption) {
          this.util.removeItem(contextImage._caption);
          contextImage._caption = null;
          modifiedCaption = true;
        }
      }
      let isNewAnchor = null;
      const anchor = this.plugins.anchor.createAnchor.call(this, contextImage.anchorCtx, true);
      if (anchor) {
        if (contextImage._linkElement !== anchor || isNewContainer && !container.contains(anchor)) {
          contextImage._linkElement = anchor.cloneNode(false);
          cover.insertBefore(this.plugins.image.onRender_link.call(this, imageEl, contextImage._linkElement), contextImage._caption);
          isNewAnchor = contextImage._element;
        } else {
          contextImage._linkElement.setAttribute("data-image-link", "image");
        }
      } else if (contextImage._linkElement !== null) {
        const imageElement = imageEl;
        imageElement.setAttribute("data-image-link", "");
        if (cover.contains(contextImage._linkElement)) {
          const newEl = imageElement.cloneNode(true);
          cover.removeChild(contextImage._linkElement);
          cover.insertBefore(newEl, contextImage._caption);
          contextImage._element = imageEl = newEl;
        }
      }
      let existElement = null;
      if (isNewContainer) {
        existElement = this.util.isRangeFormatElement(contextImage._element.parentNode) || this.util.isWysiwygDiv(contextImage._element.parentNode) ? contextImage._element : this.util.isAnchor(contextImage._element.parentNode) ? contextImage._element.parentNode : this.util.getFormatElement(contextImage._element) || contextImage._element;
        if (this.util.getParentElement(contextImage._element, this.util.isNotCheckingNode)) {
          existElement = isNewAnchor ? anchor : contextImage._element;
          existElement.parentNode.replaceChild(container, existElement);
        } else if (this.util.isListCell(existElement)) {
          const refer = this.util.getParentElement(contextImage._element, function(current) {
            return current.parentNode === existElement;
          });
          existElement.insertBefore(container, refer);
          this.util.removeItem(contextImage._element);
          this.util.removeEmptyNode(refer, null, true);
        } else if (this.util.isFormatElement(existElement)) {
          const refer = this.util.getParentElement(contextImage._element, function(current) {
            return current.parentNode === existElement;
          });
          existElement = this.util.splitElement(existElement, refer);
          existElement.parentNode.insertBefore(container, existElement);
          this.util.removeItem(contextImage._element);
          this.util.removeEmptyNode(existElement, null, true);
          if (existElement.children.length === 0) existElement.innerHTML = this.util.htmlRemoveWhiteSpace(existElement.innerHTML);
        } else {
          if (this.util.isFormatElement(existElement.parentNode)) {
            const formats = existElement.parentNode;
            formats.parentNode.insertBefore(container, existElement.previousSibling ? formats.nextElementSibling : formats);
            if (contextImage.__updateTags.map(function(current) {
              return existElement.contains(current);
            }).length === 0) this.util.removeItem(existElement);
          } else {
            existElement = this.util.isFigures(existElement.parentNode) ? existElement.parentNode : existElement;
            existElement.parentNode.replaceChild(container, existElement);
          }
        }
        imageEl = container.querySelector("img");
        contextImage._element = imageEl;
        contextImage._cover = cover;
        contextImage._container = container;
      }
      if (isNewAnchor) {
        if (!isNewContainer) {
          this.util.removeItem(anchor);
        } else {
          this.util.removeItem(isNewAnchor);
          if (this.util.getListChildren(anchor, function(current) {
            return /IMG/i.test(current.tagName);
          }).length === 0) {
            this.util.removeItem(anchor);
          }
        }
      }
      if (modifiedCaption || !contextImage._onlyPercentage && changeSize) {
        if (!init && (/\d+/.test(imageEl.style.height) || this.context.resizing._rotateVertical && contextImage._captionChecked)) {
          if (/%$/.test(contextImage.inputX.value) || /%$/.test(contextImage.inputY.value)) {
            this.plugins.resizing.resetTransform.call(this, imageEl);
          } else {
            this.plugins.resizing.setTransformSize.call(this, imageEl, this.util.getNumber(contextImage.inputX.value, 0), this.util.getNumber(contextImage.inputY.value, 0));
          }
        }
      }
      if (contextImage._resizing) {
        imageEl.setAttribute("data-proportion", contextImage._proportionChecked);
        if (changeSize) {
          this.plugins.image.applySize.call(this);
        }
      }
      this.plugins.image.setAlign.call(this, null, imageEl, null, null);
      if (init) {
        this.plugins.fileManager.setInfo.call(this, "image", imageEl, this.functions.onImageUpload, null, true);
      }
      if (openController) {
        this.selectComponent(imageEl, "image");
      }
      if (!notHistoryPush) this.history.push(false);
    },
    update_src: function(src, element, file) {
      element.src = src;
      this._w.setTimeout(this.plugins.fileManager.setInfo.bind(this, "image", element, this.functions.onImageUpload, file, true));
      this.selectComponent(element, "image");
    },
    /**
     * @Required @Override fileManager, resizing
     */
    onModifyMode: function(element, size) {
      if (!element) return;
      const contextImage = this.context.image;
      contextImage._linkElement = contextImage.anchorCtx.linkAnchor = this.util.isAnchor(element.parentNode) ? element.parentNode : null;
      contextImage._element = element;
      contextImage._cover = this.util.getParentElement(element, "FIGURE");
      contextImage._container = this.util.getParentElement(element, this.util.isMediaComponent);
      contextImage._caption = this.util.getChildElement(contextImage._cover, "FIGCAPTION");
      contextImage._align = element.getAttribute("data-align") || element.style.float || "none";
      element.style.float = "";
      this.plugins.anchor.setCtx(contextImage._linkElement, contextImage.anchorCtx);
      if (size) {
        contextImage._element_w = size.w;
        contextImage._element_h = size.h;
        contextImage._element_t = size.t;
        contextImage._element_l = size.l;
      }
      let userSize = contextImage._element.getAttribute("data-size") || contextImage._element.getAttribute("data-origin");
      let w, h;
      if (userSize) {
        userSize = userSize.split(",");
        w = userSize[0];
        h = userSize[1];
      } else if (size) {
        w = size.w;
        h = size.h;
      }
      contextImage._origin_w = w || element.style.width || element.width || "";
      contextImage._origin_h = h || element.style.height || element.height || "";
    },
    /**
     * @Required @Override fileManager, resizing
     */
    openModify: function(notOpen) {
      const contextImage = this.context.image;
      if (contextImage.imgUrlFile) {
        contextImage._v_src._linkValue = contextImage.previewSrc.textContent = contextImage.imgUrlFile.value = contextImage._element.src;
      }
      contextImage._altText = contextImage.altText.value = contextImage._element.alt;
      (contextImage.modal.querySelector('input[name="suneditor_image_radio"][value="' + contextImage._align + '"]') || contextImage.modal.querySelector('input[name="suneditor_image_radio"][value="none"]')).checked = true;
      contextImage._align = contextImage.modal.querySelector('input[name="suneditor_image_radio"]:checked').value;
      contextImage._captionChecked = contextImage.captionCheckEl.checked = !!contextImage._caption;
      if (contextImage._resizing) {
        this.plugins.resizing._module_setModifyInputSize.call(this, contextImage, this.plugins.image);
      }
      if (!notOpen) this.plugins.dialog.open.call(this, "image", true);
    },
    /**
     * @Override fileManager
     */
    applySize: function(w, h) {
      const contextImage = this.context.image;
      if (!w) w = contextImage.inputX.value || this.options.imageWidth;
      if (!h) h = contextImage.inputY.value || this.options.imageHeight;
      if (contextImage._onlyPercentage && !!w || /%$/.test(w)) {
        this.plugins.image.setPercentSize.call(this, w, h);
        return true;
      } else if ((!w || w === "auto") && (!h || h === "auto")) {
        this.plugins.image.setAutoSize.call(this);
      } else {
        this.plugins.image.setSize.call(this, w, h, false);
      }
      return false;
    },
    /**
     * @Override resizing
     */
    sizeRevert: function() {
      this.plugins.resizing._module_sizeRevert.call(this, this.context.image);
    },
    /**
     * @Override resizing
     */
    setSize: function(w, h, notResetPercentage, direction) {
      const contextImage = this.context.image;
      const onlyW = /^(rw|lw)$/.test(direction) && /\d+/.test(contextImage._element.style.height);
      const onlyH = /^(th|bh)$/.test(direction) && /\d+/.test(contextImage._element.style.width);
      if (!onlyH) {
        contextImage._element.style.width = this.util.isNumber(w) ? w + contextImage.sizeUnit : w;
        this.plugins.image.cancelPercentAttr.call(this);
      }
      if (!onlyW) {
        contextImage._element.style.height = this.util.isNumber(h) ? h + contextImage.sizeUnit : /%$/.test(h) ? "" : h;
      }
      if (contextImage._align === "center") this.plugins.image.setAlign.call(this, null, null, null, null);
      if (!notResetPercentage) contextImage._element.removeAttribute("data-percentage");
      this.plugins.resizing._module_saveCurrentSize.call(this, contextImage);
    },
    /**
     * @Override resizing
     */
    setAutoSize: function() {
      const contextImage = this.context.image;
      if (contextImage._caption) contextImage._caption.style.marginTop = "";
      this.plugins.resizing.resetTransform.call(this, contextImage._element);
      this.plugins.image.cancelPercentAttr.call(this);
      contextImage._element.style.maxWidth = "";
      contextImage._element.style.width = "";
      contextImage._element.style.height = "";
      contextImage._cover.style.width = "";
      contextImage._cover.style.height = "";
      this.plugins.image.setAlign.call(this, null, null, null, null);
      contextImage._element.setAttribute("data-percentage", "auto,auto");
      this.plugins.resizing._module_saveCurrentSize.call(this, contextImage);
    },
    /**
     * @Override resizing
     */
    setOriginSize: function() {
      const contextImage = this.context.image;
      contextImage._element.removeAttribute("data-percentage");
      this.plugins.resizing.resetTransform.call(this, contextImage._element);
      this.plugins.image.cancelPercentAttr.call(this);
      const originSize = (contextImage._element.getAttribute("data-origin") || "").split(",");
      const w = originSize[0];
      const h = originSize[1];
      if (originSize) {
        if (contextImage._onlyPercentage || /%$/.test(w) && (/%$/.test(h) || !/\d/.test(h))) {
          this.plugins.image.setPercentSize.call(this, w, h);
        } else {
          this.plugins.image.setSize.call(this, w, h);
        }
        this.plugins.resizing._module_saveCurrentSize.call(this, contextImage);
      }
    },
    /**
     * @Override resizing
     */
    setPercentSize: function(w, h) {
      const contextImage = this.context.image;
      h = !!h && !/%$/.test(h) && !this.util.getNumber(h, 0) ? this.util.isNumber(h) ? h + "%" : h : this.util.isNumber(h) ? h + contextImage.sizeUnit : h || "";
      const heightPercentage = /%$/.test(h);
      contextImage._container.style.width = this.util.isNumber(w) ? w + "%" : w;
      contextImage._container.style.height = "";
      contextImage._cover.style.width = "100%";
      contextImage._cover.style.height = !heightPercentage ? "" : h;
      contextImage._element.style.width = "100%";
      contextImage._element.style.height = heightPercentage ? "" : h;
      contextImage._element.style.maxWidth = "";
      if (contextImage._align === "center") this.plugins.image.setAlign.call(this, null, null, null, null);
      contextImage._element.setAttribute("data-percentage", w + "," + h);
      this.plugins.resizing.setCaptionPosition.call(this, contextImage._element);
      this.plugins.resizing._module_saveCurrentSize.call(this, contextImage);
    },
    /**
     * @Override resizing
     */
    cancelPercentAttr: function() {
      const contextImage = this.context.image;
      contextImage._cover.style.width = "";
      contextImage._cover.style.height = "";
      contextImage._container.style.width = "";
      contextImage._container.style.height = "";
      this.util.removeClass(contextImage._container, this.context.image._floatClassRegExp);
      this.util.addClass(contextImage._container, "__se__float-" + contextImage._align);
      if (contextImage._align === "center") this.plugins.image.setAlign.call(this, null, null, null, null);
    },
    /**
     * @Override resizing
     */
    setAlign: function(align, element, cover, container) {
      const contextImage = this.context.image;
      if (!align) align = contextImage._align;
      if (!element) element = contextImage._element;
      if (!cover) cover = contextImage._cover;
      if (!container) container = contextImage._container;
      if (/%$/.test(element.style.width) && align === "center") {
        container.style.minWidth = "100%";
        cover.style.width = container.style.width;
      } else {
        container.style.minWidth = "";
        cover.style.width = this.context.resizing._rotateVertical ? element.style.height || element.offsetHeight : !element.style.width || element.style.width === "auto" ? "" : element.style.width || "100%";
      }
      if (!this.util.hasClass(container, "__se__float-" + align)) {
        this.util.removeClass(container, contextImage._floatClassRegExp);
        this.util.addClass(container, "__se__float-" + align);
      }
      element.setAttribute("data-align", align);
    },
    /**
     * @Override dialog
     */
    init: function() {
      const contextImage = this.context.image;
      if (contextImage.imgInputFile) contextImage.imgInputFile.value = "";
      if (contextImage.imgUrlFile) contextImage._v_src._linkValue = contextImage.previewSrc.textContent = contextImage.imgUrlFile.value = "";
      if (contextImage.imgInputFile && contextImage.imgUrlFile) {
        contextImage.imgUrlFile.removeAttribute("disabled");
        contextImage.previewSrc.style.textDecoration = "";
      }
      contextImage.altText.value = "";
      contextImage.modal.querySelector('input[name="suneditor_image_radio"][value="none"]').checked = true;
      contextImage.captionCheckEl.checked = false;
      contextImage._element = null;
      this.plugins.image.openTab.call(this, "init");
      if (contextImage._resizing) {
        contextImage.inputX.value = this.options.imageWidth === contextImage._defaultSizeX ? "" : this.options.imageWidth;
        contextImage.inputY.value = this.options.imageHeight === contextImage._defaultSizeY ? "" : this.options.imageHeight;
        contextImage.proportion.checked = true;
        contextImage._ratio = false;
        contextImage._ratioX = 1;
        contextImage._ratioY = 1;
      }
      this.plugins.anchor.init.call(this, contextImage.anchorCtx);
    }
  };

  // ../../node_modules/suneditor/src/plugins/dialog/video.js
  var import_dialog3 = __toESM(require_dialog());
  var import_component2 = __toESM(require_component2());
  var import_resizing2 = __toESM(require_resizing());
  var import_fileManager2 = __toESM(require_fileManager());
  var video_default = {
    name: "video",
    display: "dialog",
    add: function(core) {
      core.addModule([import_dialog3.default, import_component2.default, import_resizing2.default, import_fileManager2.default]);
      const options = core.options;
      const context = core.context;
      const contextVideo = context.video = {
        _infoList: [],
        // @Override fileManager
        _infoIndex: 0,
        // @Override fileManager
        _uploadFileLength: 0,
        // @Override fileManager
        focusElement: null,
        // @Override dialog // This element has focus when the dialog is opened.
        sizeUnit: options._videoSizeUnit,
        _align: "none",
        _floatClassRegExp: "__se__float\\-[a-z]+",
        _youtubeQuery: options.youtubeQuery,
        _vimeoQuery: options.vimeoQuery,
        _videoRatio: options.videoRatio * 100 + "%",
        _defaultRatio: options.videoRatio * 100 + "%",
        _linkValue: "",
        // @require @Override component
        _element: null,
        _cover: null,
        _container: null,
        // @Override resizing properties
        inputX: null,
        inputY: null,
        _element_w: 1,
        _element_h: 1,
        _element_l: 0,
        _element_t: 0,
        _defaultSizeX: "100%",
        _defaultSizeY: options.videoRatio * 100 + "%",
        _origin_w: options.videoWidth === "100%" ? "" : options.videoWidth,
        _origin_h: options.videoHeight === "56.25%" ? "" : options.videoHeight,
        _proportionChecked: true,
        _resizing: options.videoResizing,
        _resizeDotHide: !options.videoHeightShow,
        _rotation: options.videoRotation,
        _alignHide: !options.videoAlignShow,
        _onlyPercentage: options.videoSizeOnlyPercentage,
        _ratio: false,
        _ratioX: 1,
        _ratioY: 1,
        _captionShow: false
      };
      let video_dialog = this.setDialog(core);
      contextVideo.modal = video_dialog;
      contextVideo.videoInputFile = video_dialog.querySelector("._se_video_file");
      contextVideo.videoUrlFile = video_dialog.querySelector(".se-input-url");
      contextVideo.focusElement = contextVideo.videoUrlFile || contextVideo.videoInputFile;
      contextVideo.preview = video_dialog.querySelector(".se-link-preview");
      video_dialog.querySelector("form").addEventListener("submit", this.submit.bind(core));
      if (contextVideo.videoInputFile) video_dialog.querySelector(".se-dialog-files-edge-button").addEventListener("click", this._removeSelectedFiles.bind(contextVideo.videoInputFile, contextVideo.videoUrlFile, contextVideo.preview));
      if (contextVideo.videoInputFile && contextVideo.videoUrlFile) contextVideo.videoInputFile.addEventListener("change", this._fileInputChange.bind(contextVideo));
      if (contextVideo.videoUrlFile) contextVideo.videoUrlFile.addEventListener("input", this._onLinkPreview.bind(contextVideo.preview, contextVideo, options.linkProtocol));
      contextVideo.proportion = {};
      contextVideo.videoRatioOption = {};
      contextVideo.inputX = {};
      contextVideo.inputY = {};
      if (options.videoResizing) {
        contextVideo.proportion = video_dialog.querySelector("._se_video_check_proportion");
        contextVideo.videoRatioOption = video_dialog.querySelector(".se-video-ratio");
        contextVideo.inputX = video_dialog.querySelector("._se_video_size_x");
        contextVideo.inputY = video_dialog.querySelector("._se_video_size_y");
        contextVideo.inputX.value = options.videoWidth;
        contextVideo.inputY.value = options.videoHeight;
        contextVideo.inputX.addEventListener("keyup", this.setInputSize.bind(core, "x"));
        contextVideo.inputY.addEventListener("keyup", this.setInputSize.bind(core, "y"));
        contextVideo.inputX.addEventListener("change", this.setRatio.bind(core));
        contextVideo.inputY.addEventListener("change", this.setRatio.bind(core));
        contextVideo.proportion.addEventListener("change", this.setRatio.bind(core));
        contextVideo.videoRatioOption.addEventListener("change", this.setVideoRatio.bind(core));
        video_dialog.querySelector(".se-dialog-btn-revert").addEventListener("click", this.sizeRevert.bind(core));
      }
      context.dialog.modal.appendChild(video_dialog);
      video_dialog = null;
    },
    /** dialog */
    setDialog: function(core) {
      const option = core.options;
      const lang = core.lang;
      const dialog6 = core.util.createElement("DIV");
      dialog6.className = "se-dialog-content";
      dialog6.style.display = "none";
      let html = '<form method="post" enctype="multipart/form-data"><div class="se-dialog-header"><button type="button" data-command="close" class="se-btn se-dialog-close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + core.icons.cancel + '</button><span class="se-modal-title">' + lang.dialogBox.videoBox.title + '</span></div><div class="se-dialog-body">';
      if (option.videoFileInput) {
        html += '<div class="se-dialog-form"><label>' + lang.dialogBox.videoBox.file + '</label><div class="se-dialog-form-files"><input class="se-input-form _se_video_file" type="file" accept="' + option.videoAccept + '"' + (option.videoMultipleFile ? ' multiple="multiple"' : "") + '/><button type="button" data-command="filesRemove" class="se-btn se-dialog-files-edge-button se-file-remove" title="' + lang.controller.remove + '" aria-label="' + lang.controller.remove + '">' + core.icons.cancel + "</button></div></div>";
      }
      if (option.videoUrlInput) {
        html += '<div class="se-dialog-form"><label>' + lang.dialogBox.videoBox.url + '</label><input class="se-input-form se-input-url" type="text" /><pre class="se-link-preview"></pre></div>';
      }
      if (option.videoResizing) {
        const ratioList = option.videoRatioList || [{ name: "16:9", value: 0.5625 }, { name: "4:3", value: 0.75 }, { name: "21:9", value: 0.4285 }];
        const ratio = option.videoRatio;
        const onlyPercentage = option.videoSizeOnlyPercentage;
        const onlyPercentDisplay = onlyPercentage ? ' style="display: none !important;"' : "";
        const heightDisplay = !option.videoHeightShow ? ' style="display: none !important;"' : "";
        const ratioDisplay = !option.videoRatioShow ? ' style="display: none !important;"' : "";
        const onlyWidthDisplay = !onlyPercentage && !option.videoHeightShow && !option.videoRatioShow ? ' style="display: none !important;"' : "";
        html += '<div class="se-dialog-form"><div class="se-dialog-size-text"><label class="size-w">' + lang.dialogBox.width + '</label><label class="se-dialog-size-x">&nbsp;</label><label class="size-h"' + heightDisplay + ">" + lang.dialogBox.height + '</label><label class="size-h"' + ratioDisplay + ">(" + lang.dialogBox.ratio + ')</label></div><input class="se-input-control _se_video_size_x" placeholder="100%"' + (onlyPercentage ? ' type="number" min="1"' : 'type="text"') + (onlyPercentage ? ' max="100"' : "") + '/><label class="se-dialog-size-x"' + onlyWidthDisplay + ">" + (onlyPercentage ? "%" : "x") + '</label><input class="se-input-control _se_video_size_y" placeholder="' + option.videoRatio * 100 + '%"' + (onlyPercentage ? ' type="number" min="1"' : 'type="text"') + (onlyPercentage ? ' max="100"' : "") + heightDisplay + '/><select class="se-input-select se-video-ratio" title="' + lang.dialogBox.ratio + '" aria-label="' + lang.dialogBox.ratio + '"' + ratioDisplay + ">";
        if (!heightDisplay) html += '<option value=""> - </option>';
        for (let i = 0, len = ratioList.length; i < len; i++) {
          html += '<option value="' + ratioList[i].value + '"' + (ratio.toString() === ratioList[i].value.toString() ? " selected" : "") + ">" + ratioList[i].name + "</option>";
        }
        html += '</select><button type="button" title="' + lang.dialogBox.revertButton + '" aria-label="' + lang.dialogBox.revertButton + '" class="se-btn se-dialog-btn-revert" style="float: right;">' + core.icons.revert + '</button></div><div class="se-dialog-form se-dialog-form-footer"' + onlyPercentDisplay + onlyWidthDisplay + '><label><input type="checkbox" class="se-dialog-btn-check _se_video_check_proportion" checked/>&nbsp;' + lang.dialogBox.proportion + "</label></div>";
      }
      html += '</div><div class="se-dialog-footer"><div' + (option.videoAlignShow ? "" : ' style="display: none"') + '><label><input type="radio" name="suneditor_video_radio" class="se-dialog-btn-radio" value="none" checked>' + lang.dialogBox.basic + '</label><label><input type="radio" name="suneditor_video_radio" class="se-dialog-btn-radio" value="left">' + lang.dialogBox.left + '</label><label><input type="radio" name="suneditor_video_radio" class="se-dialog-btn-radio" value="center">' + lang.dialogBox.center + '</label><label><input type="radio" name="suneditor_video_radio" class="se-dialog-btn-radio" value="right">' + lang.dialogBox.right + '</label></div><button type="submit" class="se-btn-primary" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '"><span>' + lang.dialogBox.submitButton + "</span></button></div></form>";
      dialog6.innerHTML = html;
      return dialog6;
    },
    _fileInputChange: function() {
      if (!this.videoInputFile.value) {
        this.videoUrlFile.removeAttribute("disabled");
        this.preview.style.textDecoration = "";
      } else {
        this.videoUrlFile.setAttribute("disabled", true);
        this.preview.style.textDecoration = "line-through";
      }
    },
    _removeSelectedFiles: function(urlInput, preview) {
      this.value = "";
      if (urlInput) {
        urlInput.removeAttribute("disabled");
        preview.style.textDecoration = "";
      }
    },
    _onLinkPreview: function(context, protocol, e) {
      const value = e.target.value.trim();
      if (/^<iframe.*\/iframe>$/.test(value)) {
        context._linkValue = value;
        this.textContent = '<IFrame :src=".."></IFrame>';
      } else {
        context._linkValue = this.textContent = !value ? "" : protocol && value.indexOf("://") === -1 && value.indexOf("#") !== 0 ? protocol + value : value.indexOf("://") === -1 ? "/" + value : value;
      }
    },
    _setTagAttrs: function(element) {
      element.setAttribute("controls", true);
      const attrs = this.options.videoTagAttrs;
      if (!attrs) return;
      for (let key in attrs) {
        if (!this.util.hasOwn(attrs, key)) continue;
        element.setAttribute(key, attrs[key]);
      }
    },
    createVideoTag: function() {
      const videoTag = this.util.createElement("VIDEO");
      this.plugins.video._setTagAttrs.call(this, videoTag);
      return videoTag;
    },
    _setIframeAttrs: function(element) {
      element.frameBorder = "0";
      element.allowFullscreen = true;
      const attrs = this.options.videoIframeAttrs;
      if (!attrs) return;
      for (let key in attrs) {
        if (!this.util.hasOwn(attrs, key)) continue;
        element.setAttribute(key, attrs[key]);
      }
    },
    createIframeTag: function() {
      const iframeTag = this.util.createElement("IFRAME");
      this.plugins.video._setIframeAttrs.call(this, iframeTag);
      return iframeTag;
    },
    /**
     * @Override @Required fileManager
     */
    fileTags: ["iframe", "video"],
    /**
     * @Override core, resizing, fileManager
     * @description It is called from core.selectComponent.
     * @param {Element} element Target element
     */
    select: function(element) {
      this.plugins.video.onModifyMode.call(this, element, this.plugins.resizing.call_controller_resize.call(this, element, "video"));
    },
    /**
     * @Override fileManager, resizing
     */
    destroy: function(element) {
      const frame = element || this.context.video._element;
      const container = this.context.video._container;
      const dataIndex = frame.getAttribute("data-index") * 1;
      if (typeof this.functions.onVideoDeleteBefore === "function" && this.functions.onVideoDeleteBefore(frame, container, dataIndex, this) === false) return;
      let focusEl = container.previousElementSibling || container.nextElementSibling;
      const emptyDiv = container.parentNode;
      this.util.removeItem(container);
      this.plugins.video.init.call(this);
      this.controllersOff();
      if (emptyDiv !== this.context.element.wysiwyg) this.util.removeItemAllParents(emptyDiv, function(current) {
        return current.childNodes.length === 0;
      }, null);
      this.focusEdge(focusEl);
      this.plugins.fileManager.deleteInfo.call(this, "video", dataIndex, this.functions.onVideoUpload);
      this.history.push(false);
    },
    /**
     * @Required @Override dialog
     */
    on: function(update) {
      const contextVideo = this.context.video;
      if (!update) {
        contextVideo.inputX.value = contextVideo._origin_w = this.options.videoWidth === contextVideo._defaultSizeX ? "" : this.options.videoWidth;
        contextVideo.inputY.value = contextVideo._origin_h = this.options.videoHeight === contextVideo._defaultSizeY ? "" : this.options.videoHeight;
        contextVideo.proportion.disabled = true;
        if (contextVideo.videoInputFile && this.options.videoMultipleFile) contextVideo.videoInputFile.setAttribute("multiple", "multiple");
      } else {
        if (contextVideo.videoInputFile && this.options.videoMultipleFile) contextVideo.videoInputFile.removeAttribute("multiple");
      }
      if (contextVideo._resizing) {
        this.plugins.video.setVideoRatioSelect.call(this, contextVideo._origin_h || contextVideo._defaultRatio);
      }
    },
    /**
     * @Required @Override dialog
     */
    open: function() {
      this.plugins.dialog.open.call(this, "video", "video" === this.currentControllerName);
    },
    setVideoRatio: function(e) {
      const contextVideo = this.context.video;
      const value = e.target.options[e.target.selectedIndex].value;
      contextVideo._defaultSizeY = contextVideo._videoRatio = !value ? contextVideo._defaultSizeY : value * 100 + "%";
      contextVideo.inputY.placeholder = !value ? "" : value * 100 + "%";
      contextVideo.inputY.value = "";
    },
    /**
     * @Override resizing
     * @param {String} xy 'x': width, 'y': height
     * @param {KeyboardEvent} e Event object
     */
    setInputSize: function(xy, e) {
      if (e && e.keyCode === 32) {
        e.preventDefault();
        return;
      }
      const contextVideo = this.context.video;
      this.plugins.resizing._module_setInputSize.call(this, contextVideo, xy);
      if (xy === "y") {
        this.plugins.video.setVideoRatioSelect.call(this, e.target.value || contextVideo._defaultRatio);
      }
    },
    /**
     * @Override resizing
     */
    setRatio: function() {
      this.plugins.resizing._module_setRatio.call(this, this.context.video);
    },
    submit: function(e) {
      const contextVideo = this.context.video;
      const videoPlugin = this.plugins.video;
      e.preventDefault();
      e.stopPropagation();
      contextVideo._align = contextVideo.modal.querySelector('input[name="suneditor_video_radio"]:checked').value;
      try {
        if (contextVideo.videoInputFile && contextVideo.videoInputFile.files.length > 0) {
          this.showLoading();
          videoPlugin.submitAction.call(this, this.context.video.videoInputFile.files);
        } else if (contextVideo.videoUrlFile && contextVideo._linkValue.length > 0) {
          this.showLoading();
          videoPlugin.setup_url.call(this, contextVideo._linkValue);
        }
      } catch (error) {
        this.closeLoading();
        throw Error('[SUNEDITOR.video.submit.fail] cause : "' + error.message + '"');
      } finally {
        this.plugins.dialog.close.call(this);
      }
      return false;
    },
    submitAction: function(fileList) {
      if (fileList.length === 0) return;
      let fileSize = 0;
      let files = [];
      for (let i = 0, len = fileList.length; i < len; i++) {
        if (/video/i.test(fileList[i].type)) {
          files.push(fileList[i]);
          fileSize += fileList[i].size;
        }
      }
      const limitSize = this.options.videoUploadSizeLimit;
      if (limitSize > 0) {
        let infoSize = 0;
        const videosInfo = this.context.video._infoList;
        for (let i = 0, len = videosInfo.length; i < len; i++) {
          infoSize += videosInfo[i].size * 1;
        }
        if (fileSize + infoSize > limitSize) {
          this.closeLoading();
          const err = "[SUNEDITOR.videoUpload.fail] Size of uploadable total videos: " + limitSize / 1e3 + "KB";
          if (typeof this.functions.onVideoUploadError !== "function" || this.functions.onVideoUploadError(err, { "limitSize": limitSize, "currentSize": infoSize, "uploadSize": fileSize }, this)) {
            this.functions.noticeOpen(err);
          }
          return;
        }
      }
      const contextVideo = this.context.video;
      contextVideo._uploadFileLength = files.length;
      const info = {
        inputWidth: contextVideo.inputX.value,
        inputHeight: contextVideo.inputY.value,
        align: contextVideo._align,
        isUpdate: this.context.dialog.updateModal,
        element: contextVideo._element
      };
      if (typeof this.functions.onVideoUploadBefore === "function") {
        const result = this.functions.onVideoUploadBefore(files, info, this, function(data2) {
          if (data2 && this._w.Array.isArray(data2.result)) {
            this.plugins.video.register.call(this, info, data2);
          } else {
            this.plugins.video.upload.call(this, info, data2);
          }
        }.bind(this));
        if (typeof result === "undefined") return;
        if (!result) {
          this.closeLoading();
          return;
        }
        if (typeof result === "object" && result.length > 0) files = result;
      }
      this.plugins.video.upload.call(this, info, files);
    },
    error: function(message, response) {
      this.closeLoading();
      if (typeof this.functions.onVideoUploadError !== "function" || this.functions.onVideoUploadError(message, response, this)) {
        this.functions.noticeOpen(message);
        throw Error("[SUNEDITOR.plugin.video.error] response: " + message);
      }
    },
    upload: function(info, files) {
      if (!files) {
        this.closeLoading();
        return;
      }
      if (typeof files === "string") {
        this.plugins.video.error.call(this, files, null);
        return;
      }
      const videoUploadUrl = this.options.videoUploadUrl;
      const filesLen = this.context.dialog.updateModal ? 1 : files.length;
      if (typeof videoUploadUrl === "string" && videoUploadUrl.length > 0) {
        const formData = new FormData();
        for (let i = 0; i < filesLen; i++) {
          formData.append("file-" + i, files[i]);
        }
        this.plugins.fileManager.upload.call(this, videoUploadUrl, this.options.videoUploadHeader, formData, this.plugins.video.callBack_videoUpload.bind(this, info), this.functions.onVideoUploadError);
      } else {
        throw Error('[SUNEDITOR.videoUpload.fail] cause : There is no "videoUploadUrl" option.');
      }
    },
    callBack_videoUpload: function(info, xmlHttp) {
      if (typeof this.functions.videoUploadHandler === "function") {
        this.functions.videoUploadHandler(xmlHttp, info, this);
      } else {
        const response = JSON.parse(xmlHttp.responseText);
        if (response.errorMessage) {
          this.plugins.video.error.call(this, response.errorMessage, response);
        } else {
          this.plugins.video.register.call(this, info, response);
        }
      }
    },
    register: function(info, response) {
      const fileList = response.result;
      const videoTag = this.plugins.video.createVideoTag.call(this);
      for (let i = 0, len = fileList.length, file; i < len; i++) {
        file = { name: fileList[i].name, size: fileList[i].size };
        this.plugins.video.create_video.call(this, info.isUpdate ? info.element : videoTag.cloneNode(false), fileList[i].url, info.inputWidth, info.inputHeight, info.align, file, info.isUpdate);
      }
      this.closeLoading();
    },
    setup_url: function(url) {
      try {
        const contextVideo = this.context.video;
        if (!url) url = contextVideo._linkValue;
        if (!url) return false;
        if (/^<iframe.*\/iframe>$/.test(url)) {
          const oIframe = new this._w.DOMParser().parseFromString(url, "text/html").querySelector("iframe");
          url = oIframe.src;
          if (url.length === 0) return false;
        }
        if (/youtu\.?be/.test(url)) {
          if (!/^http/.test(url)) url = "https://" + url;
          url = url.replace("watch?v=", "");
          if (!/^\/\/.+\/embed\//.test(url)) {
            url = url.replace(url.match(/\/\/.+\//)[0], "//www.youtube.com/embed/").replace("&", "?&");
          }
          if (contextVideo._youtubeQuery.length > 0) {
            if (/\?/.test(url)) {
              const splitUrl = url.split("?");
              url = splitUrl[0] + "?" + contextVideo._youtubeQuery + "&" + splitUrl[1];
            } else {
              url += "?" + contextVideo._youtubeQuery;
            }
          }
        } else if (/vimeo\.com/.test(url)) {
          if (url.endsWith("/")) {
            url = url.slice(0, -1);
          }
          url = "https://player.vimeo.com/video/" + url.slice(url.lastIndexOf("/") + 1);
          if (contextVideo._vimeoQuery.length > 0) {
            if (/\?/.test(url)) {
              const splitUrl = url.split("?");
              url = splitUrl[0] + "?" + contextVideo._vimeoQuery + "&" + splitUrl[1];
            } else {
              url += "?" + contextVideo._vimeoQuery;
            }
          }
        }
        this.plugins.video.create_video.call(this, this.plugins.video[!/embed|iframe|player|\/e\/|\.php|\.html?/.test(url) && !/vimeo\.com/.test(url) ? "createVideoTag" : "createIframeTag"].call(this), url, contextVideo.inputX.value, contextVideo.inputY.value, contextVideo._align, null, this.context.dialog.updateModal);
      } catch (error) {
        throw Error('[SUNEDITOR.video.upload.fail] cause : "' + error.message + '"');
      } finally {
        this.closeLoading();
      }
    },
    create_video: function(oFrame, src, width, height, align, file, isUpdate) {
      this.context.resizing._resize_plugin = "video";
      const contextVideo = this.context.video;
      let cover = null;
      let container = null;
      let init = false;
      if (isUpdate) {
        oFrame = contextVideo._element;
        if (oFrame.src !== src) {
          init = true;
          const isYoutube = /youtu\.?be/.test(src);
          const isVimeo = /vimeo\.com/.test(src);
          if ((isYoutube || isVimeo) && !/^iframe$/i.test(oFrame.nodeName)) {
            const newTag = this.plugins.video.createIframeTag.call(this);
            newTag.src = src;
            oFrame.parentNode.replaceChild(newTag, oFrame);
            contextVideo._element = oFrame = newTag;
          } else if (!isYoutube && !isVimeo && !/^video$/i.test(oFrame.nodeName)) {
            const newTag = this.plugins.video.createVideoTag.call(this);
            newTag.src = src;
            oFrame.parentNode.replaceChild(newTag, oFrame);
            contextVideo._element = oFrame = newTag;
          } else {
            oFrame.src = src;
          }
        }
        container = contextVideo._container;
        cover = this.util.getParentElement(oFrame, "FIGURE");
      } else {
        init = true;
        oFrame.src = src;
        contextVideo._element = oFrame;
        cover = this.plugins.component.set_cover.call(this, oFrame);
        container = this.plugins.component.set_container.call(this, cover, "se-video-container");
      }
      contextVideo._cover = cover;
      contextVideo._container = container;
      const inputUpdate = this.plugins.resizing._module_getSizeX.call(this, contextVideo) !== (width || contextVideo._defaultSizeX) || this.plugins.resizing._module_getSizeY.call(this, contextVideo) !== (height || contextVideo._videoRatio);
      const changeSize = !isUpdate || inputUpdate;
      if (contextVideo._resizing) {
        this.context.video._proportionChecked = contextVideo.proportion.checked;
        oFrame.setAttribute("data-proportion", contextVideo._proportionChecked);
      }
      let isPercent = false;
      if (changeSize) {
        isPercent = this.plugins.video.applySize.call(this);
      }
      if (!(isPercent && align === "center")) {
        this.plugins.video.setAlign.call(this, null, oFrame, cover, container);
      }
      let changed = true;
      if (!isUpdate) {
        changed = this.insertComponent(container, false, true, !this.options.mediaAutoSelect);
        if (!this.options.mediaAutoSelect) {
          const line = this.appendFormatTag(container, null);
          if (line) this.setRange(line, 0, line, 0);
        }
      } else if (contextVideo._resizing && this.context.resizing._rotateVertical && changeSize) {
        this.plugins.resizing.setTransformSize.call(this, oFrame, null, null);
      }
      if (changed) {
        if (init) {
          this.plugins.fileManager.setInfo.call(this, "video", oFrame, this.functions.onVideoUpload, file, true);
        }
        if (isUpdate) {
          this.selectComponent(oFrame, "video");
          this.history.push(false);
        }
      }
      this.context.resizing._resize_plugin = "";
    },
    _update_videoCover: function(oFrame) {
      if (!oFrame) return;
      const contextVideo = this.context.video;
      if (/^video$/i.test(oFrame.nodeName)) this.plugins.video._setTagAttrs.call(this, oFrame);
      else this.plugins.video._setIframeAttrs.call(this, oFrame);
      let existElement = this.util.isRangeFormatElement(oFrame.parentNode) || this.util.isWysiwygDiv(oFrame.parentNode) ? oFrame : this.util.getFormatElement(oFrame) || oFrame;
      const prevFrame = oFrame;
      contextVideo._element = oFrame = oFrame.cloneNode(true);
      const cover = contextVideo._cover = this.plugins.component.set_cover.call(this, oFrame);
      const container = contextVideo._container = this.plugins.component.set_container.call(this, cover, "se-video-container");
      try {
        const figcaption = existElement.querySelector("figcaption");
        let caption = null;
        if (!!figcaption) {
          caption = this.util.createElement("DIV");
          caption.innerHTML = figcaption.innerHTML;
          this.util.removeItem(figcaption);
        }
        const size = (oFrame.getAttribute("data-size") || oFrame.getAttribute("data-origin") || "").split(",");
        this.plugins.video.applySize.call(this, size[0] || prevFrame.style.width || prevFrame.width || "", size[1] || prevFrame.style.height || prevFrame.height || "");
        const format = this.util.getFormatElement(prevFrame);
        if (format) contextVideo._align = format.style.textAlign || format.style.float;
        this.plugins.video.setAlign.call(this, null, oFrame, cover, container);
        if (this.util.getParentElement(prevFrame, this.util.isNotCheckingNode)) {
          prevFrame.parentNode.replaceChild(container, prevFrame);
        } else if (this.util.isListCell(existElement)) {
          const refer = this.util.getParentElement(prevFrame, function(current) {
            return current.parentNode === existElement;
          });
          existElement.insertBefore(container, refer);
          this.util.removeItem(prevFrame);
          this.util.removeEmptyNode(refer, null, true);
        } else if (this.util.isFormatElement(existElement)) {
          const refer = this.util.getParentElement(prevFrame, function(current) {
            return current.parentNode === existElement;
          });
          existElement = this.util.splitElement(existElement, refer);
          existElement.parentNode.insertBefore(container, existElement);
          this.util.removeItem(prevFrame);
          this.util.removeEmptyNode(existElement, null, true);
          if (existElement.children.length === 0) existElement.innerHTML = this.util.htmlRemoveWhiteSpace(existElement.innerHTML);
        } else {
          existElement.parentNode.replaceChild(container, existElement);
        }
        if (!!caption) existElement.parentNode.insertBefore(caption, container.nextElementSibling);
      } catch (error) {
        console.warn("[SUNEDITOR.video.error] Maybe the video tag is nested.", error);
      }
      this.plugins.fileManager.setInfo.call(this, "video", oFrame, this.functions.onVideoUpload, null, true);
      this.plugins.video.init.call(this);
    },
    /**
     * @Required @Override fileManager, resizing
     */
    onModifyMode: function(element, size) {
      const contextVideo = this.context.video;
      contextVideo._element = element;
      contextVideo._cover = this.util.getParentElement(element, "FIGURE");
      contextVideo._container = this.util.getParentElement(element, this.util.isMediaComponent);
      contextVideo._align = element.style.float || element.getAttribute("data-align") || "none";
      element.style.float = "";
      if (size) {
        contextVideo._element_w = size.w;
        contextVideo._element_h = size.h;
        contextVideo._element_t = size.t;
        contextVideo._element_l = size.l;
      }
      let origin = contextVideo._element.getAttribute("data-size") || contextVideo._element.getAttribute("data-origin");
      let w, h;
      if (origin) {
        origin = origin.split(",");
        w = origin[0];
        h = origin[1];
      } else if (size) {
        w = size.w;
        h = size.h;
      }
      contextVideo._origin_w = w || element.style.width || element.width || "";
      contextVideo._origin_h = h || element.style.height || element.height || "";
    },
    /**
     * @Required @Override fileManager, resizing
     */
    openModify: function(notOpen) {
      const contextVideo = this.context.video;
      if (contextVideo.videoUrlFile) contextVideo._linkValue = contextVideo.preview.textContent = contextVideo.videoUrlFile.value = contextVideo._element.src || (contextVideo._element.querySelector("source") || "").src || "";
      (contextVideo.modal.querySelector('input[name="suneditor_video_radio"][value="' + contextVideo._align + '"]') || contextVideo.modal.querySelector('input[name="suneditor_video_radio"][value="none"]')).checked = true;
      if (contextVideo._resizing) {
        this.plugins.resizing._module_setModifyInputSize.call(this, contextVideo, this.plugins.video);
        const y = contextVideo._videoRatio = this.plugins.resizing._module_getSizeY.call(this, contextVideo);
        const ratioSelected = this.plugins.video.setVideoRatioSelect.call(this, y);
        if (!ratioSelected) contextVideo.inputY.value = contextVideo._onlyPercentage ? this.util.getNumber(y, 2) : y;
      }
      if (!notOpen) this.plugins.dialog.open.call(this, "video", true);
    },
    setVideoRatioSelect: function(value) {
      let ratioSelected = false;
      const contextVideo = this.context.video;
      const ratioOptions = contextVideo.videoRatioOption.options;
      if (/%$/.test(value) || contextVideo._onlyPercentage) value = this.util.getNumber(value, 2) / 100 + "";
      else if (!this.util.isNumber(value) || value * 1 >= 1) value = "";
      contextVideo.inputY.placeholder = "";
      for (let i = 0, len = ratioOptions.length; i < len; i++) {
        if (ratioOptions[i].value === value) {
          ratioSelected = ratioOptions[i].selected = true;
          contextVideo.inputY.placeholder = !value ? "" : value * 100 + "%";
        } else ratioOptions[i].selected = false;
      }
      return ratioSelected;
    },
    /**
     * @Override fileManager
     */
    checkFileInfo: function() {
      this.plugins.fileManager.checkInfo.call(this, "video", ["iframe", "video"], this.functions.onVideoUpload, this.plugins.video._update_videoCover.bind(this), true);
    },
    /**
     * @Override fileManager
     */
    resetFileInfo: function() {
      this.plugins.fileManager.resetInfo.call(this, "video", this.functions.onVideoUpload);
    },
    /**
     * @Override fileManager
     */
    applySize: function(w, h) {
      const contextVideo = this.context.video;
      if (!w) w = contextVideo.inputX.value || this.options.videoWidth;
      if (!h) h = contextVideo.inputY.value || this.options.videoHeight;
      if (contextVideo._onlyPercentage || /%$/.test(w) || !w) {
        this.plugins.video.setPercentSize.call(this, w || "100%", h || (/%$/.test(contextVideo._videoRatio) ? contextVideo._videoRatio : contextVideo._defaultRatio));
        return true;
      } else if ((!w || w === "auto") && (!h || h === "auto")) {
        this.plugins.video.setAutoSize.call(this);
      } else {
        this.plugins.video.setSize.call(this, w, h || contextVideo._videoRatio || contextVideo._defaultRatio, false);
      }
      return false;
    },
    /**
     * @Override resizing
     */
    sizeRevert: function() {
      this.plugins.resizing._module_sizeRevert.call(this, this.context.video);
    },
    /**
     * @Override resizing
     */
    setSize: function(w, h, notResetPercentage, direction) {
      const contextVideo = this.context.video;
      const onlyW = /^(rw|lw)$/.test(direction);
      const onlyH = /^(th|bh)$/.test(direction);
      if (!onlyH) w = this.util.getNumber(w, 0);
      if (!onlyW) h = this.util.isNumber(h) ? h + contextVideo.sizeUnit : !h ? "" : h;
      w = w ? w + contextVideo.sizeUnit : "";
      if (!onlyH) contextVideo._element.style.width = w;
      if (!onlyW) contextVideo._cover.style.paddingBottom = contextVideo._cover.style.height = h;
      if (!onlyH && !/%$/.test(w)) {
        contextVideo._cover.style.width = w;
        contextVideo._container.style.width = "";
      }
      if (!onlyW && !/%$/.test(h)) {
        contextVideo._element.style.height = h;
      } else {
        contextVideo._element.style.height = "";
      }
      if (!notResetPercentage) contextVideo._element.removeAttribute("data-percentage");
      this.plugins.resizing._module_saveCurrentSize.call(this, contextVideo);
    },
    /**
     * @Override resizing
     */
    setAutoSize: function() {
      this.plugins.video.setPercentSize.call(this, 100, this.context.video._defaultRatio);
    },
    /**
     * @Override resizing
     */
    setOriginSize: function(dataSize) {
      const contextVideo = this.context.video;
      contextVideo._element.removeAttribute("data-percentage");
      this.plugins.resizing.resetTransform.call(this, contextVideo._element);
      this.plugins.video.cancelPercentAttr.call(this);
      const originSize = ((dataSize ? contextVideo._element.getAttribute("data-size") : "") || contextVideo._element.getAttribute("data-origin") || "").split(",");
      if (originSize) {
        const w = originSize[0];
        const h = originSize[1];
        if (contextVideo._onlyPercentage || /%$/.test(w) && (/%$/.test(h) || !/\d/.test(h))) {
          this.plugins.video.setPercentSize.call(this, w, h);
        } else {
          this.plugins.video.setSize.call(this, w, h);
        }
        this.plugins.resizing._module_saveCurrentSize.call(this, contextVideo);
      }
    },
    /**
     * @Override resizing
     */
    setPercentSize: function(w, h) {
      const contextVideo = this.context.video;
      h = !!h && !/%$/.test(h) && !this.util.getNumber(h, 0) ? this.util.isNumber(h) ? h + "%" : h : this.util.isNumber(h) ? h + contextVideo.sizeUnit : h || contextVideo._defaultRatio;
      contextVideo._container.style.width = this.util.isNumber(w) ? w + "%" : w;
      contextVideo._container.style.height = "";
      contextVideo._cover.style.width = "100%";
      contextVideo._cover.style.height = h;
      contextVideo._cover.style.paddingBottom = h;
      contextVideo._element.style.width = "100%";
      contextVideo._element.style.height = "100%";
      contextVideo._element.style.maxWidth = "";
      if (contextVideo._align === "center") this.plugins.video.setAlign.call(this, null, null, null, null);
      contextVideo._element.setAttribute("data-percentage", w + "," + h);
      this.plugins.resizing._module_saveCurrentSize.call(this, contextVideo);
    },
    /**
     * @Override resizing
     */
    cancelPercentAttr: function() {
      const contextVideo = this.context.video;
      contextVideo._cover.style.width = "";
      contextVideo._cover.style.height = "";
      contextVideo._cover.style.paddingBottom = "";
      contextVideo._container.style.width = "";
      contextVideo._container.style.height = "";
      this.util.removeClass(contextVideo._container, this.context.video._floatClassRegExp);
      this.util.addClass(contextVideo._container, "__se__float-" + contextVideo._align);
      if (contextVideo._align === "center") this.plugins.video.setAlign.call(this, null, null, null, null);
    },
    /**
     * @Override resizing
     */
    setAlign: function(align, element, cover, container) {
      const contextVideo = this.context.video;
      if (!align) align = contextVideo._align;
      if (!element) element = contextVideo._element;
      if (!cover) cover = contextVideo._cover;
      if (!container) container = contextVideo._container;
      if (/%$/.test(element.style.width) && align === "center") {
        container.style.minWidth = "100%";
        cover.style.width = container.style.width;
        cover.style.height = cover.style.height;
        cover.style.paddingBottom = !/%$/.test(cover.style.height) ? cover.style.height : this.util.getNumber(this.util.getNumber(cover.style.height, 2) / 100 * this.util.getNumber(cover.style.width, 2), 2) + "%";
      } else {
        container.style.minWidth = "";
        cover.style.width = this.context.resizing._rotateVertical ? element.style.height || element.offsetHeight : element.style.width || "100%";
        cover.style.paddingBottom = cover.style.height;
      }
      if (!this.util.hasClass(container, "__se__float-" + align)) {
        this.util.removeClass(container, contextVideo._floatClassRegExp);
        this.util.addClass(container, "__se__float-" + align);
      }
      element.setAttribute("data-align", align);
    },
    /**
     * @Override dialog
     */
    init: function() {
      const contextVideo = this.context.video;
      if (contextVideo.videoInputFile) contextVideo.videoInputFile.value = "";
      if (contextVideo.videoUrlFile) contextVideo._linkValue = contextVideo.preview.textContent = contextVideo.videoUrlFile.value = "";
      if (contextVideo.videoInputFile && contextVideo.videoUrlFile) {
        contextVideo.videoUrlFile.removeAttribute("disabled");
        contextVideo.preview.style.textDecoration = "";
      }
      contextVideo._origin_w = this.options.videoWidth;
      contextVideo._origin_h = this.options.videoHeight;
      contextVideo.modal.querySelector('input[name="suneditor_video_radio"][value="none"]').checked = true;
      if (contextVideo._resizing) {
        contextVideo.inputX.value = this.options.videoWidth === contextVideo._defaultSizeX ? "" : this.options.videoWidth;
        contextVideo.inputY.value = this.options.videoHeight === contextVideo._defaultSizeY ? "" : this.options.videoHeight;
        contextVideo.proportion.checked = true;
        contextVideo.proportion.disabled = true;
        this.plugins.video.setVideoRatioSelect.call(this, contextVideo._defaultRatio);
      }
    }
  };

  // ../../node_modules/suneditor/src/plugins/dialog/audio.js
  var import_dialog4 = __toESM(require_dialog());
  var import_component3 = __toESM(require_component2());
  var import_fileManager3 = __toESM(require_fileManager());
  var audio_default = {
    name: "audio",
    display: "dialog",
    add: function(core) {
      core.addModule([import_dialog4.default, import_component3.default, import_fileManager3.default]);
      const context = core.context;
      const contextAudio = context.audio = {
        _infoList: [],
        // @Override fileManager
        _infoIndex: 0,
        // @Override fileManager
        _uploadFileLength: 0,
        // @Override fileManager
        focusElement: null,
        // @Override dialog // This element has focus when the dialog is opened.
        targetSelect: null,
        _origin_w: core.options.audioWidth,
        _origin_h: core.options.audioHeight,
        _linkValue: "",
        // @require @Override component
        _element: null,
        _cover: null,
        _container: null
      };
      let audio_dialog = this.setDialog(core);
      contextAudio.modal = audio_dialog;
      contextAudio.audioInputFile = audio_dialog.querySelector("._se_audio_files");
      contextAudio.audioUrlFile = audio_dialog.querySelector(".se-input-url");
      contextAudio.focusElement = contextAudio.audioInputFile || contextAudio.audioUrlFile;
      contextAudio.preview = audio_dialog.querySelector(".se-link-preview");
      let audio_controller = this.setController(core);
      contextAudio.controller = audio_controller;
      audio_dialog.querySelector("form").addEventListener("submit", this.submit.bind(core));
      if (contextAudio.audioInputFile) audio_dialog.querySelector(".se-dialog-files-edge-button").addEventListener("click", this._removeSelectedFiles.bind(contextAudio.audioInputFile, contextAudio.audioUrlFile, contextAudio.preview));
      if (contextAudio.audioInputFile && contextAudio.audioUrlFile) contextAudio.audioInputFile.addEventListener("change", this._fileInputChange.bind(contextAudio));
      audio_controller.addEventListener("click", this.onClick_controller.bind(core));
      if (contextAudio.audioUrlFile) contextAudio.audioUrlFile.addEventListener("input", this._onLinkPreview.bind(contextAudio.preview, contextAudio, core.options.linkProtocol));
      context.dialog.modal.appendChild(audio_dialog);
      context.element.relative.appendChild(audio_controller);
      audio_dialog = null, audio_controller = null;
    },
    /** HTML - dialog */
    setDialog: function(core) {
      const option = core.options;
      const lang = core.lang;
      const dialog6 = core.util.createElement("DIV");
      dialog6.className = "se-dialog-content";
      dialog6.style.display = "none";
      let html = '<form method="post" enctype="multipart/form-data"><div class="se-dialog-header"><button type="button" data-command="close" class="se-btn se-dialog-close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + core.icons.cancel + '</button><span class="se-modal-title">' + lang.dialogBox.audioBox.title + '</span></div><div class="se-dialog-body">';
      if (option.audioFileInput) {
        html += '<div class="se-dialog-form"><label>' + lang.dialogBox.audioBox.file + '</label><div class="se-dialog-form-files"><input class="se-input-form _se_audio_files" type="file" accept="' + option.audioAccept + '"' + (option.audioMultipleFile ? ' multiple="multiple"' : "") + '/><button type="button" data-command="filesRemove" class="se-btn se-dialog-files-edge-button se-file-remove" title="' + lang.controller.remove + '" aria-label="' + lang.controller.remove + '">' + core.icons.cancel + "</button></div></div>";
      }
      if (option.audioUrlInput) {
        html += '<div class="se-dialog-form"><label>' + lang.dialogBox.audioBox.url + '</label><input class="se-input-form se-input-url" type="text" /><pre class="se-link-preview"></pre></div>';
      }
      html += '</div><div class="se-dialog-footer"><button type="submit" class="se-btn-primary" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '"><span>' + lang.dialogBox.submitButton + "</span></button></div></form>";
      dialog6.innerHTML = html;
      return dialog6;
    },
    /** HTML - controller */
    setController: function(core) {
      const lang = core.lang;
      const icons = core.icons;
      const link_btn = core.util.createElement("DIV");
      link_btn.className = "se-controller se-controller-link";
      link_btn.innerHTML = '<div class="se-arrow se-arrow-up"></div><div class="link-content"><div class="se-btn-group"><button type="button" data-command="update" tabindex="-1" class="se-tooltip">' + icons.edit + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.edit + '</span></span></button><button type="button" data-command="delete" tabindex="-1" class="se-tooltip">' + icons.delete + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.remove + "</span></span></button></div></div>";
      return link_btn;
    },
    // Disable url input when uploading files
    _fileInputChange: function() {
      if (!this.audioInputFile.value) {
        this.audioUrlFile.removeAttribute("disabled");
        this.preview.style.textDecoration = "";
      } else {
        this.audioUrlFile.setAttribute("disabled", true);
        this.preview.style.textDecoration = "line-through";
      }
    },
    // Disable url input when uploading files
    _removeSelectedFiles: function(urlInput, preview) {
      this.value = "";
      if (urlInput) {
        urlInput.removeAttribute("disabled");
        preview.style.textDecoration = "";
      }
    },
    // create new audio tag
    _createAudioTag: function() {
      const oAudio = this.util.createElement("AUDIO");
      this.plugins.audio._setTagAttrs.call(this, oAudio);
      const w = this.context.audio._origin_w;
      const h = this.context.audio._origin_h;
      oAudio.setAttribute("origin-size", w + "," + h);
      oAudio.style.cssText = (w ? "width:" + w + "; " : "") + (h ? "height:" + h + ";" : "");
      return oAudio;
    },
    _setTagAttrs: function(element) {
      element.setAttribute("controls", true);
      const attrs = this.options.audioTagAttrs;
      if (!attrs) return;
      for (let key in attrs) {
        if (!this.util.hasOwn(attrs, key)) continue;
        element.setAttribute(key, attrs[key]);
      }
    },
    _onLinkPreview: function(context, protocol, e) {
      const value = e.target.value.trim();
      context._linkValue = this.textContent = !value ? "" : protocol && value.indexOf("://") === -1 && value.indexOf("#") !== 0 ? protocol + value : value.indexOf("://") === -1 ? "/" + value : value;
    },
    /**
     * @Required @Override fileManager
     */
    fileTags: ["audio"],
    /**
     * @Override core, fileManager, resizing
     * @description It is called from core.selectComponent.
     * @param {Element} element Target element
     */
    select: function(element) {
      this.plugins.audio.onModifyMode.call(this, element);
    },
    /**
     * @Override fileManager, resizing 
     */
    destroy: function(element) {
      element = element || this.context.audio._element;
      const container = this.util.getParentElement(element, this.util.isComponent) || element;
      const dataIndex = element.getAttribute("data-index") * 1;
      if (typeof this.functions.onAudioDeleteBefore === "function" && this.functions.onAudioDeleteBefore(element, container, dataIndex, this) === false) return;
      const focusEl = container.previousElementSibling || container.nextElementSibling;
      const emptyDiv = container.parentNode;
      this.util.removeItem(container);
      this.plugins.audio.init.call(this);
      this.controllersOff();
      if (emptyDiv !== this.context.element.wysiwyg) this.util.removeItemAllParents(emptyDiv, function(current) {
        return current.childNodes.length === 0;
      }, null);
      this.focusEdge(focusEl);
      this.plugins.fileManager.deleteInfo.call(this, "audio", dataIndex, this.functions.onAudioUpload);
      this.history.push(false);
    },
    /**
     * @Override fileManager
     */
    checkFileInfo: function() {
      this.plugins.fileManager.checkInfo.call(this, "audio", ["audio"], this.functions.onAudioUpload, this.plugins.audio.updateCover.bind(this), false);
    },
    /**
     * @Override fileManager
     */
    resetFileInfo: function() {
      this.plugins.fileManager.resetInfo.call(this, "audio", this.functions.onAudioUpload);
    },
    /**
     * @Required @Override dialog
     */
    on: function(update) {
      const contextAudio = this.context.audio;
      if (!update) {
        this.plugins.audio.init.call(this);
        if (contextAudio.audioInputFile && this.options.audioMultipleFile) contextAudio.audioInputFile.setAttribute("multiple", "multiple");
      } else if (contextAudio._element) {
        this.context.dialog.updateModal = true;
        contextAudio._linkValue = contextAudio.preview.textContent = contextAudio.audioUrlFile.value = contextAudio._element.src;
        if (contextAudio.audioInputFile && this.options.audioMultipleFile) contextAudio.audioInputFile.removeAttribute("multiple");
      } else {
        if (contextAudio.audioInputFile && this.options.audioMultipleFile) contextAudio.audioInputFile.removeAttribute("multiple");
      }
    },
    /**
     * @Required @Override dialog
     */
    open: function() {
      this.plugins.dialog.open.call(this, "audio", "audio" === this.currentControllerName);
    },
    submit: function(e) {
      const contextAudio = this.context.audio;
      e.preventDefault();
      e.stopPropagation();
      try {
        if (contextAudio.audioInputFile && contextAudio.audioInputFile.files.length > 0) {
          this.showLoading();
          this.plugins.audio.submitAction.call(this, contextAudio.audioInputFile.files);
        } else if (contextAudio.audioUrlFile && contextAudio._linkValue.length > 0) {
          this.showLoading();
          this.plugins.audio.setupUrl.call(this, contextAudio._linkValue);
        }
      } catch (error) {
        this.closeLoading();
        throw Error('[SUNEDITOR.audio.submit.fail] cause : "' + error.message + '"');
      } finally {
        this.plugins.dialog.close.call(this);
      }
      return false;
    },
    submitAction: function(fileList) {
      if (fileList.length === 0) return;
      let fileSize = 0;
      let files = [];
      for (let i = 0, len = fileList.length; i < len; i++) {
        if (/audio/i.test(fileList[i].type)) {
          files.push(fileList[i]);
          fileSize += fileList[i].size;
        }
      }
      const limitSize = this.options.audioUploadSizeLimit;
      if (limitSize > 0) {
        let infoSize = 0;
        const audiosInfo = this.context.audio._infoList;
        for (let i = 0, len = audiosInfo.length; i < len; i++) {
          infoSize += audiosInfo[i].size * 1;
        }
        if (fileSize + infoSize > limitSize) {
          this.closeLoading();
          const err = "[SUNEDITOR.audioUpload.fail] Size of uploadable total audios: " + limitSize / 1e3 + "KB";
          if (typeof this.functions.onAudioUploadError !== "function" || this.functions.onAudioUploadError(err, { "limitSize": limitSize, "currentSize": infoSize, "uploadSize": fileSize }, this)) {
            this.functions.noticeOpen(err);
          }
          return;
        }
      }
      const contextAudio = this.context.audio;
      contextAudio._uploadFileLength = files.length;
      const info = {
        isUpdate: this.context.dialog.updateModal,
        element: contextAudio._element
      };
      if (typeof this.functions.onAudioUploadBefore === "function") {
        const result = this.functions.onAudioUploadBefore(files, info, this, function(data2) {
          if (data2 && this._w.Array.isArray(data2.result)) {
            this.plugins.audio.register.call(this, info, data2);
          } else {
            this.plugins.audio.upload.call(this, info, data2);
          }
        }.bind(this));
        if (typeof result === "undefined") return;
        if (!result) {
          this.closeLoading();
          return;
        }
        if (typeof result === "object" && result.length > 0) files = result;
      }
      this.plugins.audio.upload.call(this, info, files);
    },
    error: function(message, response) {
      this.closeLoading();
      if (typeof this.functions.onAudioUploadError !== "function" || this.functions.onAudioUploadError(message, response, this)) {
        this.functions.noticeOpen(message);
        throw Error("[SUNEDITOR.plugin.audio.exception] response: " + message);
      }
    },
    upload: function(info, files) {
      if (!files) {
        this.closeLoading();
        return;
      }
      if (typeof files === "string") {
        this.plugins.audio.error.call(this, files, null);
        return;
      }
      const audioUploadUrl = this.options.audioUploadUrl;
      const filesLen = this.context.dialog.updateModal ? 1 : files.length;
      const formData = new FormData();
      for (let i = 0; i < filesLen; i++) {
        formData.append("file-" + i, files[i]);
      }
      this.plugins.fileManager.upload.call(this, audioUploadUrl, this.options.audioUploadHeader, formData, this.plugins.audio.callBack_upload.bind(this, info), this.functions.onAudioUploadError);
    },
    callBack_upload: function(info, xmlHttp) {
      if (typeof this.functions.audioUploadHandler === "function") {
        this.functions.audioUploadHandler(xmlHttp, info, this);
      } else {
        const response = JSON.parse(xmlHttp.responseText);
        if (response.errorMessage) {
          this.plugins.audio.error.call(this, response.errorMessage, response);
        } else {
          this.plugins.audio.register.call(this, info, response);
        }
      }
    },
    register: function(info, response) {
      const fileList = response.result;
      for (let i = 0, len = fileList.length, file, oAudio; i < len; i++) {
        if (info.isUpdate) oAudio = info.element;
        else oAudio = this.plugins.audio._createAudioTag.call(this);
        file = { name: fileList[i].name, size: fileList[i].size };
        this.plugins.audio.create_audio.call(this, oAudio, fileList[i].url, file, info.isUpdate);
      }
      this.closeLoading();
    },
    setupUrl: function(src) {
      try {
        if (src.length === 0) return false;
        this.plugins.audio.create_audio.call(this, this.plugins.audio._createAudioTag.call(this), src, null, this.context.dialog.updateModal);
      } catch (error) {
        throw Error('[SUNEDITOR.audio.audio.fail] cause : "' + error.message + '"');
      } finally {
        this.closeLoading();
      }
    },
    create_audio: function(element, src, file, isUpdate) {
      const contextAudio = this.context.audio;
      if (!isUpdate) {
        element.src = src;
        const cover = this.plugins.component.set_cover.call(this, element);
        const container = this.plugins.component.set_container.call(this, cover, "");
        if (!this.insertComponent(container, false, true, !this.options.mediaAutoSelect)) {
          this.focus();
          return;
        }
        if (!this.options.mediaAutoSelect) {
          const line = this.appendFormatTag(container, null);
          if (line) this.setRange(line, 0, line, 0);
        }
      } else {
        if (contextAudio._element) element = contextAudio._element;
        if (element && element.src !== src) {
          element.src = src;
          this.selectComponent(element, "audio");
        } else {
          this.selectComponent(element, "audio");
          return;
        }
      }
      this.plugins.fileManager.setInfo.call(this, "audio", element, this.functions.onAudioUpload, file, false);
      if (isUpdate) this.history.push(false);
    },
    updateCover: function(element) {
      const contextAudio = this.context.audio;
      this.plugins.audio._setTagAttrs.call(this, element);
      let existElement = this.util.isRangeFormatElement(element.parentNode) || this.util.isWysiwygDiv(element.parentNode) ? element : this.util.getFormatElement(element) || element;
      const prevElement = element;
      contextAudio._element = element = element.cloneNode(false);
      const cover = this.plugins.component.set_cover.call(this, element);
      const container = this.plugins.component.set_container.call(this, cover, "se-audio-container");
      try {
        if (this.util.getParentElement(prevElement, this.util.isNotCheckingNode)) {
          prevElement.parentNode.replaceChild(container, prevElement);
        } else if (this.util.isListCell(existElement)) {
          const refer = this.util.getParentElement(prevElement, function(current) {
            return current.parentNode === existElement;
          });
          existElement.insertBefore(container, refer);
          this.util.removeItem(prevElement);
          this.util.removeEmptyNode(refer, null, true);
        } else if (this.util.isFormatElement(existElement)) {
          const refer = this.util.getParentElement(prevElement, function(current) {
            return current.parentNode === existElement;
          });
          existElement = this.util.splitElement(existElement, refer);
          existElement.parentNode.insertBefore(container, existElement);
          this.util.removeItem(prevElement);
          this.util.removeEmptyNode(existElement, null, true);
          if (existElement.children.length === 0) existElement.innerHTML = this.util.htmlRemoveWhiteSpace(existElement.innerHTML);
        } else {
          existElement.parentNode.replaceChild(container, existElement);
        }
      } catch (error) {
        console.warn("[SUNEDITOR.audio.error] Maybe the audio tag is nested.", error);
      }
      this.plugins.fileManager.setInfo.call(this, "audio", element, this.functions.onAudioUpload, null, false);
      this.plugins.audio.init.call(this);
    },
    /**
     * @Required @Override fileManager, resizing
     */
    onModifyMode: function(selectionTag) {
      const contextAudio = this.context.audio;
      this.setControllerPosition(contextAudio.controller, selectionTag, "bottom", { left: 0, top: 0 });
      this.controllersOn(contextAudio.controller, selectionTag, this.plugins.audio.onControllerOff.bind(this, selectionTag), "audio");
      this.util.addClass(selectionTag, "active");
      contextAudio._element = selectionTag;
      contextAudio._cover = this.util.getParentElement(selectionTag, "FIGURE");
      contextAudio._container = this.util.getParentElement(selectionTag, this.util.isComponent);
    },
    /**
     * @Required @Override fileManager, resizing
     */
    openModify: function(notOpen) {
      if (this.context.audio.audioUrlFile) {
        const contextAudio = this.context.audio;
        contextAudio._linkValue = contextAudio.preview.textContent = contextAudio.audioUrlFile.value = contextAudio._element.src;
      }
      if (!notOpen) this.plugins.dialog.open.call(this, "audio", true);
    },
    onClick_controller: function(e) {
      e.stopPropagation();
      const command = e.target.getAttribute("data-command");
      if (!command) return;
      e.preventDefault();
      if (/update/.test(command)) {
        this.plugins.audio.openModify.call(this, false);
      } else {
        this.plugins.audio.destroy.call(this, this.context.audio._element);
      }
      this.controllersOff();
    },
    onControllerOff: function(selectionTag) {
      this.util.removeClass(selectionTag, "active");
      this.context.audio.controller.style.display = "none";
    },
    /**
     * @Required @Override dialog
     */
    init: function() {
      if (this.context.dialog.updateModal) return;
      const contextAudio = this.context.audio;
      if (contextAudio.audioInputFile) contextAudio.audioInputFile.value = "";
      if (contextAudio.audioUrlFile) contextAudio._linkValue = contextAudio.preview.textContent = contextAudio.audioUrlFile.value = "";
      if (contextAudio.audioInputFile && contextAudio.audioUrlFile) {
        contextAudio.audioUrlFile.removeAttribute("disabled");
        contextAudio.preview.style.textDecoration = "";
      }
      contextAudio._element = null;
    }
  };

  // ../../node_modules/suneditor/src/plugins/dialog/math.js
  var import_dialog5 = __toESM(require_dialog());
  var KATEX_WEBSITE = "https://katex.org/docs/supported.html";
  var math_default = {
    name: "math",
    display: "dialog",
    add: function(core) {
      core.addModule([import_dialog5.default]);
      const context = core.context;
      context.math = {
        focusElement: null,
        // @Override dialog // This element has focus when the dialog is opened.
        previewElement: null,
        fontSizeElement: null,
        defaultFontSize: "",
        _mathExp: null
      };
      let math_dialog = this.setDialog(core);
      context.math.modal = math_dialog;
      context.math.focusElement = math_dialog.querySelector(".se-math-exp");
      context.math.previewElement = math_dialog.querySelector(".se-math-preview");
      context.math.fontSizeElement = math_dialog.querySelector(".se-math-size");
      context.math.focusElement.addEventListener("paste", function(e) {
        if (typeof core.functions.onPasteMath === "function") {
          core.functions.onPasteMath(e, core);
        }
      }, false);
      context.math.focusElement.addEventListener(core.util.isIE ? "textinput" : "input", this._renderMathExp.bind(core, context.math), false);
      context.math.fontSizeElement.addEventListener("change", function(e) {
        this.fontSize = e.target.value;
      }.bind(context.math.previewElement.style), false);
      let math_controller = this.setController_MathButton(core);
      context.math.mathController = math_controller;
      context.math._mathExp = null;
      math_dialog.querySelector("form").addEventListener("submit", this.submit.bind(core), false);
      math_controller.addEventListener("click", this.onClick_mathController.bind(core));
      context.math.previewElement.style.fontSize = context.math.defaultFontSize;
      context.dialog.modal.appendChild(math_dialog);
      context.element.relative.appendChild(math_controller);
      math_dialog = null, math_controller = null;
    },
    /** dialog */
    setDialog: function(core) {
      const lang = core.lang;
      const dialog6 = core.util.createElement("DIV");
      const fontSize = core.options.mathFontSize;
      let defaultFontSize = fontSize[0].value;
      dialog6.className = "se-dialog-content";
      dialog6.style.display = "none";
      let html = '<form><div class="se-dialog-header"><button type="button" data-command="close" class="se-btn se-dialog-close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + core.icons.cancel + '</button><span class="se-modal-title">' + lang.dialogBox.mathBox.title + '</span></div><div class="se-dialog-body"><div class="se-dialog-form"><label>' + lang.dialogBox.mathBox.inputLabel + ' (<a href="' + KATEX_WEBSITE + '" target="_blank">KaTeX</a>)</label><textarea class="se-input-form se-math-exp" type="text"></textarea></div><div class="se-dialog-form"><label>' + lang.dialogBox.mathBox.fontSizeLabel + '</label><select class="se-input-select se-math-size">';
      for (let i = 0, len = fontSize.length, f; i < len; i++) {
        f = fontSize[i];
        if (f.default) defaultFontSize = f.value;
        html += '<option value="' + f.value + '"' + (f.default ? " selected" : "") + ">" + f.text + "</option>";
      }
      html += '</select></div><div class="se-dialog-form"><label>' + lang.dialogBox.mathBox.previewLabel + '</label><p class="se-math-preview"></p></div></div><div class="se-dialog-footer"><button type="submit" class="se-btn-primary" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '"><span>' + lang.dialogBox.submitButton + "</span></button></div></form>";
      core.context.math.defaultFontSize = defaultFontSize;
      dialog6.innerHTML = html;
      return dialog6;
    },
    /** modify controller button */
    setController_MathButton: function(core) {
      const lang = core.lang;
      const math_btn = core.util.createElement("DIV");
      math_btn.className = "se-controller se-controller-link";
      math_btn.innerHTML = '<div class="se-arrow se-arrow-up"></div><div class="link-content"><div class="se-btn-group"><button type="button" data-command="update" tabindex="-1" class="se-btn se-tooltip">' + core.icons.edit + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.edit + '</span></span></button><button type="button" data-command="delete" tabindex="-1" class="se-btn se-tooltip">' + core.icons.delete + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.remove + "</span></span></button></div></div>";
      return math_btn;
    },
    /**
     * @Required @Override dialog
     */
    open: function() {
      this.plugins.dialog.open.call(this, "math", "math" === this.currentControllerName);
    },
    /**
     * @Override core - managedTagsInfo
     */
    managedTags: function() {
      return {
        className: "katex",
        method: function(element) {
          if (!element.getAttribute("data-exp") || !this.options.katex) return;
          const dom = this._d.createRange().createContextualFragment(this.plugins.math._renderer.call(this, this.util.HTMLDecoder(element.getAttribute("data-exp"))));
          element.innerHTML = dom.querySelector(".katex").innerHTML;
          element.setAttribute("contenteditable", false);
        }
      };
    },
    _renderer: function(exp) {
      let result = "";
      try {
        this.util.removeClass(this.context.math.focusElement, "se-error");
        result = this.options.katex.src.renderToString(exp, { throwOnError: true, displayMode: true });
      } catch (error) {
        this.util.addClass(this.context.math.focusElement, "se-error");
        result = '<span class="se-math-katex-error">Katex syntax error. (Refer <a href="' + KATEX_WEBSITE + '" target="_blank">KaTeX</a>)</span>';
        console.warn("[SUNEDITOR.math.Katex.error] ", error);
      }
      return result;
    },
    _renderMathExp: function(contextMath, e) {
      contextMath.previewElement.innerHTML = this.plugins.math._renderer.call(this, e.target.value);
    },
    submit: function(e) {
      this.showLoading();
      e.preventDefault();
      e.stopPropagation();
      const submitAction = function() {
        if (this.context.math.focusElement.value.trim().length === 0) return false;
        const contextMath = this.context.math;
        const mathExp = contextMath.focusElement.value;
        const katexEl = contextMath.previewElement.querySelector(".katex");
        if (!katexEl) return false;
        katexEl.className = "__se__katex " + katexEl.className;
        katexEl.setAttribute("contenteditable", false);
        katexEl.setAttribute("data-exp", this.util.HTMLEncoder(mathExp));
        katexEl.setAttribute("data-font-size", contextMath.fontSizeElement.value);
        katexEl.style.fontSize = contextMath.fontSizeElement.value;
        if (!this.context.dialog.updateModal) {
          const selectedFormats = this.getSelectedElements();
          if (selectedFormats.length > 1) {
            const oFormat = this.util.createElement(selectedFormats[0].nodeName);
            oFormat.appendChild(katexEl);
            if (!this.insertNode(oFormat, null, true)) return false;
          } else {
            if (!this.insertNode(katexEl, null, true)) return false;
          }
          const empty = this.util.createTextNode(this.util.zeroWidthSpace);
          katexEl.parentNode.insertBefore(empty, katexEl.nextSibling);
          this.setRange(katexEl, 0, katexEl, 1);
        } else {
          const containerEl = this.util.getParentElement(contextMath._mathExp, ".katex");
          containerEl.parentNode.replaceChild(katexEl, containerEl);
          this.setRange(katexEl, 0, katexEl, 1);
        }
        contextMath.focusElement.value = "";
        contextMath.fontSizeElement.value = "1em";
        contextMath.previewElement.style.fontSize = "1em";
        contextMath.previewElement.innerHTML = "";
        return true;
      }.bind(this);
      try {
        if (submitAction()) {
          this.plugins.dialog.close.call(this);
          this.history.push(false);
        }
      } catch (e2) {
        this.plugins.dialog.close.call(this);
      } finally {
        this.closeLoading();
      }
      return false;
    },
    active: function(element) {
      if (!element) {
        if (this.controllerArray.indexOf(this.context.math.mathController) > -1) {
          this.controllersOff();
        }
      } else if (element.getAttribute("data-exp")) {
        if (this.controllerArray.indexOf(this.context.math.mathController) < 0) {
          this.setRange(element, 0, element, 1);
          this.plugins.math.call_controller.call(this, element);
        }
        return true;
      }
      return false;
    },
    on: function(update) {
      if (!update) {
        this.plugins.math.init.call(this);
      } else {
        const contextMath = this.context.math;
        if (contextMath._mathExp) {
          const exp = this.util.HTMLDecoder(contextMath._mathExp.getAttribute("data-exp"));
          const fontSize = contextMath._mathExp.getAttribute("data-font-size") || "1em";
          this.context.dialog.updateModal = true;
          contextMath.focusElement.value = exp;
          contextMath.fontSizeElement.value = fontSize;
          contextMath.previewElement.innerHTML = this.plugins.math._renderer.call(this, exp);
          contextMath.previewElement.style.fontSize = fontSize;
        }
      }
    },
    call_controller: function(mathTag) {
      this.context.math._mathExp = mathTag;
      const mathBtn = this.context.math.mathController;
      this.setControllerPosition(mathBtn, mathTag, "bottom", { left: 0, top: 0 });
      this.controllersOn(mathBtn, mathTag, "math");
    },
    onClick_mathController: function(e) {
      e.stopPropagation();
      const command = e.target.getAttribute("data-command") || e.target.parentNode.getAttribute("data-command");
      if (!command) return;
      e.preventDefault();
      if (/update/.test(command)) {
        this.context.math.focusElement.value = this.util.HTMLDecoder(this.context.math._mathExp.getAttribute("data-exp"));
        this.plugins.dialog.open.call(this, "math", true);
      } else {
        this.util.removeItem(this.context.math._mathExp);
        this.context.math._mathExp = null;
        this.focus();
        this.history.push(false);
      }
      this.controllersOff();
    },
    init: function() {
      const contextMath = this.context.math;
      contextMath.mathController.style.display = "none";
      contextMath._mathExp = null;
      contextMath.focusElement.value = "";
      contextMath.previewElement.innerHTML = "";
    }
  };

  // ../../node_modules/suneditor/src/plugins/fileBrowser/imageGallery.js
  var import_fileBrowser = __toESM(require_fileBrowser());
  var imageGallery_default = {
    name: "imageGallery",
    /**
     * @description Constructor
     * @param {Object} core Core object 
     */
    add: function(core) {
      core.addModule([import_fileBrowser.default]);
      const context = core.context;
      context.imageGallery = {
        title: core.lang.toolbar.imageGallery,
        // @Required @Override fileBrowser - File browser window title.
        url: core.options.imageGalleryUrl,
        // @Required @Override fileBrowser - File server url.
        header: core.options.imageGalleryHeader,
        // @Required @Override fileBrowser - File server http header.
        listClass: "se-image-list",
        // @Required @Override fileBrowser - Class name of list div.
        itemTemplateHandler: this.drawItems,
        // @Required @Override fileBrowser - Function that defines the HTML of an file item.
        selectorHandler: this.setImage.bind(core),
        // @Required @Override fileBrowser - Function that action when item click.
        columnSize: 4
        // @Option @Override fileBrowser - Number of "div.se-file-item-column" to be created (default: 4)
      };
    },
    /**
     * @Required @Override fileBrowser
     * @description Open a file browser.
     * @param {Function|null} selectorHandler When the function comes as an argument value, it substitutes "context.selectorHandler".
     */
    open: function(selectorHandler) {
      this.plugins.fileBrowser.open.call(this, "imageGallery", selectorHandler);
    },
    /**
     * @Required @Override fileBrowser
     * @description Define the HTML of the item to be put in "div.se-file-item-column".
     * Format: [
     *      { src: "image src", name: "name(@option)", alt: "image alt(@option)", tag: "tag name(@option)" }
     * ]
     * @param {Object} item Item of the response data's array
     */
    drawItems: function(item) {
      const srcName = item.src.split("/").pop();
      return '<div class="se-file-item-img"><img src="' + (item.thumbnail || item.src) + '" alt="' + (item.alt || srcName) + '" data-command="pick" data-value="' + (item.src || item.thumbnail) + '"><div class="se-file-img-name se-file-name-back"></div><div class="se-file-img-name __se__img_name">' + (item.name || srcName) + "</div></div>";
    },
    setImage: function(target, fileName) {
      this.callPlugin("image", function() {
        const file = { name: fileName, size: 0 };
        this.plugins.image.create_image.call(this, target.getAttribute("data-value"), null, this.context.image._origin_w, this.context.image._origin_h, "none", file, target.alt);
      }.bind(this), null);
    }
  };

  // ../../node_modules/suneditor/src/plugins/index.js
  var plugins_default = { blockquote: blockquote_default, align: align_default, font: font_default, fontSize: fontSize_default, fontColor: fontColor_default, hiliteColor: hiliteColor_default, horizontalRule: horizontalRule_default, list: list_default, table: table_default, formatBlock: formatBlock_default, lineHeight: lineHeight_default, template: template_default, paragraphStyle: paragraphStyle_default, textStyle: textStyle_default, link: link_default, image: image_default, video: video_default, audio: audio_default, math: math_default, imageGallery: imageGallery_default };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\wysiwyg.ink
  var import_StyleSet11 = __toESM(require_StyleSet());
  var import_display3 = __toESM(require_display());
  var Wysiwyg_7e3499be9641069413db = class extends import_Component16.default {
    static id = "7e3499be9641069413db";
    static tagname = "wysiwyg";
    static classname = "Wysiwyg_7e3499be9641069413db";
    styles() {
      return `.sun-editor {width:auto; height:auto; box-sizing:border-box; font-family:Helvetica Neue; border:1px solid #dadada; background-color:#FFF; color:#000; user-select:none; -o-user-select:none; -moz-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -ms-user-select:none;}
  .sun-editor * {box-sizing:border-box;  -webkit-user-drag:none; overflow:visible;}
  .sun-editor-common input, .sun-editor-common select, .sun-editor-common textarea, .sun-editor-common button {font-size:14px; line-height:1.5;}
  .sun-editor-common body, .sun-editor-common div, .sun-editor-common dl, .sun-editor-common dt, .sun-editor-common dd, .sun-editor-common ul, .sun-editor-common ol, .sun-editor-common li,
  .sun-editor-common h1, .sun-editor-common h2, .sun-editor-common h3, .sun-editor-common h4, .sun-editor-common h5, .sun-editor-common h6, .sun-editor-common pre, .sun-editor-common code,
  .sun-editor-common form, .sun-editor-common fieldset, .sun-editor-common legend, .sun-editor-common textarea, .sun-editor-common p, .sun-editor-common blockquote, .sun-editor-common th,
  .sun-editor-common td, .sun-editor-common input, .sun-editor-common select, .sun-editor-common textarea, .sun-editor-common button {margin:0; padding:0; border:0;}
  .sun-editor-common dl, .sun-editor-common ul, .sun-editor-common ol, .sun-editor-common menu, .sun-editor-common li {list-style:none !important;}
  .sun-editor-common hr {margin:6px 0 6px 0 !important;}
  .sun-editor textarea {resize:none; border:0; padding:0;}
  .sun-editor button {border:0 none; background-color:transparent; touch-action:manipulation; cursor:pointer; outline:none;}
  .sun-editor input, .sun-editor select, .sun-editor textarea, .sun-editor button {vertical-align:middle;}
  .sun-editor button span {display:block; margin:0; padding:0;}
  .sun-editor button .txt {display:block; margin-top:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  .sun-editor button * {
    pointer-events: none;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
    -moz-backface-visibility: hidden;
  }
  .sun-editor svg {
    fill: currentColor;
  }
  .sun-editor button > svg, .sun-editor .se-svg {
    width: 16px;
    height: 16px;
    margin: auto;
    fill: currentColor;
    display: block;
    text-align: center;
    float: none;
  }
  .sun-editor .close > svg, .sun-editor .se-dialog-close > svg {
    width: 10px;
    height: 10px;
  }
  .sun-editor .se-btn-select > svg {
    float: right;
    width: 10px;
    height: 10px;
  }
  .sun-editor .se-btn-list > .se-list-icon {
    display: inline-block;
    width: 16px;
    height: 16px;
    margin: -1px 10px 0 0;
    vertical-align: middle;
  }
  .sun-editor .se-line-breaker > button > svg {
    width: 24px;
    height: 24px;
  }
  .sun-editor button > i::before {
    -moz-osx-font-smoothing:grayscale;
    -webkit-font-smoothing:antialiased;
    display: inline-block;
    font-style: normal;
    font-variant: normal;
    text-rendering:auto;
    font-size: 15px;
    line-height: 2;
  }
  .sun-editor button > [class="se-icon-text"] {
    font-size: 20px;
    line-height: 1;
  }
  .sun-editor .se-arrow, .sun-editor .se-arrow::after {position:absolute; display:block; width:0; height:0; border:11px solid transparent;}
  .sun-editor .se-arrow.se-arrow-up {top:-11px; left:20px; margin-left:-11px; border-top-width:0; border-bottom-color:#dadada;}
  .sun-editor .se-arrow.se-arrow-up::after {top:1px; margin-left:-11px; content:" "; border-top-width:0; border-bottom-color:#fff;}
  .sun-editor .se-toolbar .se-arrow.se-arrow-up::after {border-bottom-color:#fafafa;}
  .sun-editor .se-arrow.se-arrow-down {top:0px; left:0px; margin-left:-11px; border-bottom-width:0; border-top-color:#dadada;}
  .sun-editor .se-arrow.se-arrow-down::after {top:-12px; margin-left:-11px; content:" "; border-bottom-width:0; border-top-color:#fff;}
  .sun-editor .se-toolbar .se-arrow.se-arrow-down::after {border-top-color:#fafafa;}
  .sun-editor .se-container {position:relative; width:auto; height:auto;}
  .sun-editor button {color:#000;}
  .sun-editor .se-btn {float:left; width:34px; height:34px; border:0; border-radius:4px; margin:1px !important; padding:0; font-size:12px; line-height:27px;}
  .sun-editor .se-btn:enabled:hover, .sun-editor .se-btn:enabled:focus {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-btn:enabled:active {background-color:#d1d1d1; border-color:#c1c1c1; -webkit-box-shadow:inset 0 3px 5px #c1c1c1; box-shadow:inset 0 3px 5px #c1c1c1;}
  .sun-editor .se-btn-primary {color:#000; background-color:#c7deff; border:1px solid #80bdff; border-radius:4px;}
  .sun-editor .se-btn-primary:hover, .sun-editor .se-btn-primary:focus {color:#000; background-color:#80bdff; border-color:#3f9dff; outline:0 none;}
  .sun-editor .se-btn-primary:active {color:#fff; background-color:#3f9dff; border-color:#4592ff; -webkit-box-shadow:inset 0 3px 5px #4592ff; box-shadow:inset 0 3px 5px #4592ff;}
  .sun-editor input, .sun-editor select, .sun-editor textarea {color:#000; border:1px solid #ccc; border-radius:4px;}
  .sun-editor input:focus, .sun-editor select:focus, .sun-editor textarea:focus {border:1px solid #80bdff; outline:0; -webkit-box-shadow:0 0 0 0.2rem #c7deff; box-shadow:0 0 0 0.2rem #c7deff; transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out;}
  .sun-editor .se-btn:enabled.active {color:#4592ff; outline:0 none;}
  .sun-editor .se-btn:enabled.active:hover, .sun-editor .se-btn:enabled.active:focus {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-btn:enabled.active:active {background-color:#d1d1d1; border-color:#c1c1c1; -webkit-box-shadow:inset 0 3px 5px #c1c1c1; box-shadow:inset 0 3px 5px #c1c1c1;}
  .sun-editor .se-btn:enabled.on {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-btn:enabled.on:hover, .sun-editor .se-btn:enabled.on:focus {background-color:#d1d1d1; border-color:#c1c1c1; outline:0 none;}
  .sun-editor .se-btn:enabled.on:active {background-color:#c1c1c1; border-color:#b1b1b1; -webkit-box-shadow:inset 0 3px 5px #b1b1b1; box-shadow:inset 0 3px 5px #b1b1b1;}
  .sun-editor .se-btn:disabled, .sun-editor .se-btn-list:disabled, .sun-editor button:disabled {cursor:not-allowed; background-color:inherit; color:#bdbdbd;}
  .sun-editor .se-loading-box {position:absolute; display:none; width:100%; height:100%; top:0; left:0; background-color:#fff; opacity:.7; filter:alpha(opacity=70); z-index:2147483647;}
  .sun-editor .se-loading-box .se-loading-effect {position:absolute; display:block; top:50%; left:50%; height:25px; width:25px; border-top:2px solid #07d; border-right:2px solid transparent; border-radius:50%; animation:spinner .8s linear infinite; margin:-25px 0 0 -25px;}
  .sun-editor .se-line-breaker {position:absolute; display:none; width:100%; height:1px; cursor:text; border-top:1px solid #3288ff; z-index:7;}
  .sun-editor .se-line-breaker > button.se-btn {position:relative; display:inline-block; width:30px; height:30px; top:-15px; float:none; left:-50%; background-color:#fff; border:1px solid #0c2240; opacity:0.6; cursor:pointer;}
  .sun-editor .se-line-breaker > button.se-btn:hover {opacity:0.9; background-color:#fff; border-color:#041b39;}
  .sun-editor .se-line-breaker-component {position:absolute; display:none; width:24px; height:24px; background-color:#fff; border:1px solid #0c2240; opacity:0.6; border-radius:4px; cursor:pointer; z-index:7;}
  .sun-editor .se-line-breaker-component:hover {opacity:0.9;}
  .sun-editor .se-toolbar {display:block; position:relative; height:auto; width:100%; overflow:visible; padding:0; margin:0; background-color:#fafafa; outline:1px solid #dadada; z-index:5;}
  .sun-editor .se-toolbar-shadow {display:block !important; height:0px !important; padding:0 !important; margin:0 !important; background-color:transparent !important;  outline:none !important; border: none !important; z-index:0 !important;}
  .sun-editor .se-toolbar-cover {position:absolute; display:none; font-size:36px; width:100%; height:100%; top:0; left:0; background-color:#fefefe; opacity:.5; filter:alpha(opacity=50); cursor:not-allowed; z-index:4;}
  .sun-editor .se-toolbar-separator-vertical {display:inline-block; height:0px; width:0px; margin:0px; vertical-align:top;}
  .sun-editor .se-toolbar.se-toolbar-inline {display:none; position:absolute; box-shadow:0 3px 9px rgba(0,0,0,.5); -webkit-box-shadow:0 3px 9px rgba(0,0,0,.5);}
  .sun-editor .se-toolbar.se-toolbar-balloon {display:none; position:absolute; z-index:2147483647; width:auto; box-shadow:0 3px 9px rgba(0,0,0,.5); -webkit-box-shadow:0 3px 9px rgba(0,0,0,.5);}
  .sun-editor .se-toolbar.se-toolbar-sticky {position:fixed; top:0px;}
  .sun-editor .se-toolbar-sticky-dummy {display:none; position:static; z-index:-1;}
  .sun-editor .se-btn-module {display:inline-block;}
  .sun-editor .se-btn-module-border {border:1px solid #dadada; border-radius:4px; margin-left:1px; margin-right:1px;}
  .sun-editor .se-btn-module-enter {display:block; width:100%; height:0px; margin:0; padding:0; background-color:transparent;}
  .sun-editor .se-toolbar-more-layer {margin:0 -3px; background-color:#fafafa;}
  .sun-editor .se-toolbar-more-layer .se-more-layer {display:none;  border-top:1px solid #dadada;}
  .sun-editor .se-toolbar-more-layer .se-more-layer .se-more-form {display:inline-block; width:100%; height:auto; padding:4px 3px 0 3px;}
  .sun-editor .se-btn-module .se-btn-more.se-btn-more-text {width:auto; padding:0 4px;}
  .sun-editor .se-btn-module .se-btn-more:hover, .sun-editor .se-btn-module .se-btn-more:focus {color:#000; background-color:#d1d1d1; border-color:#c1c1c1; outline:0 none;}
  .sun-editor .se-btn-module .se-btn-more.on {color:#333; background-color:#d1d1d1; border-color:#c1c1c1; outline:0 none;}
  .sun-editor .se-btn-module .se-btn-more.on:hover {color:#000; background-color:#c1c1c1; border-color:#b1b1b1; outline:0 none;}
  .sun-editor .se-menu-list {float:left; padding:0; margin:0;}
  .sun-editor .se-menu-list li {position:relative; float:left; padding:0; margin:0;}
  .sun-editor .se-btn-select {width:auto; display:flex; padding:4px 6px;}
  .sun-editor .se-btn-select .txt {flex:auto; text-align:left;}
  .sun-editor .se-btn-select.se-btn-tool-font {width:100px;}
  .sun-editor .se-btn-select.se-btn-tool-format {width:82px;}
  .sun-editor .se-btn-select.se-btn-tool-size {width:78px;}
  .sun-editor .se-btn-tray {position:relative; width:100%; height:auto; padding:4px 3px 0 3px; margin:0;}
  .sun-editor .se-menu-tray {position:absolute; top:0px; left:0px; width:100%; height:0px;}
  .sun-editor .se-submenu {overflow-x:hidden; overflow-y:auto;}
  .sun-editor .se-menu-container {overflow-x:unset; overflow-y:unset;}
  .sun-editor .se-list-layer {display:none; position:absolute; top:0px; left:0px; height:auto; z-index:5; border:1px solid #bababa; border-radius:4px; padding:6px 0; background-color:#fff; -webkit-box-shadow:0 3px 9px rgba(0, 0, 0, .5); box-shadow:0 3px 9px rgba(0, 0, 0, .5); outline:0 none;}
  .sun-editor .se-list-layer .se-list-inner {padding:0; margin:0; overflow-x:initial; overflow-y:initial; overflow:visible;}
  .sun-editor .se-list-layer button {margin:0; width:100%;}
  .sun-editor .se-list-inner ul {width:100%; padding:0;}
  .sun-editor .se-list-inner li > button {min-width:100%; width:max-content;}
  .sun-editor .se-list-inner .se-list-basic li {width:100%;}
  .sun-editor .se-list-inner .se-list-basic li button.active {background-color:#80bdff; border:1px solid #3f9dff; border-left:0; border-right:0;}
  .sun-editor .se-list-inner .se-list-basic li button.active:hover {background-color:#3f9dff; border:1px solid #4592ff; border-left:0; border-right:0;}
  .sun-editor .se-list-inner .se-list-basic li button.active:active {background-color:#4592ff; border:1px solid #407dd1; border-left:0; border-right:0; -webkit-box-shadow:inset 0 3px 5px #407dd1; box-shadow:inset 0 3px 5px #407dd1;}
  .sun-editor .se-list-inner .se-list-checked li button > .se-svg {float:left; padding:6px 6px 0 0;}
  .sun-editor .se-list-inner .se-list-checked li button > .se-svg > svg {display:none;}
  .sun-editor .se-list-inner .se-list-checked li button.se-checked {color:#4592ff;}
  .sun-editor .se-list-inner .se-list-checked li button.se-checked > .se-svg > svg {display:block;}
  .sun-editor .se-btn-list {width:100%; height:auto; min-height:32px; padding:0 14px; cursor:pointer; font-size:12px; line-height:normal; text-indent:0; text-decoration:none; text-align:left;}
  .sun-editor .se-btn-list.default_value {background-color:#f3f3f3; border-top:1px dotted #b1b1b1; border-bottom:1px dotted #b1b1b1;}
  .sun-editor .se-btn-list:hover, .sun-editor .se-btn-list:focus {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-btn-list:active {background-color:#d1d1d1; border-color:#c1c1c1; -webkit-box-shadow:inset 0 3px 5px #c1c1c1; box-shadow:inset 0 3px 5px #c1c1c1;}
  .sun-editor .se-list-layer.se-list-font-size {min-width:140px; max-height:300px;}
  .sun-editor .se-list-layer.se-list-font-family {min-width:156px;}
  .sun-editor .se-list-layer.se-list-font-family .default {border-bottom:1px solid #CCC;}
  .sun-editor .se-list-layer.se-list-line {width:125px;}
  .sun-editor .se-list-layer.se-list-line hr {border-width: 1px 0 0; height: 1px;}
  .sun-editor .se-list-layer.se-list-align .se-list-inner {left:9px;}
  .sun-editor .se-list-layer.se-list-format {min-width:156px;}
  .sun-editor .se-list-layer.se-list-format li {padding:0; width:100%;}
  .sun-editor .se-list-layer.se-list-format ul .se-btn-list {line-height:100%;}
  .sun-editor .se-list-layer.se-list-format ul .se-btn-list[data-value="h1"] {height:40px;}
  .sun-editor .se-list-layer.se-list-format ul .se-btn-list[data-value="h2"] {height:34px;}
  .sun-editor .se-list-layer.se-list-format ul p {font-size:13px;}
  .sun-editor .se-list-layer.se-list-format ul div {font-size:13px; padding:4px 2px;}
  .sun-editor .se-list-layer.se-list-format ul h1 {font-size:2em; font-weight:bold; color:#333;}
  .sun-editor .se-list-layer.se-list-format ul h2 {font-size:1.5em; font-weight:bold; color:#333;}
  .sun-editor .se-list-layer.se-list-format ul h3 {font-size:1.17em; font-weight:bold; color:#333;}
  .sun-editor .se-list-layer.se-list-format ul h4 {font-size:1em; font-weight:bold; color:#333;}
  .sun-editor .se-list-layer.se-list-format ul h5 {font-size:0.83em; font-weight:bold; color:#333;}
  .sun-editor .se-list-layer.se-list-format ul h6 {font-size:0.67em; font-weight:bold; color:#333;}
  .sun-editor .se-list-layer.se-list-format ul blockquote {font-size:13px; color:#999; height:22px; margin:0; background-color:transparent; line-height:1.5; border-style:solid; border-color:#b1b1b1; padding:0 0 0 7px; border-left-width:5px;}
  .sun-editor .se-list-layer.se-list-format ul pre {font-size:13px; color:#666; padding:4px 11px; margin:0; background-color:#f9f9f9; border:1px solid #e1e1e1; border-radius:4px;}
  .sun-editor .se-selector-table {display:none; position:absolute; top:34px; left:1px; z-index:5; padding:5px 0; float:left; margin:2px 0 0; font-size:14px; text-align:left; list-style:none; background-color:#fff; -webkit-background-clip:padding-box; background-clip:padding-box; border:1px solid #ccc; border-radius:4px; -webkit-box-shadow:0 6px 12px rgba(0, 0, 0, .175); box-shadow:0 6px 12px rgba(0, 0, 0, .175);}
  .sun-editor .se-selector-table .se-table-size {font-size:18px; padding:0 5px;}
  .sun-editor .se-selector-table .se-table-size-picker {position:absolute !important; z-index:3; font-size:18px; width:10em; height:10em; cursor:pointer;}
  .sun-editor .se-selector-table .se-table-size-highlighted {position:absolute !important; z-index:2; font-size:18px; width:1em; height:1em; background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAADJmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4QTZCNzMzN0I3RUYxMUU4ODcwQ0QwMjM1NTgzRTJDNyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4QTZCNzMzNkI3RUYxMUU4ODcwQ0QwMjM1NTgzRTJDNyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0MzYyNEUxRUI3RUUxMUU4ODZGQzgwRjNBODgyNTdFOSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MzYyNEUxRkI3RUUxMUU4ODZGQzgwRjNBODgyNTdFOSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pl0yAuwAAABBSURBVDhPY/wPBAxUAGCDGvdBeWSAeicIDTfIXREiQArYeR9hEBOEohyMGkQYjBpEGAxjg6ib+yFMygCVvMbAAABj0hwMTNeKJwAAAABJRU5ErkJggg==') repeat;}
  .sun-editor .se-selector-table .se-table-size-unhighlighted {position:relative !important; z-index:1; font-size:18px; width:10em; height:10em; background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASAgMAAAAroGbEAAAACVBMVEUAAIj4+Pjp6ekKlAqjAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfYAR0BKhmnaJzPAAAAG0lEQVQI12NgAAOtVatWMTCohoaGUY+EmIkEAEruEzK2J7tvAAAAAElFTkSuQmCC') repeat;}
  .sun-editor .se-selector-table .se-table-size-display {padding-left:5px;}
  .sun-editor .se-list-layer.se-table-split {top:36px;}
  .sun-editor .se-list-layer .se-selector-color {display:flex; width:max-content; max-width:270px; height:auto; padding:0; margin:auto;}
  .sun-editor .se-list-layer .se-selector-color .se-color-pallet {width:100%; height:100%; padding:0;}
  .sun-editor .se-list-layer .se-selector-color .se-color-pallet li {display:flex; float:left; position:relative; margin:0;}
  .sun-editor .se-list-layer .se-selector-color .se-color-pallet button {display:block; cursor:default; width:30px; height:30px; text-indent:-9999px;}
  .sun-editor .se-list-layer .se-selector-color .se-color-pallet button.active, 
  .sun-editor .se-list-layer .se-selector-color .se-color-pallet button:hover, 
  .sun-editor .se-list-layer .se-selector-color .se-color-pallet button:focus {border:3px solid #fff;}
  .sun-editor .se-form-group {display:flex; width:100%; min-height:40px; height:auto; padding:4px;}
  .sun-editor .se-form-group input {flex:auto; display:inline-block; width:auto; height:33px; font-size:12px; margin:1px 0 1px 0; padding:0; border-radius:0.25rem; border:1px solid #ccc;}
  .sun-editor .se-form-group button, .sun-editor .se-submenu-form-group button {float:right; width:34px; height:34px; margin:0 2px !important;}
  .sun-editor .se-form-group button.se-btn, .sun-editor .se-form-group button.se-btn {border:1px solid #ccc;}
  .sun-editor .se-form-group > div {position:relative;}
  .sun-editor .se-form-group label {display:inline-block; max-width:100%; margin-bottom:5px; font-weight:bold;}
  .sun-editor .se-form-group-label {width:100%; height:auto; padding:0px 4px;}
  .sun-editor .se-form-group-label label {font-size:13px; font-weight:bold;}
  .sun-editor .se-submenu .se-form-group input {width:auto; height:33px; color:#555;}
  .sun-editor .se-submenu .se-form-group .se-color-input {width:72px; text-transform:uppercase; border:none; border-bottom:2px solid #b1b1b1; outline:none;}
  .sun-editor .se-submenu .se-form-group .se-color-input:focus {border-bottom:3px solid #b1b1b1;}
  .sun-editor .se-wrapper {position:relative !important; width:100%; height:auto; overflow:hidden; z-index:1;}
  .sun-editor .se-wrapper .se-wrapper-inner {width:100%; height:100%; min-height:65px; overflow-y:auto; overflow-x:auto; -webkit-overflow-scrolling:touch; user-select:auto; -o-user-select:auto; -moz-user-select:auto; -khtml-user-select:auto; -webkit-user-select:auto; -ms-user-select:auto;}
  .sun-editor .se-wrapper .se-wrapper-inner:focus {outline:none;}
  .sun-editor .se-wrapper .se-wrapper-code {background-color:#191919; color:#fff; font-size:13px; word-break:break-all; padding:4px; margin:0; resize:none !important;}
  .sun-editor .se-wrapper .se-wrapper-wysiwyg {display:block;}
  .sun-editor .se-wrapper .se-wrapper-code-mirror {font-size:13px;}
  .sun-editor .se-wrapper .se-placeholder {position:absolute; display:none; white-space:nowrap; text-overflow:ellipsis; z-index:1; color:#b1b1b1; font-size:13px; line-height:1.5; top:0; left:0; right:0; overflow:hidden; margin-top:0px; padding-top:16px; padding-left:16px; margin-left:0px; padding-right:16px; margin-right:0px; pointer-events:none; backface-visibility:hidden; -webkit-backface-visibility:hidden; -moz-backface-visibility:hidden;}
  .sun-editor .se-resizing-bar {display:flex; width:auto; height:auto; min-height:16px; border-top:1px solid #dadada; padding:0 4px; background-color:#fafafa; cursor:ns-resize;}
  .sun-editor .se-resizing-bar.se-resizing-none {cursor:default;}
  .sun-editor .se-resizing-back {position:absolute; display:none; cursor:default; top:0; left:0; width:100%; height:100%; z-index:2147483647;}
  .sun-editor .se-resizing-bar .se-navigation {flex:auto; position:relative; width:auto; height:auto; color:#666; margin:0; padding:0; font-size:10px; line-height:1.5; background:transparent;}
  .sun-editor .se-resizing-bar .se-char-counter-wrapper {flex:none; position:relative; display:block; width:auto; height:auto; margin:0; padding:0; color:#999; font-size:13px; background:transparent;}
  .sun-editor .se-resizing-bar .se-char-counter-wrapper.se-blink {color:#b94a48; animation:blinker 0.2s linear infinite;}
  .sun-editor .se-resizing-bar .se-char-counter-wrapper .se-char-label {margin-right:4px;}
  .sun-editor .se-dialog {position:absolute; display:none; top:0; left:0; width:100%; height:100%; z-index:2147483647;}
  .sun-editor .se-dialog label, .sun-editor .se-dialog input, .sun-editor .se-dialog button {font-size:14px; line-height:1.5; color:#111; margin:0;}
  .sun-editor .se-dialog .se-dialog-back {position:absolute; width:100%; height:100%; top:0; left:0; background-color:#222; opacity:0.5;}
  .sun-editor .se-dialog .se-dialog-inner {position:absolute; width:100%; height:100%; top:0; left:0;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-content {position:relative; width:auto; max-width:500px; margin:1.75rem auto; background-color:#fff; -webkit-background-clip:padding-box; background-clip:padding-box; border:1px solid rgba(0, 0, 0, .2); border-radius:4px; outline:0; -webkit-box-shadow:0 3px 9px rgba(0, 0, 0, .5); box-shadow:0 3px 9px rgba(0, 0, 0, .5);}
  @media screen and (max-width:509px) { .sun-editor .se-dialog .se-dialog-inner .se-dialog-content {width:100%;} }
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-content label {display:inline-block; max-width:100%; margin-bottom:5px; font-weight:bold;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-content .se-btn-primary {display:inline-block; padding:6px 12px; margin:0 0 10px 0 !important; font-size:14px; font-weight:normal; line-height:1.42857143; text-align:center; white-space:nowrap; vertical-align:middle; -ms-touch-action:manipulation; touch-action:manipulation; border-radius:4px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-header {height:50px; padding:6px 15px 6px 15px; border-bottom:1px solid #e5e5e5;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-header .se-dialog-close {float:right; font-weight:bold; text-shadow:0 1px 0 #fff; -webkit-appearance:none; filter:alpha(opacity=100); opacity:1;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-header .se-modal-title {float:left; font-size:14px; font-weight:bold; margin:0; padding:0; line-height:2.5;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-body {position:relative; padding:15px 15px 5px 15px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form {margin-bottom:10px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form-footer {margin-top:10px; margin-bottom:0;}
  .sun-editor .se-dialog .se-dialog-inner input:disabled {background-color:#f3f3f3;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-size-text {width:100%;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-size-text .size-w {width:70px; text-align:center;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-size-text .size-h {width:70px; text-align:center;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-size-x {margin:0 8px 0 8px; width:25px; text-align:center;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-footer {height:auto; min-height:55px; padding:10px 15px 0px 15px; text-align:right; border-top:1px solid #e5e5e5;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-footer > div {float:left;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-footer > div > label {margin:0 5px 0 0;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-btn-radio {margin-left:12px; margin-right:6px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-btn-check {margin-left:12px; margin-right:4px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form-footer .se-dialog-btn-check {margin-left:0; margin-right:4px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form-footer label:first-child {margin-right:16px; margin-left:0px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-dialog-form-files {position:relative; display:flex; align-items:center;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-dialog-form-files > input {flex:auto;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-dialog-form-files .se-dialog-files-edge-button {flex:auto; opacity:0.8; border:1px solid #ccc;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-dialog-form-files .se-dialog-files-edge-button.se-file-remove > svg {width:8px; height:8px;} /* custom."remove icon" */
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-dialog-form-files .se-dialog-files-edge-button:hover {background-color:#f0f0f0; outline:0 none;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-dialog-form-files .se-dialog-files-edge-button:active {background-color:#e9e9e9; -webkit-box-shadow:inset 0 3px 5px #d6d6d6; box-shadow:inset 0 3px 5px #d6d6d6;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-input-select {display:inline-block; width:auto; height:34px; font-size:14px; text-align:center; line-height:1.42857143;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-input-control {display:inline-block; width:70px; height:34px; font-size:14px; text-align:center; line-height:1.42857143;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-input-form {display:block; width:100%; height:34px; font-size:14px; line-height:1.42857143; padding:0 4px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-input-form.se-input-url {direction:ltr;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-input-form.se-input-url:disabled {text-decoration:line-through; color:#999;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-video-ratio {width:70px; margin-left:4px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form a {color:#004cff;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-btn-revert {border:1px solid #ccc;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-btn-revert:hover {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-btn-revert:active {background-color:#d1d1d1; border-color:#c1c1c1; -webkit-box-shadow:inset 0 3px 5px #c1c1c1; box-shadow:inset 0 3px 5px #c1c1c1;}
  .sun-editor .se-dialog-tabs {width:100%; height:25px; border-bottom:1px solid #e5e5e5;}
  .sun-editor .se-dialog-tabs button {background-color:#e5e5e5; border-right:1px solid #e5e5e5; float:left; outline:none; padding:2px 13px; transition:0.3s;}
  .sun-editor .se-dialog-tabs button:hover {background-color:#fff;}
  .sun-editor .se-dialog-tabs button.active {background-color:#fff;border-bottom:0;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-input-form.se-math-exp {resize:vertical; height:14em; border:1px solid #ccc; font-size:13px; padding:4px; direction:ltr;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-input-select.se-math-size {width:6em; height:28px; margin-left:1em;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-math-preview {font-size:13px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-math-preview > span {display:inline-block; -webkit-box-shadow:0 0 0 0.1rem #c7deff; box-shadow:0 0 0 0.1rem #c7deff;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-math-preview > span * {direction:ltr;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-math-preview > .se-math-katex-error {color:#b94a48; -webkit-box-shadow:0 0 0 0.1rem #f2dede; box-shadow:0 0 0 0.1rem #f2dede;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-math-preview > .se-math-katex-error svg {width:auto; height:30px; color:#b94a48;}
  .sun-editor .se-dialog .se-dialog-inner .se-link-preview {display:block; height:auto; max-height:18px; font-size:13px; font-weight:normal; font-family:inherit; color:#666; background-color:transparent; overflow:hidden; text-overflow:ellipsis; word-break:break-all; white-space:pre;}
  .sun-editor .se-dialog .se-dialog-inner .se-anchor-preview-form {width:100%; display:flex; margin-top:4px;}
  .sun-editor .se-dialog .se-dialog-inner .se-anchor-preview-form .se-svg.se-anchor-preview-icon {flex:unset; display:none; line-height:1.5; color:#4592ff;}
  .sun-editor .se-dialog .se-dialog-inner .se-anchor-preview-form .se-link-preview {flex:auto; margin:0; }
  .sun-editor .se-dialog .se-dialog-inner .se-anchor-rel {height:34px;}
  .sun-editor .se-dialog .se-dialog-inner .se-anchor-rel-btn {width:46px; color:#3f9dff;}
  .sun-editor .se-dialog .se-dialog-inner .se-anchor-rel-wrapper {display:flex; line-height:1.5; padding-top:6px;}
  .sun-editor .se-dialog .se-dialog-inner .se-anchor-rel-preview {text-align:left;}
  .sun-editor .se-controller .se-arrow.se-arrow-up {border-bottom-color:rgba(0, 0, 0, .25);}
  .sun-editor .se-controller {position:absolute; display:none; overflow:visible; z-index:6; border:1px solid rgba(0, 0, 0, .25); border-radius:4px; text-align:start; text-decoration:none; text-shadow:none; text-transform:none; letter-spacing:normal; word-break:normal; word-spacing:normal; word-wrap:normal; white-space:normal; background-color:#fff; -webkit-background-clip:padding-box; background-clip:padding-box; -webkit-box-shadow:0 5px 10px rgba(0, 0, 0, .2); box-shadow:0 5px 10px rgba(0, 0, 0, .2); line-break:auto;}
  .sun-editor .se-controller .se-btn-group {position:relative; display:flex; vertical-align:middle; padding:2px; top:0; left:0;}
  .sun-editor .se-controller .se-btn-group .se-btn-group-sub {left:50%; min-width:auto; width:max-content; display:none;/* display: inline-table; */}
  .sun-editor .se-controller .se-btn-group .se-btn-group-sub button {margin:0; min-width:72px;}
  .sun-editor .se-controller .se-btn-group button {position:relative; min-height:34px; height:auto; border:none; border-radius:4px; margin:1px; padding:5px 10px; font-size:12px; line-height:1.5; display:inline-block; font-weight:normal; text-align:center; white-space:nowrap; vertical-align:middle; -ms-touch-action:manipulation; touch-action:manipulation;}
  .sun-editor .se-controller .se-btn-group button:hover:enabled, .sun-editor .se-controller .se-btn-group button:focus:enabled {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-controller .se-btn-group button:active:enabled {background-color:#d1d1d1; border-color:#c1c1c1; -webkit-box-shadow:inset 0 3px 5px #c1c1c1; box-shadow:inset 0 3px 5px #c1c1c1;}
  .sun-editor .se-controller .se-btn-group button span {display:block; padding:0; margin:0;}
  .sun-editor .se-controller .se-btn-group button:enabled.active {color:#4592ff; outline:0 none;}
  .sun-editor .se-controller .se-btn-group button:enabled.active:hover, .sun-editor .se-controller .se-btn-group button:enabled.active:focus {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-controller .se-btn-group button:enabled.active:active {background-color:#d1d1d1; border-color:#c1c1c1; -webkit-box-shadow:inset 0 3px 5px #c1c1c1; box-shadow:inset 0 3px 5px #c1c1c1;}
  .sun-editor .se-controller .se-btn-group button:enabled.on {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-controller .se-btn-group button:enabled.on:hover, .sun-editor .se-controller .se-btn-group button:enabled.on:focus {background-color:#d1d1d1; border-color:#c1c1c1; outline:0 none;}
  .sun-editor .se-controller .se-btn-group button:enabled.on:active {background-color:#c1c1c1; border-color:#b1b1b1; -webkit-box-shadow:inset 0 3px 5px #b1b1b1; box-shadow:inset 0 3px 5px #b1b1b1;}
  .sun-editor .se-controller .se-form-group input {min-width:120px;}
  .sun-editor .se-controller-resizing {margin-top:-50px !important; padding:0; font-size:14px; font-style:normal; font-weight:normal; line-height:1.42857143;}
  .sun-editor .se-controller-resizing .se-btn-group .se-btn-group-sub.se-resizing-align-list {width:74px;}
  .sun-editor .se-resizing-container {position:absolute; display:none; outline:1px solid #3f9dff; background-color:transparent;}
  .sun-editor .se-resizing-container .se-modal-resize {position:absolute; display:inline-block; background-color:#3f9dff; opacity:0.3;}
  .sun-editor .se-resizing-container .se-resize-dot {position:absolute; top:0px; left:0px; width:100%; height:100%}
  .sun-editor .se-resizing-container .se-resize-dot > span {position:absolute; width:7px; height:7px; background-color:#3f9dff; border:1px solid #4592ff;}
  .sun-editor .se-resizing-container .se-resize-dot > span.tl {top:-5px; left:-5px; cursor:nw-resize;}
  .sun-editor .se-resizing-container .se-resize-dot > span.tr {top:-5px; right:-5px; cursor:ne-resize;}
  .sun-editor .se-resizing-container .se-resize-dot > span.bl {bottom:-5px; left:-5px; cursor:sw-resize;}
  .sun-editor .se-resizing-container .se-resize-dot > span.br {right:-5px; bottom:-5px; cursor:se-resize;}
  .sun-editor .se-resizing-container .se-resize-dot > span.lw {left:-7px; bottom:50%; cursor:w-resize;}
  .sun-editor .se-resizing-container .se-resize-dot > span.th {left:50%; top:-7px; cursor:n-resize;}
  .sun-editor .se-resizing-container .se-resize-dot > span.rw {right:-7px; bottom:50%; cursor:e-resize;}
  .sun-editor .se-resizing-container .se-resize-dot > span.bh {right:50%; bottom:-7px; cursor:s-resize;}
  .sun-editor .se-resizing-container .se-resize-display {position:absolute; right:0; bottom:0; padding:5px; margin:5px; font-size:12px; color:#fff; background-color:#333; border-radius:4px;}
  .sun-editor .se-controller-table {width:auto; padding:0; font-size:14px; font-style:normal; font-weight:normal; line-height:1.42857143;}
  .sun-editor .se-controller-table-cell {width:auto; padding:0; font-size:14px; font-style:normal; font-weight:normal; line-height:1.42857143;}
  .sun-editor .se-controller-link {padding:0; font-size:14px; font-style:normal; font-weight:normal; line-height:1.42857143;}
  .sun-editor .se-controller-link::before, .sun-editor .se-controller-link::after {-webkit-box-sizing:border-box; -moz-box-sizing:border-box; box-sizing:border-box;}
  .sun-editor .se-controller-link .link-content {padding:0; margin:0;}
  .sun-editor .se-controller-link .link-content a {display:inline-block; color:#4592ff; max-width:200px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; vertical-align:middle; margin-left:5px;}
  .sun-editor .se-select-list {position:absolute; top:0px; left:0px; display:none; width:auto; max-width:100%; background-color:#fff; padding:0; margin:0; border:1px solid #bababa; -webkit-box-shadow:0 3px 9px rgba(0, 0, 0, .5); box-shadow:0 3px 9px rgba(0, 0, 0, .5); outline:0 none;}
  .sun-editor .se-select-list .se-select-item {line-height:28px; min-height:28px; font-size:13px; padding:0 5px; margin:2px 0; cursor:pointer;}
  .sun-editor .se-select-list.__se_select-menu-mouse-move .se-select-item:hover, .sun-editor .se-select-list:not(.__se_select-menu-mouse-move) .se-select-item.active {background-color:#e1e1e1;}
  .sun-editor .se-dialog-form-files .se-select-list {width:100%;}
  .sun-editor .se-file-browser {position:absolute; display:none; top:0; left:0; width:100%; height:100%; z-index:2147483647;}
  .sun-editor .se-file-browser label, .sun-editor .se-file-browser input, .sun-editor .se-file-browser button {font-size:14px; line-height:1.5; color:#111; margin:0;}
  .sun-editor .se-file-browser .se-file-browser-back {position:absolute; display:block; width:100%; height:100%; top:0; left:0; background-color:#222; opacity:0.5;}
  .sun-editor .se-file-browser .se-file-browser-inner {position:absolute; display:block; width:100%; height:100%; top:0; left:0;}
  .sun-editor .se-file-browser .se-file-browser-inner .se-file-browser-content {position:relative; width:960px; max-width:100%; margin:20px auto; background-color:#fff; -webkit-background-clip:padding-box; background-clip:padding-box; border:1px solid rgba(0, 0, 0, .2); border-radius:4px; outline:0; -webkit-box-shadow:0 3px 9px rgba(0, 0, 0, .5); box-shadow:0 3px 9px rgba(0, 0, 0, .5);}
  .sun-editor .se-file-browser .se-file-browser-header {height:auto; min-height:50px; padding:6px 15px 6px 15px; border-bottom:1px solid #e5e5e5;}
  .sun-editor .se-file-browser .se-file-browser-header .se-file-browser-close {float:right; font-weight:bold; text-shadow:0 1px 0 #fff; -webkit-appearance:none; filter:alpha(opacity=100); opacity:1;}
  .sun-editor .se-file-browser .se-file-browser-header .se-file-browser-close > svg {width:12px; height:12px;}
  .sun-editor .se-file-browser .se-file-browser-header .se-file-browser-title {font-size:16px; font-weight:bold; margin:0; padding:0; line-height:2.2;}
  .sun-editor .se-file-browser .se-file-browser-tags {display:block; width:100%; padding:0; text-align:left; margin:0 -15px;}
  .sun-editor .se-file-browser .se-file-browser-tags a {display:inline-block; background-color:#f5f5f5; padding:6px 12px; margin:8px 0 8px 8px; color:#333; text-decoration:none; border-radius:32px; -moz-border-radius:32px; -webkit-border-radius:32px; -moz-background-clip:padding; -webkit-background-clip:padding-box; background-clip:padding-box; cursor:pointer;}
  .sun-editor .se-file-browser .se-file-browser-tags a:hover {background-color:#e1e1e1;}
  .sun-editor .se-file-browser .se-file-browser-tags a:active {background-color:#d1d1d1;}
  .sun-editor .se-file-browser .se-file-browser-tags a.on {background-color:#ebf3fe; color:#4592ff;}
  .sun-editor .se-file-browser .se-file-browser-tags a.on:hover {background-color:#d8e8fe;}
  .sun-editor .se-file-browser .se-file-browser-tags a.on:active {background-color:#c7deff;}
  .sun-editor .se-file-browser .se-file-browser-body {position:relative; height:auto; min-height:350px; padding:20px; overflow-y:auto;}
  .sun-editor .se-file-browser .se-file-browser-body .se-file-browser-list {position:relative; width:100%;}
  @media screen and (max-width:992px) { .sun-editor .se-file-browser .se-file-browser-inner .se-file-browser-content {width:748px;} }
  @media screen and (max-width:768px) { .sun-editor .se-file-browser .se-file-browser-inner .se-file-browser-content {width:600px;} }
  .sun-editor .se-file-browser .se-file-browser-list .se-file-item-column {position:relative; display:block; height:auto; float:left;}
  .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-column {width:calc(25% - 20px); margin:0 10px;}
  @media screen and (max-width:992px) { .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-column {width:calc(33% - 20px);} }
  @media screen and (max-width:768px) { .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-column {width:calc(50% - 20px);} }
  .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-img {position:relative; display:block; cursor: pointer; width:100%; height:auto; border-radius:4px; outline:0; margin:10px 0;}
  .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-img:hover {opacity:0.8; -webkit-box-shadow:0 0 0 0.2rem #3288ff; box-shadow:0 0 0 0.2rem #3288ff;}
  .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-img > img {position:relative; display:block; width:100%; border-radius:4px; outline:0; height:auto;}
  .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-img > .se-file-img-name {position: absolute; z-index:1; font-size:13px; color:#fff; left:0px; bottom:0; padding:5px 10px; background-color:transparent; width:100%; height:30px; border-bottom-right-radius:4px; border-bottom-left-radius:4px;}
  .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-img > .se-file-img-name.se-file-name-back {background-color:#333; opacity:0.6;}
  .sun-editor .se-notice {position:absolute; top:0; display:none; z-index:7; width:100%; height:auto; word-break:break-all; font-size:13px; color:#b94a48; background-color:#f2dede; padding:15px; margin:0; border:1px solid #eed3d7; user-select:auto; -o-user-select:auto; -moz-user-select:auto; -khtml-user-select:auto; -webkit-user-select:auto; -ms-user-select:auto;}
  .sun-editor .se-notice button {float:right; padding:7px;}
  .sun-editor .se-tooltip {position:relative; overflow:visible;}
  .sun-editor .se-tooltip .se-tooltip-inner {visibility:hidden; position:absolute; display:block; width:auto; height:auto; top:120%; left:50%; background:transparent; opacity:0; z-index:1; line-height:1.5; transition:opacity 0.5s; margin:0; padding:0; bottom:auto; float:none; pointer-events:none; backface-visibility:hidden; -webkit-backface-visibility:hidden; -moz-backface-visibility:hidden;}
  .sun-editor .se-tooltip .se-tooltip-inner .se-tooltip-text {position:relative; display:inline-block; width:auto; height:auto; left:-50%; font-size:0.9em; margin:0; padding:4px 6px; border-radius:2px; background-color:#333; color:#fff; text-align:center; line-height:unset; white-space:nowrap; cursor:auto;}
  .sun-editor .se-tooltip .se-tooltip-inner .se-tooltip-text::after {content:""; position:absolute; bottom:100%; left:50%; margin-left:-5px; border-width:5px; border-style:solid; border-color:transparent transparent #333 transparent;}
  .sun-editor .se-tooltip:hover .se-tooltip-inner {visibility:visible; opacity:1;}
  .sun-editor .se-tooltip .se-tooltip-inner .se-tooltip-text .se-shortcut {display:block !important;}
  .sun-editor .se-tooltip .se-tooltip-inner .se-tooltip-text .se-shortcut > .se-shortcut-key {display:inline; font-weight:bold;}
  .sun-editor.se-rtl .se-btn-tray {direction:rtl;}
  .sun-editor.se-rtl .se-btn-select svg {margin:auto 1px;}
  .sun-editor.se-rtl .se-btn-select .txt {flex:auto; text-align:right; direction:rtl;}
  .sun-editor.se-rtl .se-btn-list {text-align:right;}
  .sun-editor.se-rtl .se-btn-list > .se-list-icon {margin:-1px 0 0 10px;}
  .sun-editor.se-rtl .se-menu-list:not(.se-menu-dir-fix) {float:right;}
  .sun-editor.se-rtl .se-menu-list:not(.se-menu-dir-fix) li {float:right;}
  .sun-editor.se-rtl .se-list-layer * {direction:rtl;}
  .sun-editor.se-rtl .se-list-layer.se-list-format ul blockquote {padding:0 7px 0 0; border-right-width:5px; border-left-width:0;}
  .sun-editor.se-rtl .se-list-layer .se-selector-color .se-color-pallet li {float:right;}
  .sun-editor.se-rtl .se-list-inner .se-list-checked li button > .se-svg {float:right; padding:6px 0 0 6px;}
  .sun-editor.se-rtl .se-wrapper .se-placeholder {direction:rtl;}
  .sun-editor.se-rtl .se-tooltip .se-tooltip-inner .se-tooltip-text {direction:rtl;}
  .sun-editor.se-rtl .se-tooltip .se-tooltip-inner .se-tooltip-text .se-shortcut {direction:ltr;}
  .sun-editor.se-rtl .se-dialog * {direction:rtl;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-form .se-video-ratio {margin-left:0; margin-right:4px;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-header .se-dialog-close {float:left;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-header .se-modal-title {float:right;}
  .sun-editor.se-rtl .se-dialog-tabs button {float:right;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-size-text {padding-right:34px;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-footer .se-btn-primary {float:left}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-footer > div {float:right;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-footer > div > label {margin:0 0 0 5px;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-form-footer label:first-child {margin-left:16px; margin-right:0px;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-anchor-rel-preview {margin-left:4px; text-align:right;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-anchor-rel-btn {float:right;}
  .sun-editor.se-rtl .se-file-browser * {direction:rtl;}
  .sun-editor.se-rtl .se-file-browser .se-file-browser-tags {text-align:right;}
  .sun-editor.se-rtl .se-file-browser .se-file-browser-tags a {margin: 8px 8px 0 8px;}
  .sun-editor.se-rtl .se-file-browser .se-file-browser-header .se-file-browser-close {float:left;}
  .sun-editor.se-rtl .se-controller .se-btn-group {direction:rtl;}
  .sun-editor.se-rtl .se-resizing-container .se-resize-display {direction:rtl;}
  .sun-editor .se-btn-module-border.module-float-left {float:left;}
  .sun-editor .se-btn-module-border.module-float-right {float:right;}
  .sun-editor .se-error {color:#d9534f;}
  .sun-editor input.se-error:focus, select.se-error:focus, textarea.se-error:focus {
    border: 1px solid #f2dede;
    outline: 0;
    -webkit-box-shadow: 0 0 0 0.2rem #eed3d7;
    box-shadow: 0 0 0 0.2rem #eed3d7;
    transition: border-color .15s ease-in-out,box-shadow .15s ease-in-out;
  }
  .sun-editor hr.__se__solid {
    border-style: solid none none;
  }
  .sun-editor hr.__se__dotted {
    border-style: dotted none none;
  }
  .sun-editor hr.__se__dashed {
    border-style: dashed none none;
  }
  @keyframes blinker { 50% {opacity:0;} }
  @keyframes spinner { to {transform:rotate(361deg);} }

  .sun-editor-editable {
    font-family: Helvetica Neue;
    font-size: 13px;
    color: #333;
    background-color: #fff;
    line-height: 1.5;
    word-break: normal;
    word-wrap: break-word;
    padding: 16px;
    margin: 0;
  }
  .sun-editor-editable * {
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    font-family: inherit;
    font-size: inherit;
    color: inherit;
  }
  .sun-editor-editable.se-rtl * {
    direction: rtl;
  }
  .sun-editor-editable .se-component > figure {
    direction: initial;
  }
  .sun-editor-editable td, .sun-editor-editable th, 
  .sun-editor-editable figure, .sun-editor-editable figcaption, .sun-editor-editable img, 
  .sun-editor-editable iframe, .sun-editor-editable video, .sun-editor-editable audio {
    position: relative;
  }
  .sun-editor-editable span {
    display: inline;
    vertical-align: baseline;
    margin: 0;
    padding: 0;
  }
  .sun-editor-editable span.katex {
    display: inline-block;
  }
  .sun-editor-editable span.katex * {
    direction: ltr;
  }
  .sun-editor-editable a {
    color: #004cff;
    text-decoration: none;
  }
  .sun-editor-editable span[style~="color:"] a {
    color: inherit;
  }
  .sun-editor-editable a:hover, .sun-editor-editable a:focus {
    cursor: pointer;
    color: #0093ff;
    text-decoration: underline;
  }
  .sun-editor-editable a.on {
    color: #0093ff;
    background-color: #e8f7ff;
  }
  .sun-editor-editable pre {
    display: block;
    padding: 8px;
    margin: 0 0 10px;
    font-family: monospace;
    color: #666;
    line-height: 1.45;
    background-color: #f9f9f9;
    border: 1px solid #e1e1e1;
    border-radius: 2px;
    white-space: pre-wrap !important;
    word-wrap: break-word;
    overflow: visible;
  }
  .sun-editor-editable ol {
    list-style-position: outside;
    display: block;
    list-style-type: decimal;
    margin-block-start: 1em;
    margin-block-end: 1em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    padding-inline-start: 40px;
  }
  .sun-editor-editable ul {
    list-style-position: outside;
    display: block;
    list-style-type: disc;
    margin-block-start: 1em;
    margin-block-end: 1em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    padding-inline-start: 40px;
  }
  .sun-editor-editable li {
    display: list-item;
    text-align: -webkit-match-parent;
    margin-bottom: 5px;
  }
  .sun-editor-editable ol ol, .sun-editor-editable ol ul, .sun-editor-editable ul ol, .sun-editor-editable ul ul {
    margin: 0;
  }
  .sun-editor-editable ol ol, .sun-editor-editable ul ol {
    list-style-type: lower-alpha;
  }
  .sun-editor-editable ol ol ol, .sun-editor-editable ul ol ol, .sun-editor-editable ul ul ol {
    list-style-type: upper-roman;
  }
  .sun-editor-editable ul ul, .sun-editor-editable ol ul {
    list-style-type: circle;
  }
  .sun-editor-editable ul ul ul, .sun-editor-editable ol ul ul, .sun-editor-editable ol ol ul {
    list-style-type: square;
  }
  .sun-editor-editable sub, .sun-editor-editable sup {
    font-size: 75%;
    line-height: 0;
  }
  .sun-editor-editable sub {
    vertical-align: sub;
  }
  .sun-editor-editable sup {
    vertical-align: super;
  }
  .sun-editor-editable p {
    display: block;
    margin: 0 0 10px;
  }
  .sun-editor-editable div {
    display: block;
    margin: 0;
    padding: 0;
  }
  .sun-editor-editable blockquote {
    display: block;
    font-family: inherit;
    font-size: inherit;
    color: #999;
    margin-block-start: 1em;
    margin-block-end: 1em;
    margin-inline-start: 0;
    margin-inline-end: 0;
    border-style: solid;
    border-width: 0;
    padding-top: 0;
    padding-bottom: 0;
    border-color: #b1b1b1;
    padding-left: 20px;
    padding-right: 5px;
    border-left-width: 5px;
    border-right-width: 0px;
  }
  .sun-editor-editable blockquote blockquote {
    border-color: #c1c1c1;
  }
  .sun-editor-editable blockquote blockquote blockquote {
    border-color: #d1d1d1;
  }
  .sun-editor-editable blockquote blockquote blockquote blockquote {
    border-color: #e1e1e1;
  }
  .sun-editor-editable.se-rtl blockquote {
    padding-left: 5px;
    padding-right: 20px;
    border-left-width: 0px;
    border-right-width: 5px;
  }
  .sun-editor-editable h1 {
    display: block;
    font-size: 2em;
    margin-block-start: 0.67em;
    margin-block-end: 0.67em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    font-weight: bold;
  }
  .sun-editor-editable h2 {
    display: block;
    font-size: 1.5em;
    margin-block-start: 0.83em;
    margin-block-end: 0.83em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    font-weight: bold;
  }
  .sun-editor-editable h3 {
    display: block;
    font-size: 1.17em;
    margin-block-start: 1em;
    margin-block-end: 1em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    font-weight: bold;
  }
  .sun-editor-editable h4 {
    display: block;
    font-size: 1em;
    margin-block-start: 1.33em;
    margin-block-end: 1.33em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    font-weight: bold;
  }
  .sun-editor-editable h5 {
    display: block;
    font-size: 0.83em;
    margin-block-start: 1.67em;
    margin-block-end: 1.67em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    font-weight: bold;
  }
  .sun-editor-editable h6 {
    display: block;
    font-size: 0.67em;
    margin-block-start: 2.33em;
    margin-block-end: 2.33em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    font-weight: bold;
  }
  .sun-editor-editable hr {
    display: flex;
    border-width: 1px 0 0;
    border-color: black;
    border-image: initial;
    height: 1px;
  }
  .sun-editor-editable hr.__se__solid {
    border-style: solid none none;
  }
  .sun-editor-editable hr.__se__dotted {
    border-style: dotted none none;
  }
  .sun-editor-editable hr.__se__dashed {
    border-style: dashed none none;
  }
  .sun-editor-editable hr.on {
    border-color: #4592ff;
    -webkit-box-shadow:0 0 0 0.1rem #c7deff;
    box-shadow:0 0 0 0.1rem #c7deff;
  }
  .sun-editor-editable table {
    display: table;
    table-layout: auto !important;
    border: 1px solid rgb(204, 204, 204);
    width: 100%;
    max-width: 100%;
    margin: 0 0 10px;
    background-color: transparent;
    border-spacing: 0;
    border-collapse: collapse;
  }
  .sun-editor-editable.se-rtl table {
    margin: 0 0 10px auto;
  }
  .sun-editor-editable table thead {
    border-bottom: 2px solid #333;
  }
  .sun-editor-editable table tr {
    border: 1px solid #efefef;
  }
  .sun-editor-editable table th {
    background-color: #f3f3f3;
  }
  .sun-editor-editable table th, .sun-editor-editable table td {
    border: 1px solid #e1e1e1;
    padding:0.4em;
    background-clip: padding-box;
  }
  .sun-editor-editable table.se-table-size-auto {
    width: auto !important;
  }
  .sun-editor-editable table.se-table-size-100 {
    width: 100% !important;
  }
  .sun-editor-editable table.se-table-layout-auto {
    table-layout: auto !important;
  }
  .sun-editor-editable table.se-table-layout-fixed {
    table-layout: fixed !important;
  }
  .sun-editor-editable table td.se-table-selected-cell, .sun-editor-editable table th.se-table-selected-cell {
    outline: 1px double #4592ff;
  }
  .sun-editor-editable.se-disabled * {
    user-select: none;
    -o-user-select: none;
    -moz-user-select: none;
    -khtml-user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
  }
  .sun-editor-editable .se-component {
    display: flex;
    padding: 1px;
    margin: 0 0 10px;
  }
  .sun-editor-editable[contenteditable=true] .se-component {
    outline: 1px dashed #e1e1e1;
  }
  .sun-editor-editable[contenteditable=true] .se-component.se-component-copy {
    -webkit-box-shadow:0 0 0 0.2rem #80bdff; box-shadow:0 0 0 0.2rem #3f9dff; transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out;
  }
  .sun-editor-editable .__se__float-left {
    float: left;
    margin-right: 4px;
  }
  .sun-editor-editable .__se__float-right {
    float: right;
    margin-left: 4px;
  }
  .sun-editor-editable .__se__float-center {
    float: center;
  }
  .sun-editor-editable .__se__float-none {
    float: none;
  }
  .sun-editor-editable img, .sun-editor-editable iframe, .sun-editor-editable video, .sun-editor-editable audio {
    display: block;
    margin: 0;
    padding: 0;
    width: auto;
    height: auto;
    max-width: 100%;
  }
  .sun-editor-editable[contenteditable="true"]:not(.se-read-only) figure::after {
    position: absolute;
    content: '';
    z-index: 1;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    cursor: default;
    display: block;
    background: rgba(0,0,0,0);
  }
  .sun-editor-editable[contenteditable="true"] figure a, .sun-editor-editable[contenteditable="true"] figure img, .sun-editor-editable[contenteditable="true"] figure iframe, .sun-editor-editable[contenteditable="true"] figure video {
    z-index: 0;
  }
  .sun-editor-editable[contenteditable="true"] figure figcaption {
    display: block;
    z-index: 2;
  }
  .sun-editor-editable[contenteditable="true"] figure figcaption:focus {
    border-color: #80bdff;
    outline: 0;
    -webkit-box-shadow: 0 0 0 0.2rem #c7deff;
    box-shadow: 0 0 0 0.2rem #c7deff;
  }
  .sun-editor-editable .se-image-container, .sun-editor-editable .se-video-container {
    width: auto;
    height: auto;
    max-width: 100%;
  }
  .sun-editor-editable figure {
    display: block;
    outline: none;
    padding: 0;
    margin: 0;
  }
  .sun-editor-editable .__se__float-left figure,
  .sun-editor-editable .__se__float-right figure,
  .sun-editor-editable .__se__float-center figure {
    margin: auto !important;
  }
  .sun-editor-editable figure figcaption {
    padding: 1em .5em;
    margin: 0;
    background-color: #f9f9f9;
    outline: none;
  }
  .sun-editor-editable figure figcaption p{
    line-height: 2;
    margin: 0;
  }
  .sun-editor-editable .se-image-container a img {
    padding: 1px;
    margin: 1px;
    outline: 1px solid #4592ff;
  }
  .sun-editor-editable .se-video-container iframe, .sun-editor-editable .se-video-container video {
    outline: 1px solid #9e9e9e;
    position: absolute;
    top: 0;
    left: 0;
    border: 0;
    width: 100%;
    height: 100%;
  }
  .sun-editor-editable .se-video-container figure {
    left: 0px;
    width: 100%;
    max-width: 100%;
  }
  .sun-editor-editable audio {
    width: 300px;
    height: 54px;
  }
  .sun-editor-editable audio.active {
    outline: 2px solid #80bdff;
  }
  .sun-editor-editable.se-show-block p, .sun-editor-editable.se-show-block div, 
  .sun-editor-editable.se-show-block h1, .sun-editor-editable.se-show-block h2, .sun-editor-editable.se-show-block h3, 
  .sun-editor-editable.se-show-block h4, .sun-editor-editable.se-show-block h5, .sun-editor-editable.se-show-block h6, .sun-editor-editable.se-show-block li, 
  .sun-editor-editable.se-show-block ol, .sun-editor-editable.se-show-block ul, 
  .sun-editor-editable.se-show-block pre {
    border:1px dashed #3f9dff !important;
    padding:14px 8px 8px 8px !important;
  }
  .sun-editor-editable.se-show-block ol, .sun-editor-editable.se-show-block ul {
    border:1px dashed #d539ff !important;
  }
  .sun-editor-editable.se-show-block pre {
    border:1px dashed #27c022 !important;
  }
  .se-show-block p {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPAQMAAAAF7dc0AAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAaSURBVAjXY/j/gwGCPvxg+F4BQiAGDP1HQQByxxw0gqOzIwAAAABJRU5ErkJggg==') no-repeat;}
  .se-show-block div {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAPAQMAAAAxlBYoAAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAmSURBVAjXY/j//wcDDH+8XsHwDYi/hwNx1A8w/nYLKH4XoQYJAwCXnSgcl2MOPgAAAABJRU5ErkJggg==') no-repeat;}
  .se-show-block h1 {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAPAQMAAAA4f7ZSAAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAfSURBVAjXY/j/v4EBhr+9B+LzEPrDeygfhI8j1CBhAEhmJGY4Rf6uAAAAAElFTkSuQmCC') no-repeat;}
  .se-show-block h2 {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAPAQMAAAA4f7ZSAAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAmSURBVAjXY/j/v4EBhr+dB+LtQPy9geEDEH97D8T3gbgdoQYJAwA51iPuD2haEAAAAABJRU5ErkJggg==') no-repeat;}
  .se-show-block h3 {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAPAQMAAAA4f7ZSAAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAiSURBVAjXY/j/v4EBhr+dB+LtQPy9geHDeQgN5p9HqEHCADeWI+69VG2MAAAAAElFTkSuQmCC') no-repeat;}
  .se-show-block h4 {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAPAQMAAADTSA1RAAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAiSURBVAjXY/j//wADDH97DsTXIfjDdiDdDMTfIRhZHRQDAKJOJ6L+K3y7AAAAAElFTkSuQmCC') no-repeat;}
  .se-show-block h5 {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAPAQMAAAA4f7ZSAAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAlSURBVAjXY/j/v4EBhr+1A/F+IO5vYPiwHUh/B2IQfR6hBgkDABlWIy5uM+9GAAAAAElFTkSuQmCC') no-repeat;}
  .se-show-block h6 {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAPAQMAAAA4f7ZSAAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAiSURBVAjXY/j/v4EBhr+dB+LtQLy/geFDP5S9HSKOrA6KAR9GIza1ptJnAAAAAElFTkSuQmCC') no-repeat;}
  .se-show-block li {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAA7SURBVDhPYxgFcNDQ0PAfykQBIHEYhgoRB/BpwCfHBKWpBkaggYxQGgOgBzyQD1aLLA4TGwWDGjAwAACR3RcEU9Ui+wAAAABJRU5ErkJggg==') no-repeat;}
  .se-show-block ol {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABHSURBVDhPYxgFcNDQ0PAfhKFcFIBLHCdA1oBNM0kGEmMAPgOZoDTVANUNxAqQvURMECADRiiNAWCagDSGGhyW4DRrMAEGBgAu0SX6WpGgjAAAAABJRU5ErkJggg==') no-repeat;}
  .se-show-block ul {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAA1SURBVDhPYxgFDA0NDf+hTBSALI5LDQgwQWmqgVEDKQcsUBoF4ItFGEBXA+QzQpmDGjAwAAA8DQ4Lni6gdAAAAABJRU5ErkJggg==') no-repeat;}
  .sun-editor-editable .__se__p-bordered, .sun-editor .__se__p-bordered {
    border-top: solid 1px #b1b1b1;
    border-bottom: solid 1px #b1b1b1;
    padding: 4px 0;
  }
  .sun-editor-editable .__se__p-spaced, .sun-editor .__se__p-spaced {
    letter-spacing: 1px;
  }
  .sun-editor-editable .__se__p-neon, .sun-editor .__se__p-neon {
    font-weight: 200;
    font-style: italic;
    background: #000;
    color: #fff;
    padding: 6px 4px;
    border: 2px solid #fff;
    border-radius: 6px;
    text-transform: uppercase;
    animation: neonFlicker 1.5s infinite alternate;     
  }
  @keyframes neonFlicker {
    0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
        text-shadow:
          -0.2rem -0.2rem 1rem #fff,
          0.2rem 0.2rem 1rem #fff,
          0 0 2px #f40,
          0 0 4px #f40,
          0 0 6px #f40,
          0 0 8px #f40,
          0 0 10px #f40;
        box-shadow:
          0 0 .5px #fff,
          inset 0 0 .5px #fff,
          0 0 2px #08f,
          inset 0 0 2px #08f,
          0 0 4px #08f,
          inset 0 0 4px #08f;      
    }
    20%, 24%, 55% {      
        text-shadow: none;
        box-shadow: none;
    }    
  }
  .sun-editor-editable .__se__t-shadow, .sun-editor .__se__t-shadow {
    text-shadow:
        -0.2rem -0.2rem 1rem #fff,
        0.2rem 0.2rem 1rem #fff,
        0 0 0.2rem #999,
        0 0 0.4rem #888,
        0 0 0.6rem #777,
        0 0 0.8rem #666,
        0 0 1rem #555;
  }
  .sun-editor-editable .__se__t-code, .sun-editor .__se__t-code {
    font-family: monospace;
    color: #666;
    background-color: rgba(27,31,35,.05);
    border-radius: 6px;
    padding: 0.2em 0.4em;
  }`;
    }
    template() {
      const {
        value = "",
        //flags
        history,
        font,
        size,
        format,
        paragraph,
        blockquote,
        style,
        color,
        highlight,
        text,
        remove,
        indent,
        align,
        rule,
        list,
        lineheight,
        table,
        link,
        image,
        video,
        audio,
        fullscreen,
        showblocks,
        code,
        print,
        save,
        dir,
        //handlers
        change,
        update,
        //for textarea
        ...attributes
      } = this.props;
      const styles = new import_StyleSet11.default();
      const css = this.styles();
      this.styles = () => css + styles.toString();
      (0, import_display3.default)(this.props, styles, "block");
      const handlers = {
        init: () => {
          const textarea = this.shadowRoot.querySelector(".sun-editor-editable");
          if (!textarea) return;
          const buttonList = [];
          if (history) buttonList.push(["undo", "redo"]);
          const group2 = [];
          if (font) group2.push("font");
          if (size) group2.push("fontSize");
          if (format) group2.push("formatBlock");
          if (group2.length) buttonList.push(group2);
          const group3 = [];
          if (paragraph) group3.push("paragraphStyle");
          if (blockquote) group3.push("blockquote");
          if (group3.length) buttonList.push(group3);
          if (style) buttonList.push(["bold", "underline", "italic", "strike", "subscript", "superscript"]);
          const group5 = [];
          if (color) group5.push("fontColor");
          if (highlight) group5.push("hiliteColor");
          if (text) group5.push("textStyle");
          if (group5.length) buttonList.push(group5);
          if (remove) buttonList.push(["removeFormat"]);
          buttonList.push("/");
          if (indent) buttonList.push(["outdent", "indent"]);
          const group8 = [];
          if (align) group8.push("align");
          if (rule) group8.push("horizontalRule");
          if (list) group8.push("list");
          if (lineheight) group8.push("lineHeight");
          if (group8.length) buttonList.push(group8);
          const group9 = [];
          if (table) group9.push("table");
          if (link) group9.push("link");
          if (image) group9.push("image");
          if (video) group9.push("video");
          if (audio) group9.push("audio");
          if (group9.length) buttonList.push(group9);
          const group10 = [];
          if (fullscreen) group10.push("fullScreen");
          if (showblocks) group10.push("showBlocks");
          if (code) group10.push("codeView");
          if (group10.length) buttonList.push(group10);
          if (print) buttonList.push(["preview", "print"]);
          if (save) buttonList.push(["save", "template"]);
          if (dir) buttonList.push(["dir", "dir_ltr", "dir_rtl"]);
          const editor = suneditor_default.create(textarea, {
            plugins: plugins_default,
            buttonList: buttonList.length > 1 ? buttonList : [],
            value
          });
          editor.onChange = handlers.change;
        },
        change: (contents, core) => {
          update && update(contents);
          const textarea = this.querySelector("textarea");
          if (!textarea) return;
          textarea.value = contents;
          textarea.setAttribute("value", contents);
          const event = new Event("change", { bubbles: true, composed: true });
          Object.defineProperty(event, "target", { writable: false, value: textarea });
          change && change(event);
        }
      };
      return () => [
        import_Registry16.default.createText(`
`, false),
        import_Registry16.default.createElement("template", { "type": `light` }, [
          import_Registry16.default.createText(`
  `, false),
          import_Registry16.default.createElement("textarea", { ...attributes, "value": value }, [
            ...this._toNodeList(value)
          ]).element,
          import_Registry16.default.createText(`
`, false)
        ]).element,
        import_Registry16.default.createText(`
`, false),
        import_Registry16.default.createElement("template", { "type": `shadow` }, [
          import_Registry16.default.createText(`
  `, false),
          import_Registry16.default.createElement("div", { "class": `sun-editor-editable`, "mount": handlers.init }, []).element,
          import_Registry16.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-document-client-resolver:C:\Users\Win 10\dev\ink\packages\ink-web\src\pages\ui\field\wysiwyg.ink
  var import_ink4 = __toESM(require_ink());
  var TemplateDocument = class _TemplateDocument extends import_Document2.default {
    static sync() {
      const document2 = new _TemplateDocument();
      return document2.sync();
    }
    template() {
      const url = "/ink/panel.html";
      const title = _("Ink UI - Web Components Meets Atomic Styles.");
      const description = _("Ink UI atomically generates CSS styles and provides out of box web components.");
      const toggle = () => {
        document.querySelector("panel-layout").toggle("left");
      };
      const crumbs = [
        { icon: "home", label: "Home", href: "/ink/index.html" },
        { icon: "book", label: "Docs", href: "/ink/docs/index.html" },
        { icon: "icons", label: "UI", href: "/ink/ui/index.html" },
        { icon: "icons", label: "Form", href: "/ink/ui/form/index.html" },
        { label: "WYSIWYG" }
      ];
      const handleChange = (e) => console.log("Change event:", e.target.value);
      const handleUpdate = (value) => console.log("Updated value:", value);
      return [
        import_Document.default.createText(`

`, false),
        import_Document.default.createElement("html", {}, [
          import_Document.default.createText(`
  `, false),
          ...[
            import_Document.default.createElement("head", {}, [
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "charset": `utf-8` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "name": `viewport`, "content": `width=device-width, initial-scale=1` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("title", {}, [
                ...this._toNodeList(title)
              ]),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "name": `description`, "content": description }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "property": `og:title`, "content": title }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "property": `og:description`, "content": description }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "property": `og:image`, "content": `https://stackpress.github.io/ink/ink-logo.png` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "property": `og:url`, "content": `https://stackpress.github.io/ink${url}` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "property": `og:type`, "content": `website` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "name": `twitter:card`, "content": `summary` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "name": `twitter:site`, "content": `@stackpress` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "name": `twitter:title`, "content": title }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "name": `twitter:description`, "content": description }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "name": `twitter:image`, "content": `https://stackpress.github.io/ink/ink-logo.png` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("link", { "rel": `favicon`, "href": `/ink/favicon.ico` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("link", { "rel": `shortcut icon`, "type": `image/png`, "href": `/ink/favicon.png` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("link", { "rel": `stylesheet`, "type": `text/css`, "href": `https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("link", { "rel": `stylesheet`, "type": `text/css`, "href": `/ink/styles/global.css` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("link", { "rel": `stylesheet`, "type": `text/css`, "href": `/ink/build/client/${(0, import_ink4.env)("BUILD_ID")}.css` }),
              import_Document.default.createElement("script", { "data-template": true, "type": `text/json` }, [
                import_Document.default.createText(`__TEMPLATE_DATA__`, true)
              ]),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("script", { "src": `/ink/build/client/${(0, import_ink4.env)("BUILD_ID")}.js` }),
              import_Document.default.createText(`
  `, false),
              ...!!((0, import_ink4.env)("PUBLIC_ENV") === "development") ? [
                import_Document.default.createText(`
    `, false),
                import_Document.default.createElement("script", { "src": `/dev.js` }),
                import_Document.default.createText(`
  `, false)
              ] : [],
              import_Document.default.createText(`
`, false)
            ])
          ],
          import_Document.default.createText(`
  `, false),
          import_Document.default.createElement("body", { "class": `light bg-t-0 tx-t-1 tx-arial` }, [
            import_Document.default.createText(`
    `, false),
            import_Document.default.createElement("panel-layout", {}, [
              import_Document.default.createText(`
      `, false),
              import_Document.default.createElement("header", {}, [
                ...[
                  import_Document.default.createElement("menu", { "class": `flex flex-center-y px-20 py-15 m-0 bg-t-1` }, [
                    import_Document.default.createText(`
  `, false),
                    ...!!(url !== "/ink/index.html" && url !== "/ink/500.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("i", { "class": `fas fa-fw fa-bars cursor-pointer py-5 pr-10 none md-inline-block tx-t-1`, "click": toggle }, []),
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("div", { "class": `flex-grow` }, []),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "href": `/ink` }, [
                        import_Document.default.createText(`
      `, false),
                        import_Document.default.createElement("img", { "alt": `Ink Logo`, "class": `h-26 mr-10`, "src": `/ink/ink-icon.png` }),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    import_Document.default.createElement("nav", { "class": `flex flex-center-y` }, [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `tx-primary`, "href": `/ink/docs/index.html` }, [
                        import_Document.default.createText(`Docs`, false)
                      ]),
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `tx-t-1 tx-5xl ml-10`, "href": `https://github.com/stackpress/ink`, "target": `_blank` }, [
                        import_Document.default.createText(`
      `, false),
                        import_Document.default.createElement("i", { "class": `fab fa-github` }, []),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `bg-h-cb3837 pill tx-t-1 tx-lg ml-5 p-5 tx-center`, "href": `https://www.npmjs.com/package/@stackpress/ink`, "target": `_blank` }, [
                        import_Document.default.createText(`
      `, false),
                        import_Document.default.createElement("i", { "class": `fab fa-npm tx-white` }, []),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ]),
                    import_Document.default.createText(`
`, false)
                  ])
                ]
              ]),
              import_Document.default.createText(`
      `, false),
              import_Document.default.createElement("aside", { "left": true }, [
                ...[
                  import_Document.default.createElement("header", { "class": `flex flex-center-y bg-t-2 py-15 pr-5 pl-10` }, [
                    import_Document.default.createText(`
  `, false),
                    import_Document.default.createElement("a", { "href": `/ink` }, [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("img", { "class": `h-26 mr-10`, "src": `/ink/ink-icon.png`, "alt": `Ink Logo` }),
                      import_Document.default.createText(`
  `, false)
                    ]),
                    import_Document.default.createText(`
  `, false),
                    import_Document.default.createElement("h3", { "class": `flex-grow m-0 tx-upper` }, [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `tx-primary`, "href": `/ink` }, [
                        import_Document.default.createText(`Ink`, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ]),
                    import_Document.default.createText(`
  `, false),
                    import_Document.default.createElement("i", { "class": `fas fa-fw fa-chevron-left cursor-pointer none md-inline-block`, "click": toggle }, []),
                    import_Document.default.createText(`
`, false)
                  ]),
                  import_Document.default.createText(`
`, false),
                  import_Document.default.createElement("nav", { "class": `bg-t-1 scroll-auto h-calc-full-60` }, [
                    import_Document.default.createText(`
  `, false),
                    import_Document.default.createElement("h6", { "class": `bt-1 bt-solid bt-t-1 tx-black tx-14 mb-0 mt-0 pt-20 pb-10 pl-10 tx-upper` }, [
                      import_Document.default.createText(`
    `, false),
                      ...this._toNodeList(_("Introduction")),
                      import_Document.default.createText(`
  `, false)
                    ]),
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/index.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Documentation")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Documentation")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/getting-started.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/getting-started.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Getting Started")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/getting-started.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Getting Started")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`

  `, false),
                    import_Document.default.createElement("h6", { "class": `bt-1 bt-solid bt-t-1 tx-black tx-14 mb-0 mt-20 pt-20 pb-10 pl-10 tx-upper` }, [
                      import_Document.default.createText(`
    `, false),
                      ...this._toNodeList(_("Features")),
                      import_Document.default.createText(`
  `, false)
                    ]),
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/markup-syntax.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/markup-syntax.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Markup Syntax")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/markup-syntax.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Markup Syntax")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/state-management.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/state-management.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("State Management")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/state-management.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("State Management")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/component-strategy.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/component-strategy.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Component Strategy")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/component-strategy.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Component Strategy")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/compiler-api.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/compiler-api.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Compiler API")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/compiler-api.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Compiler API")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/client-api.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/client-api.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Client API")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/client-api.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Client API")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`

  `, false),
                    import_Document.default.createElement("h6", { "class": `bt-1 bt-solid bt-t-1 tx-black tx-14 mb-0 mt-20 pt-20 pb-10 pl-10 tx-upper` }, [
                      import_Document.default.createText(`
    `, false),
                      ...this._toNodeList(_("Usage")),
                      import_Document.default.createText(`
  `, false)
                    ]),
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/template-engine.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/template-engine.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Template Engine")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/template-engine.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Template Engine")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/single-page.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/single-page.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Single Page App")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/single-page.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Single Page App")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/static-site.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/static-site.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Static Site Generator")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/static-site.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Static Site Generator")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/component-publisher.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/component-publisher.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Component Publisher")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/component-publisher.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Component Publisher")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/developer-tools.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/developer-tools.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Developer Tools")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/developer-tools.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Developer Tools")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`


    `, false),
                    import_Document.default.createElement("h6", { "class": `bt-1 bt-solid bt-t-1 tx-black tx-14 mb-0 mt-20 pt-20 pb-10 pl-10 tx-upper` }, [
                      import_Document.default.createText(`
    `, false),
                      ...this._toNodeList(_("UI")),
                      import_Document.default.createText(`
  `, false)
                    ]),
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/ui/index.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/ui/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Components")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/ui/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Components")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  
  
  `, false),
                    ...!!(url === "/docs/state-management.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/ui/form/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Form")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/ui/form/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Form")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`

  `, false),
                    ...!!(url === "/docs/client-api.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/ui/formats/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Formats")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 mb-100`, "href": `/ink/ui/formats/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Formats")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
`, false)
                  ])
                ]
              ]),
              import_Document.default.createText(`
      `, false),
              import_Document.default.createElement("aside", { "right": true }, [
                import_Document.default.createText(`
        `, false),
                import_Document.default.createElement("menu", { "class": `m-0 px-10 py-20 h-calc-full-40 bg-t-2 scroll-auto` }, [
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("h6", { "class": `tx-muted tx-14 mb-0 mt-0 pb-10 tx-upper` }, [
                    import_Document.default.createText(`
            `, false),
                    ...this._toNodeList(_("On this page")),
                    import_Document.default.createText(`
          `, false)
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("nav", { "class": `tx-14 tx-lh-32` }, [
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("a", { "class": `block tx-t-0`, "href": `#WYSIWYG` }, [
                      ...this._toNodeList(_("WYSIWYG"))
                    ]),
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("nav", { "class": `pl-20` }, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("a", { "class": `block tx-t-1`, "href": `#props` }, [
                        import_Document.default.createText(`\u2022 `, false),
                        ...this._toNodeList(_("Props"))
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("a", { "class": `block tx-t-1`, "href": `#basicWYSIWYG` }, [
                        import_Document.default.createText(`\u2022 `, false),
                        ...this._toNodeList(_("Basic WYSIWYG Editor"))
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("a", { "class": `block tx-t-1`, "href": `#styledWYSIWYG` }, [
                        import_Document.default.createText(`\u2022 `, false),
                        ...this._toNodeList(_("Styled WYSIWYG Editor"))
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("a", { "class": `block tx-t-1`, "href": `#minimalWYSIWYG` }, [
                        import_Document.default.createText(`\u2022 `, false),
                        ...this._toNodeList(_("Minimal WYSIWYG Editor"))
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("a", { "class": `block tx-t-1`, "href": `#fullFeaturedWYSIWYG` }, [
                        import_Document.default.createText(`\u2022 `, false),
                        ...this._toNodeList(_("Full-Featured WYSIWYG Editor"))
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("a", { "class": `block tx-t-1`, "href": `#preFilledWYSIWYG` }, [
                        import_Document.default.createText(`\u2022 `, false),
                        ...this._toNodeList(_("Pre-filled WYSIWYG Editor"))
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("a", { "class": `block tx-t-1`, "href": `#disabledWYSIWYG` }, [
                        import_Document.default.createText(`\u2022 `, false),
                        ...this._toNodeList(_("Disabled WYSIWYG Editor"))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`
          `, false)
                  ]),
                  import_Document.default.createText(`
        `, false)
                ]),
                import_Document.default.createText(`
      `, false)
              ]),
              import_Document.default.createText(`
      `, false),
              import_Document.default.createElement("main", {}, [
                import_Document.default.createText(`
        `, false),
                import_Document.default.createElement("api-docs", {}, [
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("nav", { "class": `p-10 bg-t-3 sticky top-0 z-50` }, [
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("element-crumbs", { "crumbs": crumbs, "block": true, "bold": true, "white": true, "sep-muted": true, "link-primary": true, "spacing": 2 }),
                    import_Document.default.createText(`
          `, false)
                  ]),
                  import_Document.default.createText(`

          `, false),
                  import_Document.default.createElement("a", { "name": `WYSIWYG` }, []),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("h1", { "class": `tx-primary tx-upper tx-30 py-20` }, [
                    ...this._toNodeList(_("WYSIWYG"))
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("ide-app", { "title": `WYSIWYG`, "class": `py-20` }, [
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("ide-code", { "class": `scroll-y-auto mb-10 w-full max-w-full min-w-full overflow-auto bg-black text-white`, "lang": `js`, "trim": true }, [
                      import_Document.default.createText(`
              import WYSIWYG from '@stackpress/ink-ui/field/wysiwyg';
            `, false)
                    ]),
                    import_Document.default.createText(`
          `, false)
                  ]),
                  import_Document.default.createText(`

          <!-- Props Section -->
          `, false),
                  import_Document.default.createElement("a", { "name": `props` }, []),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("h2", { "class": `tx-primary tx-upper tx-30 py-20` }, [
                    ...this._toNodeList(_("Props"))
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("p", { "class": `mb-20` }, [
                    ...this._toNodeList(_("The `<field-wysiwyg>` component provides a rich text editor for creating formatted content. Use Ink utilities via the `class` prop to style it responsively. Below are its props:"))
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("layout-table", { "top": true, "head": `py-16 px-12 bg-t-1 b-solid b-black bt-1 bb-0 bx-0`, "body": `py-16 px-12 b-solid b-black bt-1 bb-0 bx-0`, "odd": `bg-t-1`, "even": `bg-t-0` }, [
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("table-head", {}, [
                      ...this._toNodeList(_("Property"))
                    ]),
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("table-head", {}, [
                      ...this._toNodeList(_("Type"))
                    ]),
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("table-head", {}, [
                      ...this._toNodeList(_("Required"))
                    ]),
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("table-head", {}, [
                      ...this._toNodeList(_("Description"))
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`name`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`String`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Name attribute for form submission."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`value`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`String`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_('Initial content for the editor (defaults to "").'))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`disabled`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Disables the editor, preventing interaction."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`readonly`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Makes the editor read-only, allowing view only."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`history`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables undo/redo buttons (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`font`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables font family selection (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`size`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables font size selection (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`format`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables format block selection (e.g., headings, paragraph; default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`paragraph`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables paragraph style options (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`blockquote`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables blockquote button (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`style`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables text style buttons (bold, italic, etc.; default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`color`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables font color selection (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`highlight`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables highlight color selection (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`text`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables text style options (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`remove`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables remove format button (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`indent`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables indent/outdent buttons (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`align`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables alignment options (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`rule`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables horizontal rule button (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`list`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables ordered/unordered list buttons (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`lineheight`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables line height selection (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`table`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables table creation button (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`link`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables link insertion button (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`image`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables image insertion button (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`video`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables video insertion button (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`audio`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables audio insertion button (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`fullscreen`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables fullscreen toggle button (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`showblocks`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables show blocks toggle button (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`code`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables code view toggle button (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`print`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables preview and print buttons (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`save`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables save and template buttons (default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`dir`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Boolean`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Enables direction toggle buttons (LTR/RTL; default: false)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`change`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Function`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Custom handler for change events, receiving the event."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`update`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`Function`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Callback with the updated content."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`class`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`String`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_('Ink utility classes for responsive styling (e.g., "w-full p-5 b-solid b-t-3 c-6").'))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`

            `, false),
                    import_Document.default.createElement("table-row", {}, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`style`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`String`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        import_Document.default.createText(`No`, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("table-col", {}, [
                        ...this._toNodeList(_("Inline styles (use `class` with Ink utilities instead)."))
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`
          `, false)
                  ]),
                  import_Document.default.createText(`

          <!-- Basic WYSIWYG Editor -->
          `, false),
                  import_Document.default.createElement("a", { "name": `basicWYSIWYG` }, []),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("h2", { "class": `tx-primary tx-upper tx-30 py-20` }, [
                    ...this._toNodeList(_("Basic WYSIWYG Editor"))
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("div", { "class": `mb-10` }, [
                    ...this._toNodeList(_("A basic WYSIWYG editor with default Ink styling and common toolbar options."))
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("div", { "class": `basis-full mb-20` }, [
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("div", { "class": `bg-t-3 p-10 flex flex-col items-center justify-center` }, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("field-wysiwyg", { "name": `content`, "history": true, "font": true, "size": true, "format": true, "style": true, "color": true, "align": true, "list": true, "link": true, "class": `w-full p-4 b-solid b-t-2 c-4 tx-md`, "style": `cursor: text;`, "change": (e) => console.log("Change event:", e.target.value), "update": (value) => console.log("Updated value:", value) }),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`
          `, false)
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("ide-code", { "class": `scroll-y-auto mb-10 w-full bg-black text-white`, "lang": `html`, "trim": true, "detab": 4 }, [
                    ...this._toNodeList(`
            <field-wysiwyg 
              name="content" 
              history 
              font 
              size 
              format 
              style 
              color 
              align 
              list 
              link 
              class="w-full p-4 b-solid b-t-2 c-4 tx-md" 
              style="cursor: text;"
              change={(e) => console.log('Change event:', e.target.value)}
              update={(value) => console.log('Updated value:', value)}
            />
          `)
                  ]),
                  import_Document.default.createText(`

          <!-- Styled WYSIWYG Editor -->
          `, false),
                  import_Document.default.createElement("a", { "name": `styledWYSIWYG` }, []),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("h2", { "class": `tx-primary tx-upper tx-30 py-20` }, [
                    ...this._toNodeList(_("Styled WYSIWYG Editor"))
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("div", { "class": `mb-10` }, [
                    ...this._toNodeList(_("A styled WYSIWYG editor with responsive Ink utilities and hover effects."))
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("div", { "class": `basis-full mb-20` }, [
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("div", { "class": `bg-t-3 p-10 flex flex-col items-center justify-center` }, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("field-wysiwyg", { "name": `article`, "history": true, "font": true, "size": true, "format": true, "style": true, "color": true, "align": true, "list": true, "link": true, "class": `w-full min-h-300 p-6 b-solid b-t-3 c-6 tx-lg md:vw-90 sm:vw-95 shadow-md bg-white transition-300 hover:b-primary hover:shadow-0-2-8-t-3`, "style": `cursor: text;`, "change": handleChange, "update": handleUpdate }),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`
          `, false)
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("ide-code", { "class": `scroll-y-auto mb-10 w-full bg-black text-white`, "lang": `html`, "trim": true, "detab": 4 }, [
                    ...this._toNodeList(`
            <field-wysiwyg 
              name="article" 
              history 
              font 
              size 
              format 
              style 
              color 
              align 
              list 
              link 
              class="w-full min-h-300 p-6 b-solid b-t-3 c-6 tx-lg md:vw-90 sm:vw-95 shadow-md bg-white transition-300 hover:b-primary hover:shadow-0-2-8-t-3" 
              style="cursor: text;"
              change={handleChange}
              update={handleUpdate}
            />
          `)
                  ]),
                  import_Document.default.createText(`

          <!-- Minimal WYSIWYG Editor -->
          `, false),
                  import_Document.default.createElement("a", { "name": `minimalWYSIWYG` }, []),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("h2", { "class": `tx-primary tx-upper tx-30 py-20` }, [
                    ...this._toNodeList(_("Minimal WYSIWYG Editor"))
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("div", { "class": `mb-10` }, [
                    ...this._toNodeList(_("A minimal WYSIWYG editor with limited toolbar options and Ink styling."))
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("div", { "class": `basis-full mb-20` }, [
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("div", { "class": `bg-t-3 p-10 flex flex-col items-center justify-center` }, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("field-wysiwyg", { "name": `note`, "style": true, "color": true, "align": true, "class": `w-full min-h-200 p-4 b-dashed b-t-1 c-4 tx-verdana`, "style": `cursor: text;`, "update": (value) => console.log("Updated value:", value) }),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`
          `, false)
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("ide-code", { "class": `scroll-y-auto mb-10 w-full bg-black text-white`, "lang": `html`, "trim": true, "detab": 4 }, [
                    ...this._toNodeList(`
            <field-wysiwyg 
              name="note" 
              style 
              color 
              align 
              class="w-full min-h-200 p-4 b-dashed b-t-1 c-4 tx-verdana" 
              style="cursor: text;"
              update={(value) => console.log('Updated value:', value)}
            />
          `)
                  ]),
                  import_Document.default.createText(`

          <!-- Full-Featured WYSIWYG Editor -->
          `, false),
                  import_Document.default.createElement("a", { "name": `fullFeaturedWYSIWYG` }, []),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("h2", { "class": `tx-primary tx-upper tx-30 py-20` }, [
                    ...this._toNodeList(_("Full-Featured WYSIWYG Editor"))
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("div", { "class": `mb-10` }, [
                    ...this._toNodeList(_("A full-featured WYSIWYG editor with all toolbar options, styled with Ink utilities and hover effects."))
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("div", { "class": `basis-full mb-20` }, [
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("div", { "class": `bg-t-3 p-10 flex flex-col items-center justify-center` }, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("field-wysiwyg", { "name": `document`, "history": true, "font": true, "size": true, "format": true, "paragraph": true, "blockquote": true, "style": true, "color": true, "highlight": true, "text": true, "remove": true, "indent": true, "align": true, "rule": true, "list": true, "lineheight": true, "table": true, "link": true, "image": true, "video": true, "audio": true, "fullscreen": true, "showblocks": true, "code": true, "print": true, "save": true, "dir": true, "class": `w-full min-h-400 p-8 b-solid b-t-4 c-8 tx-xl md:vw-90 sm:vw-95 lg:shadow-lg transition-300 hover:b-primary`, "style": `cursor: text;`, "change": (e) => console.log("Change event:", e.target.value), "update": handleUpdate }),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`
          `, false)
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("ide-code", { "class": `scroll-y-auto mb-10 w-full bg-black text-white`, "lang": `html`, "trim": true, "detab": 4 }, [
                    ...this._toNodeList(`
            <field-wysiwyg 
              name="document" 
              history 
              font 
              size 
              format 
              paragraph 
              blockquote 
              style 
              color 
              highlight 
              text 
              remove 
              indent 
              align 
              rule 
              list 
              lineheight 
              table 
              link 
              image 
              video 
              audio 
              fullscreen 
              showblocks 
              code 
              print 
              save 
              dir 
              class="w-full min-h-400 p-8 b-solid b-t-4 c-8 tx-xl md:vw-90 sm:vw-95 lg:shadow-lg transition-300 hover:b-primary" 
              style="cursor: text;"
              change={(e) => console.log('Change event:', e.target.value)}
              update={handleUpdate}
            />
          `)
                  ]),
                  import_Document.default.createText(`

          <!-- Pre-filled WYSIWYG Editor -->
          `, false),
                  import_Document.default.createElement("a", { "name": `preFilledWYSIWYG` }, []),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("h2", { "class": `tx-primary tx-upper tx-30 py-20` }, [
                    ...this._toNodeList(_("Pre-filled WYSIWYG Editor"))
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("div", { "class": `mb-10` }, [
                    ...this._toNodeList(_("A WYSIWYG editor pre-filled with initial content, styled with Ink."))
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("div", { "class": `basis-full mb-20` }, [
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("div", { "class": `bg-t-3 p-10 flex flex-col items-center justify-center` }, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("field-wysiwyg", { "name": `blog`, "value": `<h1>Welcome</h1><p>This is a <b>pre-filled</b> editor with some content.</p>`, "history": true, "font": true, "size": true, "style": true, "color": true, "align": true, "list": true, "link": true, "class": `w-full min-h-300 p-6 b-solid b-t-3 c-6 tx-md transition-300 hover:b-primary`, "style": `cursor: text;`, "change": handleChange, "update": (value) => console.log("Updated value:", value) }),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`
          `, false)
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("ide-code", { "class": `scroll-y-auto mb-10 w-full bg-black text-white`, "lang": `html`, "trim": true, "detab": 4 }, [
                    ...this._toNodeList(`
            <field-wysiwyg 
              name="blog" 
              value="<h1>Welcome</h1><p>This is a <b>pre-filled</b> editor with some content.</p>" 
              history 
              font 
              size 
              style 
              color 
              align 
              list 
              link 
              class="w-full min-h-300 p-6 b-solid b-t-3 c-6 tx-md transition-300 hover:b-primary" 
              style="cursor: text;"
              change={handleChange}
              update={(value) => console.log('Updated value:', value)}
            />
          `)
                  ]),
                  import_Document.default.createText(`

          <!-- Disabled WYSIWYG Editor -->
          `, false),
                  import_Document.default.createElement("a", { "name": `disabledWYSIWYG` }, []),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("h2", { "class": `tx-primary tx-upper tx-30 py-20` }, [
                    ...this._toNodeList(_("Disabled WYSIWYG Editor"))
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("div", { "class": `mb-10` }, [
                    ...this._toNodeList(_("A disabled WYSIWYG editor with pre-filled content and muted styling."))
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("div", { "class": `basis-full mb-20` }, [
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("div", { "class": `bg-t-3 p-10 flex flex-col items-center justify-center` }, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("field-wysiwyg", { "name": `lockedContent`, "value": `<p>This content is <i>locked</i> and cannot be edited.</p>`, "disabled": true, "class": `w-full min-h-200 p-4 b-solid b-muted c-5 tx-muted`, "style": `cursor: not-allowed;` }),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`
          `, false)
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("ide-code", { "class": `scroll-y-auto mb-10 w-full bg-black text-white`, "lang": `html`, "trim": true, "detab": 4 }, [
                    ...this._toNodeList(`
            <field-wysiwyg 
              name="lockedContent" 
              value="<p>This content is <i>locked</i> and cannot be edited.</p>" 
              disabled 
              class="w-full min-h-200 p-4 b-solid b-muted c-5 tx-muted" 
              style="cursor: not-allowed;"
            />
          `)
                  ]),
                  import_Document.default.createText(`

          <!-- Navigation -->
          `, false),
                  import_Document.default.createElement("nav", { "class": `flex` }, [
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("a", { "class": `tx-primary py-40`, "href": `/ink/ui/field/time.html` }, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("element-icon", { "name": `chevron-left`, "theme": `tx-1` }),
                      import_Document.default.createText(`
              `, false),
                      ...this._toNodeList(_("Time")),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("a", { "class": `flex-grow tx-right tx-primary py-40`, "href": `/ink/ui/field/text.html` }, [
                      import_Document.default.createText(`
              `, false),
                      ...this._toNodeList(_("Text")),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("element-icon", { "name": `chevron-right`, "theme": `tx-1` }),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`
          `, false)
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("footer", { "class": `foot` }, []),
                  import_Document.default.createText(`
        `, false)
                ]),
                import_Document.default.createText(`
      `, false)
              ]),
              import_Document.default.createText(`
    `, false)
            ]),
            import_Document.default.createText(`
  `, false)
          ]),
          import_Document.default.createText(`
`, false)
        ])
      ];
    }
  };
  var components = {
    "ApiDocs_0ab1bce486b32e7cdafc": Docs_0ab1bce486b32e7cdafc,
    "IdeApp_4ec139eab67151540039": App_4ec139eab67151540039,
    "IdeCode_5387662ecbed97347dd0": Code_5387662ecbed97347dd0,
    "I18nTranslate_794a00a5e900fca28310": Translate_794a00a5e900fca28310,
    "PanelLayout_c4c96a14064fc0c4d224": Panel_c4c96a14064fc0c4d224,
    "ElementIcon_33cb84912ffcb000a388": Icon_33cb84912ffcb000a388,
    "ElementCrumbs_e4598fe781cc66b1ce2c": Crumbs_e4598fe781cc66b1ce2c,
    "InterfaceIcon_33cb84912ffcb000a388": Icon_33cb84912ffcb000a388,
    "LayoutTable_02bc3cbacda5727a0af3": Table_02bc3cbacda5727a0af3,
    "TableWrapper_cb9231b6c52140a254d4": Table_cb9231b6c52140a254d4,
    "TableHead_d8755504d9458a2c21da": Head_d8755504d9458a2c21da,
    "TableRow_0b3723ad0a2356b54f11": Row_0b3723ad0a2356b54f11,
    "TableCol_f45aa9d13a1588f1d9ab": Col_f45aa9d13a1588f1d9ab,
    "FieldWysiwyg_7e3499be9641069413db": Wysiwyg_7e3499be9641069413db
  };
  var elements = {
    "api-docs": Docs_0ab1bce486b32e7cdafc,
    "ide-app": App_4ec139eab67151540039,
    "ide-code": Code_5387662ecbed97347dd0,
    "i18n-translate": Translate_794a00a5e900fca28310,
    "panel-layout": Panel_c4c96a14064fc0c4d224,
    "element-icon": Icon_33cb84912ffcb000a388,
    "element-crumbs": Crumbs_e4598fe781cc66b1ce2c,
    "layout-table": Table_02bc3cbacda5727a0af3,
    "table-head": Head_d8755504d9458a2c21da,
    "table-row": Row_0b3723ad0a2356b54f11,
    "table-col": Col_f45aa9d13a1588f1d9ab,
    "field-wysiwyg": Wysiwyg_7e3499be9641069413db
  };
  var BUILD_ID = "423152b6b1055d88a088";
  import_Emitter.default.once("ready", () => {
    TemplateDocument.sync();
    for (const [tagname, definition] of Object.entries(elements)) {
      if (!customElements.getName(definition)) {
        customElements.define(tagname, definition);
      }
    }
    import_Emitter.default.emit("mounted", document.body);
  });
  return __toCommonJS(wysiwyg_exports);
})();
/*! Bundled license information:

prismjs/prism.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)
*/
