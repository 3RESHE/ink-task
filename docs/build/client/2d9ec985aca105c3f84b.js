var InkAPI = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // ../../node_modules/@stackpress/ink/dist/dom/Node.js
  var require_Node = __commonJS({
    "../../node_modules/@stackpress/ink/dist/dom/Node.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var Node2 = class {
        constructor() {
          this._parent = null;
        }
        get parent() {
          return this._parent;
        }
        get parentElement() {
          return this._parent;
        }
        set parent(parent) {
          this._parent = parent;
        }
      };
      exports.default = Node2;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/dom/Comment.js
  var require_Comment = __commonJS({
    "../../node_modules/@stackpress/ink/dist/dom/Comment.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Node_1 = __importDefault(require_Node());
      var Comment = class extends Node_1.default {
        get nodeName() {
          return this.name;
        }
        get nodeType() {
          return this.type;
        }
        constructor(value) {
          super();
          this.name = "#comment";
          this.type = 8;
          this.value = value;
        }
        export() {
          return {
            type: this.type,
            name: this.name,
            value: this.value
          };
        }
        toString() {
          return `<!--${this.value}-->`;
        }
      };
      exports.default = Comment;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/dom/Doctype.js
  var require_Doctype = __commonJS({
    "../../node_modules/@stackpress/ink/dist/dom/Doctype.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Node_1 = __importDefault(require_Node());
      var Doctype = class extends Node_1.default {
        get nodeName() {
          return this.name;
        }
        get nodeType() {
          return this.type;
        }
        constructor(value) {
          super();
          this.name = "#doctype";
          this.type = 10;
          this.value = value;
        }
        export() {
          return {
            type: this.type,
            name: this.name,
            value: this.value
          };
        }
        toString() {
          return `<!DOCTYPE ${this.value}>`;
        }
      };
      exports.default = Doctype;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/dom/Element.js
  var require_Element = __commonJS({
    "../../node_modules/@stackpress/ink/dist/dom/Element.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Node_1 = __importDefault(require_Node());
      var selfClosingTags = [
        "area",
        "base",
        "br",
        "col",
        "embed",
        "hr",
        "img",
        "input",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ];
      var Element2 = class _Element extends Node_1.default {
        get attributes() {
          return Object.fromEntries(this._attributes);
        }
        get childList() {
          return Array.from(this.children);
        }
        get elements() {
          return this.nodes.filter((node) => node instanceof _Element);
        }
        get nodeName() {
          return this.name.toUpperCase();
        }
        get nodes() {
          const nodes = [this];
          this._flatten(Array.from(this.children), nodes);
          return nodes;
        }
        get nodeType() {
          return this.type;
        }
        get parent() {
          return this._parent;
        }
        set parent(parent) {
          this._parent = parent;
        }
        constructor(name2, attributes = {}, children2 = []) {
          super();
          this.type = 1;
          this._parent = null;
          this.name = name2;
          this._attributes = new Map(Object.entries(attributes));
          this.children = new Set(children2.filter(Boolean));
        }
        appendChild(child) {
          this.children.add(child);
          child.parent = this;
          return this;
        }
        export() {
          return {
            type: this.type,
            name: this.name,
            attributes: Object.fromEntries(this._attributes.entries()),
            children: Array.from(this.children).map((child) => child.export())
          };
        }
        getAttribute(name2) {
          return this._attributes.get(name2);
        }
        hasAttribute(name2) {
          return this._attributes.has(name2);
        }
        removeAttribute(name2) {
          this._attributes.delete(name2);
          return this;
        }
        removeChild(child) {
          this.children.delete(child);
          child.parent = null;
          return;
        }
        setAttribute(name2, value) {
          this._attributes.set(name2, value);
          return this;
        }
        toString() {
          const entries = Array.from(this._attributes.entries());
          const attributes = entries.length > 0 ? " " + entries.map(([key, value]) => {
            if (typeof value === "string" && !/["<>\n]/.test(value)) {
              return `${key}="${value}"`;
            } else if (typeof value === "boolean") {
              return value ? key : "";
            }
          }).join(" ") : "";
          if (selfClosingTags.includes(this.name)) {
            return `<${this.name}${attributes} />`;
          }
          const children2 = Array.from(this.children.values()).map((child) => child.toString()).join("");
          return `<${this.name}${attributes}>${children2}</${this.name}>`;
        }
        _flatten(markup, nodes) {
          markup.forEach((node) => {
            nodes.push(node);
            if (node instanceof _Element) {
              this._flatten(Array.from(node.children), nodes);
            }
          });
        }
      };
      exports.default = Element2;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/dom/Text.js
  var require_Text = __commonJS({
    "../../node_modules/@stackpress/ink/dist/dom/Text.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Node_1 = __importDefault(require_Node());
      var Text2 = class extends Node_1.default {
        get nodeName() {
          return "#text";
        }
        get nodeType() {
          return this.type;
        }
        get value() {
          return this._escape ? this._value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") : this._value;
        }
        constructor(value, escape2 = false) {
          super();
          this.name = "#text";
          this.type = 3;
          this._escape = escape2;
          this._value = value;
        }
        export() {
          return {
            type: this.type,
            name: this.name,
            value: this.value
          };
        }
        toString() {
          return this.value;
        }
      };
      exports.default = Text2;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/dom/Document.js
  var require_Document = __commonJS({
    "../../node_modules/@stackpress/ink/dist/dom/Document.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Comment_1 = __importDefault(require_Comment());
      var Doctype_1 = __importDefault(require_Doctype());
      var Element_1 = __importDefault(require_Element());
      var Text_1 = __importDefault(require_Text());
      var Document = class _Document {
        static createComment(value, parent) {
          const node = new Comment_1.default(value);
          if (parent) {
            node.parent = parent;
          }
          return node;
        }
        static createDoctype(value = "html", parent) {
          const node = new Doctype_1.default(value);
          if (parent) {
            node.parent = parent;
          }
          return node;
        }
        static createElement(name2, attributes = {}, children2 = [], parent) {
          const element = new Element_1.default(name2, attributes, children2);
          if (parent) {
            element.parent = parent;
          }
          return element;
        }
        static createText(value, escape2 = false, parent) {
          const node = new Text_1.default(value, escape2);
          if (parent) {
            node.parent = parent;
          }
          return node;
        }
        static import(data2, parent) {
          return data2.map((node) => {
            const { value } = node;
            const { name: name2, attributes, children: children2 } = node;
            switch (node.type) {
              case 1:
                const element = this.createElement(name2, attributes, [], parent);
                _Document.import(children2, element).forEach((child) => element.appendChild(child));
                return element;
              case 3:
                return this.createText(value, true, parent);
              case 8:
                return this.createComment(value, parent);
              case 10:
                return this.createDoctype(value, parent);
            }
            return null;
          }).filter(Boolean);
        }
        static load(children2) {
          return new _Document(children2);
        }
        get childList() {
          return Array.from(this.children);
        }
        get elements() {
          return this.nodes.filter((node) => node instanceof Element_1.default);
        }
        get nodes() {
          return Array.from(this.children).map((child) => child instanceof Element_1.default ? child.nodes : [child]).flat();
        }
        constructor(children2) {
          this.children = new Set(children2.filter(Boolean));
        }
        export() {
          return this.childList.map((child) => child.export());
        }
        toString() {
          return Array.from(this.children).map((child) => child.toString()).join("");
        }
      };
      exports.default = Document;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/data.js
  var require_data = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/data.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TemplateData = void 0;
      var TemplateData = class {
        constructor() {
          if (!window.__TEMPLATE_DATA__) {
            window.__TEMPLATE_DATA__ = {};
          }
        }
        clear() {
          window.__TEMPLATE_DATA__ = {};
          return this;
        }
        delete(key) {
          if (this.has(key)) {
            delete window.__TEMPLATE_DATA__[key];
            return true;
          }
          return false;
        }
        entries() {
          return Object.entries(window.__TEMPLATE_DATA__);
        }
        has(key) {
          return key in window.__TEMPLATE_DATA__;
        }
        get(key) {
          return window.__TEMPLATE_DATA__[key];
        }
        keys() {
          return Object.keys(window.__TEMPLATE_DATA__);
        }
        set(key, value) {
          window.__TEMPLATE_DATA__[key] = value;
          return this;
        }
        values() {
          return Object.values(window.__TEMPLATE_DATA__);
        }
      };
      exports.TemplateData = TemplateData;
      var data2 = new TemplateData();
      exports.default = data2;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/Emitter.js
  var require_Emitter = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/Emitter.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.match = exports.ClientEmitter = exports.events = void 0;
      exports.bindAttribute = bindAttribute;
      exports.unbindAttribute = unbindAttribute;
      var Registry_1 = __importDefault(require_Registry());
      exports.events = [
        "click",
        "dblclick",
        "mousedown",
        "mouseup",
        "mousemove",
        "mouseover",
        "mouseout",
        "wheel",
        "keydown",
        "keypress",
        "keyup",
        "blur",
        "change",
        "contextmenu",
        "focus",
        "input",
        "submit",
        "invalid",
        "reset",
        "search",
        "select",
        "copy",
        "cut",
        "paste",
        "drag",
        "dragstart",
        "dragend",
        "dragover",
        "dragenter",
        "dragleave",
        "drop",
        "scroll",
        "durationchange",
        "ended",
        "error",
        "loadeddata",
        "loadedmetadata",
        "loadstart",
        "pause",
        "play",
        "playing",
        "progress",
        "ratechange",
        "seeked",
        "seeking",
        "stalled",
        "suspend",
        "timeupdate",
        "volumechange",
        "waiting",
        "animationstart",
        "animationend",
        "animationiteration",
        "transitionend",
        "toggle"
      ];
      var ClientEmitter = class extends EventTarget {
        emit(event, target) {
          this.dispatchEvent(new CustomEvent(event, { detail: target }));
          return this;
        }
        on(event, callback) {
          if (event === "ready") {
            if (document.readyState !== "loading") {
              const event2 = new CustomEvent("ready");
              setTimeout(() => callback(event2), 1);
              return this;
            }
          }
          this.addEventListener(event, callback);
          return this;
        }
        once(event, callback) {
          const unbinder = (e) => {
            this.unbind(event, unbinder);
            callback(e);
          };
          this.on(event, unbinder);
          return this;
        }
        unbind(event, callback) {
          this.removeEventListener(event, callback);
          return this;
        }
      };
      exports.ClientEmitter = ClientEmitter;
      var match = (element, attribute, bind = true) => {
        return Array.from(element.querySelectorAll("*")).filter((element2) => {
          const node = Registry_1.default.get(element2);
          const matched = node && node.hasAttribute(attribute) && (!bind || !node.hasEvent(attribute));
          if (matched) {
            node.addEvent(attribute);
          }
          return matched;
        }).map((element2) => Registry_1.default.get(element2));
      };
      exports.match = match;
      function bindAttribute(name2, bind) {
        emitter2.on("mounted", (e) => {
          if (!e.detail)
            return;
          const element = e.detail;
          (0, exports.match)(element.shadowRoot || element, name2).forEach(bind);
        });
      }
      function unbindAttribute(name2, bind) {
        emitter2.on("unmounted", (e) => {
          if (!e.detail)
            return;
          const element = e.detail;
          (0, exports.match)(element.shadowRoot || element, name2, false).forEach(bind);
        });
      }
      var emitter2 = new ClientEmitter();
      exports.default = (() => {
        document.onreadystatechange = () => {
          if (document.readyState !== "loading") {
            emitter2.emit("ready");
          }
        };
        bindAttribute("mount", (element) => {
          const callback = element.getAttribute("mount");
          if (typeof callback === "function") {
            const event = new CustomEvent("mount", {
              detail: {
                node: element,
                target: element.element
              }
            });
            callback(event);
          }
        });
        unbindAttribute("unmount", (element) => {
          const callback = element.getAttribute("unmount");
          if (typeof callback === "function") {
            const event = new CustomEvent("unmount", {
              detail: {
                node: element,
                target: element.element
              }
            });
            callback(event);
          }
        });
        bindAttribute("if", (element) => {
          const condition = element.getAttribute("if");
          if (condition === false || condition === "false") {
            element.element.remove();
          } else if (typeof condition === "function" && !condition()) {
            element.element.remove();
          }
        });
        exports.events.forEach((event) => {
          bindAttribute(event, (element) => {
            const callback = element.getAttribute(event);
            if (typeof callback === "function") {
              element.element.removeEventListener(event, callback);
              element.element.addEventListener(event, callback);
            }
          });
          unbindAttribute(event, (element) => {
            const callback = element.getAttribute(event);
            if (typeof callback === "function") {
              element.element.removeEventListener(event, callback);
            }
          });
        });
        return emitter2;
      })();
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/Element.js
  var require_Element2 = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/Element.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Emitter_1 = __importDefault(require_Emitter());
      var ClientElement = class {
        get attributes() {
          return Object.assign({}, this._attributes);
        }
        get element() {
          return this._element;
        }
        get events() {
          return this._events;
        }
        constructor(element, attributes) {
          this._events = /* @__PURE__ */ new Set();
          this._element = element;
          this._attributes = attributes;
        }
        addEvent(event) {
          this._events.add(event);
          return this;
        }
        camel() {
          return Object.fromEntries(Object.entries(this._attributes).map(([key, value]) => {
            if (key === "class") {
              return ["className", value];
            }
            const camel = key.replace(/-([a-z])/g, (_2, letter) => letter.toUpperCase()).replaceAll("-", "");
            return [camel, value];
          }));
        }
        getAttribute(key) {
          return this._attributes[key];
        }
        hasAttribute(key) {
          return key in this._attributes;
        }
        hasEvent(event) {
          return this._events.has(event);
        }
        removeAttribute(key, silent = false) {
          const current = this.getAttribute(key);
          if (typeof current === "undefined") {
            return this;
          }
          delete this._attributes[key];
          if (!silent) {
            Emitter_1.default.emit("attribute-remove", {
              element: this,
              key,
              previous: current
            });
          }
          return this;
        }
        setAttribute(key, value, silent = false) {
          if (typeof value === "undefined") {
            return this.removeAttribute(key, silent);
          }
          const current = this.getAttribute(key);
          if (current === value) {
            return this;
          }
          this._attributes[key] = value;
          if (!silent) {
            if (typeof current === "undefined") {
              Emitter_1.default.emit("attribute-create", { element: this, key, value });
            } else {
              Emitter_1.default.emit("attribute-update", {
                element: this,
                key,
                value,
                previous: current
              });
            }
          }
          return this;
        }
        setAttributes(attributes, silent = false) {
          for (const [key, value] of Object.entries(attributes)) {
            this.setAttribute(key, value, silent);
          }
          const names = Object.keys(attributes);
          for (const key of Object.keys(this._attributes)) {
            if (!names.includes(key)) {
              this.removeAttribute(key, silent);
            }
          }
          return this;
        }
        tree(attributes, name2, value) {
          if (!attributes) {
            attributes = Object.assign({}, this._attributes);
          }
          if (name2) {
            const path = name2.split("-");
            if (path.length > 0) {
              const key = path.shift();
              if (path.length > 0) {
                if (!attributes[key])
                  attributes[key] = {};
                this.tree(attributes[key], path.join("-"), value);
              } else {
                attributes[key] = value;
              }
            }
            return attributes;
          }
          const branch = {};
          for (const [name3, value2] of Object.entries(attributes)) {
            this.tree(branch, name3, value2);
          }
          return branch;
        }
      };
      exports.default = ClientElement;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/client.js
  var require_client = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/client.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = () => window.InkAPI;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/Registry.js
  var require_Registry = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/Registry.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Element_1 = __importDefault(require_Element2());
      var client_1 = __importDefault(require_client());
      var decoder = document.createElement("textarea");
      var decode = (value) => {
        decoder.innerHTML = value;
        return decoder.value;
      };
      var ClientRegistry35 = class _ClientRegistry {
        static get elements() {
          return this._elements;
        }
        static createComponent(tagname, definition, attributes = {}, children2 = []) {
          var _a;
          const { registered } = definition;
          if (!registered && !((_a = (0, client_1.default)()) === null || _a === void 0 ? void 0 : _a.elements[tagname])) {
            return this.createVirtualComponent(tagname, definition, attributes, children2);
          }
          const name2 = registered || tagname;
          const component4 = document.createElement(name2);
          customElements.whenDefined(name2).then(() => {
            customElements.upgrade(component4);
            if (!component4.initiated) {
              component4.connectedCallback();
            }
          });
          const element = _ClientRegistry.register(component4, attributes);
          element.setAttributes(attributes, true);
          for (const [name3, value] of Object.entries(attributes)) {
            if (typeof value === "string") {
              component4.setAttribute(name3, value);
            } else if (value === true) {
              component4.setAttribute(name3, "");
            }
          }
          this._cleanChildren(children2).forEach((child) => component4.appendChild(child));
          return element;
        }
        static createElement(name2, attributes = {}, children2 = []) {
          const element = document.createElement(name2);
          for (const [name3, value] of Object.entries(attributes)) {
            if (typeof value === "string") {
              element.setAttribute(name3, value);
            } else if (value === true) {
              element.setAttribute(name3, "");
            }
          }
          this._cleanChildren(children2).forEach((child) => element.appendChild(child));
          return this.register(element, attributes);
        }
        static createText(value, escape2 = true) {
          return document.createTextNode(decode(value));
        }
        static createVirtualComponent(tagname, definition, attributes = {}, children2 = []) {
          const component4 = document.createElement(tagname);
          component4.definition = definition;
          Object.setPrototypeOf(component4, definition.prototype);
          component4.constructor = definition.constructor;
          component4.constructor.id = definition.id;
          component4.constructor.tagname = definition.tagname;
          component4.constructor.classname = definition.classname;
          if (definition.observedAttributes) {
            component4.constructor.observedAttributes = definition.observedAttributes;
          }
          component4.register(attributes, children2);
          return component4.element;
        }
        static cloneElement(node, andChildren = false) {
          var _a;
          const component4 = node;
          if (component4.definition) {
            const children2 = component4.originalChildren || [];
            return this.createComponent(component4.nodeName.toLowerCase(), component4.definition, component4.props || {}, andChildren ? children2.map((element) => this.cloneElement(element, andChildren)) : []).element;
          } else if (node instanceof HTMLElement) {
            const children2 = Array.from(node.childNodes);
            return this.createElement(node.nodeName.toLowerCase(), this.has(node) ? (_a = this.get(node)) === null || _a === void 0 ? void 0 : _a.attributes : Object.fromEntries(Array.from(node.attributes).map((attribute) => [attribute.name, attribute.value])), andChildren ? children2.map((element) => this.cloneElement(element, andChildren)) : []).element;
          }
          return node.cloneNode(andChildren);
        }
        static filter(callback) {
          const elements2 = [];
          this._elements.forEach((ink, html2) => {
            if (callback(ink, html2)) {
              elements2.push(ink);
            }
          });
          return elements2;
        }
        static get(element) {
          return this._elements.get(element) || null;
        }
        static has(element) {
          return this._elements.has(element);
        }
        static map(callback) {
          const elements2 = [];
          this._elements.forEach((ink, html2) => {
            elements2.push(callback(ink, html2));
          });
          return elements2;
        }
        static register(element, attributes, andChildren = false) {
          if (this.has(element)) {
            return this.get(element);
          }
          if (!attributes) {
            Array.from(element.attributes).forEach((attribute) => {
              attributes = attributes || {};
              attributes[attribute.name] = attribute.value !== "" ? attribute.value : true;
            });
          }
          const node = new Element_1.default(element, attributes || {});
          this._elements.set(element, node);
          if (andChildren) {
            Array.from(element.children).forEach((child) => {
              if (child instanceof Element) {
                this.register(child, void 0, true);
              }
            });
          }
          return node;
        }
        static _cleanChildren(children2) {
          return Array.from(children2).filter((child) => typeof child !== "undefined").map((child) => typeof child === "string" ? this.createText(child) : child instanceof Element_1.default ? child.element : child);
        }
      };
      ClientRegistry35._elements = /* @__PURE__ */ new Map();
      exports.default = ClientRegistry35;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/Document.js
  var require_Document2 = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/Document.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Document_1 = __importDefault(require_Document());
      var data_1 = __importDefault(require_data());
      var Registry_1 = __importDefault(require_Registry());
      var ClientDocument2 = class {
        constructor() {
          const template = document.querySelector("script[data-template]");
          if (!template) {
            throw new Error("TEMPLATE_DATA not found");
          }
          try {
            window.__TEMPLATE_DATA__ = JSON.parse(template.innerText.trim());
            Object.entries(window.__TEMPLATE_DATA__).forEach(([key, value]) => {
              data_1.default.set(key, value);
            });
          } catch (error) {
            throw new Error("TEMPLATE_DATA is not a valid JSON");
          }
        }
        bindings() {
          data_1.default.set("current", "document");
          const markup = this.template();
          data_1.default.delete("current");
          const sequence = Document_1.default.load(markup).elements;
          const entries = Array.from(sequence).map((el, id) => [String(id), el.attributes]).filter((entry) => Object.keys(entry[1]).length);
          return Object.fromEntries(entries);
        }
        sync() {
          const bindings = this.bindings();
          const map = Array.from(document.querySelectorAll("*"));
          for (const element of map) {
            const attributes = Object.fromEntries(Array.from(element.attributes).map((attribute) => [
              attribute.nodeName,
              attribute.nodeValue && attribute.nodeValue.length > 0 ? attribute.nodeValue : true
            ]));
            const id = String(Registry_1.default.elements.size);
            if (bindings[id]) {
              Object.assign(attributes, bindings[id]);
            }
            Registry_1.default.register(element, attributes);
          }
          return bindings;
        }
        _toNodeList(value) {
          if (typeof value === "object" && typeof value.nodeType === "number") {
            return [value];
          }
          if (Array.isArray(value)) {
            if (value.every((item) => typeof item === "object" && typeof item.nodeType === "number")) {
              return value;
            }
          }
          return [Registry_1.default.createText(String(value))];
        }
      };
      exports.default = ClientDocument2;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/Component.js
  var require_Component = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/Component.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Element_1 = __importDefault(require_Element2());
      var Registry_1 = __importDefault(require_Registry());
      var Emitter_1 = __importDefault(require_Emitter());
      var data_1 = __importDefault(require_data());
      var ClientComponent31 = class _ClientComponent extends HTMLElement {
        static get registered() {
          return customElements.getName(this);
        }
        static register() {
          customElements.define(this.tagname, this);
        }
        get attr() {
          return Object.fromEntries(Array.from(this.attributes).map((attr) => [attr.name, attr.value]));
        }
        get definition() {
          return this._definition || this.constructor;
        }
        get element() {
          if (!Registry_1.default.has(this)) {
            throw new Error(`Component ${this.metadata.classname} not mapped.`);
          }
          return Registry_1.default.get(this);
        }
        get initiated() {
          return this._initiated;
        }
        get metadata() {
          const { id, classname, tagname, registered, observedAttributes: observed = [] } = this.definition;
          return {
            id,
            tagname,
            classname,
            registered,
            observed
          };
        }
        get originalChildren() {
          return this._children;
        }
        get props() {
          return this.getAttributes();
        }
        get propsCamel() {
          return this.element.camel();
        }
        get propsTree() {
          return this.element.tree();
        }
        get virtual() {
          return this._virtual;
        }
        set props(props) {
          this.setAttributes(props);
        }
        set definition(definition) {
          this._definition = definition;
        }
        set originalChildren(children2) {
          if (typeof this._children === "undefined") {
            this._children = this._cleanChildren(children2 || []);
          }
        }
        constructor() {
          super();
          this._children = void 0;
          this._definition = null;
          this._initiated = false;
          this._observer = null;
          this._rendering = false;
          this._template = null;
          this._virtual = false;
          if (!Registry_1.default.has(this)) {
            const { registered } = this.metadata;
            if (!registered) {
              throw new Error(`Component ${this.metadata.classname} not registered in customElements.`);
            }
            const attributes = Object.fromEntries(Array.from(this.attributes).map((attr) => [attr.name, attr.value !== "" ? attr.value : true]));
            Registry_1.default.register(this, attributes);
          }
        }
        adoptedCallback() {
          this.render();
          this.emit("adopt", this);
        }
        attributeChangedCallback(name2, prev, next) {
          if (this._rendering) {
            return;
          }
          const action = prev === null ? "add" : next === null ? "remove" : "update";
          if (next === null && this.hasAttribute(name2)) {
            this.element.removeAttribute(name2);
          } else if (next === "") {
            this.element.setAttribute(name2, true);
          } else {
            this.element.setAttribute(name2, next);
          }
          this.emit("attributechange", { action, name: name2, prev, value: next, target: this });
        }
        clone(andChildren = false) {
          return this.cloneElement(this, andChildren);
        }
        cloneElement(element, andChildren = false) {
          return Registry_1.default.cloneElement(element, andChildren);
        }
        connectedCallback() {
          this.wait();
          this.emit("connect", this);
        }
        createComponent(tagname, definition, attributes = {}, children2 = []) {
          return Registry_1.default.createComponent(tagname, definition, attributes, children2);
        }
        createElement(name2, attributes = {}, children2 = []) {
          return Registry_1.default.createElement(name2, attributes, children2);
        }
        disconnectedCallback() {
          this.emit("disconnect", this);
        }
        emit(event, detail) {
          this.dispatchEvent(new CustomEvent(event, { detail }));
          return this;
        }
        getAttribute(name2) {
          return this.element.getAttribute(name2);
        }
        getAttributes() {
          return Object.assign({}, this.element.attributes);
        }
        getChildren(type = true) {
          if (type === true) {
            return Array.from(this.childNodes);
          } else if (type === false) {
            return this._children;
          } else if (type === null && this.shadowRoot) {
            return Array.from(this.shadowRoot.childNodes);
          }
          return [];
        }
        getElement(element) {
          return Registry_1.default.get(element);
        }
        getParentComponent() {
          let parent = this.parentElement;
          while (parent) {
            if (parent instanceof _ClientComponent) {
              return parent;
            }
            parent = parent.parentElement;
          }
          return null;
        }
        hasAttribute(name2) {
          return this.element.hasAttribute(name2);
        }
        on(event, callback) {
          this.removeEventListener(event, callback);
          this.addEventListener(event, callback);
          return this;
        }
        once(event, callback) {
          const unbinder = (e) => {
            this.removeEventListener(event, callback);
            callback(e);
          };
          this.on(event, unbinder);
          return this;
        }
        register(attributes = {}, children2 = []) {
          if (Registry_1.default.has(this)) {
            const element = Registry_1.default.get(this);
            element.setAttributes(attributes);
          } else {
            Registry_1.default.register(this, attributes);
          }
          for (const [name2, value] of Object.entries(attributes)) {
            if (typeof value === "string" || value === true) {
              super.setAttribute(name2, value === "" || value === name2 || value === true ? true : value);
            }
          }
          this._children = this._cleanChildren(children2);
          this._children.forEach((child) => this.appendChild(child));
          this._virtual = true;
          this.connectedCallback();
        }
        removeAttribute(name2) {
          const prev = this.getAttribute(name2);
          if (this.hasAttribute(name2)) {
            this.element.removeAttribute(name2);
          }
          if (super.hasAttribute(name2)) {
            super.removeAttribute(name2);
          }
          if (this._virtual && this.metadata.observed.includes(name2)) {
            this.attributeChangedCallback(name2, prev, null);
          }
        }
        render() {
          const parent = this.getParentComponent();
          if (parent && !parent.initiated) {
            return;
          } else if (this._rendering) {
            return;
          }
          this._rendering = true;
          const prev = data_1.default.get("current");
          data_1.default.set("current", this);
          if (!this._template) {
            this._template = this.template();
          } else {
            Emitter_1.default.emit("unmounted", this);
          }
          const children2 = this._template().filter(Boolean);
          const styles = this.styles();
          const mode = styles.length === 0 ? "light" : "shadow";
          const { light, shadow } = this._getChildren(children2, mode);
          if (shadow.length === 0 && mode === "light") {
            this.textContent = "";
            light.forEach((child) => this.appendChild(child));
          } else {
            if (!this.shadowRoot) {
              this.attachShadow({ mode: "open", delegatesFocus: true });
            }
            const style = document.createElement("style");
            style.innerText = styles;
            const shadowRoot = this.shadowRoot;
            shadowRoot.textContent = "";
            shadowRoot.appendChild(style);
            shadow.forEach((child) => shadowRoot.appendChild(child));
            if (light.length) {
              this.textContent = "";
              light.forEach((child) => this.appendChild(child));
            }
          }
          if (prev) {
            data_1.default.set("current", prev);
          } else {
            data_1.default.delete("current");
          }
          this._initiated = true;
          this._rendering = false;
          Emitter_1.default.emit("mounted", this);
          return this.shadowRoot ? this.shadowRoot.innerHTML : this.innerHTML;
        }
        setAttribute(name2, value) {
          const prev = this.getAttribute(name2);
          if (value === "" || value === true) {
            this.element.setAttribute(name2, true);
            super.setAttribute(name2, "");
          } else if (value === false) {
            this.element.setAttribute(name2, value);
            super.removeAttribute(name2);
          } else if (typeof value === "string") {
            this.element.setAttribute(name2, value);
            super.setAttribute(name2, value);
          } else {
            this.element.setAttribute(name2, value);
          }
          if (this._virtual && this.metadata.observed.includes(name2) && typeof value === "string") {
            this.attributeChangedCallback(name2, prev, value);
          }
        }
        setAttributes(attributes) {
          Object.entries(attributes).forEach(([key, value]) => this.setAttribute(key, value));
        }
        unbind(event, callback) {
          this.removeEventListener(event, callback);
          return this;
        }
        wait() {
          if (document.readyState !== "loading") {
            this._update();
          } else {
            const next = () => {
              this._update();
              Emitter_1.default.unbind("ready", next);
            };
            Emitter_1.default.on("ready", next);
          }
        }
        _cleanChildren(children2) {
          return Array.from(children2).filter((child) => typeof child !== "undefined").map((child) => typeof child === "string" ? Registry_1.default.createText(child) : child instanceof Element_1.default ? child.element : child);
        }
        _getChildren(children2, mode) {
          const anyNodes = this._getTemplateNodes(children2);
          const lightNodes = this._getTemplateNodes(children2, "light");
          const shadowNodes = this._getTemplateNodes(children2, "shadow");
          const defaultNodes = anyNodes.length > 0 ? anyNodes : children2;
          return {
            light: lightNodes.length > 0 ? lightNodes : mode === "light" ? defaultNodes : [],
            shadow: shadowNodes.length > 0 ? shadowNodes : mode === "shadow" ? defaultNodes : []
          };
        }
        _getTemplateNodes(children2, type) {
          const template = children2.find((child) => this._isTemplate(child, type));
          if (!template)
            return [];
          return Array.from(template.childNodes || []);
        }
        _isTemplate(child, type) {
          if (child.nodeName !== "TEMPLATE")
            return false;
          const template = child;
          if (!type)
            return !template.hasAttribute("type");
          return type === template.getAttribute("type");
        }
        _toNodeList(value) {
          if (value instanceof Node) {
            return [value];
          }
          if (Array.isArray(value)) {
            if (value.every((item) => item instanceof Node)) {
              return value;
            }
          }
          return [Registry_1.default.createText(String(value))];
        }
        _update() {
          if (typeof this._children === "undefined") {
            this._children = this._cleanChildren(Array.from(this.childNodes || []));
          }
          if (!this._initiated) {
            this.render();
          }
        }
      };
      exports.default = ClientComponent31;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/Field.js
  var require_Field = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/Field.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Component_1 = __importDefault(require_Component());
      var ClientField4 = class extends Component_1.default {
        get field() {
          return this._field;
        }
        constructor() {
          super();
          this._field = this.attachInternals();
        }
        formAssociatedCallback(form) {
          this.emit("formassociate", this);
        }
        formDisabledCallback(disabled) {
          this.emit("formdisable", this);
        }
        formResetCallback() {
          this.emit("formreset", this);
        }
      };
      ClientField4.formAssociated = true;
      exports.default = ClientField4;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/component.js
  var require_component = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/component.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = component4;
      var data_1 = __importDefault(require_data());
      function component4(component5 = null, nullable = false) {
        if (!component5) {
          component5 = data_1.default.get("current");
          if (!component5) {
            if (!nullable) {
              throw new Error("Not called within a Ink component");
            }
            return null;
          }
        }
        return component5;
      }
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/env.js
  var require_env = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/env.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var data_1 = __importDefault(require_data());
      function env2(name2) {
        const env3 = data_1.default.get("env") || {};
        if (name2) {
          return env3[name2] || null;
        }
        return env3;
      }
      exports.default = env2;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/props.js
  var require_props = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/props.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = props;
      var component_1 = __importDefault(require_component());
      var data_1 = __importDefault(require_data());
      function props(pointer = null) {
        const component4 = (0, component_1.default)(pointer, true);
        if (typeof component4 === "string") {
          return data_1.default.get("props") || {};
        }
        return component4 ? component4.props : {};
      }
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/classnames.js
  var require_classnames = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/classnames.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.classlist = classlist2;
      exports.default = classnames;
      var component_1 = __importDefault(require_component());
      var props_1 = __importDefault(require_props());
      function classlist2(pointer = null) {
        var _a;
        if (pointer === "body") {
          return document.body.classList;
        } else if (pointer === "head") {
          return document.head.classList;
        } else if (pointer === "document") {
          return (_a = document.body.parentElement) === null || _a === void 0 ? void 0 : _a.classList;
        }
        const component4 = (0, component_1.default)(pointer);
        return component4 === null || component4 === void 0 ? void 0 : component4.classList;
      }
      function classnames(pointer = null) {
        return (0, props_1.default)(pointer)["class"] || "";
      }
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/children.js
  var require_children = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/children.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.innerHTML = innerHTML;
      exports.innerText = innerText;
      exports.default = children2;
      var component_1 = __importDefault(require_component());
      function innerHTML(pointer = null) {
        const inner = children2(pointer);
        const wrapper = document.createElement("template");
        wrapper.append(...inner.map((child) => child.cloneNode(true)));
        return wrapper.innerHTML;
      }
      function innerText(pointer = null) {
        const inner = children2(pointer);
        const wrapper = document.createElement("template");
        wrapper.append(...inner.map((child) => child.cloneNode(true)));
        return wrapper.innerText;
      }
      function children2(pointer = null) {
        const component4 = (0, component_1.default)(pointer, true);
        return typeof component4 !== "string" && component4 ? component4.originalChildren || [] : [];
      }
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client/api/signal.js
  var require_signal = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client/api/signal.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SignalRegistry = void 0;
      exports.default = signal7;
      var component_1 = __importDefault(require_component());
      var SignalRegistry = class _SignalRegistry {
        static observe(component4, value) {
          const methods = {
            getter: () => property.raw,
            setter: (value2) => value2
          };
          const listeners = /* @__PURE__ */ new Set();
          const property = {
            raw: value,
            change(callback) {
              listeners.add(callback);
              return property;
            },
            getter(callback) {
              methods.getter = callback;
              return property;
            },
            setter(callback) {
              methods.setter = callback;
              return property;
            }
          };
          Object.defineProperty(property, "value", {
            get() {
              return methods.getter();
            },
            set(value2) {
              const formatted = methods.setter(value2);
              const rerender = _SignalRegistry.serialize(formatted) !== _SignalRegistry.serialize(property.raw);
              property.raw = formatted;
              if (rerender) {
                listeners.forEach((listener) => listener(formatted));
                component4.render();
              }
            }
          });
          const observer = this._observers.get(component4);
          if (!observer) {
            this._observers.set(component4, {
              observed: 1,
              values: [property]
            });
          } else {
            observer.observed++;
            observer.values.push(property);
          }
          return property;
        }
        static observer(component4) {
          return this._observers.get(component4) || null;
        }
        static serialize(value) {
          return JSON.stringify(value);
        }
      };
      exports.SignalRegistry = SignalRegistry;
      SignalRegistry._observers = /* @__PURE__ */ new Map();
      function signal7(value, pointer = null) {
        const component4 = (0, component_1.default)(pointer);
        if (!component4.initiated) {
          return SignalRegistry.observe(component4, value);
        }
        const observer = SignalRegistry.observer(component4);
        if (!observer) {
          throw new Error("Signal state mismatch");
        }
        const values = observer.values;
        return values[observer.observed++ % observer.values.length];
      }
    }
  });

  // ../../node_modules/@stackpress/ink/dist/style/StyleMap.js
  var require_StyleMap = __commonJS({
    "../../node_modules/@stackpress/ink/dist/style/StyleMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stylemap = stylemap;
      function stylemap(styles = {}) {
        return new StyleMap(Object.entries(styles));
      }
      var StyleMap = class _StyleMap extends Map {
        add(property, values) {
          if (!this.has(property)) {
            this.set(property, []);
          }
          const styles = this.get(property);
          if (typeof values === "string" || typeof values === "number") {
            styles.push(values);
          } else if (Array.isArray(values)) {
            styles.push(...values);
          }
          return this;
        }
        clone() {
          const stylemap2 = new _StyleMap();
          for (const [key, values] of this.entries()) {
            stylemap2.set(key, values.slice());
          }
          return stylemap2;
        }
        replaceAll(search, replace) {
          for (const [key, values] of this.entries()) {
            this.set(key, values.map((value) => {
              if (typeof value === "string") {
                return value.replaceAll(search, replace);
              }
              return value;
            }));
          }
          return this;
        }
      };
      exports.default = StyleMap;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/style/StyleSet.js
  var require_StyleSet = __commonJS({
    "../../node_modules/@stackpress/ink/dist/style/StyleSet.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.styleset = styleset;
      var StyleMap_1 = __importDefault(require_StyleMap());
      function styleset(styles = {}) {
        return new StyleSet28(Object.entries(styles));
      }
      var StyleSet28 = class extends Map {
        add(selector, property, values) {
          if (!this.has(selector)) {
            this.set(selector, new StyleMap_1.default());
          }
          const styles = this.get(selector);
          if (typeof values === "string") {
            styles.set(property, values.split(" "));
          } else if (Array.isArray(values)) {
            styles.set(property, values);
          }
          return this;
        }
        map(selector, map) {
          this.set(selector, map);
          return this;
        }
        toString() {
          const styleset2 = [];
          for (const [selector, styles] of this.entries()) {
            const definitions = [];
            for (const [property, values] of styles.entries()) {
              if (property && (values === null || values === void 0 ? void 0 : values.length)) {
                definitions.push(`${property}:${values.join(" ")}`);
              }
            }
            if (definitions.length) {
              styleset2.push(`${selector}{${definitions.join(";")}}`);
            }
          }
          return styleset2.join("");
        }
      };
      exports.default = StyleSet28;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/style/StyleSheet.js
  var require_StyleSheet = __commonJS({
    "../../node_modules/@stackpress/ink/dist/style/StyleSheet.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.breakpoints = void 0;
      exports.stylesheet = stylesheet;
      var StyleSet_1 = __importDefault(require_StyleSet());
      exports.breakpoints = {
        all: 0,
        xl4: 1920,
        xl3: 1536,
        xl2: 1280,
        xl: 1024,
        lg: 992,
        md: 767,
        sm: 420,
        xs: 360
      };
      function stylesheet() {
        return new StyleSheet();
      }
      var StyleSheet = class extends Map {
        add(media, selector, property, values) {
          if (!this.has(media)) {
            this.set(media, new StyleSet_1.default());
          }
          const styleset = this.get(media);
          styleset.add(selector, property, values);
          return this;
        }
        map(media, selector, map) {
          if (!this.has(media)) {
            this.set(media, new StyleSet_1.default());
          }
          const styleset = this.get(media);
          styleset.map(selector, map);
          return this;
        }
        toString() {
          var _a;
          const stylesheet2 = [];
          for (const [media, breakpoint] of Object.entries(exports.breakpoints)) {
            const styles = (_a = this.get(media)) === null || _a === void 0 ? void 0 : _a.toString();
            if (!styles) {
              continue;
            }
            if (media === "all") {
              stylesheet2.push(styles);
              continue;
            }
            stylesheet2.push(`@media (max-width:${breakpoint}px){${styles}}`);
          }
          return stylesheet2.join("");
        }
      };
      exports.default = StyleSheet;
    }
  });

  // ../../node_modules/@stackpress/lib/dist/Status.js
  var require_Status = __commonJS({
    "../../node_modules/@stackpress/lib/dist/Status.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getStatus = getStatus;
      var statuses = {
        CONTINUE: { code: 100, status: "Continue" },
        PROCESSING: { code: 102, status: "Processing" },
        OK: { code: 200, status: "OK" },
        CREATED: { code: 201, status: "Created" },
        ACCEPTED: { code: 202, status: "Accepted" },
        EMPTY: { code: 204, status: "No Content" },
        RESET: { code: 205, status: "Reset Content" },
        PARTIAL: { code: 206, status: "Partial Content" },
        MOVED: { code: 301, status: "Moved Permanently" },
        FOUND: { code: 302, status: "Found" },
        REDIRECT: { code: 303, status: "See Other" },
        CACHE: { code: 304, status: "Not Modified" },
        TEMPORARY: { code: 307, status: "Temporary Redirect" },
        PERMANENT: { code: 308, status: "Permanent Redirect" },
        ABORT: { code: 309, status: "Aborted" },
        BAD_REQUEST: { code: 400, status: "Bad Request" },
        UNAUTHORIZED: { code: 401, status: "Unauthorized" },
        FORBIDDEN: { code: 403, status: "Forbidden" },
        NOT_FOUND: { code: 404, status: "Not Found" },
        BAD_METHOD: { code: 405, status: "Method Not Allowed" },
        NOT_ACCEPTABLE: { code: 406, status: "Not Acceptable" },
        REQUEST_TIMEOUT: { code: 408, status: "Request Timeout" },
        CONFLICT: { code: 409, status: "Conflict" },
        GONE: { code: 410, status: "Gone" },
        LENGTH_REQUIRED: { code: 411, status: "Length Required" },
        TOO_LARGE: { code: 413, status: "Payload Too Large" },
        TOO_LONG: { code: 414, status: "URI Too Long" },
        UNSUPPORTED_TYPE: { code: 415, status: "Unsupported Media Type" },
        BAD_RANGE: { code: 416, status: "Range Not Satisfiable" },
        BAD_EXPECTATION: { code: 417, status: "Expectation Failed" },
        MISDIRECTED: { code: 421, status: "Misdirected Request" },
        UNPROCESSABLE: { code: 422, status: "Unprocessable Content" },
        LOCKED: { code: 423, status: "Locked" },
        BAD_DEPENDENCY: { code: 424, status: "Failed Dependency" },
        UPGRADE_REQUIRED: { code: 426, status: "Upgrade Required" },
        BAD_PRECONDITION: { code: 428, status: "Precondition Required" },
        TOO_MANY: { code: 429, status: "Too Many Requests" },
        HEADER_TOO_LARGE: { code: 431, status: "Request Header Fields Too Large" },
        LEGAL_REASONS: { code: 451, status: "Unavailable For Legal Reasons" },
        ERROR: { code: 500, status: "Internal Server Error" },
        NOT_IMPLEMENTED: { code: 501, status: "Not Implemented" },
        BAD_GATEWAY: { code: 502, status: "Bad Gateway" },
        UNAVAILABLE: { code: 503, status: "Service Unavailable" },
        RESPONSE_TIMEOUT: { code: 504, status: "Gateway Timeout" },
        BAD_VERSION: { code: 505, status: "HTTP Version Not Supported" },
        INSUFFICIENT_STORAGE: { code: 507, status: "Insufficient Storage" },
        INFINITE_LOOP: { code: 508, status: "Loop Detected" },
        NETWORK_AUTHENTICATION_REQUIRED: { code: 511, status: "Network Authentication Required" }
      };
      exports.default = statuses;
      function getStatus(code) {
        return Object.values(statuses).find((status) => status.code === code);
      }
    }
  });

  // ../../node_modules/@stackpress/lib/dist/Exception.js
  var require_Exception = __commonJS({
    "../../node_modules/@stackpress/lib/dist/Exception.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var Status_1 = require_Status();
      var Exception = class _Exception extends Error {
        static for(message, ...values) {
          values.forEach(function(value) {
            message = message.replace("%s", String(value));
          });
          return new this(message);
        }
        static forErrors(errors) {
          const exception = new this("Invalid Parameters");
          exception.withErrors(errors);
          return exception;
        }
        static require(condition, message, ...values) {
          if (!condition) {
            for (const value of values) {
              message = message.replace("%s", value);
            }
            throw new this(message);
          }
        }
        static try(callback) {
          return {
            catch: (catcher) => {
              try {
                return callback();
              } catch (error) {
                if (error instanceof _Exception) {
                  return catcher(error, error.type);
                } else if (error instanceof Error) {
                  const e = _Exception.upgrade(error);
                  return catcher(e, e.type);
                } else if (typeof error === "string") {
                  const e = _Exception.for(error);
                  return catcher(e, e.type);
                }
                return catcher(error, "unknown");
              }
            }
          };
        }
        static upgrade(error, code = 500) {
          if (error instanceof _Exception) {
            return error;
          }
          const exception = new this(error.message, code);
          exception.name = error.name;
          exception.stack = error.stack;
          return exception;
        }
        get code() {
          return this._code;
        }
        get end() {
          return this._end;
        }
        get errors() {
          return Object.assign({}, this._errors);
        }
        get start() {
          return this._start;
        }
        get type() {
          return this._type;
        }
        constructor(message, code = 500) {
          var _a;
          super(message);
          this._errors = {};
          this._start = 0;
          this._end = 0;
          this.name = this.constructor.name;
          this._type = this.constructor.name;
          this._code = code;
          this._status = ((_a = (0, Status_1.getStatus)(code)) === null || _a === void 0 ? void 0 : _a.status) || "Unknown";
        }
        toJSON() {
          return JSON.stringify(this.toResponse(), null, 2);
        }
        toResponse(start = 0, end = 0) {
          const json = {
            code: this._code,
            status: this._status,
            error: this.message,
            start: this._start,
            end: this._end,
            stack: this.trace(start, end)
          };
          if (Object.keys(this._errors).length > 0) {
            json.errors = this._errors;
          }
          return json;
        }
        trace(start = 0, end = 0) {
          if (typeof this.stack !== "string") {
            return [];
          }
          const trace = this.stack.split("\n").slice(start, end || this.stack.length).map((line) => line.trim()).map((trace2) => {
            if (!trace2.startsWith("at")) {
              return false;
            }
            let [_2, method, location2] = trace2.split(" ");
            if (!location2) {
              location2 = `(${method})`;
              method = "<none>";
            }
            const [file, line, char] = location2.substring(1, location2.length - 1).split(":");
            return {
              method,
              file,
              line: parseInt(line) || 0,
              char: parseInt(char) || 0
            };
          }).filter(Boolean);
          return trace;
        }
        withCode(code) {
          this._code = code;
          return this;
        }
        withErrors(errors) {
          this._errors = errors;
          return this;
        }
        withPosition(start, end) {
          this._start = start;
          this._end = end;
          return this;
        }
      };
      exports.default = Exception;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/Exception.js
  var require_Exception2 = __commonJS({
    "../../node_modules/@stackpress/ink/dist/Exception.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Exception_1 = __importDefault(require_Exception());
      var InkException = class extends Exception_1.default {
      };
      exports.default = InkException;
    }
  });

  // ../../node_modules/@stackpress/ink/dist/client.js
  var require_client2 = __commonJS({
    "../../node_modules/@stackpress/ink/dist/client.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StyleSheet = exports.StyleSet = exports.StyleMap = exports.stylesheet = exports.styleset = exports.stylemap = exports.breakpoints = exports.emitter = exports.signal = exports.innerHTML = exports.innerText = exports.children = exports.classnames = exports.classlist = exports.props = exports.env = exports.data = exports.client = exports.component = exports.SignalRegistry = exports.ClientException = exports.ClientEmitter = exports.ClientElement = exports.ClientRegistry = exports.ClientComponent = exports.ClientField = exports.TemplateData = exports.DOMNode = exports.DOMText = exports.DOMElement = exports.DOMDocument = exports.DOMDoctype = exports.DOMComment = void 0;
      var Comment_1 = __importDefault(require_Comment());
      exports.DOMComment = Comment_1.default;
      var Doctype_1 = __importDefault(require_Doctype());
      exports.DOMDoctype = Doctype_1.default;
      var Document_1 = __importDefault(require_Document());
      exports.DOMDocument = Document_1.default;
      var Element_1 = __importDefault(require_Element());
      exports.DOMElement = Element_1.default;
      var Text_1 = __importDefault(require_Text());
      exports.DOMText = Text_1.default;
      var Node_1 = __importDefault(require_Node());
      exports.DOMNode = Node_1.default;
      var Field_1 = __importDefault(require_Field());
      exports.ClientField = Field_1.default;
      var Component_1 = __importDefault(require_Component());
      exports.ClientComponent = Component_1.default;
      var Registry_1 = __importDefault(require_Registry());
      exports.ClientRegistry = Registry_1.default;
      var Element_2 = __importDefault(require_Element2());
      exports.ClientElement = Element_2.default;
      var Emitter_1 = __importStar(require_Emitter());
      exports.emitter = Emitter_1.default;
      Object.defineProperty(exports, "ClientEmitter", { enumerable: true, get: function() {
        return Emitter_1.ClientEmitter;
      } });
      var client_1 = __importDefault(require_client());
      exports.client = client_1.default;
      var component_1 = __importDefault(require_component());
      exports.component = component_1.default;
      var data_1 = __importStar(require_data());
      exports.data = data_1.default;
      Object.defineProperty(exports, "TemplateData", { enumerable: true, get: function() {
        return data_1.TemplateData;
      } });
      var env_1 = __importDefault(require_env());
      exports.env = env_1.default;
      var props_1 = __importDefault(require_props());
      exports.props = props_1.default;
      var classnames_1 = __importStar(require_classnames());
      exports.classnames = classnames_1.default;
      Object.defineProperty(exports, "classlist", { enumerable: true, get: function() {
        return classnames_1.classlist;
      } });
      var children_1 = __importStar(require_children());
      exports.children = children_1.default;
      Object.defineProperty(exports, "innerHTML", { enumerable: true, get: function() {
        return children_1.innerHTML;
      } });
      Object.defineProperty(exports, "innerText", { enumerable: true, get: function() {
        return children_1.innerText;
      } });
      var signal_1 = __importStar(require_signal());
      exports.signal = signal_1.default;
      Object.defineProperty(exports, "SignalRegistry", { enumerable: true, get: function() {
        return signal_1.SignalRegistry;
      } });
      var StyleMap_1 = __importStar(require_StyleMap());
      exports.StyleMap = StyleMap_1.default;
      Object.defineProperty(exports, "stylemap", { enumerable: true, get: function() {
        return StyleMap_1.stylemap;
      } });
      var StyleSet_1 = __importStar(require_StyleSet());
      exports.StyleSet = StyleSet_1.default;
      Object.defineProperty(exports, "styleset", { enumerable: true, get: function() {
        return StyleSet_1.styleset;
      } });
      var StyleSheet_1 = __importStar(require_StyleSheet());
      exports.StyleSheet = StyleSheet_1.default;
      Object.defineProperty(exports, "stylesheet", { enumerable: true, get: function() {
        return StyleSheet_1.stylesheet;
      } });
      Object.defineProperty(exports, "breakpoints", { enumerable: true, get: function() {
        return StyleSheet_1.breakpoints;
      } });
      var Exception_1 = __importDefault(require_Exception2());
      exports.ClientException = Exception_1.default;
    }
  });

  // ../../node_modules/@stackpress/ink/index.js
  var require_ink = __commonJS({
    "../../node_modules/@stackpress/ink/index.js"(exports, module) {
      module.exports = { ...require_client2() };
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/style/color.js
  var require_color = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/style/color.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = color;
      function color(props, styles, initial = false, selector = ":host", property = "color") {
        const { color: color2, white, black, info, warning, success, error, muted, primary, secondary, theme } = props;
        const style = color2 ? color2 : theme ? `var(--${theme})` : white ? "var(--white)" : black ? "var(--black)" : info ? "var(--info)" : warning ? "var(--warning)" : success ? "var(--success)" : error ? "var(--error)" : muted ? "var(--muted)" : primary ? "var(--primary)" : secondary ? "var(--secondary)" : initial;
        if (style) {
          styles.add(selector, property, style);
        }
        return color2 ? "color" : white ? "white" : black ? "black" : info ? "info" : warning ? "warning" : success ? "success" : error ? "error" : muted ? "muted" : primary ? "primary" : secondary ? "secondary" : "initial";
      }
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/style/curve.js
  var require_curve = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/style/curve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = curve;
      function curve(props, styles, initial = false, selector = ":host") {
        const { curve: curve2, curved, rounded, pill } = props;
        const style = curve2 ? `${curve2}px` : curved ? "4px" : rounded ? "12px" : pill ? "10000px" : initial;
        if (style) {
          styles.add(selector, "border-radius", style);
          styles.add(selector, "overflow", "hidden");
        }
        return curve2 ? "curve" : curved ? "curved" : rounded ? "rounded" : pill ? "pill" : "initial";
      }
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/style/display.js
  var require_display = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/style/display.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = display;
      function display(props, styles, initial = false, selector = ":host") {
        const { flex, none, inline: inline2, block: block2, "inline-block": iblock, "inline-flex": iflex } = props;
        const style = flex ? "flex" : none ? "none" : block2 ? "block" : inline2 ? "inline" : iflex ? "inline-flex" : iblock ? "inline-block" : initial;
        if (style) {
          styles.add(selector, "display", style);
        }
        return style || "initial";
      }
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/style/padding.js
  var require_padding = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/style/padding.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = padding;
      function padding(props, styles, selector = ":host") {
        const { padding: padding2, "padding-x": paddingX, "padding-y": paddingY } = props;
        let set = false;
        if (!isNaN(parseInt(padding2))) {
          styles.add(selector, "padding", `${padding2}px`);
          set = true;
        }
        if (!isNaN(parseInt(paddingX))) {
          styles.add(selector, "padding-left", `${paddingX}px`);
          styles.add(selector, "padding-right", `${paddingX}px`);
          set = true;
        }
        if (!isNaN(parseInt(paddingY))) {
          styles.add(selector, "padding-top", `${paddingY}px`);
          styles.add(selector, "padding-bottom", `${paddingY}px`);
          set = true;
        }
        return set;
      }
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/events.js
  var require_events = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/events.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.removeEvents = removeEvents2;
      var Emitter_1 = require_Emitter();
      function removeEvents2(props) {
        const attributes = Object.assign({}, props);
        for (const key in attributes) {
          if (Emitter_1.events.includes(key)) {
            delete attributes[key];
          }
        }
        return attributes;
      }
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/fieldset.js
  var require_fieldset = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/fieldset.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.buttonStyles = buttonStyles4;
      exports.borderStyles = borderStyles2;
      exports.cloneElement = cloneElement;
      exports.getHandlers = getHandlers13;
      var Registry_1 = __importDefault(require_Registry());
      var color_1 = __importDefault(require_color());
      var curve_1 = __importDefault(require_curve());
      var padding_1 = __importDefault(require_padding());
      function buttonStyles4(props, styles) {
        const { size, xs, sm, md, lg, xl, xl2, xl3, xl4, xl5, outline, solid, transparent, full } = props;
        const pad = (0, padding_1.default)(props, styles, "button");
        if (!pad) {
          xs ? styles.add("button", "padding", "2px 4px") : sm ? styles.add("button", "padding", "5px 10px") : md ? styles.add("button", "padding", "8px 16px") : lg ? styles.add("button", "padding", "12px 24px") : xl ? styles.add("button", "padding", "15px 30px") : xl2 ? styles.add("button", "padding", "18px 36px") : xl3 ? styles.add("button", "padding", "22px 44px") : xl4 ? styles.add("button", "padding", "26px 52px") : xl5 ? styles.add("button", "padding", "30px 60px") : size ? styles.add("button", "padding", size) : styles.add("button", "padding", "5px 10px");
        }
        (0, curve_1.default)(props, styles, false, "button");
        if (full) {
          styles.add("button", "width", "100%");
        }
        if (outline || transparent) {
          (0, color_1.default)(props, styles, "var(--muted)", "button", "color");
          (0, color_1.default)(props, styles, "var(--muted)", "button", "border-color");
          styles.add("button", "border-style", "solid");
          styles.add("button", "border-width", "1px");
          if (outline) {
            styles.add("button", "background-color", "var(--white)");
          }
        } else if (solid) {
          styles.add("button", "border", "0");
          styles.add("button", "color", "var(--white)");
          (0, color_1.default)(props, styles, "var(--muted)", "button", "background-color");
        } else {
          styles.add("button", "border", "0");
          styles.add("button", "color", "var(--white)");
          (0, color_1.default)(props, styles, "var(--muted)", "button", "background-color");
        }
      }
      function borderStyles2(props, styles) {
        const { border = {} } = props;
        const color = (0, color_1.default)(border, styles, "transparent", "fieldset", "border-color");
        if (color === "initial") {
          styles.add("fieldset", "border", "0");
          styles.add("fieldset", "padding", "0");
          styles.add("fieldset", "margin", "0");
        } else {
          styles.add("fieldset", "border-style", "solid");
          styles.add("fieldset", "border-width", "1px");
        }
      }
      function cloneElement(node, prepare, andChildren = false) {
        const component4 = node;
        if (component4.definition) {
          const children2 = component4.originalChildren || [];
          const attributes = prepare(component4);
          return Registry_1.default.createComponent(component4.nodeName.toLowerCase(), component4.definition, attributes || {}, andChildren ? children2.map((element) => cloneElement(element, prepare, andChildren)) : []).element;
        } else if (node instanceof HTMLElement) {
          const children2 = Array.from(node.childNodes);
          const attributes = prepare(component4);
          return Registry_1.default.createElement(node.nodeName.toLowerCase(), attributes || {}, andChildren ? children2.map((element) => cloneElement(element, prepare, andChildren)) : []).element;
        }
        return node.cloneNode(andChildren);
      }
      function getHandlers13(host, template) {
        const { name: name2, legend } = host.props;
        const handlers = {
          add: (e) => {
            const shadow = host.shadowRoot;
            if (!shadow)
              return;
            const button = shadow.querySelector("button");
            if (!button)
              return;
            const { fieldset, slot } = handlers.create(host.childElementCount);
            button.before(fieldset);
            host.appendChild(slot);
          },
          create: (index, input = {}, errors = {}) => {
            input = (input === null || input === void 0 ? void 0 : input.constructor.name) === "Object" ? input : {};
            errors = (errors === null || errors === void 0 ? void 0 : errors.constructor.name) === "Object" ? errors : {};
            const fields = template.map((element) => cloneElement(element, (node) => {
              var _a;
              const component4 = node;
              const attributes = component4.definition ? component4.props || {} : node instanceof HTMLElement && Registry_1.default.has(node) ? ((_a = Registry_1.default.get(node)) === null || _a === void 0 ? void 0 : _a.attributes) || {} : node instanceof HTMLElement ? Object.fromEntries(Array.from(node.attributes).map((attribute) => [attribute.name, attribute.value])) : {};
              if (attributes.field) {
                attributes.name = `${name2}[${index}][${attributes.field}]`;
                if (typeof input[attributes.field] !== "undefined") {
                  attributes.value = input[attributes.field];
                }
                if (typeof errors[attributes.field] === "string") {
                  attributes.error = errors[attributes.field];
                }
              } else if (attributes.control && typeof errors[attributes.control] === "string") {
                attributes.error = errors[attributes.control];
              }
              return attributes;
            }, true));
            const slot = Registry_1.default.createElement("div", { slot: `row-${index}` }, fields).element;
            const title = legend ? legend.replace("%s", index + 1) : void 0;
            const remove = Registry_1.default.createElement("a", {}, ["&times;"]).element;
            const label = legend ? Registry_1.default.createElement("span", {}, [title]).element : void 0;
            const fieldset = Registry_1.default.createElement("fieldset", {}, [
              Registry_1.default.createElement("legend", {}, [label, remove]).element,
              Registry_1.default.createElement("slot", { name: `row-${index}` }).element
            ]).element;
            remove.addEventListener("click", () => handlers.remove(fieldset, slot));
            return { fieldset, slot };
          },
          remove: (fieldset, slot) => {
            var _a;
            const shadow = host.shadowRoot;
            if (!shadow)
              return;
            fieldset.remove();
            slot.remove();
            shadow.querySelectorAll("fieldset slot").forEach((slot2, index) => {
              slot2.setAttribute("name", `row-${index}`);
            });
            host.querySelectorAll(":scope > div[slot]").forEach((slot2, index) => {
              slot2.setAttribute("slot", `row-${index}`);
              if (name2) {
                Array.from(slot2.querySelectorAll("[name]")).forEach((element) => {
                  const key = element.getAttribute("data-key");
                  if (key) {
                    element.setAttribute("name", `${name2}[${index}][${key}]`);
                  }
                });
              }
            });
            if (legend) {
              (_a = host.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll("fieldset legend span").forEach((span, index) => {
                span.textContent = legend.replace("%s", index + 1);
              });
            }
          },
          set: (input = {}, errors = {}) => {
            input = (input === null || input === void 0 ? void 0 : input.constructor.name) === "Object" ? input : {};
            errors = (errors === null || errors === void 0 ? void 0 : errors.constructor.name) === "Object" ? errors : {};
            const fields = template.map((element) => cloneElement(element, (node) => {
              var _a;
              const component4 = node;
              const attributes = component4.definition ? component4.props || {} : node instanceof HTMLElement && Registry_1.default.has(node) ? ((_a = Registry_1.default.get(node)) === null || _a === void 0 ? void 0 : _a.attributes) || {} : node instanceof HTMLElement ? Object.fromEntries(Array.from(node.attributes).map((attribute) => [attribute.name, attribute.value])) : {};
              if (attributes.field) {
                attributes.name = `${name2}[${attributes.field}]`;
                if (typeof input[attributes.field] !== "undefined") {
                  attributes.value = input[attributes.field];
                }
                if (typeof errors[attributes.field] === "string") {
                  attributes.error = errors[attributes.field];
                }
              } else if (attributes.control && typeof errors[attributes.control] === "string") {
                attributes.error = errors[attributes.control];
              }
              return attributes;
            }, true));
            const slot = Registry_1.default.createElement("div", {}, fields).element;
            const fieldset = Registry_1.default.createElement("fieldset", {}, [
              Registry_1.default.createElement("slot").element
            ]).element;
            return { fieldset, slot };
          }
        };
        return handlers;
      }
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/option.js
  var require_option = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/option.js"(exports) {
      "use strict";
      var __rest = exports && exports.__rest || function(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getProps = getProps11;
      exports.setStyles = setStyles3;
      exports.getHandlers = getHandlers13;
      function getProps11(host) {
        const _a = host.props, { label, error, check, circle, square, rounded, blue, orange, change, update, click, style, "class": _2 } = _a, attributes = __rest(_a, ["label", "error", "check", "circle", "square", "rounded", "blue", "orange", "change", "update", "click", "style", "class"]);
        return {
          label,
          error,
          check,
          circle,
          square,
          rounded,
          blue,
          orange,
          change,
          update,
          attributes
        };
      }
      function setStyles3(props, styles, initial) {
        const { rounded, circle, square, check, blue, orange } = props;
        styles.add("label", "font-family", "Arial, Helvetica, sans-serif");
        styles.add("label", "display", "inline-block");
        styles.add("label", "position", "relative");
        styles.add("label", "cursor", "pointer");
        styles.add("span", "align-items", "center");
        styles.add("span", "display", "inline-flex");
        styles.add("span", "font-weight", "400");
        styles.add("span", "line-height", "18px");
        styles.add("span", "margin", "0");
        styles.add("span", "min-height", "18px");
        styles.add("span", "min-width", "18px");
        styles.add("span", "pointer-events", "none");
        styles.add("span", "position", "relative");
        styles.add("span", "z-index", "1");
        styles.add("span::before", "border-width", "1px");
        styles.add("span::before", "border-style", "solid");
        styles.add("span::before", "box-shadow", "0 1px 2px rgba(0, 0, 0, 0.05)");
        styles.add("span::before", "content", '"\\a0"');
        styles.add("span::before", "display", "inline-block");
        styles.add("span::before", "font-size", "11px");
        styles.add("span::before", "font-weight", "400");
        styles.add("span::before", "height", "18px");
        styles.add("span::before", "min-width", "18px");
        styles.add("span::before", "margin-right", "5px");
        styles.add("span::before", "text-align", "center");
        styles.add("input", "height", "20px");
        styles.add("input", "opacity", "0");
        styles.add("input", "margin", "0");
        styles.add("input", "position", "absolute");
        styles.add("input", "width", "20px");
        styles.add("input:checked", "outline", "0 !important");
        styles.add("input:focus", "outline", "0 !important");
        styles.add("input:checked + span::before", "display", "inline-block");
        styles.add("input:checked + span::before", "box-shadow", [
          "0 1px 2px rgba(0, 0, 0, 0.05)",
          "inset 0 -15px 10px -12px rgba(0, 0, 0, 0.05)",
          "inset 15px 10px -12px rgba(255, 255, 255, 0.1)"
        ].join(", "));
        styles.add("input:checked + span::before", "font-weight", "900");
        styles.add("input:active + span::before", "box-shadow", [
          "0 1px 2px rgba(0, 0, 0, 0.05)",
          "inset 0 1px 3px rgba(0, 0, 0, 0.1)"
        ].join(", "));
        styles.add("input:checked:active + span::before", "box-shadow", [
          "0 1px 2px rgba(0, 0, 0, 0.05)",
          "inset 0 1px 3px rgba(0, 0, 0, 0.1)"
        ].join(", "));
        styles.add("input:disabled + span::before", "background-color", "#DDDDDD !important");
        styles.add("input:disabled + span::before", "border-color", "#CCCCCC !important");
        styles.add("input:disabled + span::before", "box-shadow", "none !important");
        styles.add("input:disabled + span::before", "color", "#BBBBBB");
        styles.add("input[disabled] + span::before", "background-color", "#DDDDDD !important");
        styles.add("input[disabled] + span::before", "border-color", "#CCCCCC !important");
        styles.add("input[disabled] + span::before", "box-shadow", "none !important");
        styles.add("input[disabled] + span::before", "color", "#BBBBBB");
        if (rounded) {
          styles.add("span::before", "border-radius", "100%");
        }
        const shape = circle ? "circle" : square ? "square" : check ? "check" : initial;
        if (shape === "circle") {
          styles.add("input:checked + span::before", "content", '"\\25CF"');
          styles.add("input:checked + span::before", "font-size", "24px");
          styles.add("input:checked + span::before", "line-height", "15px");
        } else if (shape === "square") {
          styles.add("input:checked + span::before", "content", '"\\25A0"');
          styles.add("input:checked + span::before", "font-size", "20px");
          styles.add("input:checked + span::before", "line-height", "15px");
        } else if (shape === "check") {
          styles.add("input:checked + span::before", "content", '"\\2713"');
          styles.add("input:checked + span::before", "font-size", "14px");
          styles.add("input:checked + span::before", "line-height", "18px");
        }
        if (blue) {
          styles.add("span::before", "background-color", "#FAFAFA");
          styles.add("span::before", "border-color", "#C8C8C8");
          styles.add("span::before", "color", "#32A3CE");
          styles.add("span::before", "text-shadow", "0 0 1px #32A3CE");
          styles.add("input:hover + span::before", "background-color", "#F5F8FC");
          styles.add("input:hover + span::before", "border-color", "#32A3CE");
          styles.add("input:checked + span::before", "border-color", "#32A3CE");
          styles.add("span:hover::before", "border-color", "#32A3CE");
        } else if (orange) {
          styles.add("input:hover + span::before", "border-color", "#FF893C");
          styles.add("span:hover::before", "border-color", "#FF893C");
          styles.add("span::before", "background-color", "#FAFAFA");
          styles.add("span::before", "border-color", "#C8C8C8");
          styles.add("span::before", "color", "#FF893C");
          styles.add("span::before", "text-shadow", "0 0 1px #FF893C");
          styles.add("input:checked + span::before", "background-color", "#F5F8FC");
          styles.add("input:checked + span::before", "border-color", "#FF893C");
        } else {
          styles.add("span::before", "background-color", "#FAFAFA");
          styles.add("span::before", "border-color", "#C8C8C8");
          styles.add("span::before", "color", "#32A3CE");
          styles.add("span::before", "text-shadow", "0 0 1px #32A3CE");
          styles.add("input:checked + span::before", "background-color", "#F5F8FC");
          styles.add("input:checked + span::before", "border-color", "#ADB8C0");
          styles.add("input:hover + span::before", "border-color", "#FF893C");
          styles.add("span:hover::before", "border-color", "#FF893C");
        }
      }
      function getHandlers13(host) {
        const { change, update, click } = host.props;
        const handlers = {
          mount() {
            const { name: name2, value, checked } = host.props;
            if (!name2)
              return;
            if (checked && typeof value === "string") {
              host.field.setFormValue(value);
            }
          },
          click(e) {
            const input = e.target;
            if (input.checked) {
              host.removeAttribute("checked");
            }
            click && click(e);
          },
          change(e) {
            const checked = e.target.checked;
            if (host.getAttribute("checked") !== checked) {
              host.setAttribute("checked", checked);
            } else {
              change && change(e);
              update && update(e.target.checked ? e.target.value : "");
            }
          },
          attribute(e) {
            var _a;
            const { action, name: name2, value, target } = e.detail;
            const input = (_a = target.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector("input");
            if (!input)
              return;
            switch (action) {
              case "add":
              case "update":
                handlers.set(input, name2, value);
                break;
              case "remove":
                handlers.remove(input, name2);
                break;
            }
          },
          set(input, name2, value) {
            input.setAttribute(name2, value);
            if (name2 === "checked") {
              input.checked = true;
              handlers.uncheck(input);
              host.field.setFormValue(input.value);
              handlers.emit(input, input.value);
            } else if (name2 === "value") {
              if (input.checked) {
                host.field.setFormValue(value);
                handlers.emit(input, value);
              }
            } else if (name2 === "disabled") {
              input.disabled = true;
              if (input.checked) {
                host.field.setFormValue(null);
                handlers.emit(input, "");
              }
            }
          },
          remove(input, name2) {
            input.removeAttribute(name2);
            if (name2 === "checked") {
              input.checked = false;
              host.field.setFormValue(null);
              handlers.emit(input, "");
            } else if (name2 === "disabled") {
              input.disabled = false;
              if (input.checked) {
                host.field.setFormValue(input.value);
                handlers.emit(input, input.value);
              }
            }
          },
          emit(input, value) {
            const event = new Event("change", {
              bubbles: true,
              cancelable: true
            });
            Object.defineProperty(event, "target", {
              writable: false,
              value: input
            });
            change && change(event);
            update && update(value);
          },
          uncheck(input) {
            if (input.getAttribute("type") !== "radio")
              return;
            const name2 = input.getAttribute("name");
            if (!name2)
              return;
            const items = host.field.form ? host.field.form.elements.namedItem(name2) : document.querySelectorAll(`[name="${name2}"]`);
            const elements2 = items instanceof NodeList ? Array.from(items) : [items];
            if (!elements2)
              return;
            for (const element of elements2) {
              if (element === host)
                continue;
              if (element instanceof HTMLInputElement) {
                element.checked = false;
                element.removeAttribute("checked");
              } else if (element instanceof HTMLElement) {
                element.removeAttribute("checked");
              }
            }
          }
        };
        host.on("attributechange", handlers.attribute);
        return handlers;
      }
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/select.js
  var require_select = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/select.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.makeOptions = makeOptions2;
      exports.getHandlers = getHandlers13;
      var Registry_1 = __importDefault(require_Registry());
      var signal_1 = __importDefault(require_signal());
      function makeOptions2(children2) {
        return Array.from(children2).filter((option) => option instanceof HTMLElement).filter((option) => option.nodeName !== "INPUT" || !option.hasAttribute("type") || option.getAttribute("type") !== "hidden").filter((option) => !option.hasAttribute("slot") || option.getAttribute("slot") === "filtered").map((option) => {
          var _a;
          if (option.nodeName !== "OPTION") {
            return option;
          }
          const attributes = ((_a = Registry_1.default.get(option)) === null || _a === void 0 ? void 0 : _a.attributes) || {};
          attributes.value = attributes.value ? attributes.value : option.hasAttribute("value") ? option.getAttribute("value") : option.innerText.trim();
          attributes.keyword = attributes.keyword ? attributes.keyword : option.hasAttribute("keyword") ? option.getAttribute("keyword") : void 0;
          attributes["class"] = attributes["class"] ? attributes["class"] : option.hasAttribute("class") ? option.getAttribute("class") : "select-default-option";
          const children3 = Array.from(option.childNodes);
          return Registry_1.default.createElement("div", attributes, children3).element;
        });
      }
      function getHandlers13(host, options2, slot = true) {
        const { value, multiple, open, close, filter, select, add, clear, change, update } = host.props;
        const handlers = {
          toggle: (e) => {
            const show = !state.value.show;
            state.value = Object.assign(Object.assign({}, state.value), { show });
            show ? open && open(e, state) : close && close(e, state);
          },
          select: (e) => {
            var _a;
            const option = e.currentTarget;
            const value2 = (_a = Registry_1.default.get(option)) === null || _a === void 0 ? void 0 : _a.getAttribute("value");
            if (typeof value2 === "undefined")
              return;
            state.value = handlers.make(state.value.options, state.value.values.includes(value2) ? state.value.values.filter((v) => v !== value2) : multiple ? [...state.value.values, value2] : [value2], state.value.query, multiple ? state.value.show : false);
            select && select(e, state);
            change && change(Object.assign(Object.assign({}, e), { target: Object.assign(Object.assign({}, host), { value: multiple ? state.value.values : value2 }) }));
            update && update(multiple ? state.value.values : value2);
          },
          filter: (e) => {
            const target = e.target;
            setTimeout(() => {
              var _a;
              const selection = [target.selectionStart, target.selectionEnd];
              const query = target.value.toLowerCase();
              state.value = handlers.make(state.value.options, state.value.values, query, state.value.show);
              const input = (_a = host.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector(".input");
              input === null || input === void 0 ? void 0 : input.focus();
              input === null || input === void 0 ? void 0 : input.setSelectionRange(selection[0], selection[1]);
              filter && filter(e, state);
            }, 1);
          },
          clear: (e) => {
            state.value = handlers.make(state.value.options, [], state.value.query, false);
            clear && clear(e, state);
            change && change(Object.assign(Object.assign({}, e), { target: Object.assign(Object.assign({}, host), { value: multiple ? [] : null }) }));
            update && update(multiple ? [] : null);
          },
          add: (e) => {
            var _a;
            const input = (_a = host.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector("input");
            if (!input)
              return;
            const value2 = input.value;
            const option = Registry_1.default.createElement("div", {
              "class": "select-default-option",
              slot: "option",
              label: value2,
              keyword: value2,
              value: value2
            }, [new Text(value2)]).element;
            state.value = handlers.make([option, ...state.value.options], multiple ? [...state.value.values, value2] : [value2], "", multiple ? state.value.show : false);
            add && add(e, state);
            change && change(Object.assign(Object.assign({}, e), { target: Object.assign(Object.assign({}, host), { value: multiple ? state.value.values : value2 }) }));
            update && update(multiple ? state.value.values : value2);
          },
          over: (e) => {
            e.stopPropagation();
            local.over = true;
            return false;
          },
          out: (e) => {
            e.stopPropagation();
            local.over = false;
            if (!state.value.show) {
              return false;
            }
            setTimeout(() => {
              if (!local.over && state.value.show) {
                state.value = Object.assign(Object.assign({}, state.value), { show: false });
                close && close(e, state);
              }
            }, 500);
            return false;
          },
          make: (options3, value2, query = "", show = false) => {
            const values = (Array.isArray(value2) ? Array.from(value2) : [value2]).filter(Boolean);
            options3.forEach((option) => {
              if (!(option instanceof HTMLElement))
                return;
              const select2 = handlers.select;
              option.removeEventListener("click", select2);
              option.addEventListener("click", select2);
              const element = Registry_1.default.get(option);
              if (element) {
                if (!element.hasAttribute("value")) {
                  element.setAttribute("value", option.innerText.trim());
                }
              }
            });
            const filtered = options3.filter((option) => {
              if (!(option instanceof Element))
                return false;
              if (!query)
                return true;
              const element = Registry_1.default.get(option);
              if (!element)
                return false;
              const keyword = element.getAttribute("keyword");
              if (!keyword)
                return false;
              return keyword.toLowerCase().includes(query.toLowerCase());
            }).map((option) => {
              if (slot && option instanceof Element) {
                option.setAttribute("slot", "filtered");
              }
              return option;
            });
            const selected = options3.filter((option) => {
              if (!(option instanceof Element))
                return false;
              const element = Registry_1.default.get(option);
              if (!element)
                return false;
              const value3 = element.getAttribute("value");
              if (!value3)
                return false;
              return values.includes(value3);
            }).map((option) => {
              const clone = option.cloneNode(true);
              if (slot && clone instanceof Element) {
                clone.setAttribute("slot", "selected");
              }
              return clone;
            });
            return { show, query, values, options: options3, filtered, selected };
          },
          attribute(e) {
            const { action, name: name2, value: value2, target } = e.detail;
            const inputs = Array.from(target.querySelectorAll(":scope > input[hidden]"));
            for (let i = 0; i < inputs.length; i++) {
              const input = inputs[i];
              if (name2 === "name") {
                switch (action) {
                  case "add":
                  case "update":
                    input.setAttribute("name", value2);
                    break;
                  case "remove":
                    input.removeAttribute("name");
                    break;
                }
              } else if (name2 === "value") {
                const values = Array.isArray(value2) ? value2 : [value2];
                if (action === "remove" || typeof values[i] === "undefined" || values[i] === null) {
                  input.removeAttribute(name2);
                  continue;
                }
                input.setAttribute(name2, values[i]);
              }
            }
          }
        };
        const state = (0, signal_1.default)(handlers.make(options2, value), host);
        const local = { over: false };
        const over = handlers.over;
        const out = handlers.out;
        host.addEventListener("mouseover", over);
        host.addEventListener("mouseout", out);
        host.on("attributechange", handlers.attribute);
        return Object.assign({ state, local }, handlers);
      }
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/style/align.js
  var require_align = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/style/align.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = align;
      function align(props, styles, initial = false, selector = ":host") {
        const { align: align2 } = props;
        if (align2) {
          styles.add(selector, "text-align", align2);
        } else if (initial) {
          styles.add(selector, "text-align", initial);
        }
        return align2 || "initial";
      }
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/style/size.js
  var require_size = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/style/size.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = size;
      function size(props, styles, initial = false, selector = ":host", property = "font-size") {
        const { size: size2, xs, sm, md, lg, xl, xl2, xl3, xl4, xl5 } = props;
        const style = size2 ? `${size2}px` : xs ? "8px" : sm ? "12px" : md ? "16px" : lg ? "20px" : xl ? "24px" : xl2 ? "28px" : xl3 ? "32px" : xl4 ? "36px" : xl5 ? "40px" : initial;
        if (style) {
          styles.add(selector, property, style);
        }
        return size2 ? "size" : xs ? "xs" : sm ? "sm" : md ? "md" : lg ? "lg" : xl ? "xl" : xl2 ? "xl2" : xl3 ? "xl3" : xl4 ? "xl4" : xl5 ? "xl5" : "initial";
      }
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/input.js
  var require_input = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/input.js"(exports) {
      "use strict";
      var __rest = exports && exports.__rest || function(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getProps = getProps11;
      exports.setDefaultStyles = setDefaultStyles10;
      exports.getHandlers = getHandlers13;
      var align_1 = __importDefault(require_align());
      var color_1 = __importDefault(require_color());
      var display_1 = __importDefault(require_display());
      var padding_1 = __importDefault(require_padding());
      var size_1 = __importDefault(require_size());
      function getProps11(host) {
        const _a = host.props, { change, update, flex, none, inline: inline2, block: block2, "inline-block": iblock, "inline-flex": iflex, padding, "padding-x": paddingX, "padding-y": paddingY, color, white, black, info, warning, success, error, muted, primary, secondary, theme, size, xs, sm, md, lg, xl, xl2, xl3, xl4, xl5, align, style, "class": _2 } = _a, attributes = __rest(_a, ["change", "update", "flex", "none", "inline", "block", "inline-block", "inline-flex", "padding", "padding-x", "padding-y", "color", "white", "black", "info", "warning", "success", "error", "muted", "primary", "secondary", "theme", "size", "xs", "sm", "md", "lg", "xl", "xl2", "xl3", "xl4", "xl5", "align", "style", "class"]);
        const { background, border } = host.propsTree;
        return {
          change,
          update,
          flex,
          none,
          inline: inline2,
          block: block2,
          "inline-block": iblock,
          "inline-flex": iflex,
          padding,
          "padding-x": paddingX,
          "padding-y": paddingY,
          color,
          white,
          black,
          info,
          warning,
          success,
          error,
          muted,
          primary,
          secondary,
          theme,
          size,
          xs,
          sm,
          md,
          lg,
          xl,
          xl2,
          xl3,
          xl4,
          xl5,
          background,
          border,
          align,
          attributes
        };
      }
      function setDefaultStyles10(props, styles) {
        const { background, border, error } = props;
        (0, display_1.default)(props, styles, "inline-block", ":host");
        if (background) {
          (0, color_1.default)(background, styles, "var(--white)", ":host", "background-color");
        } else {
          styles.add(":host", "background-color", "var(--white)");
        }
        styles.add(":host", "border-width", "1px");
        styles.add(":host", "border-style", "solid");
        if (error) {
          styles.add(":host", "border-color", "var(--error)");
        } else if (border) {
          (0, color_1.default)(border, styles, "var(--black)", ":host", "border-color");
        } else {
          styles.add(":host", "border-color", "var(--black)");
        }
        styles.add("::slotted(*)", "background", "transparent");
        styles.add("::slotted(*)", "border", "0");
        styles.add("::slotted(*)", "box-sizing", "border-box");
        styles.add("::slotted(*)", "font-family", "inherit");
        styles.add("::slotted(*)", "display", "block");
        styles.add("::slotted(*)", "height", "100%");
        styles.add("::slotted(*:focus)", "outline", "none");
        styles.add("::slotted(*)", "width", "100%");
        styles.add("::host([error]) ::slotted(*)", "color", "var(--error)");
        styles.add("::host([error]) ::slotted(*)", "border-color", "var(--error)");
        (0, align_1.default)(props, styles, "left", "::slotted(*)");
        (0, size_1.default)(props, styles, "inherit", "::slotted(*)", "font-size");
        (0, color_1.default)(props, styles, "var(--black)", "::slotted(*)", "color");
        const padding = (0, padding_1.default)(props, styles, "::slotted(*)");
        if (!padding) {
          styles.add("::slotted(*)", "padding", "7px");
        }
      }
      function getHandlers13(host, change, update) {
        const handlers = {
          change(e) {
            change && change(e);
            update && update(e.target.value);
          },
          attribute(e) {
            const { action, name: name2, value, target } = e.detail;
            const input = target.querySelector("input");
            switch (action) {
              case "add":
              case "update":
                input === null || input === void 0 ? void 0 : input.setAttribute(name2, value);
                break;
              case "remove":
                input === null || input === void 0 ? void 0 : input.removeAttribute(name2);
                break;
            }
          }
        };
        host.on("attributechange", handlers.attribute);
        return handlers;
      }
    }
  });

  // ../../node_modules/codemirror/lib/codemirror.js
  var require_codemirror = __commonJS({
    "../../node_modules/codemirror/lib/codemirror.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = global || self, global.CodeMirror = factory());
      })(exports, function() {
        "use strict";
        var userAgent = navigator.userAgent;
        var platform = navigator.platform;
        var gecko = /gecko\/\d/i.test(userAgent);
        var ie_upto10 = /MSIE \d/.test(userAgent);
        var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
        var edge = /Edge\/(\d+)/.exec(userAgent);
        var ie = ie_upto10 || ie_11up || edge;
        var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
        var webkit = !edge && /WebKit\//.test(userAgent);
        var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
        var chrome = !edge && /Chrome\/(\d+)/.exec(userAgent);
        var chrome_version = chrome && +chrome[1];
        var presto = /Opera\//.test(userAgent);
        var safari = /Apple Computer/.test(navigator.vendor);
        var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
        var phantom = /PhantomJS/.test(userAgent);
        var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
        var android = /Android/.test(userAgent);
        var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
        var mac = ios || /Mac/.test(platform);
        var chromeOS = /\bCrOS\b/.test(userAgent);
        var windows = /win/i.test(platform);
        var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
        if (presto_version) {
          presto_version = Number(presto_version[1]);
        }
        if (presto_version && presto_version >= 15) {
          presto = false;
          webkit = true;
        }
        var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
        var captureRightClick = gecko || ie && ie_version >= 9;
        function classTest(cls) {
          return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
        }
        var rmClass = function(node, cls) {
          var current = node.className;
          var match = classTest(cls).exec(current);
          if (match) {
            var after = current.slice(match.index + match[0].length);
            node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
          }
        };
        function removeChildren(e) {
          for (var count = e.childNodes.length; count > 0; --count) {
            e.removeChild(e.firstChild);
          }
          return e;
        }
        function removeChildrenAndAdd(parent, e) {
          return removeChildren(parent).appendChild(e);
        }
        function elt(tag2, content, className, style) {
          var e = document.createElement(tag2);
          if (className) {
            e.className = className;
          }
          if (style) {
            e.style.cssText = style;
          }
          if (typeof content == "string") {
            e.appendChild(document.createTextNode(content));
          } else if (content) {
            for (var i2 = 0; i2 < content.length; ++i2) {
              e.appendChild(content[i2]);
            }
          }
          return e;
        }
        function eltP(tag2, content, className, style) {
          var e = elt(tag2, content, className, style);
          e.setAttribute("role", "presentation");
          return e;
        }
        var range;
        if (document.createRange) {
          range = function(node, start, end, endNode) {
            var r = document.createRange();
            r.setEnd(endNode || node, end);
            r.setStart(node, start);
            return r;
          };
        } else {
          range = function(node, start, end) {
            var r = document.body.createTextRange();
            try {
              r.moveToElementText(node.parentNode);
            } catch (e) {
              return r;
            }
            r.collapse(true);
            r.moveEnd("character", end);
            r.moveStart("character", start);
            return r;
          };
        }
        function contains(parent, child) {
          if (child.nodeType == 3) {
            child = child.parentNode;
          }
          if (parent.contains) {
            return parent.contains(child);
          }
          do {
            if (child.nodeType == 11) {
              child = child.host;
            }
            if (child == parent) {
              return true;
            }
          } while (child = child.parentNode);
        }
        function activeElt(rootNode2) {
          var doc2 = rootNode2.ownerDocument || rootNode2;
          var activeElement;
          try {
            activeElement = rootNode2.activeElement;
          } catch (e) {
            activeElement = doc2.body || null;
          }
          while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
            activeElement = activeElement.shadowRoot.activeElement;
          }
          return activeElement;
        }
        function addClass(node, cls) {
          var current = node.className;
          if (!classTest(cls).test(current)) {
            node.className += (current ? " " : "") + cls;
          }
        }
        function joinClasses(a, b) {
          var as = a.split(" ");
          for (var i2 = 0; i2 < as.length; i2++) {
            if (as[i2] && !classTest(as[i2]).test(b)) {
              b += " " + as[i2];
            }
          }
          return b;
        }
        var selectInput = function(node) {
          node.select();
        };
        if (ios) {
          selectInput = function(node) {
            node.selectionStart = 0;
            node.selectionEnd = node.value.length;
          };
        } else if (ie) {
          selectInput = function(node) {
            try {
              node.select();
            } catch (_e) {
            }
          };
        }
        function doc(cm) {
          return cm.display.wrapper.ownerDocument;
        }
        function root(cm) {
          return rootNode(cm.display.wrapper);
        }
        function rootNode(element) {
          return element.getRootNode ? element.getRootNode() : element.ownerDocument;
        }
        function win(cm) {
          return doc(cm).defaultView;
        }
        function bind(f) {
          var args = Array.prototype.slice.call(arguments, 1);
          return function() {
            return f.apply(null, args);
          };
        }
        function copyObj(obj, target, overwrite) {
          if (!target) {
            target = {};
          }
          for (var prop2 in obj) {
            if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {
              target[prop2] = obj[prop2];
            }
          }
          return target;
        }
        function countColumn(string, end, tabSize, startIndex, startValue) {
          if (end == null) {
            end = string.search(/[^\s\u00a0]/);
            if (end == -1) {
              end = string.length;
            }
          }
          for (var i2 = startIndex || 0, n = startValue || 0; ; ) {
            var nextTab = string.indexOf("	", i2);
            if (nextTab < 0 || nextTab >= end) {
              return n + (end - i2);
            }
            n += nextTab - i2;
            n += tabSize - n % tabSize;
            i2 = nextTab + 1;
          }
        }
        var Delayed = function() {
          this.id = null;
          this.f = null;
          this.time = 0;
          this.handler = bind(this.onTimeout, this);
        };
        Delayed.prototype.onTimeout = function(self2) {
          self2.id = 0;
          if (self2.time <= +/* @__PURE__ */ new Date()) {
            self2.f();
          } else {
            setTimeout(self2.handler, self2.time - +/* @__PURE__ */ new Date());
          }
        };
        Delayed.prototype.set = function(ms, f) {
          this.f = f;
          var time = +/* @__PURE__ */ new Date() + ms;
          if (!this.id || time < this.time) {
            clearTimeout(this.id);
            this.id = setTimeout(this.handler, ms);
            this.time = time;
          }
        };
        function indexOf(array, elt2) {
          for (var i2 = 0; i2 < array.length; ++i2) {
            if (array[i2] == elt2) {
              return i2;
            }
          }
          return -1;
        }
        var scrollerGap = 50;
        var Pass = { toString: function() {
          return "CodeMirror.Pass";
        } };
        var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };
        function findColumn(string, goal, tabSize) {
          for (var pos = 0, col = 0; ; ) {
            var nextTab = string.indexOf("	", pos);
            if (nextTab == -1) {
              nextTab = string.length;
            }
            var skipped = nextTab - pos;
            if (nextTab == string.length || col + skipped >= goal) {
              return pos + Math.min(skipped, goal - col);
            }
            col += nextTab - pos;
            col += tabSize - col % tabSize;
            pos = nextTab + 1;
            if (col >= goal) {
              return pos;
            }
          }
        }
        var spaceStrs = [""];
        function spaceStr(n) {
          while (spaceStrs.length <= n) {
            spaceStrs.push(lst(spaceStrs) + " ");
          }
          return spaceStrs[n];
        }
        function lst(arr) {
          return arr[arr.length - 1];
        }
        function map(array, f) {
          var out = [];
          for (var i2 = 0; i2 < array.length; i2++) {
            out[i2] = f(array[i2], i2);
          }
          return out;
        }
        function insertSorted(array, value, score) {
          var pos = 0, priority = score(value);
          while (pos < array.length && score(array[pos]) <= priority) {
            pos++;
          }
          array.splice(pos, 0, value);
        }
        function nothing() {
        }
        function createObj(base, props) {
          var inst;
          if (Object.create) {
            inst = Object.create(base);
          } else {
            nothing.prototype = base;
            inst = new nothing();
          }
          if (props) {
            copyObj(props, inst);
          }
          return inst;
        }
        var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
        function isWordCharBasic(ch) {
          return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
        }
        function isWordChar(ch, helper) {
          if (!helper) {
            return isWordCharBasic(ch);
          }
          if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
            return true;
          }
          return helper.test(ch);
        }
        function isEmpty(obj) {
          for (var n in obj) {
            if (obj.hasOwnProperty(n) && obj[n]) {
              return false;
            }
          }
          return true;
        }
        var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
        function isExtendingChar(ch) {
          return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
        }
        function skipExtendingChars(str, pos, dir) {
          while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
            pos += dir;
          }
          return pos;
        }
        function findFirst(pred, from, to) {
          var dir = from > to ? -1 : 1;
          for (; ; ) {
            if (from == to) {
              return from;
            }
            var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
            if (mid == from) {
              return pred(mid) ? from : to;
            }
            if (pred(mid)) {
              to = mid;
            } else {
              from = mid + dir;
            }
          }
        }
        function iterateBidiSections(order, from, to, f) {
          if (!order) {
            return f(from, to, "ltr", 0);
          }
          var found = false;
          for (var i2 = 0; i2 < order.length; ++i2) {
            var part = order[i2];
            if (part.from < to && part.to > from || from == to && part.to == from) {
              f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i2);
              found = true;
            }
          }
          if (!found) {
            f(from, to, "ltr");
          }
        }
        var bidiOther = null;
        function getBidiPartAt(order, ch, sticky) {
          var found;
          bidiOther = null;
          for (var i2 = 0; i2 < order.length; ++i2) {
            var cur = order[i2];
            if (cur.from < ch && cur.to > ch) {
              return i2;
            }
            if (cur.to == ch) {
              if (cur.from != cur.to && sticky == "before") {
                found = i2;
              } else {
                bidiOther = i2;
              }
            }
            if (cur.from == ch) {
              if (cur.from != cur.to && sticky != "before") {
                found = i2;
              } else {
                bidiOther = i2;
              }
            }
          }
          return found != null ? found : bidiOther;
        }
        var bidiOrdering = /* @__PURE__ */ function() {
          var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
          var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
          function charType(code) {
            if (code <= 247) {
              return lowTypes.charAt(code);
            } else if (1424 <= code && code <= 1524) {
              return "R";
            } else if (1536 <= code && code <= 1785) {
              return arabicTypes.charAt(code - 1536);
            } else if (1774 <= code && code <= 2220) {
              return "r";
            } else if (8192 <= code && code <= 8203) {
              return "w";
            } else if (code == 8204) {
              return "b";
            } else {
              return "L";
            }
          }
          var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
          var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
          function BidiSpan(level, from, to) {
            this.level = level;
            this.from = from;
            this.to = to;
          }
          return function(str, direction) {
            var outerType = direction == "ltr" ? "L" : "R";
            if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
              return false;
            }
            var len = str.length, types = [];
            for (var i2 = 0; i2 < len; ++i2) {
              types.push(charType(str.charCodeAt(i2)));
            }
            for (var i$12 = 0, prev = outerType; i$12 < len; ++i$12) {
              var type = types[i$12];
              if (type == "m") {
                types[i$12] = prev;
              } else {
                prev = type;
              }
            }
            for (var i$22 = 0, cur = outerType; i$22 < len; ++i$22) {
              var type$1 = types[i$22];
              if (type$1 == "1" && cur == "r") {
                types[i$22] = "n";
              } else if (isStrong.test(type$1)) {
                cur = type$1;
                if (type$1 == "r") {
                  types[i$22] = "R";
                }
              }
            }
            for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
              var type$2 = types[i$3];
              if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
                types[i$3] = "1";
              } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
                types[i$3] = prev$1;
              }
              prev$1 = type$2;
            }
            for (var i$4 = 0; i$4 < len; ++i$4) {
              var type$3 = types[i$4];
              if (type$3 == ",") {
                types[i$4] = "N";
              } else if (type$3 == "%") {
                var end = void 0;
                for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {
                }
                var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";
                for (var j = i$4; j < end; ++j) {
                  types[j] = replace;
                }
                i$4 = end - 1;
              }
            }
            for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
              var type$4 = types[i$5];
              if (cur$1 == "L" && type$4 == "1") {
                types[i$5] = "L";
              } else if (isStrong.test(type$4)) {
                cur$1 = type$4;
              }
            }
            for (var i$6 = 0; i$6 < len; ++i$6) {
              if (isNeutral.test(types[i$6])) {
                var end$1 = void 0;
                for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {
                }
                var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
                var after = (end$1 < len ? types[end$1] : outerType) == "L";
                var replace$1 = before == after ? before ? "L" : "R" : outerType;
                for (var j$1 = i$6; j$1 < end$1; ++j$1) {
                  types[j$1] = replace$1;
                }
                i$6 = end$1 - 1;
              }
            }
            var order = [], m;
            for (var i$7 = 0; i$7 < len; ) {
              if (countsAsLeft.test(types[i$7])) {
                var start = i$7;
                for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {
                }
                order.push(new BidiSpan(0, start, i$7));
              } else {
                var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
                for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {
                }
                for (var j$2 = pos; j$2 < i$7; ) {
                  if (countsAsNum.test(types[j$2])) {
                    if (pos < j$2) {
                      order.splice(at, 0, new BidiSpan(1, pos, j$2));
                      at += isRTL;
                    }
                    var nstart = j$2;
                    for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {
                    }
                    order.splice(at, 0, new BidiSpan(2, nstart, j$2));
                    at += isRTL;
                    pos = j$2;
                  } else {
                    ++j$2;
                  }
                }
                if (pos < i$7) {
                  order.splice(at, 0, new BidiSpan(1, pos, i$7));
                }
              }
            }
            if (direction == "ltr") {
              if (order[0].level == 1 && (m = str.match(/^\s+/))) {
                order[0].from = m[0].length;
                order.unshift(new BidiSpan(0, 0, m[0].length));
              }
              if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
                lst(order).to -= m[0].length;
                order.push(new BidiSpan(0, len - m[0].length, len));
              }
            }
            return direction == "rtl" ? order.reverse() : order;
          };
        }();
        function getOrder(line, direction) {
          var order = line.order;
          if (order == null) {
            order = line.order = bidiOrdering(line.text, direction);
          }
          return order;
        }
        var noHandlers = [];
        var on = function(emitter2, type, f) {
          if (emitter2.addEventListener) {
            emitter2.addEventListener(type, f, false);
          } else if (emitter2.attachEvent) {
            emitter2.attachEvent("on" + type, f);
          } else {
            var map2 = emitter2._handlers || (emitter2._handlers = {});
            map2[type] = (map2[type] || noHandlers).concat(f);
          }
        };
        function getHandlers13(emitter2, type) {
          return emitter2._handlers && emitter2._handlers[type] || noHandlers;
        }
        function off(emitter2, type, f) {
          if (emitter2.removeEventListener) {
            emitter2.removeEventListener(type, f, false);
          } else if (emitter2.detachEvent) {
            emitter2.detachEvent("on" + type, f);
          } else {
            var map2 = emitter2._handlers, arr = map2 && map2[type];
            if (arr) {
              var index = indexOf(arr, f);
              if (index > -1) {
                map2[type] = arr.slice(0, index).concat(arr.slice(index + 1));
              }
            }
          }
        }
        function signal7(emitter2, type) {
          var handlers = getHandlers13(emitter2, type);
          if (!handlers.length) {
            return;
          }
          var args = Array.prototype.slice.call(arguments, 2);
          for (var i2 = 0; i2 < handlers.length; ++i2) {
            handlers[i2].apply(null, args);
          }
        }
        function signalDOMEvent(cm, e, override) {
          if (typeof e == "string") {
            e = { type: e, preventDefault: function() {
              this.defaultPrevented = true;
            } };
          }
          signal7(cm, override || e.type, cm, e);
          return e_defaultPrevented(e) || e.codemirrorIgnore;
        }
        function signalCursorActivity(cm) {
          var arr = cm._handlers && cm._handlers.cursorActivity;
          if (!arr) {
            return;
          }
          var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
          for (var i2 = 0; i2 < arr.length; ++i2) {
            if (indexOf(set, arr[i2]) == -1) {
              set.push(arr[i2]);
            }
          }
        }
        function hasHandler(emitter2, type) {
          return getHandlers13(emitter2, type).length > 0;
        }
        function eventMixin(ctor) {
          ctor.prototype.on = function(type, f) {
            on(this, type, f);
          };
          ctor.prototype.off = function(type, f) {
            off(this, type, f);
          };
        }
        function e_preventDefault(e) {
          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
        }
        function e_stopPropagation(e) {
          if (e.stopPropagation) {
            e.stopPropagation();
          } else {
            e.cancelBubble = true;
          }
        }
        function e_defaultPrevented(e) {
          return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
        }
        function e_stop(e) {
          e_preventDefault(e);
          e_stopPropagation(e);
        }
        function e_target(e) {
          return e.target || e.srcElement;
        }
        function e_button(e) {
          var b = e.which;
          if (b == null) {
            if (e.button & 1) {
              b = 1;
            } else if (e.button & 2) {
              b = 3;
            } else if (e.button & 4) {
              b = 2;
            }
          }
          if (mac && e.ctrlKey && b == 1) {
            b = 3;
          }
          return b;
        }
        var dragAndDrop = function() {
          if (ie && ie_version < 9) {
            return false;
          }
          var div = elt("div");
          return "draggable" in div || "dragDrop" in div;
        }();
        var zwspSupported;
        function zeroWidthElement(measure) {
          if (zwspSupported == null) {
            var test = elt("span", "\u200B");
            removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
            if (measure.firstChild.offsetHeight != 0) {
              zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
            }
          }
          var node = zwspSupported ? elt("span", "\u200B") : elt("span", "\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");
          node.setAttribute("cm-text", "");
          return node;
        }
        var badBidiRects;
        function hasBadBidiRects(measure) {
          if (badBidiRects != null) {
            return badBidiRects;
          }
          var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062EA"));
          var r0 = range(txt, 0, 1).getBoundingClientRect();
          var r1 = range(txt, 1, 2).getBoundingClientRect();
          removeChildren(measure);
          if (!r0 || r0.left == r0.right) {
            return false;
          }
          return badBidiRects = r1.right - r0.right < 3;
        }
        var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function(string) {
          var pos = 0, result = [], l = string.length;
          while (pos <= l) {
            var nl = string.indexOf("\n", pos);
            if (nl == -1) {
              nl = string.length;
            }
            var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
            var rt = line.indexOf("\r");
            if (rt != -1) {
              result.push(line.slice(0, rt));
              pos += rt + 1;
            } else {
              result.push(line);
              pos = nl + 1;
            }
          }
          return result;
        } : function(string) {
          return string.split(/\r\n?|\n/);
        };
        var hasSelection = window.getSelection ? function(te) {
          try {
            return te.selectionStart != te.selectionEnd;
          } catch (e) {
            return false;
          }
        } : function(te) {
          var range2;
          try {
            range2 = te.ownerDocument.selection.createRange();
          } catch (e) {
          }
          if (!range2 || range2.parentElement() != te) {
            return false;
          }
          return range2.compareEndPoints("StartToEnd", range2) != 0;
        };
        var hasCopyEvent = function() {
          var e = elt("div");
          if ("oncopy" in e) {
            return true;
          }
          e.setAttribute("oncopy", "return;");
          return typeof e.oncopy == "function";
        }();
        var badZoomedRects = null;
        function hasBadZoomedRects(measure) {
          if (badZoomedRects != null) {
            return badZoomedRects;
          }
          var node = removeChildrenAndAdd(measure, elt("span", "x"));
          var normal = node.getBoundingClientRect();
          var fromRange = range(node, 0, 1).getBoundingClientRect();
          return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
        }
        var modes = {}, mimeModes = {};
        function defineMode(name2, mode) {
          if (arguments.length > 2) {
            mode.dependencies = Array.prototype.slice.call(arguments, 2);
          }
          modes[name2] = mode;
        }
        function defineMIME(mime, spec) {
          mimeModes[mime] = spec;
        }
        function resolveMode(spec) {
          if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
            spec = mimeModes[spec];
          } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
            var found = mimeModes[spec.name];
            if (typeof found == "string") {
              found = { name: found };
            }
            spec = createObj(found, spec);
            spec.name = found.name;
          } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
            return resolveMode("application/xml");
          } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
            return resolveMode("application/json");
          }
          if (typeof spec == "string") {
            return { name: spec };
          } else {
            return spec || { name: "null" };
          }
        }
        function getMode(options2, spec) {
          spec = resolveMode(spec);
          var mfactory = modes[spec.name];
          if (!mfactory) {
            return getMode(options2, "text/plain");
          }
          var modeObj = mfactory(options2, spec);
          if (modeExtensions.hasOwnProperty(spec.name)) {
            var exts = modeExtensions[spec.name];
            for (var prop2 in exts) {
              if (!exts.hasOwnProperty(prop2)) {
                continue;
              }
              if (modeObj.hasOwnProperty(prop2)) {
                modeObj["_" + prop2] = modeObj[prop2];
              }
              modeObj[prop2] = exts[prop2];
            }
          }
          modeObj.name = spec.name;
          if (spec.helperType) {
            modeObj.helperType = spec.helperType;
          }
          if (spec.modeProps) {
            for (var prop$1 in spec.modeProps) {
              modeObj[prop$1] = spec.modeProps[prop$1];
            }
          }
          return modeObj;
        }
        var modeExtensions = {};
        function extendMode(mode, properties) {
          var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
          copyObj(properties, exts);
        }
        function copyState(mode, state) {
          if (state === true) {
            return state;
          }
          if (mode.copyState) {
            return mode.copyState(state);
          }
          var nstate = {};
          for (var n in state) {
            var val = state[n];
            if (val instanceof Array) {
              val = val.concat([]);
            }
            nstate[n] = val;
          }
          return nstate;
        }
        function innerMode(mode, state) {
          var info;
          while (mode.innerMode) {
            info = mode.innerMode(state);
            if (!info || info.mode == mode) {
              break;
            }
            state = info.state;
            mode = info.mode;
          }
          return info || { mode, state };
        }
        function startState(mode, a1, a2) {
          return mode.startState ? mode.startState(a1, a2) : true;
        }
        var StringStream = function(string, tabSize, lineOracle) {
          this.pos = this.start = 0;
          this.string = string;
          this.tabSize = tabSize || 8;
          this.lastColumnPos = this.lastColumnValue = 0;
          this.lineStart = 0;
          this.lineOracle = lineOracle;
        };
        StringStream.prototype.eol = function() {
          return this.pos >= this.string.length;
        };
        StringStream.prototype.sol = function() {
          return this.pos == this.lineStart;
        };
        StringStream.prototype.peek = function() {
          return this.string.charAt(this.pos) || void 0;
        };
        StringStream.prototype.next = function() {
          if (this.pos < this.string.length) {
            return this.string.charAt(this.pos++);
          }
        };
        StringStream.prototype.eat = function(match) {
          var ch = this.string.charAt(this.pos);
          var ok;
          if (typeof match == "string") {
            ok = ch == match;
          } else {
            ok = ch && (match.test ? match.test(ch) : match(ch));
          }
          if (ok) {
            ++this.pos;
            return ch;
          }
        };
        StringStream.prototype.eatWhile = function(match) {
          var start = this.pos;
          while (this.eat(match)) {
          }
          return this.pos > start;
        };
        StringStream.prototype.eatSpace = function() {
          var start = this.pos;
          while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
            ++this.pos;
          }
          return this.pos > start;
        };
        StringStream.prototype.skipToEnd = function() {
          this.pos = this.string.length;
        };
        StringStream.prototype.skipTo = function(ch) {
          var found = this.string.indexOf(ch, this.pos);
          if (found > -1) {
            this.pos = found;
            return true;
          }
        };
        StringStream.prototype.backUp = function(n) {
          this.pos -= n;
        };
        StringStream.prototype.column = function() {
          if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
          }
          return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        };
        StringStream.prototype.indentation = function() {
          return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        };
        StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
          if (typeof pattern == "string") {
            var cased = function(str) {
              return caseInsensitive ? str.toLowerCase() : str;
            };
            var substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
              if (consume !== false) {
                this.pos += pattern.length;
              }
              return true;
            }
          } else {
            var match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0) {
              return null;
            }
            if (match && consume !== false) {
              this.pos += match[0].length;
            }
            return match;
          }
        };
        StringStream.prototype.current = function() {
          return this.string.slice(this.start, this.pos);
        };
        StringStream.prototype.hideFirstChars = function(n, inner) {
          this.lineStart += n;
          try {
            return inner();
          } finally {
            this.lineStart -= n;
          }
        };
        StringStream.prototype.lookAhead = function(n) {
          var oracle = this.lineOracle;
          return oracle && oracle.lookAhead(n);
        };
        StringStream.prototype.baseToken = function() {
          var oracle = this.lineOracle;
          return oracle && oracle.baseToken(this.pos);
        };
        function getLine(doc2, n) {
          n -= doc2.first;
          if (n < 0 || n >= doc2.size) {
            throw new Error("There is no line " + (n + doc2.first) + " in the document.");
          }
          var chunk = doc2;
          while (!chunk.lines) {
            for (var i2 = 0; ; ++i2) {
              var child = chunk.children[i2], sz = child.chunkSize();
              if (n < sz) {
                chunk = child;
                break;
              }
              n -= sz;
            }
          }
          return chunk.lines[n];
        }
        function getBetween(doc2, start, end) {
          var out = [], n = start.line;
          doc2.iter(start.line, end.line + 1, function(line) {
            var text = line.text;
            if (n == end.line) {
              text = text.slice(0, end.ch);
            }
            if (n == start.line) {
              text = text.slice(start.ch);
            }
            out.push(text);
            ++n;
          });
          return out;
        }
        function getLines(doc2, from, to) {
          var out = [];
          doc2.iter(from, to, function(line) {
            out.push(line.text);
          });
          return out;
        }
        function updateLineHeight(line, height) {
          var diff = height - line.height;
          if (diff) {
            for (var n = line; n; n = n.parent) {
              n.height += diff;
            }
          }
        }
        function lineNo(line) {
          if (line.parent == null) {
            return null;
          }
          var cur = line.parent, no = indexOf(cur.lines, line);
          for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
            for (var i2 = 0; ; ++i2) {
              if (chunk.children[i2] == cur) {
                break;
              }
              no += chunk.children[i2].chunkSize();
            }
          }
          return no + cur.first;
        }
        function lineAtHeight(chunk, h) {
          var n = chunk.first;
          outer: do {
            for (var i$12 = 0; i$12 < chunk.children.length; ++i$12) {
              var child = chunk.children[i$12], ch = child.height;
              if (h < ch) {
                chunk = child;
                continue outer;
              }
              h -= ch;
              n += child.chunkSize();
            }
            return n;
          } while (!chunk.lines);
          var i2 = 0;
          for (; i2 < chunk.lines.length; ++i2) {
            var line = chunk.lines[i2], lh = line.height;
            if (h < lh) {
              break;
            }
            h -= lh;
          }
          return n + i2;
        }
        function isLine(doc2, l) {
          return l >= doc2.first && l < doc2.first + doc2.size;
        }
        function lineNumberFor(options2, i2) {
          return String(options2.lineNumberFormatter(i2 + options2.firstLineNumber));
        }
        function Pos(line, ch, sticky) {
          if (sticky === void 0) sticky = null;
          if (!(this instanceof Pos)) {
            return new Pos(line, ch, sticky);
          }
          this.line = line;
          this.ch = ch;
          this.sticky = sticky;
        }
        function cmp(a, b) {
          return a.line - b.line || a.ch - b.ch;
        }
        function equalCursorPos(a, b) {
          return a.sticky == b.sticky && cmp(a, b) == 0;
        }
        function copyPos(x) {
          return Pos(x.line, x.ch);
        }
        function maxPos(a, b) {
          return cmp(a, b) < 0 ? b : a;
        }
        function minPos(a, b) {
          return cmp(a, b) < 0 ? a : b;
        }
        function clipLine(doc2, n) {
          return Math.max(doc2.first, Math.min(n, doc2.first + doc2.size - 1));
        }
        function clipPos(doc2, pos) {
          if (pos.line < doc2.first) {
            return Pos(doc2.first, 0);
          }
          var last = doc2.first + doc2.size - 1;
          if (pos.line > last) {
            return Pos(last, getLine(doc2, last).text.length);
          }
          return clipToLen(pos, getLine(doc2, pos.line).text.length);
        }
        function clipToLen(pos, linelen) {
          var ch = pos.ch;
          if (ch == null || ch > linelen) {
            return Pos(pos.line, linelen);
          } else if (ch < 0) {
            return Pos(pos.line, 0);
          } else {
            return pos;
          }
        }
        function clipPosArray(doc2, array) {
          var out = [];
          for (var i2 = 0; i2 < array.length; i2++) {
            out[i2] = clipPos(doc2, array[i2]);
          }
          return out;
        }
        var SavedContext = function(state, lookAhead) {
          this.state = state;
          this.lookAhead = lookAhead;
        };
        var Context = function(doc2, state, line, lookAhead) {
          this.state = state;
          this.doc = doc2;
          this.line = line;
          this.maxLookAhead = lookAhead || 0;
          this.baseTokens = null;
          this.baseTokenPos = 1;
        };
        Context.prototype.lookAhead = function(n) {
          var line = this.doc.getLine(this.line + n);
          if (line != null && n > this.maxLookAhead) {
            this.maxLookAhead = n;
          }
          return line;
        };
        Context.prototype.baseToken = function(n) {
          if (!this.baseTokens) {
            return null;
          }
          while (this.baseTokens[this.baseTokenPos] <= n) {
            this.baseTokenPos += 2;
          }
          var type = this.baseTokens[this.baseTokenPos + 1];
          return {
            type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n
          };
        };
        Context.prototype.nextLine = function() {
          this.line++;
          if (this.maxLookAhead > 0) {
            this.maxLookAhead--;
          }
        };
        Context.fromSaved = function(doc2, saved, line) {
          if (saved instanceof SavedContext) {
            return new Context(doc2, copyState(doc2.mode, saved.state), line, saved.lookAhead);
          } else {
            return new Context(doc2, copyState(doc2.mode, saved), line);
          }
        };
        Context.prototype.save = function(copy) {
          var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
          return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
        };
        function highlightLine(cm, line, context, forceToEnd) {
          var st = [cm.state.modeGen], lineClasses = {};
          runMode(
            cm,
            line.text,
            cm.doc.mode,
            context,
            function(end, style) {
              return st.push(end, style);
            },
            lineClasses,
            forceToEnd
          );
          var state = context.state;
          var loop = function(o2) {
            context.baseTokens = st;
            var overlay = cm.state.overlays[o2], i2 = 1, at = 0;
            context.state = true;
            runMode(cm, line.text, overlay.mode, context, function(end, style) {
              var start = i2;
              while (at < end) {
                var i_end = st[i2];
                if (i_end > end) {
                  st.splice(i2, 1, end, st[i2 + 1], i_end);
                }
                i2 += 2;
                at = Math.min(end, i_end);
              }
              if (!style) {
                return;
              }
              if (overlay.opaque) {
                st.splice(start, i2 - start, end, "overlay " + style);
                i2 = start + 2;
              } else {
                for (; start < i2; start += 2) {
                  var cur = st[start + 1];
                  st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
                }
              }
            }, lineClasses);
            context.state = state;
            context.baseTokens = null;
            context.baseTokenPos = 1;
          };
          for (var o = 0; o < cm.state.overlays.length; ++o) loop(o);
          return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
        }
        function getLineStyles(cm, line, updateFrontier) {
          if (!line.styles || line.styles[0] != cm.state.modeGen) {
            var context = getContextBefore(cm, lineNo(line));
            var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
            var result = highlightLine(cm, line, context);
            if (resetState) {
              context.state = resetState;
            }
            line.stateAfter = context.save(!resetState);
            line.styles = result.styles;
            if (result.classes) {
              line.styleClasses = result.classes;
            } else if (line.styleClasses) {
              line.styleClasses = null;
            }
            if (updateFrontier === cm.doc.highlightFrontier) {
              cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
            }
          }
          return line.styles;
        }
        function getContextBefore(cm, n, precise) {
          var doc2 = cm.doc, display = cm.display;
          if (!doc2.mode.startState) {
            return new Context(doc2, true, n);
          }
          var start = findStartLine(cm, n, precise);
          var saved = start > doc2.first && getLine(doc2, start - 1).stateAfter;
          var context = saved ? Context.fromSaved(doc2, saved, start) : new Context(doc2, startState(doc2.mode), start);
          doc2.iter(start, n, function(line) {
            processLine(cm, line.text, context);
            var pos = context.line;
            line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
            context.nextLine();
          });
          if (precise) {
            doc2.modeFrontier = context.line;
          }
          return context;
        }
        function processLine(cm, text, context, startAt) {
          var mode = cm.doc.mode;
          var stream = new StringStream(text, cm.options.tabSize, context);
          stream.start = stream.pos = startAt || 0;
          if (text == "") {
            callBlankLine(mode, context.state);
          }
          while (!stream.eol()) {
            readToken(mode, stream, context.state);
            stream.start = stream.pos;
          }
        }
        function callBlankLine(mode, state) {
          if (mode.blankLine) {
            return mode.blankLine(state);
          }
          if (!mode.innerMode) {
            return;
          }
          var inner = innerMode(mode, state);
          if (inner.mode.blankLine) {
            return inner.mode.blankLine(inner.state);
          }
        }
        function readToken(mode, stream, state, inner) {
          for (var i2 = 0; i2 < 10; i2++) {
            if (inner) {
              inner[0] = innerMode(mode, state).mode;
            }
            var style = mode.token(stream, state);
            if (stream.pos > stream.start) {
              return style;
            }
          }
          throw new Error("Mode " + mode.name + " failed to advance stream.");
        }
        var Token = function(stream, type, state) {
          this.start = stream.start;
          this.end = stream.pos;
          this.string = stream.current();
          this.type = type || null;
          this.state = state;
        };
        function takeToken(cm, pos, precise, asArray) {
          var doc2 = cm.doc, mode = doc2.mode, style;
          pos = clipPos(doc2, pos);
          var line = getLine(doc2, pos.line), context = getContextBefore(cm, pos.line, precise);
          var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
          if (asArray) {
            tokens = [];
          }
          while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
            stream.start = stream.pos;
            style = readToken(mode, stream, context.state);
            if (asArray) {
              tokens.push(new Token(stream, style, copyState(doc2.mode, context.state)));
            }
          }
          return asArray ? tokens : new Token(stream, style, context.state);
        }
        function extractLineClasses(type, output) {
          if (type) {
            for (; ; ) {
              var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
              if (!lineClass) {
                break;
              }
              type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
              var prop2 = lineClass[1] ? "bgClass" : "textClass";
              if (output[prop2] == null) {
                output[prop2] = lineClass[2];
              } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop2])) {
                output[prop2] += " " + lineClass[2];
              }
            }
          }
          return type;
        }
        function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
          var flattenSpans = mode.flattenSpans;
          if (flattenSpans == null) {
            flattenSpans = cm.options.flattenSpans;
          }
          var curStart = 0, curStyle = null;
          var stream = new StringStream(text, cm.options.tabSize, context), style;
          var inner = cm.options.addModeClass && [null];
          if (text == "") {
            extractLineClasses(callBlankLine(mode, context.state), lineClasses);
          }
          while (!stream.eol()) {
            if (stream.pos > cm.options.maxHighlightLength) {
              flattenSpans = false;
              if (forceToEnd) {
                processLine(cm, text, context, stream.pos);
              }
              stream.pos = text.length;
              style = null;
            } else {
              style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
            }
            if (inner) {
              var mName = inner[0].name;
              if (mName) {
                style = "m-" + (style ? mName + " " + style : mName);
              }
            }
            if (!flattenSpans || curStyle != style) {
              while (curStart < stream.start) {
                curStart = Math.min(stream.start, curStart + 5e3);
                f(curStart, curStyle);
              }
              curStyle = style;
            }
            stream.start = stream.pos;
          }
          while (curStart < stream.pos) {
            var pos = Math.min(stream.pos, curStart + 5e3);
            f(pos, curStyle);
            curStart = pos;
          }
        }
        function findStartLine(cm, n, precise) {
          var minindent, minline, doc2 = cm.doc;
          var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100);
          for (var search = n; search > lim; --search) {
            if (search <= doc2.first) {
              return doc2.first;
            }
            var line = getLine(doc2, search - 1), after = line.stateAfter;
            if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc2.modeFrontier)) {
              return search;
            }
            var indented = countColumn(line.text, null, cm.options.tabSize);
            if (minline == null || minindent > indented) {
              minline = search - 1;
              minindent = indented;
            }
          }
          return minline;
        }
        function retreatFrontier(doc2, n) {
          doc2.modeFrontier = Math.min(doc2.modeFrontier, n);
          if (doc2.highlightFrontier < n - 10) {
            return;
          }
          var start = doc2.first;
          for (var line = n - 1; line > start; line--) {
            var saved = getLine(doc2, line).stateAfter;
            if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
              start = line + 1;
              break;
            }
          }
          doc2.highlightFrontier = Math.min(doc2.highlightFrontier, start);
        }
        var sawReadOnlySpans = false, sawCollapsedSpans = false;
        function seeReadOnlySpans() {
          sawReadOnlySpans = true;
        }
        function seeCollapsedSpans() {
          sawCollapsedSpans = true;
        }
        function MarkedSpan(marker, from, to) {
          this.marker = marker;
          this.from = from;
          this.to = to;
        }
        function getMarkedSpanFor(spans, marker) {
          if (spans) {
            for (var i2 = 0; i2 < spans.length; ++i2) {
              var span = spans[i2];
              if (span.marker == marker) {
                return span;
              }
            }
          }
        }
        function removeMarkedSpan(spans, span) {
          var r;
          for (var i2 = 0; i2 < spans.length; ++i2) {
            if (spans[i2] != span) {
              (r || (r = [])).push(spans[i2]);
            }
          }
          return r;
        }
        function addMarkedSpan(line, span, op) {
          var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = /* @__PURE__ */ new WeakSet()));
          if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {
            line.markedSpans.push(span);
          } else {
            line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
            if (inThisOp) {
              inThisOp.add(line.markedSpans);
            }
          }
          span.marker.attachLine(line);
        }
        function markedSpansBefore(old, startCh, isInsert) {
          var nw;
          if (old) {
            for (var i2 = 0; i2 < old.length; ++i2) {
              var span = old[i2], marker = span.marker;
              var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
              if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
                var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
              }
            }
          }
          return nw;
        }
        function markedSpansAfter(old, endCh, isInsert) {
          var nw;
          if (old) {
            for (var i2 = 0; i2 < old.length; ++i2) {
              var span = old[i2], marker = span.marker;
              var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
              if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
                var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                (nw || (nw = [])).push(new MarkedSpan(
                  marker,
                  startsBefore ? null : span.from - endCh,
                  span.to == null ? null : span.to - endCh
                ));
              }
            }
          }
          return nw;
        }
        function stretchSpansOverChange(doc2, change) {
          if (change.full) {
            return null;
          }
          var oldFirst = isLine(doc2, change.from.line) && getLine(doc2, change.from.line).markedSpans;
          var oldLast = isLine(doc2, change.to.line) && getLine(doc2, change.to.line).markedSpans;
          if (!oldFirst && !oldLast) {
            return null;
          }
          var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
          var first = markedSpansBefore(oldFirst, startCh, isInsert);
          var last = markedSpansAfter(oldLast, endCh, isInsert);
          var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
          if (first) {
            for (var i2 = 0; i2 < first.length; ++i2) {
              var span = first[i2];
              if (span.to == null) {
                var found = getMarkedSpanFor(last, span.marker);
                if (!found) {
                  span.to = startCh;
                } else if (sameLine) {
                  span.to = found.to == null ? null : found.to + offset;
                }
              }
            }
          }
          if (last) {
            for (var i$12 = 0; i$12 < last.length; ++i$12) {
              var span$1 = last[i$12];
              if (span$1.to != null) {
                span$1.to += offset;
              }
              if (span$1.from == null) {
                var found$1 = getMarkedSpanFor(first, span$1.marker);
                if (!found$1) {
                  span$1.from = offset;
                  if (sameLine) {
                    (first || (first = [])).push(span$1);
                  }
                }
              } else {
                span$1.from += offset;
                if (sameLine) {
                  (first || (first = [])).push(span$1);
                }
              }
            }
          }
          if (first) {
            first = clearEmptySpans(first);
          }
          if (last && last != first) {
            last = clearEmptySpans(last);
          }
          var newMarkers = [first];
          if (!sameLine) {
            var gap = change.text.length - 2, gapMarkers;
            if (gap > 0 && first) {
              for (var i$22 = 0; i$22 < first.length; ++i$22) {
                if (first[i$22].to == null) {
                  (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$22].marker, null, null));
                }
              }
            }
            for (var i$3 = 0; i$3 < gap; ++i$3) {
              newMarkers.push(gapMarkers);
            }
            newMarkers.push(last);
          }
          return newMarkers;
        }
        function clearEmptySpans(spans) {
          for (var i2 = 0; i2 < spans.length; ++i2) {
            var span = spans[i2];
            if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
              spans.splice(i2--, 1);
            }
          }
          if (!spans.length) {
            return null;
          }
          return spans;
        }
        function removeReadOnlyRanges(doc2, from, to) {
          var markers = null;
          doc2.iter(from.line, to.line + 1, function(line) {
            if (line.markedSpans) {
              for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {
                var mark = line.markedSpans[i3].marker;
                if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
                  (markers || (markers = [])).push(mark);
                }
              }
            }
          });
          if (!markers) {
            return null;
          }
          var parts = [{ from, to }];
          for (var i2 = 0; i2 < markers.length; ++i2) {
            var mk = markers[i2], m = mk.find(0);
            for (var j = 0; j < parts.length; ++j) {
              var p = parts[j];
              if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
                continue;
              }
              var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
              if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
                newParts.push({ from: p.from, to: m.from });
              }
              if (dto > 0 || !mk.inclusiveRight && !dto) {
                newParts.push({ from: m.to, to: p.to });
              }
              parts.splice.apply(parts, newParts);
              j += newParts.length - 3;
            }
          }
          return parts;
        }
        function detachMarkedSpans(line) {
          var spans = line.markedSpans;
          if (!spans) {
            return;
          }
          for (var i2 = 0; i2 < spans.length; ++i2) {
            spans[i2].marker.detachLine(line);
          }
          line.markedSpans = null;
        }
        function attachMarkedSpans(line, spans) {
          if (!spans) {
            return;
          }
          for (var i2 = 0; i2 < spans.length; ++i2) {
            spans[i2].marker.attachLine(line);
          }
          line.markedSpans = spans;
        }
        function extraLeft(marker) {
          return marker.inclusiveLeft ? -1 : 0;
        }
        function extraRight(marker) {
          return marker.inclusiveRight ? 1 : 0;
        }
        function compareCollapsedMarkers(a, b) {
          var lenDiff = a.lines.length - b.lines.length;
          if (lenDiff != 0) {
            return lenDiff;
          }
          var aPos = a.find(), bPos = b.find();
          var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
          if (fromCmp) {
            return -fromCmp;
          }
          var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
          if (toCmp) {
            return toCmp;
          }
          return b.id - a.id;
        }
        function collapsedSpanAtSide(line, start) {
          var sps = sawCollapsedSpans && line.markedSpans, found;
          if (sps) {
            for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
              sp = sps[i2];
              if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
                found = sp.marker;
              }
            }
          }
          return found;
        }
        function collapsedSpanAtStart(line) {
          return collapsedSpanAtSide(line, true);
        }
        function collapsedSpanAtEnd(line) {
          return collapsedSpanAtSide(line, false);
        }
        function collapsedSpanAround(line, ch) {
          var sps = sawCollapsedSpans && line.markedSpans, found;
          if (sps) {
            for (var i2 = 0; i2 < sps.length; ++i2) {
              var sp = sps[i2];
              if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
                found = sp.marker;
              }
            }
          }
          return found;
        }
        function conflictingCollapsedRange(doc2, lineNo2, from, to, marker) {
          var line = getLine(doc2, lineNo2);
          var sps = sawCollapsedSpans && line.markedSpans;
          if (sps) {
            for (var i2 = 0; i2 < sps.length; ++i2) {
              var sp = sps[i2];
              if (!sp.marker.collapsed) {
                continue;
              }
              var found = sp.marker.find(0);
              var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
              var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
              if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
                continue;
              }
              if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
                return true;
              }
            }
          }
        }
        function visualLine(line) {
          var merged;
          while (merged = collapsedSpanAtStart(line)) {
            line = merged.find(-1, true).line;
          }
          return line;
        }
        function visualLineEnd(line) {
          var merged;
          while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
          }
          return line;
        }
        function visualLineContinued(line) {
          var merged, lines;
          while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
            (lines || (lines = [])).push(line);
          }
          return lines;
        }
        function visualLineNo(doc2, lineN) {
          var line = getLine(doc2, lineN), vis = visualLine(line);
          if (line == vis) {
            return lineN;
          }
          return lineNo(vis);
        }
        function visualLineEndNo(doc2, lineN) {
          if (lineN > doc2.lastLine()) {
            return lineN;
          }
          var line = getLine(doc2, lineN), merged;
          if (!lineIsHidden(doc2, line)) {
            return lineN;
          }
          while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
          }
          return lineNo(line) + 1;
        }
        function lineIsHidden(doc2, line) {
          var sps = sawCollapsedSpans && line.markedSpans;
          if (sps) {
            for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
              sp = sps[i2];
              if (!sp.marker.collapsed) {
                continue;
              }
              if (sp.from == null) {
                return true;
              }
              if (sp.marker.widgetNode) {
                continue;
              }
              if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc2, line, sp)) {
                return true;
              }
            }
          }
        }
        function lineIsHiddenInner(doc2, line, span) {
          if (span.to == null) {
            var end = span.marker.find(1, true);
            return lineIsHiddenInner(doc2, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
          }
          if (span.marker.inclusiveRight && span.to == line.text.length) {
            return true;
          }
          for (var sp = void 0, i2 = 0; i2 < line.markedSpans.length; ++i2) {
            sp = line.markedSpans[i2];
            if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc2, line, sp)) {
              return true;
            }
          }
        }
        function heightAtLine(lineObj) {
          lineObj = visualLine(lineObj);
          var h = 0, chunk = lineObj.parent;
          for (var i2 = 0; i2 < chunk.lines.length; ++i2) {
            var line = chunk.lines[i2];
            if (line == lineObj) {
              break;
            } else {
              h += line.height;
            }
          }
          for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
            for (var i$12 = 0; i$12 < p.children.length; ++i$12) {
              var cur = p.children[i$12];
              if (cur == chunk) {
                break;
              } else {
                h += cur.height;
              }
            }
          }
          return h;
        }
        function lineLength(line) {
          if (line.height == 0) {
            return 0;
          }
          var len = line.text.length, merged, cur = line;
          while (merged = collapsedSpanAtStart(cur)) {
            var found = merged.find(0, true);
            cur = found.from.line;
            len += found.from.ch - found.to.ch;
          }
          cur = line;
          while (merged = collapsedSpanAtEnd(cur)) {
            var found$1 = merged.find(0, true);
            len -= cur.text.length - found$1.from.ch;
            cur = found$1.to.line;
            len += cur.text.length - found$1.to.ch;
          }
          return len;
        }
        function findMaxLine(cm) {
          var d = cm.display, doc2 = cm.doc;
          d.maxLine = getLine(doc2, doc2.first);
          d.maxLineLength = lineLength(d.maxLine);
          d.maxLineChanged = true;
          doc2.iter(function(line) {
            var len = lineLength(line);
            if (len > d.maxLineLength) {
              d.maxLineLength = len;
              d.maxLine = line;
            }
          });
        }
        var Line = function(text, markedSpans, estimateHeight2) {
          this.text = text;
          attachMarkedSpans(this, markedSpans);
          this.height = estimateHeight2 ? estimateHeight2(this) : 1;
        };
        Line.prototype.lineNo = function() {
          return lineNo(this);
        };
        eventMixin(Line);
        function updateLine(line, text, markedSpans, estimateHeight2) {
          line.text = text;
          if (line.stateAfter) {
            line.stateAfter = null;
          }
          if (line.styles) {
            line.styles = null;
          }
          if (line.order != null) {
            line.order = null;
          }
          detachMarkedSpans(line);
          attachMarkedSpans(line, markedSpans);
          var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;
          if (estHeight != line.height) {
            updateLineHeight(line, estHeight);
          }
        }
        function cleanUpLine(line) {
          line.parent = null;
          detachMarkedSpans(line);
        }
        var styleToClassCache = {}, styleToClassCacheWithMode = {};
        function interpretTokenStyle(style, options2) {
          if (!style || /^\s*$/.test(style)) {
            return null;
          }
          var cache = options2.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
          return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
        }
        function buildLineContent(cm, lineView) {
          var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
          var builder = {
            pre: eltP("pre", [content], "CodeMirror-line"),
            content,
            col: 0,
            pos: 0,
            cm,
            trailingSpace: false,
            splitSpaces: cm.getOption("lineWrapping")
          };
          lineView.measure = {};
          for (var i2 = 0; i2 <= (lineView.rest ? lineView.rest.length : 0); i2++) {
            var line = i2 ? lineView.rest[i2 - 1] : lineView.line, order = void 0;
            builder.pos = 0;
            builder.addToken = buildToken;
            if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
              builder.addToken = buildTokenBadBidi(builder.addToken, order);
            }
            builder.map = [];
            var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
            insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
            if (line.styleClasses) {
              if (line.styleClasses.bgClass) {
                builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
              }
              if (line.styleClasses.textClass) {
                builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
              }
            }
            if (builder.map.length == 0) {
              builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
            }
            if (i2 == 0) {
              lineView.measure.map = builder.map;
              lineView.measure.cache = {};
            } else {
              (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
              (lineView.measure.caches || (lineView.measure.caches = [])).push({});
            }
          }
          if (webkit) {
            var last = builder.content.lastChild;
            if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
              builder.content.className = "cm-tab-wrap-hack";
            }
          }
          signal7(cm, "renderLine", cm, lineView.line, builder.pre);
          if (builder.pre.className) {
            builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
          }
          return builder;
        }
        function defaultSpecialCharPlaceholder(ch) {
          var token = elt("span", "\u2022", "cm-invalidchar");
          token.title = "\\u" + ch.charCodeAt(0).toString(16);
          token.setAttribute("aria-label", token.title);
          return token;
        }
        function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
          if (!text) {
            return;
          }
          var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
          var special = builder.cm.state.specialChars, mustWrap = false;
          var content;
          if (!special.test(text)) {
            builder.col += text.length;
            content = document.createTextNode(displayText);
            builder.map.push(builder.pos, builder.pos + text.length, content);
            if (ie && ie_version < 9) {
              mustWrap = true;
            }
            builder.pos += text.length;
          } else {
            content = document.createDocumentFragment();
            var pos = 0;
            while (true) {
              special.lastIndex = pos;
              var m = special.exec(text);
              var skipped = m ? m.index - pos : text.length - pos;
              if (skipped) {
                var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
                if (ie && ie_version < 9) {
                  content.appendChild(elt("span", [txt]));
                } else {
                  content.appendChild(txt);
                }
                builder.map.push(builder.pos, builder.pos + skipped, txt);
                builder.col += skipped;
                builder.pos += skipped;
              }
              if (!m) {
                break;
              }
              pos += skipped + 1;
              var txt$1 = void 0;
              if (m[0] == "	") {
                var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
                txt$1.setAttribute("role", "presentation");
                txt$1.setAttribute("cm-text", "	");
                builder.col += tabWidth;
              } else if (m[0] == "\r" || m[0] == "\n") {
                txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
                txt$1.setAttribute("cm-text", m[0]);
                builder.col += 1;
              } else {
                txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
                txt$1.setAttribute("cm-text", m[0]);
                if (ie && ie_version < 9) {
                  content.appendChild(elt("span", [txt$1]));
                } else {
                  content.appendChild(txt$1);
                }
                builder.col += 1;
              }
              builder.map.push(builder.pos, builder.pos + 1, txt$1);
              builder.pos++;
            }
          }
          builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
          if (style || startStyle || endStyle || mustWrap || css || attributes) {
            var fullStyle = style || "";
            if (startStyle) {
              fullStyle += startStyle;
            }
            if (endStyle) {
              fullStyle += endStyle;
            }
            var token = elt("span", [content], fullStyle, css);
            if (attributes) {
              for (var attr in attributes) {
                if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
                  token.setAttribute(attr, attributes[attr]);
                }
              }
            }
            return builder.content.appendChild(token);
          }
          builder.content.appendChild(content);
        }
        function splitSpaces(text, trailingBefore) {
          if (text.length > 1 && !/  /.test(text)) {
            return text;
          }
          var spaceBefore = trailingBefore, result = "";
          for (var i2 = 0; i2 < text.length; i2++) {
            var ch = text.charAt(i2);
            if (ch == " " && spaceBefore && (i2 == text.length - 1 || text.charCodeAt(i2 + 1) == 32)) {
              ch = "\xA0";
            }
            result += ch;
            spaceBefore = ch == " ";
          }
          return result;
        }
        function buildTokenBadBidi(inner, order) {
          return function(builder, text, style, startStyle, endStyle, css, attributes) {
            style = style ? style + " cm-force-border" : "cm-force-border";
            var start = builder.pos, end = start + text.length;
            for (; ; ) {
              var part = void 0;
              for (var i2 = 0; i2 < order.length; i2++) {
                part = order[i2];
                if (part.to > start && part.from <= start) {
                  break;
                }
              }
              if (part.to >= end) {
                return inner(builder, text, style, startStyle, endStyle, css, attributes);
              }
              inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
              startStyle = null;
              text = text.slice(part.to - start);
              start = part.to;
            }
          };
        }
        function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
          var widget = !ignoreWidget && marker.widgetNode;
          if (widget) {
            builder.map.push(builder.pos, builder.pos + size, widget);
          }
          if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
            if (!widget) {
              widget = builder.content.appendChild(document.createElement("span"));
            }
            widget.setAttribute("cm-marker", marker.id);
          }
          if (widget) {
            builder.cm.display.input.setUneditable(widget);
            builder.content.appendChild(widget);
          }
          builder.pos += size;
          builder.trailingSpace = false;
        }
        function insertLineContent(line, builder, styles) {
          var spans = line.markedSpans, allText = line.text, at = 0;
          if (!spans) {
            for (var i$12 = 1; i$12 < styles.length; i$12 += 2) {
              builder.addToken(builder, allText.slice(at, at = styles[i$12]), interpretTokenStyle(styles[i$12 + 1], builder.cm.options));
            }
            return;
          }
          var len = allText.length, pos = 0, i2 = 1, text = "", style, css;
          var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
          for (; ; ) {
            if (nextChange == pos) {
              spanStyle = spanEndStyle = spanStartStyle = css = "";
              attributes = null;
              collapsed = null;
              nextChange = Infinity;
              var foundBookmarks = [], endStyles = void 0;
              for (var j = 0; j < spans.length; ++j) {
                var sp = spans[j], m = sp.marker;
                if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
                  foundBookmarks.push(m);
                } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
                  if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                    nextChange = sp.to;
                    spanEndStyle = "";
                  }
                  if (m.className) {
                    spanStyle += " " + m.className;
                  }
                  if (m.css) {
                    css = (css ? css + ";" : "") + m.css;
                  }
                  if (m.startStyle && sp.from == pos) {
                    spanStartStyle += " " + m.startStyle;
                  }
                  if (m.endStyle && sp.to == nextChange) {
                    (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
                  }
                  if (m.title) {
                    (attributes || (attributes = {})).title = m.title;
                  }
                  if (m.attributes) {
                    for (var attr in m.attributes) {
                      (attributes || (attributes = {}))[attr] = m.attributes[attr];
                    }
                  }
                  if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
                    collapsed = sp;
                  }
                } else if (sp.from > pos && nextChange > sp.from) {
                  nextChange = sp.from;
                }
              }
              if (endStyles) {
                for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
                  if (endStyles[j$1 + 1] == nextChange) {
                    spanEndStyle += " " + endStyles[j$1];
                  }
                }
              }
              if (!collapsed || collapsed.from == pos) {
                for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
                  buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
                }
              }
              if (collapsed && (collapsed.from || 0) == pos) {
                buildCollapsedSpan(
                  builder,
                  (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                  collapsed.marker,
                  collapsed.from == null
                );
                if (collapsed.to == null) {
                  return;
                }
                if (collapsed.to == pos) {
                  collapsed = false;
                }
              }
            }
            if (pos >= len) {
              break;
            }
            var upto = Math.min(len, nextChange);
            while (true) {
              if (text) {
                var end = pos + text.length;
                if (!collapsed) {
                  var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                  builder.addToken(
                    builder,
                    tokenText,
                    style ? style + spanStyle : spanStyle,
                    spanStartStyle,
                    pos + tokenText.length == nextChange ? spanEndStyle : "",
                    css,
                    attributes
                  );
                }
                if (end >= upto) {
                  text = text.slice(upto - pos);
                  pos = upto;
                  break;
                }
                pos = end;
                spanStartStyle = "";
              }
              text = allText.slice(at, at = styles[i2++]);
              style = interpretTokenStyle(styles[i2++], builder.cm.options);
            }
          }
        }
        function LineView(doc2, line, lineN) {
          this.line = line;
          this.rest = visualLineContinued(line);
          this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
          this.node = this.text = null;
          this.hidden = lineIsHidden(doc2, line);
        }
        function buildViewArray(cm, from, to) {
          var array = [], nextPos;
          for (var pos = from; pos < to; pos = nextPos) {
            var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
            nextPos = pos + view.size;
            array.push(view);
          }
          return array;
        }
        var operationGroup = null;
        function pushOperation(op) {
          if (operationGroup) {
            operationGroup.ops.push(op);
          } else {
            op.ownsGroup = operationGroup = {
              ops: [op],
              delayedCallbacks: []
            };
          }
        }
        function fireCallbacksForOps(group) {
          var callbacks = group.delayedCallbacks, i2 = 0;
          do {
            for (; i2 < callbacks.length; i2++) {
              callbacks[i2].call(null);
            }
            for (var j = 0; j < group.ops.length; j++) {
              var op = group.ops[j];
              if (op.cursorActivityHandlers) {
                while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
                  op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
                }
              }
            }
          } while (i2 < callbacks.length);
        }
        function finishOperation(op, endCb) {
          var group = op.ownsGroup;
          if (!group) {
            return;
          }
          try {
            fireCallbacksForOps(group);
          } finally {
            operationGroup = null;
            endCb(group);
          }
        }
        var orphanDelayedCallbacks = null;
        function signalLater(emitter2, type) {
          var arr = getHandlers13(emitter2, type);
          if (!arr.length) {
            return;
          }
          var args = Array.prototype.slice.call(arguments, 2), list2;
          if (operationGroup) {
            list2 = operationGroup.delayedCallbacks;
          } else if (orphanDelayedCallbacks) {
            list2 = orphanDelayedCallbacks;
          } else {
            list2 = orphanDelayedCallbacks = [];
            setTimeout(fireOrphanDelayed, 0);
          }
          var loop = function(i3) {
            list2.push(function() {
              return arr[i3].apply(null, args);
            });
          };
          for (var i2 = 0; i2 < arr.length; ++i2)
            loop(i2);
        }
        function fireOrphanDelayed() {
          var delayed = orphanDelayedCallbacks;
          orphanDelayedCallbacks = null;
          for (var i2 = 0; i2 < delayed.length; ++i2) {
            delayed[i2]();
          }
        }
        function updateLineForChanges(cm, lineView, lineN, dims) {
          for (var j = 0; j < lineView.changes.length; j++) {
            var type = lineView.changes[j];
            if (type == "text") {
              updateLineText(cm, lineView);
            } else if (type == "gutter") {
              updateLineGutter(cm, lineView, lineN, dims);
            } else if (type == "class") {
              updateLineClasses(cm, lineView);
            } else if (type == "widget") {
              updateLineWidgets(cm, lineView, dims);
            }
          }
          lineView.changes = null;
        }
        function ensureLineWrapped(lineView) {
          if (lineView.node == lineView.text) {
            lineView.node = elt("div", null, null, "position: relative");
            if (lineView.text.parentNode) {
              lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
            }
            lineView.node.appendChild(lineView.text);
            if (ie && ie_version < 8) {
              lineView.node.style.zIndex = 2;
            }
          }
          return lineView.node;
        }
        function updateLineBackground(cm, lineView) {
          var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
          if (cls) {
            cls += " CodeMirror-linebackground";
          }
          if (lineView.background) {
            if (cls) {
              lineView.background.className = cls;
            } else {
              lineView.background.parentNode.removeChild(lineView.background);
              lineView.background = null;
            }
          } else if (cls) {
            var wrap = ensureLineWrapped(lineView);
            lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
            cm.display.input.setUneditable(lineView.background);
          }
        }
        function getLineContent(cm, lineView) {
          var ext = cm.display.externalMeasured;
          if (ext && ext.line == lineView.line) {
            cm.display.externalMeasured = null;
            lineView.measure = ext.measure;
            return ext.built;
          }
          return buildLineContent(cm, lineView);
        }
        function updateLineText(cm, lineView) {
          var cls = lineView.text.className;
          var built = getLineContent(cm, lineView);
          if (lineView.text == lineView.node) {
            lineView.node = built.pre;
          }
          lineView.text.parentNode.replaceChild(built.pre, lineView.text);
          lineView.text = built.pre;
          if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
            lineView.bgClass = built.bgClass;
            lineView.textClass = built.textClass;
            updateLineClasses(cm, lineView);
          } else if (cls) {
            lineView.text.className = cls;
          }
        }
        function updateLineClasses(cm, lineView) {
          updateLineBackground(cm, lineView);
          if (lineView.line.wrapClass) {
            ensureLineWrapped(lineView).className = lineView.line.wrapClass;
          } else if (lineView.node != lineView.text) {
            lineView.node.className = "";
          }
          var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
          lineView.text.className = textClass || "";
        }
        function updateLineGutter(cm, lineView, lineN, dims) {
          if (lineView.gutter) {
            lineView.node.removeChild(lineView.gutter);
            lineView.gutter = null;
          }
          if (lineView.gutterBackground) {
            lineView.node.removeChild(lineView.gutterBackground);
            lineView.gutterBackground = null;
          }
          if (lineView.line.gutterClass) {
            var wrap = ensureLineWrapped(lineView);
            lineView.gutterBackground = elt(
              "div",
              null,
              "CodeMirror-gutter-background " + lineView.line.gutterClass,
              "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px"
            );
            cm.display.input.setUneditable(lineView.gutterBackground);
            wrap.insertBefore(lineView.gutterBackground, lineView.text);
          }
          var markers = lineView.line.gutterMarkers;
          if (cm.options.lineNumbers || markers) {
            var wrap$1 = ensureLineWrapped(lineView);
            var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
            gutterWrap.setAttribute("aria-hidden", "true");
            cm.display.input.setUneditable(gutterWrap);
            wrap$1.insertBefore(gutterWrap, lineView.text);
            if (lineView.line.gutterClass) {
              gutterWrap.className += " " + lineView.line.gutterClass;
            }
            if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
              lineView.lineNumber = gutterWrap.appendChild(
                elt(
                  "div",
                  lineNumberFor(cm.options, lineN),
                  "CodeMirror-linenumber CodeMirror-gutter-elt",
                  "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"
                )
              );
            }
            if (markers) {
              for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
                var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
                if (found) {
                  gutterWrap.appendChild(elt(
                    "div",
                    [found],
                    "CodeMirror-gutter-elt",
                    "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"
                  ));
                }
              }
            }
          }
        }
        function updateLineWidgets(cm, lineView, dims) {
          if (lineView.alignable) {
            lineView.alignable = null;
          }
          var isWidget = classTest("CodeMirror-linewidget");
          for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
            next = node.nextSibling;
            if (isWidget.test(node.className)) {
              lineView.node.removeChild(node);
            }
          }
          insertLineWidgets(cm, lineView, dims);
        }
        function buildLineElement(cm, lineView, lineN, dims) {
          var built = getLineContent(cm, lineView);
          lineView.text = lineView.node = built.pre;
          if (built.bgClass) {
            lineView.bgClass = built.bgClass;
          }
          if (built.textClass) {
            lineView.textClass = built.textClass;
          }
          updateLineClasses(cm, lineView);
          updateLineGutter(cm, lineView, lineN, dims);
          insertLineWidgets(cm, lineView, dims);
          return lineView.node;
        }
        function insertLineWidgets(cm, lineView, dims) {
          insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
          if (lineView.rest) {
            for (var i2 = 0; i2 < lineView.rest.length; i2++) {
              insertLineWidgetsFor(cm, lineView.rest[i2], lineView, dims, false);
            }
          }
        }
        function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
          if (!line.widgets) {
            return;
          }
          var wrap = ensureLineWrapped(lineView);
          for (var i2 = 0, ws = line.widgets; i2 < ws.length; ++i2) {
            var widget = ws[i2], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
            if (!widget.handleMouseEvents) {
              node.setAttribute("cm-ignore-events", "true");
            }
            positionLineWidget(widget, node, lineView, dims);
            cm.display.input.setUneditable(node);
            if (allowAbove && widget.above) {
              wrap.insertBefore(node, lineView.gutter || lineView.text);
            } else {
              wrap.appendChild(node);
            }
            signalLater(widget, "redraw");
          }
        }
        function positionLineWidget(widget, node, lineView, dims) {
          if (widget.noHScroll) {
            (lineView.alignable || (lineView.alignable = [])).push(node);
            var width = dims.wrapperWidth;
            node.style.left = dims.fixedPos + "px";
            if (!widget.coverGutter) {
              width -= dims.gutterTotalWidth;
              node.style.paddingLeft = dims.gutterTotalWidth + "px";
            }
            node.style.width = width + "px";
          }
          if (widget.coverGutter) {
            node.style.zIndex = 5;
            node.style.position = "relative";
            if (!widget.noHScroll) {
              node.style.marginLeft = -dims.gutterTotalWidth + "px";
            }
          }
        }
        function widgetHeight(widget) {
          if (widget.height != null) {
            return widget.height;
          }
          var cm = widget.doc.cm;
          if (!cm) {
            return 0;
          }
          if (!contains(document.body, widget.node)) {
            var parentStyle = "position: relative;";
            if (widget.coverGutter) {
              parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
            }
            if (widget.noHScroll) {
              parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
            }
            removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
          }
          return widget.height = widget.node.parentNode.offsetHeight;
        }
        function eventInWidget(display, e) {
          for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
            if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
              return true;
            }
          }
        }
        function paddingTop(display) {
          return display.lineSpace.offsetTop;
        }
        function paddingVert(display) {
          return display.mover.offsetHeight - display.lineSpace.offsetHeight;
        }
        function paddingH(display) {
          if (display.cachedPaddingH) {
            return display.cachedPaddingH;
          }
          var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
          var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
          var data2 = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
          if (!isNaN(data2.left) && !isNaN(data2.right)) {
            display.cachedPaddingH = data2;
          }
          return data2;
        }
        function scrollGap(cm) {
          return scrollerGap - cm.display.nativeBarWidth;
        }
        function displayWidth(cm) {
          return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
        }
        function displayHeight(cm) {
          return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
        }
        function ensureLineHeights(cm, lineView, rect) {
          var wrapping = cm.options.lineWrapping;
          var curWidth = wrapping && displayWidth(cm);
          if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
            var heights = lineView.measure.heights = [];
            if (wrapping) {
              lineView.measure.width = curWidth;
              var rects = lineView.text.firstChild.getClientRects();
              for (var i2 = 0; i2 < rects.length - 1; i2++) {
                var cur = rects[i2], next = rects[i2 + 1];
                if (Math.abs(cur.bottom - next.bottom) > 2) {
                  heights.push((cur.bottom + next.top) / 2 - rect.top);
                }
              }
            }
            heights.push(rect.bottom - rect.top);
          }
        }
        function mapFromLineView(lineView, line, lineN) {
          if (lineView.line == line) {
            return { map: lineView.measure.map, cache: lineView.measure.cache };
          }
          if (lineView.rest) {
            for (var i2 = 0; i2 < lineView.rest.length; i2++) {
              if (lineView.rest[i2] == line) {
                return { map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2] };
              }
            }
            for (var i$12 = 0; i$12 < lineView.rest.length; i$12++) {
              if (lineNo(lineView.rest[i$12]) > lineN) {
                return { map: lineView.measure.maps[i$12], cache: lineView.measure.caches[i$12], before: true };
              }
            }
          }
        }
        function updateExternalMeasurement(cm, line) {
          line = visualLine(line);
          var lineN = lineNo(line);
          var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
          view.lineN = lineN;
          var built = view.built = buildLineContent(cm, view);
          view.text = built.pre;
          removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
          return view;
        }
        function measureChar(cm, line, ch, bias) {
          return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
        }
        function findViewForLine(cm, lineN) {
          if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
            return cm.display.view[findViewIndex(cm, lineN)];
          }
          var ext = cm.display.externalMeasured;
          if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
            return ext;
          }
        }
        function prepareMeasureForLine(cm, line) {
          var lineN = lineNo(line);
          var view = findViewForLine(cm, lineN);
          if (view && !view.text) {
            view = null;
          } else if (view && view.changes) {
            updateLineForChanges(cm, view, lineN, getDimensions(cm));
            cm.curOp.forceUpdate = true;
          }
          if (!view) {
            view = updateExternalMeasurement(cm, line);
          }
          var info = mapFromLineView(view, line, lineN);
          return {
            line,
            view,
            rect: null,
            map: info.map,
            cache: info.cache,
            before: info.before,
            hasHeights: false
          };
        }
        function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
          if (prepared.before) {
            ch = -1;
          }
          var key = ch + (bias || ""), found;
          if (prepared.cache.hasOwnProperty(key)) {
            found = prepared.cache[key];
          } else {
            if (!prepared.rect) {
              prepared.rect = prepared.view.text.getBoundingClientRect();
            }
            if (!prepared.hasHeights) {
              ensureLineHeights(cm, prepared.view, prepared.rect);
              prepared.hasHeights = true;
            }
            found = measureCharInner(cm, prepared, ch, bias);
            if (!found.bogus) {
              prepared.cache[key] = found;
            }
          }
          return {
            left: found.left,
            right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom
          };
        }
        var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
        function nodeAndOffsetInLineMap(map2, ch, bias) {
          var node, start, end, collapse, mStart, mEnd;
          for (var i2 = 0; i2 < map2.length; i2 += 3) {
            mStart = map2[i2];
            mEnd = map2[i2 + 1];
            if (ch < mStart) {
              start = 0;
              end = 1;
              collapse = "left";
            } else if (ch < mEnd) {
              start = ch - mStart;
              end = start + 1;
            } else if (i2 == map2.length - 3 || ch == mEnd && map2[i2 + 3] > ch) {
              end = mEnd - mStart;
              start = end - 1;
              if (ch >= mEnd) {
                collapse = "right";
              }
            }
            if (start != null) {
              node = map2[i2 + 2];
              if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
                collapse = bias;
              }
              if (bias == "left" && start == 0) {
                while (i2 && map2[i2 - 2] == map2[i2 - 3] && map2[i2 - 1].insertLeft) {
                  node = map2[(i2 -= 3) + 2];
                  collapse = "left";
                }
              }
              if (bias == "right" && start == mEnd - mStart) {
                while (i2 < map2.length - 3 && map2[i2 + 3] == map2[i2 + 4] && !map2[i2 + 5].insertLeft) {
                  node = map2[(i2 += 3) + 2];
                  collapse = "right";
                }
              }
              break;
            }
          }
          return { node, start, end, collapse, coverStart: mStart, coverEnd: mEnd };
        }
        function getUsefulRect(rects, bias) {
          var rect = nullRect;
          if (bias == "left") {
            for (var i2 = 0; i2 < rects.length; i2++) {
              if ((rect = rects[i2]).left != rect.right) {
                break;
              }
            }
          } else {
            for (var i$12 = rects.length - 1; i$12 >= 0; i$12--) {
              if ((rect = rects[i$12]).left != rect.right) {
                break;
              }
            }
          }
          return rect;
        }
        function measureCharInner(cm, prepared, ch, bias) {
          var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
          var node = place.node, start = place.start, end = place.end, collapse = place.collapse;
          var rect;
          if (node.nodeType == 3) {
            for (var i$12 = 0; i$12 < 4; i$12++) {
              while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
                --start;
              }
              while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
                ++end;
              }
              if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
                rect = node.parentNode.getBoundingClientRect();
              } else {
                rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
              }
              if (rect.left || rect.right || start == 0) {
                break;
              }
              end = start;
              start = start - 1;
              collapse = "right";
            }
            if (ie && ie_version < 11) {
              rect = maybeUpdateRectForZooming(cm.display.measure, rect);
            }
          } else {
            if (start > 0) {
              collapse = bias = "right";
            }
            var rects;
            if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
              rect = rects[bias == "right" ? rects.length - 1 : 0];
            } else {
              rect = node.getBoundingClientRect();
            }
          }
          if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
            var rSpan = node.parentNode.getClientRects()[0];
            if (rSpan) {
              rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
            } else {
              rect = nullRect;
            }
          }
          var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
          var mid = (rtop + rbot) / 2;
          var heights = prepared.view.measure.heights;
          var i2 = 0;
          for (; i2 < heights.length - 1; i2++) {
            if (mid < heights[i2]) {
              break;
            }
          }
          var top = i2 ? heights[i2 - 1] : 0, bot = heights[i2];
          var result = {
            left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
            right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
            top,
            bottom: bot
          };
          if (!rect.left && !rect.right) {
            result.bogus = true;
          }
          if (!cm.options.singleCursorHeightPerLine) {
            result.rtop = rtop;
            result.rbottom = rbot;
          }
          return result;
        }
        function maybeUpdateRectForZooming(measure, rect) {
          if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
            return rect;
          }
          var scaleX = screen.logicalXDPI / screen.deviceXDPI;
          var scaleY = screen.logicalYDPI / screen.deviceYDPI;
          return {
            left: rect.left * scaleX,
            right: rect.right * scaleX,
            top: rect.top * scaleY,
            bottom: rect.bottom * scaleY
          };
        }
        function clearLineMeasurementCacheFor(lineView) {
          if (lineView.measure) {
            lineView.measure.cache = {};
            lineView.measure.heights = null;
            if (lineView.rest) {
              for (var i2 = 0; i2 < lineView.rest.length; i2++) {
                lineView.measure.caches[i2] = {};
              }
            }
          }
        }
        function clearLineMeasurementCache(cm) {
          cm.display.externalMeasure = null;
          removeChildren(cm.display.lineMeasure);
          for (var i2 = 0; i2 < cm.display.view.length; i2++) {
            clearLineMeasurementCacheFor(cm.display.view[i2]);
          }
        }
        function clearCaches(cm) {
          clearLineMeasurementCache(cm);
          cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
          if (!cm.options.lineWrapping) {
            cm.display.maxLineChanged = true;
          }
          cm.display.lineNumChars = null;
        }
        function pageScrollX(doc2) {
          if (chrome && android) {
            return -(doc2.body.getBoundingClientRect().left - parseInt(getComputedStyle(doc2.body).marginLeft));
          }
          return doc2.defaultView.pageXOffset || (doc2.documentElement || doc2.body).scrollLeft;
        }
        function pageScrollY(doc2) {
          if (chrome && android) {
            return -(doc2.body.getBoundingClientRect().top - parseInt(getComputedStyle(doc2.body).marginTop));
          }
          return doc2.defaultView.pageYOffset || (doc2.documentElement || doc2.body).scrollTop;
        }
        function widgetTopHeight(lineObj) {
          var ref = visualLine(lineObj);
          var widgets = ref.widgets;
          var height = 0;
          if (widgets) {
            for (var i2 = 0; i2 < widgets.length; ++i2) {
              if (widgets[i2].above) {
                height += widgetHeight(widgets[i2]);
              }
            }
          }
          return height;
        }
        function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
          if (!includeWidgets) {
            var height = widgetTopHeight(lineObj);
            rect.top += height;
            rect.bottom += height;
          }
          if (context == "line") {
            return rect;
          }
          if (!context) {
            context = "local";
          }
          var yOff = heightAtLine(lineObj);
          if (context == "local") {
            yOff += paddingTop(cm.display);
          } else {
            yOff -= cm.display.viewOffset;
          }
          if (context == "page" || context == "window") {
            var lOff = cm.display.lineSpace.getBoundingClientRect();
            yOff += lOff.top + (context == "window" ? 0 : pageScrollY(doc(cm)));
            var xOff = lOff.left + (context == "window" ? 0 : pageScrollX(doc(cm)));
            rect.left += xOff;
            rect.right += xOff;
          }
          rect.top += yOff;
          rect.bottom += yOff;
          return rect;
        }
        function fromCoordSystem(cm, coords, context) {
          if (context == "div") {
            return coords;
          }
          var left = coords.left, top = coords.top;
          if (context == "page") {
            left -= pageScrollX(doc(cm));
            top -= pageScrollY(doc(cm));
          } else if (context == "local" || !context) {
            var localBox = cm.display.sizer.getBoundingClientRect();
            left += localBox.left;
            top += localBox.top;
          }
          var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
          return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top };
        }
        function charCoords(cm, pos, context, lineObj, bias) {
          if (!lineObj) {
            lineObj = getLine(cm.doc, pos.line);
          }
          return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
        }
        function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
          lineObj = lineObj || getLine(cm.doc, pos.line);
          if (!preparedMeasure) {
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
          }
          function get(ch2, right) {
            var m = measureCharPrepared(cm, preparedMeasure, ch2, right ? "right" : "left", varHeight);
            if (right) {
              m.left = m.right;
            } else {
              m.right = m.left;
            }
            return intoCoordSystem(cm, lineObj, m, context);
          }
          var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
          if (ch >= lineObj.text.length) {
            ch = lineObj.text.length;
            sticky = "before";
          } else if (ch <= 0) {
            ch = 0;
            sticky = "after";
          }
          if (!order) {
            return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
          }
          function getBidi(ch2, partPos2, invert) {
            var part = order[partPos2], right = part.level == 1;
            return get(invert ? ch2 - 1 : ch2, right != invert);
          }
          var partPos = getBidiPartAt(order, ch, sticky);
          var other = bidiOther;
          var val = getBidi(ch, partPos, sticky == "before");
          if (other != null) {
            val.other = getBidi(ch, other, sticky != "before");
          }
          return val;
        }
        function estimateCoords(cm, pos) {
          var left = 0;
          pos = clipPos(cm.doc, pos);
          if (!cm.options.lineWrapping) {
            left = charWidth(cm.display) * pos.ch;
          }
          var lineObj = getLine(cm.doc, pos.line);
          var top = heightAtLine(lineObj) + paddingTop(cm.display);
          return { left, right: left, top, bottom: top + lineObj.height };
        }
        function PosWithInfo(line, ch, sticky, outside, xRel) {
          var pos = Pos(line, ch, sticky);
          pos.xRel = xRel;
          if (outside) {
            pos.outside = outside;
          }
          return pos;
        }
        function coordsChar(cm, x, y) {
          var doc2 = cm.doc;
          y += cm.display.viewOffset;
          if (y < 0) {
            return PosWithInfo(doc2.first, 0, null, -1, -1);
          }
          var lineN = lineAtHeight(doc2, y), last = doc2.first + doc2.size - 1;
          if (lineN > last) {
            return PosWithInfo(doc2.first + doc2.size - 1, getLine(doc2, last).text.length, null, 1, 1);
          }
          if (x < 0) {
            x = 0;
          }
          var lineObj = getLine(doc2, lineN);
          for (; ; ) {
            var found = coordsCharInner(cm, lineObj, lineN, x, y);
            var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
            if (!collapsed) {
              return found;
            }
            var rangeEnd = collapsed.find(1);
            if (rangeEnd.line == lineN) {
              return rangeEnd;
            }
            lineObj = getLine(doc2, lineN = rangeEnd.line);
          }
        }
        function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
          y -= widgetTopHeight(lineObj);
          var end = lineObj.text.length;
          var begin = findFirst(function(ch) {
            return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
          }, end, 0);
          end = findFirst(function(ch) {
            return measureCharPrepared(cm, preparedMeasure, ch).top > y;
          }, begin, end);
          return { begin, end };
        }
        function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
          if (!preparedMeasure) {
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
          }
          var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
          return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
        }
        function boxIsAfter(box, x, y, left) {
          return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
        }
        function coordsCharInner(cm, lineObj, lineNo2, x, y) {
          y -= heightAtLine(lineObj);
          var preparedMeasure = prepareMeasureForLine(cm, lineObj);
          var widgetHeight2 = widgetTopHeight(lineObj);
          var begin = 0, end = lineObj.text.length, ltr = true;
          var order = getOrder(lineObj, cm.doc.direction);
          if (order) {
            var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order, x, y);
            ltr = part.level != 1;
            begin = ltr ? part.from : part.to - 1;
            end = ltr ? part.to : part.from - 1;
          }
          var chAround = null, boxAround = null;
          var ch = findFirst(function(ch2) {
            var box = measureCharPrepared(cm, preparedMeasure, ch2);
            box.top += widgetHeight2;
            box.bottom += widgetHeight2;
            if (!boxIsAfter(box, x, y, false)) {
              return false;
            }
            if (box.top <= y && box.left <= x) {
              chAround = ch2;
              boxAround = box;
            }
            return true;
          }, begin, end);
          var baseX, sticky, outside = false;
          if (boxAround) {
            var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
            ch = chAround + (atStart ? 0 : 1);
            sticky = atStart ? "after" : "before";
            baseX = atLeft ? boxAround.left : boxAround.right;
          } else {
            if (!ltr && (ch == end || ch == begin)) {
              ch++;
            }
            sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y == ltr ? "after" : "before";
            var coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);
            baseX = coords.left;
            outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
          }
          ch = skipExtendingChars(lineObj.text, ch, 1);
          return PosWithInfo(lineNo2, ch, sticky, outside, x - baseX);
        }
        function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order, x, y) {
          var index = findFirst(function(i2) {
            var part2 = order[i2], ltr2 = part2.level != 1;
            return boxIsAfter(cursorCoords(
              cm,
              Pos(lineNo2, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"),
              "line",
              lineObj,
              preparedMeasure
            ), x, y, true);
          }, 0, order.length - 1);
          var part = order[index];
          if (index > 0) {
            var ltr = part.level != 1;
            var start = cursorCoords(
              cm,
              Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"),
              "line",
              lineObj,
              preparedMeasure
            );
            if (boxIsAfter(start, x, y, true) && start.top > y) {
              part = order[index - 1];
            }
          }
          return part;
        }
        function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
          var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
          var begin = ref.begin;
          var end = ref.end;
          if (/\s/.test(lineObj.text.charAt(end - 1))) {
            end--;
          }
          var part = null, closestDist = null;
          for (var i2 = 0; i2 < order.length; i2++) {
            var p = order[i2];
            if (p.from >= end || p.to <= begin) {
              continue;
            }
            var ltr = p.level != 1;
            var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
            var dist = endX < x ? x - endX + 1e9 : endX - x;
            if (!part || closestDist > dist) {
              part = p;
              closestDist = dist;
            }
          }
          if (!part) {
            part = order[order.length - 1];
          }
          if (part.from < begin) {
            part = { from: begin, to: part.to, level: part.level };
          }
          if (part.to > end) {
            part = { from: part.from, to: end, level: part.level };
          }
          return part;
        }
        var measureText;
        function textHeight(display) {
          if (display.cachedTextHeight != null) {
            return display.cachedTextHeight;
          }
          if (measureText == null) {
            measureText = elt("pre", null, "CodeMirror-line-like");
            for (var i2 = 0; i2 < 49; ++i2) {
              measureText.appendChild(document.createTextNode("x"));
              measureText.appendChild(elt("br"));
            }
            measureText.appendChild(document.createTextNode("x"));
          }
          removeChildrenAndAdd(display.measure, measureText);
          var height = measureText.offsetHeight / 50;
          if (height > 3) {
            display.cachedTextHeight = height;
          }
          removeChildren(display.measure);
          return height || 1;
        }
        function charWidth(display) {
          if (display.cachedCharWidth != null) {
            return display.cachedCharWidth;
          }
          var anchor = elt("span", "xxxxxxxxxx");
          var pre = elt("pre", [anchor], "CodeMirror-line-like");
          removeChildrenAndAdd(display.measure, pre);
          var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
          if (width > 2) {
            display.cachedCharWidth = width;
          }
          return width || 10;
        }
        function getDimensions(cm) {
          var d = cm.display, left = {}, width = {};
          var gutterLeft = d.gutters.clientLeft;
          for (var n = d.gutters.firstChild, i2 = 0; n; n = n.nextSibling, ++i2) {
            var id = cm.display.gutterSpecs[i2].className;
            left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
            width[id] = n.clientWidth;
          }
          return {
            fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth
          };
        }
        function compensateForHScroll(display) {
          return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
        }
        function estimateHeight(cm) {
          var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
          var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
          return function(line) {
            if (lineIsHidden(cm.doc, line)) {
              return 0;
            }
            var widgetsHeight = 0;
            if (line.widgets) {
              for (var i2 = 0; i2 < line.widgets.length; i2++) {
                if (line.widgets[i2].height) {
                  widgetsHeight += line.widgets[i2].height;
                }
              }
            }
            if (wrapping) {
              return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
            } else {
              return widgetsHeight + th;
            }
          };
        }
        function estimateLineHeights(cm) {
          var doc2 = cm.doc, est = estimateHeight(cm);
          doc2.iter(function(line) {
            var estHeight = est(line);
            if (estHeight != line.height) {
              updateLineHeight(line, estHeight);
            }
          });
        }
        function posFromMouse(cm, e, liberal, forRect) {
          var display = cm.display;
          if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
            return null;
          }
          var x, y, space = display.lineSpace.getBoundingClientRect();
          try {
            x = e.clientX - space.left;
            y = e.clientY - space.top;
          } catch (e$1) {
            return null;
          }
          var coords = coordsChar(cm, x, y), line;
          if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
            var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
            coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
          }
          return coords;
        }
        function findViewIndex(cm, n) {
          if (n >= cm.display.viewTo) {
            return null;
          }
          n -= cm.display.viewFrom;
          if (n < 0) {
            return null;
          }
          var view = cm.display.view;
          for (var i2 = 0; i2 < view.length; i2++) {
            n -= view[i2].size;
            if (n < 0) {
              return i2;
            }
          }
        }
        function regChange(cm, from, to, lendiff) {
          if (from == null) {
            from = cm.doc.first;
          }
          if (to == null) {
            to = cm.doc.first + cm.doc.size;
          }
          if (!lendiff) {
            lendiff = 0;
          }
          var display = cm.display;
          if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
            display.updateLineNumbers = from;
          }
          cm.curOp.viewChanged = true;
          if (from >= display.viewTo) {
            if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
              resetView(cm);
            }
          } else if (to <= display.viewFrom) {
            if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
              resetView(cm);
            } else {
              display.viewFrom += lendiff;
              display.viewTo += lendiff;
            }
          } else if (from <= display.viewFrom && to >= display.viewTo) {
            resetView(cm);
          } else if (from <= display.viewFrom) {
            var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cut) {
              display.view = display.view.slice(cut.index);
              display.viewFrom = cut.lineN;
              display.viewTo += lendiff;
            } else {
              resetView(cm);
            }
          } else if (to >= display.viewTo) {
            var cut$1 = viewCuttingPoint(cm, from, from, -1);
            if (cut$1) {
              display.view = display.view.slice(0, cut$1.index);
              display.viewTo = cut$1.lineN;
            } else {
              resetView(cm);
            }
          } else {
            var cutTop = viewCuttingPoint(cm, from, from, -1);
            var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cutTop && cutBot) {
              display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
              display.viewTo += lendiff;
            } else {
              resetView(cm);
            }
          }
          var ext = display.externalMeasured;
          if (ext) {
            if (to < ext.lineN) {
              ext.lineN += lendiff;
            } else if (from < ext.lineN + ext.size) {
              display.externalMeasured = null;
            }
          }
        }
        function regLineChange(cm, line, type) {
          cm.curOp.viewChanged = true;
          var display = cm.display, ext = cm.display.externalMeasured;
          if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
            display.externalMeasured = null;
          }
          if (line < display.viewFrom || line >= display.viewTo) {
            return;
          }
          var lineView = display.view[findViewIndex(cm, line)];
          if (lineView.node == null) {
            return;
          }
          var arr = lineView.changes || (lineView.changes = []);
          if (indexOf(arr, type) == -1) {
            arr.push(type);
          }
        }
        function resetView(cm) {
          cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
          cm.display.view = [];
          cm.display.viewOffset = 0;
        }
        function viewCuttingPoint(cm, oldN, newN, dir) {
          var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
          if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
            return { index, lineN: newN };
          }
          var n = cm.display.viewFrom;
          for (var i2 = 0; i2 < index; i2++) {
            n += view[i2].size;
          }
          if (n != oldN) {
            if (dir > 0) {
              if (index == view.length - 1) {
                return null;
              }
              diff = n + view[index].size - oldN;
              index++;
            } else {
              diff = n - oldN;
            }
            oldN += diff;
            newN += diff;
          }
          while (visualLineNo(cm.doc, newN) != newN) {
            if (index == (dir < 0 ? 0 : view.length - 1)) {
              return null;
            }
            newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
            index += dir;
          }
          return { index, lineN: newN };
        }
        function adjustView(cm, from, to) {
          var display = cm.display, view = display.view;
          if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
            display.view = buildViewArray(cm, from, to);
            display.viewFrom = from;
          } else {
            if (display.viewFrom > from) {
              display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
            } else if (display.viewFrom < from) {
              display.view = display.view.slice(findViewIndex(cm, from));
            }
            display.viewFrom = from;
            if (display.viewTo < to) {
              display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
            } else if (display.viewTo > to) {
              display.view = display.view.slice(0, findViewIndex(cm, to));
            }
          }
          display.viewTo = to;
        }
        function countDirtyView(cm) {
          var view = cm.display.view, dirty = 0;
          for (var i2 = 0; i2 < view.length; i2++) {
            var lineView = view[i2];
            if (!lineView.hidden && (!lineView.node || lineView.changes)) {
              ++dirty;
            }
          }
          return dirty;
        }
        function updateSelection(cm) {
          cm.display.input.showSelection(cm.display.input.prepareSelection());
        }
        function prepareSelection(cm, primary) {
          if (primary === void 0) primary = true;
          var doc2 = cm.doc, result = {};
          var curFragment = result.cursors = document.createDocumentFragment();
          var selFragment = result.selection = document.createDocumentFragment();
          var customCursor = cm.options.$customCursor;
          if (customCursor) {
            primary = true;
          }
          for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
            if (!primary && i2 == doc2.sel.primIndex) {
              continue;
            }
            var range2 = doc2.sel.ranges[i2];
            if (range2.from().line >= cm.display.viewTo || range2.to().line < cm.display.viewFrom) {
              continue;
            }
            var collapsed = range2.empty();
            if (customCursor) {
              var head = customCursor(cm, range2);
              if (head) {
                drawSelectionCursor(cm, head, curFragment);
              }
            } else if (collapsed || cm.options.showCursorWhenSelecting) {
              drawSelectionCursor(cm, range2.head, curFragment);
            }
            if (!collapsed) {
              drawSelectionRange(cm, range2, selFragment);
            }
          }
          return result;
        }
        function drawSelectionCursor(cm, head, output) {
          var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
          var cursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor"));
          cursor.style.left = pos.left + "px";
          cursor.style.top = pos.top + "px";
          cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
          if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
            var charPos = charCoords(cm, head, "div", null, null);
            var width = charPos.right - charPos.left;
            cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";
          }
          if (pos.other) {
            var otherCursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
            otherCursor.style.display = "";
            otherCursor.style.left = pos.other.left + "px";
            otherCursor.style.top = pos.other.top + "px";
            otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
          }
        }
        function cmpCoords(a, b) {
          return a.top - b.top || a.left - b.left;
        }
        function drawSelectionRange(cm, range2, output) {
          var display = cm.display, doc2 = cm.doc;
          var fragment = document.createDocumentFragment();
          var padding = paddingH(cm.display), leftSide = padding.left;
          var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
          var docLTR = doc2.direction == "ltr";
          function add(left, top, width, bottom) {
            if (top < 0) {
              top = 0;
            }
            top = Math.round(top);
            bottom = Math.round(bottom);
            fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
          }
          function drawForLine(line, fromArg, toArg) {
            var lineObj = getLine(doc2, line);
            var lineLen = lineObj.text.length;
            var start, end;
            function coords(ch, bias) {
              return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
            }
            function wrapX(pos, dir, side) {
              var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
              var prop2 = dir == "ltr" == (side == "after") ? "left" : "right";
              var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
              return coords(ch, prop2)[prop2];
            }
            var order = getOrder(lineObj, doc2.direction);
            iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i2) {
              var ltr = dir == "ltr";
              var fromPos = coords(from, ltr ? "left" : "right");
              var toPos = coords(to - 1, ltr ? "right" : "left");
              var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
              var first = i2 == 0, last = !order || i2 == order.length - 1;
              if (toPos.top - fromPos.top <= 3) {
                var openLeft = (docLTR ? openStart : openEnd) && first;
                var openRight = (docLTR ? openEnd : openStart) && last;
                var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
                var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
                add(left, fromPos.top, right - left, fromPos.bottom);
              } else {
                var topLeft, topRight, botLeft, botRight;
                if (ltr) {
                  topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
                  topRight = docLTR ? rightSide : wrapX(from, dir, "before");
                  botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
                  botRight = docLTR && openEnd && last ? rightSide : toPos.right;
                } else {
                  topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
                  topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
                  botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
                  botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
                }
                add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
                if (fromPos.bottom < toPos.top) {
                  add(leftSide, fromPos.bottom, null, toPos.top);
                }
                add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
              }
              if (!start || cmpCoords(fromPos, start) < 0) {
                start = fromPos;
              }
              if (cmpCoords(toPos, start) < 0) {
                start = toPos;
              }
              if (!end || cmpCoords(fromPos, end) < 0) {
                end = fromPos;
              }
              if (cmpCoords(toPos, end) < 0) {
                end = toPos;
              }
            });
            return { start, end };
          }
          var sFrom = range2.from(), sTo = range2.to();
          if (sFrom.line == sTo.line) {
            drawForLine(sFrom.line, sFrom.ch, sTo.ch);
          } else {
            var fromLine = getLine(doc2, sFrom.line), toLine = getLine(doc2, sTo.line);
            var singleVLine = visualLine(fromLine) == visualLine(toLine);
            var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
            var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
            if (singleVLine) {
              if (leftEnd.top < rightStart.top - 2) {
                add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
                add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
              } else {
                add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
              }
            }
            if (leftEnd.bottom < rightStart.top) {
              add(leftSide, leftEnd.bottom, null, rightStart.top);
            }
          }
          output.appendChild(fragment);
        }
        function restartBlink(cm) {
          if (!cm.state.focused) {
            return;
          }
          var display = cm.display;
          clearInterval(display.blinker);
          var on2 = true;
          display.cursorDiv.style.visibility = "";
          if (cm.options.cursorBlinkRate > 0) {
            display.blinker = setInterval(function() {
              if (!cm.hasFocus()) {
                onBlur(cm);
              }
              display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";
            }, cm.options.cursorBlinkRate);
          } else if (cm.options.cursorBlinkRate < 0) {
            display.cursorDiv.style.visibility = "hidden";
          }
        }
        function ensureFocus(cm) {
          if (!cm.hasFocus()) {
            cm.display.input.focus();
            if (!cm.state.focused) {
              onFocus(cm);
            }
          }
        }
        function delayBlurEvent(cm) {
          cm.state.delayingBlurEvent = true;
          setTimeout(function() {
            if (cm.state.delayingBlurEvent) {
              cm.state.delayingBlurEvent = false;
              if (cm.state.focused) {
                onBlur(cm);
              }
            }
          }, 100);
        }
        function onFocus(cm, e) {
          if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
            cm.state.delayingBlurEvent = false;
          }
          if (cm.options.readOnly == "nocursor") {
            return;
          }
          if (!cm.state.focused) {
            signal7(cm, "focus", cm, e);
            cm.state.focused = true;
            addClass(cm.display.wrapper, "CodeMirror-focused");
            if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
              cm.display.input.reset();
              if (webkit) {
                setTimeout(function() {
                  return cm.display.input.reset(true);
                }, 20);
              }
            }
            cm.display.input.receivedFocus();
          }
          restartBlink(cm);
        }
        function onBlur(cm, e) {
          if (cm.state.delayingBlurEvent) {
            return;
          }
          if (cm.state.focused) {
            signal7(cm, "blur", cm, e);
            cm.state.focused = false;
            rmClass(cm.display.wrapper, "CodeMirror-focused");
          }
          clearInterval(cm.display.blinker);
          setTimeout(function() {
            if (!cm.state.focused) {
              cm.display.shift = false;
            }
          }, 150);
        }
        function updateHeightsInViewport(cm) {
          var display = cm.display;
          var prevBottom = display.lineDiv.offsetTop;
          var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
          var oldHeight = display.lineDiv.getBoundingClientRect().top;
          var mustScroll = 0;
          for (var i2 = 0; i2 < display.view.length; i2++) {
            var cur = display.view[i2], wrapping = cm.options.lineWrapping;
            var height = void 0, width = 0;
            if (cur.hidden) {
              continue;
            }
            oldHeight += cur.line.height;
            if (ie && ie_version < 8) {
              var bot = cur.node.offsetTop + cur.node.offsetHeight;
              height = bot - prevBottom;
              prevBottom = bot;
            } else {
              var box = cur.node.getBoundingClientRect();
              height = box.bottom - box.top;
              if (!wrapping && cur.text.firstChild) {
                width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
              }
            }
            var diff = cur.line.height - height;
            if (diff > 5e-3 || diff < -5e-3) {
              if (oldHeight < viewTop) {
                mustScroll -= diff;
              }
              updateLineHeight(cur.line, height);
              updateWidgetHeight(cur.line);
              if (cur.rest) {
                for (var j = 0; j < cur.rest.length; j++) {
                  updateWidgetHeight(cur.rest[j]);
                }
              }
            }
            if (width > cm.display.sizerWidth) {
              var chWidth = Math.ceil(width / charWidth(cm.display));
              if (chWidth > cm.display.maxLineLength) {
                cm.display.maxLineLength = chWidth;
                cm.display.maxLine = cur.line;
                cm.display.maxLineChanged = true;
              }
            }
          }
          if (Math.abs(mustScroll) > 2) {
            display.scroller.scrollTop += mustScroll;
          }
        }
        function updateWidgetHeight(line) {
          if (line.widgets) {
            for (var i2 = 0; i2 < line.widgets.length; ++i2) {
              var w = line.widgets[i2], parent = w.node.parentNode;
              if (parent) {
                w.height = parent.offsetHeight;
              }
            }
          }
        }
        function visibleLines(display, doc2, viewport) {
          var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
          top = Math.floor(top - paddingTop(display));
          var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
          var from = lineAtHeight(doc2, top), to = lineAtHeight(doc2, bottom);
          if (viewport && viewport.ensure) {
            var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
            if (ensureFrom < from) {
              from = ensureFrom;
              to = lineAtHeight(doc2, heightAtLine(getLine(doc2, ensureFrom)) + display.wrapper.clientHeight);
            } else if (Math.min(ensureTo, doc2.lastLine()) >= to) {
              from = lineAtHeight(doc2, heightAtLine(getLine(doc2, ensureTo)) - display.wrapper.clientHeight);
              to = ensureTo;
            }
          }
          return { from, to: Math.max(to, from + 1) };
        }
        function maybeScrollWindow(cm, rect) {
          if (signalDOMEvent(cm, "scrollCursorIntoView")) {
            return;
          }
          var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
          var doc2 = display.wrapper.ownerDocument;
          if (rect.top + box.top < 0) {
            doScroll = true;
          } else if (rect.bottom + box.top > (doc2.defaultView.innerHeight || doc2.documentElement.clientHeight)) {
            doScroll = false;
          }
          if (doScroll != null && !phantom) {
            var scrollNode = elt("div", "\u200B", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
            cm.display.lineSpace.appendChild(scrollNode);
            scrollNode.scrollIntoView(doScroll);
            cm.display.lineSpace.removeChild(scrollNode);
          }
        }
        function scrollPosIntoView(cm, pos, end, margin) {
          if (margin == null) {
            margin = 0;
          }
          var rect;
          if (!cm.options.lineWrapping && pos == end) {
            end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
            pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
          }
          for (var limit = 0; limit < 5; limit++) {
            var changed = false;
            var coords = cursorCoords(cm, pos);
            var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
            rect = {
              left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin
            };
            var scrollPos = calculateScrollPos(cm, rect);
            var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
            if (scrollPos.scrollTop != null) {
              updateScrollTop(cm, scrollPos.scrollTop);
              if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
                changed = true;
              }
            }
            if (scrollPos.scrollLeft != null) {
              setScrollLeft(cm, scrollPos.scrollLeft);
              if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
                changed = true;
              }
            }
            if (!changed) {
              break;
            }
          }
          return rect;
        }
        function scrollIntoView(cm, rect) {
          var scrollPos = calculateScrollPos(cm, rect);
          if (scrollPos.scrollTop != null) {
            updateScrollTop(cm, scrollPos.scrollTop);
          }
          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);
          }
        }
        function calculateScrollPos(cm, rect) {
          var display = cm.display, snapMargin = textHeight(cm.display);
          if (rect.top < 0) {
            rect.top = 0;
          }
          var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
          var screen2 = displayHeight(cm), result = {};
          if (rect.bottom - rect.top > screen2) {
            rect.bottom = rect.top + screen2;
          }
          var docBottom = cm.doc.height + paddingVert(display);
          var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
          if (rect.top < screentop) {
            result.scrollTop = atTop ? 0 : rect.top;
          } else if (rect.bottom > screentop + screen2) {
            var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);
            if (newTop != screentop) {
              result.scrollTop = newTop;
            }
          }
          var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
          var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
          var screenw = displayWidth(cm) - display.gutters.offsetWidth;
          var tooWide = rect.right - rect.left > screenw;
          if (tooWide) {
            rect.right = rect.left + screenw;
          }
          if (rect.left < 10) {
            result.scrollLeft = 0;
          } else if (rect.left < screenleft) {
            result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
          } else if (rect.right > screenw + screenleft - 3) {
            result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
          }
          return result;
        }
        function addToScrollTop(cm, top) {
          if (top == null) {
            return;
          }
          resolveScrollToPos(cm);
          cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
        }
        function ensureCursorVisible(cm) {
          resolveScrollToPos(cm);
          var cur = cm.getCursor();
          cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
        }
        function scrollToCoords(cm, x, y) {
          if (x != null || y != null) {
            resolveScrollToPos(cm);
          }
          if (x != null) {
            cm.curOp.scrollLeft = x;
          }
          if (y != null) {
            cm.curOp.scrollTop = y;
          }
        }
        function scrollToRange(cm, range2) {
          resolveScrollToPos(cm);
          cm.curOp.scrollToPos = range2;
        }
        function resolveScrollToPos(cm) {
          var range2 = cm.curOp.scrollToPos;
          if (range2) {
            cm.curOp.scrollToPos = null;
            var from = estimateCoords(cm, range2.from), to = estimateCoords(cm, range2.to);
            scrollToCoordsRange(cm, from, to, range2.margin);
          }
        }
        function scrollToCoordsRange(cm, from, to, margin) {
          var sPos = calculateScrollPos(cm, {
            left: Math.min(from.left, to.left),
            top: Math.min(from.top, to.top) - margin,
            right: Math.max(from.right, to.right),
            bottom: Math.max(from.bottom, to.bottom) + margin
          });
          scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
        }
        function updateScrollTop(cm, val) {
          if (Math.abs(cm.doc.scrollTop - val) < 2) {
            return;
          }
          if (!gecko) {
            updateDisplaySimple(cm, { top: val });
          }
          setScrollTop(cm, val, true);
          if (gecko) {
            updateDisplaySimple(cm);
          }
          startWorker(cm, 100);
        }
        function setScrollTop(cm, val, forceScroll) {
          val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
          if (cm.display.scroller.scrollTop == val && !forceScroll) {
            return;
          }
          cm.doc.scrollTop = val;
          cm.display.scrollbars.setScrollTop(val);
          if (cm.display.scroller.scrollTop != val) {
            cm.display.scroller.scrollTop = val;
          }
        }
        function setScrollLeft(cm, val, isScroller, forceScroll) {
          val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
          if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
            return;
          }
          cm.doc.scrollLeft = val;
          alignHorizontally(cm);
          if (cm.display.scroller.scrollLeft != val) {
            cm.display.scroller.scrollLeft = val;
          }
          cm.display.scrollbars.setScrollLeft(val);
        }
        function measureForScrollbars(cm) {
          var d = cm.display, gutterW = d.gutters.offsetWidth;
          var docH = Math.round(cm.doc.height + paddingVert(cm.display));
          return {
            clientHeight: d.scroller.clientHeight,
            viewHeight: d.wrapper.clientHeight,
            scrollWidth: d.scroller.scrollWidth,
            clientWidth: d.scroller.clientWidth,
            viewWidth: d.wrapper.clientWidth,
            barLeft: cm.options.fixedGutter ? gutterW : 0,
            docHeight: docH,
            scrollHeight: docH + scrollGap(cm) + d.barHeight,
            nativeBarWidth: d.nativeBarWidth,
            gutterWidth: gutterW
          };
        }
        var NativeScrollbars = function(place, scroll, cm) {
          this.cm = cm;
          var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
          var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
          vert.tabIndex = horiz.tabIndex = -1;
          place(vert);
          place(horiz);
          on(vert, "scroll", function() {
            if (vert.clientHeight) {
              scroll(vert.scrollTop, "vertical");
            }
          });
          on(horiz, "scroll", function() {
            if (horiz.clientWidth) {
              scroll(horiz.scrollLeft, "horizontal");
            }
          });
          this.checkedZeroWidth = false;
          if (ie && ie_version < 8) {
            this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
          }
        };
        NativeScrollbars.prototype.update = function(measure) {
          var needsH = measure.scrollWidth > measure.clientWidth + 1;
          var needsV = measure.scrollHeight > measure.clientHeight + 1;
          var sWidth = measure.nativeBarWidth;
          if (needsV) {
            this.vert.style.display = "block";
            this.vert.style.bottom = needsH ? sWidth + "px" : "0";
            var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
            this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
          } else {
            this.vert.scrollTop = 0;
            this.vert.style.display = "";
            this.vert.firstChild.style.height = "0";
          }
          if (needsH) {
            this.horiz.style.display = "block";
            this.horiz.style.right = needsV ? sWidth + "px" : "0";
            this.horiz.style.left = measure.barLeft + "px";
            var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
            this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
          } else {
            this.horiz.style.display = "";
            this.horiz.firstChild.style.width = "0";
          }
          if (!this.checkedZeroWidth && measure.clientHeight > 0) {
            if (sWidth == 0) {
              this.zeroWidthHack();
            }
            this.checkedZeroWidth = true;
          }
          return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
        };
        NativeScrollbars.prototype.setScrollLeft = function(pos) {
          if (this.horiz.scrollLeft != pos) {
            this.horiz.scrollLeft = pos;
          }
          if (this.disableHoriz) {
            this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
          }
        };
        NativeScrollbars.prototype.setScrollTop = function(pos) {
          if (this.vert.scrollTop != pos) {
            this.vert.scrollTop = pos;
          }
          if (this.disableVert) {
            this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
          }
        };
        NativeScrollbars.prototype.zeroWidthHack = function() {
          var w = mac && !mac_geMountainLion ? "12px" : "18px";
          this.horiz.style.height = this.vert.style.width = w;
          this.horiz.style.visibility = this.vert.style.visibility = "hidden";
          this.disableHoriz = new Delayed();
          this.disableVert = new Delayed();
        };
        NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {
          bar.style.visibility = "";
          function maybeDisable() {
            var box = bar.getBoundingClientRect();
            var elt2 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
            if (elt2 != bar) {
              bar.style.visibility = "hidden";
            } else {
              delay.set(1e3, maybeDisable);
            }
          }
          delay.set(1e3, maybeDisable);
        };
        NativeScrollbars.prototype.clear = function() {
          var parent = this.horiz.parentNode;
          parent.removeChild(this.horiz);
          parent.removeChild(this.vert);
        };
        var NullScrollbars = function() {
        };
        NullScrollbars.prototype.update = function() {
          return { bottom: 0, right: 0 };
        };
        NullScrollbars.prototype.setScrollLeft = function() {
        };
        NullScrollbars.prototype.setScrollTop = function() {
        };
        NullScrollbars.prototype.clear = function() {
        };
        function updateScrollbars(cm, measure) {
          if (!measure) {
            measure = measureForScrollbars(cm);
          }
          var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
          updateScrollbarsInner(cm, measure);
          for (var i2 = 0; i2 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i2++) {
            if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
              updateHeightsInViewport(cm);
            }
            updateScrollbarsInner(cm, measureForScrollbars(cm));
            startWidth = cm.display.barWidth;
            startHeight = cm.display.barHeight;
          }
        }
        function updateScrollbarsInner(cm, measure) {
          var d = cm.display;
          var sizes = d.scrollbars.update(measure);
          d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
          d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
          d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
          if (sizes.right && sizes.bottom) {
            d.scrollbarFiller.style.display = "block";
            d.scrollbarFiller.style.height = sizes.bottom + "px";
            d.scrollbarFiller.style.width = sizes.right + "px";
          } else {
            d.scrollbarFiller.style.display = "";
          }
          if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
            d.gutterFiller.style.display = "block";
            d.gutterFiller.style.height = sizes.bottom + "px";
            d.gutterFiller.style.width = measure.gutterWidth + "px";
          } else {
            d.gutterFiller.style.display = "";
          }
        }
        var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };
        function initScrollbars(cm) {
          if (cm.display.scrollbars) {
            cm.display.scrollbars.clear();
            if (cm.display.scrollbars.addClass) {
              rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
            }
          }
          cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
            cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
            on(node, "mousedown", function() {
              if (cm.state.focused) {
                setTimeout(function() {
                  return cm.display.input.focus();
                }, 0);
              }
            });
            node.setAttribute("cm-not-content", "true");
          }, function(pos, axis) {
            if (axis == "horizontal") {
              setScrollLeft(cm, pos);
            } else {
              updateScrollTop(cm, pos);
            }
          }, cm);
          if (cm.display.scrollbars.addClass) {
            addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
          }
        }
        var nextOpId = 0;
        function startOperation(cm) {
          cm.curOp = {
            cm,
            viewChanged: false,
            // Flag that indicates that lines might need to be redrawn
            startHeight: cm.doc.height,
            // Used to detect need to update scrollbar
            forceUpdate: false,
            // Used to force a redraw
            updateInput: 0,
            // Whether to reset the input textarea
            typing: false,
            // Whether this reset should be careful to leave existing text (for compositing)
            changeObjs: null,
            // Accumulated changes, for firing change events
            cursorActivityHandlers: null,
            // Set of handlers to fire cursorActivity on
            cursorActivityCalled: 0,
            // Tracks which cursorActivity handlers have been called already
            selectionChanged: false,
            // Whether the selection needs to be redrawn
            updateMaxLine: false,
            // Set when the widest line needs to be determined anew
            scrollLeft: null,
            scrollTop: null,
            // Intermediate scroll position, not pushed to DOM yet
            scrollToPos: null,
            // Used to scroll to a specific position
            focus: false,
            id: ++nextOpId,
            // Unique ID
            markArrays: null
            // Used by addMarkedSpan
          };
          pushOperation(cm.curOp);
        }
        function endOperation(cm) {
          var op = cm.curOp;
          if (op) {
            finishOperation(op, function(group) {
              for (var i2 = 0; i2 < group.ops.length; i2++) {
                group.ops[i2].cm.curOp = null;
              }
              endOperations(group);
            });
          }
        }
        function endOperations(group) {
          var ops = group.ops;
          for (var i2 = 0; i2 < ops.length; i2++) {
            endOperation_R1(ops[i2]);
          }
          for (var i$12 = 0; i$12 < ops.length; i$12++) {
            endOperation_W1(ops[i$12]);
          }
          for (var i$22 = 0; i$22 < ops.length; i$22++) {
            endOperation_R2(ops[i$22]);
          }
          for (var i$3 = 0; i$3 < ops.length; i$3++) {
            endOperation_W2(ops[i$3]);
          }
          for (var i$4 = 0; i$4 < ops.length; i$4++) {
            endOperation_finish(ops[i$4]);
          }
        }
        function endOperation_R1(op) {
          var cm = op.cm, display = cm.display;
          maybeClipScrollbars(cm);
          if (op.updateMaxLine) {
            findMaxLine(cm);
          }
          op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
          op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
        }
        function endOperation_W1(op) {
          op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
        }
        function endOperation_R2(op) {
          var cm = op.cm, display = cm.display;
          if (op.updatedDisplay) {
            updateHeightsInViewport(cm);
          }
          op.barMeasure = measureForScrollbars(cm);
          if (display.maxLineChanged && !cm.options.lineWrapping) {
            op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
            cm.display.sizerWidth = op.adjustWidthTo;
            op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
            op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
          }
          if (op.updatedDisplay || op.selectionChanged) {
            op.preparedSelection = display.input.prepareSelection();
          }
        }
        function endOperation_W2(op) {
          var cm = op.cm;
          if (op.adjustWidthTo != null) {
            cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
            if (op.maxScrollLeft < cm.doc.scrollLeft) {
              setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
            }
            cm.display.maxLineChanged = false;
          }
          var takeFocus = op.focus && op.focus == activeElt(root(cm));
          if (op.preparedSelection) {
            cm.display.input.showSelection(op.preparedSelection, takeFocus);
          }
          if (op.updatedDisplay || op.startHeight != cm.doc.height) {
            updateScrollbars(cm, op.barMeasure);
          }
          if (op.updatedDisplay) {
            setDocumentHeight(cm, op.barMeasure);
          }
          if (op.selectionChanged) {
            restartBlink(cm);
          }
          if (cm.state.focused && op.updateInput) {
            cm.display.input.reset(op.typing);
          }
          if (takeFocus) {
            ensureFocus(op.cm);
          }
        }
        function endOperation_finish(op) {
          var cm = op.cm, display = cm.display, doc2 = cm.doc;
          if (op.updatedDisplay) {
            postUpdateDisplay(cm, op.update);
          }
          if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
            display.wheelStartX = display.wheelStartY = null;
          }
          if (op.scrollTop != null) {
            setScrollTop(cm, op.scrollTop, op.forceScroll);
          }
          if (op.scrollLeft != null) {
            setScrollLeft(cm, op.scrollLeft, true, true);
          }
          if (op.scrollToPos) {
            var rect = scrollPosIntoView(
              cm,
              clipPos(doc2, op.scrollToPos.from),
              clipPos(doc2, op.scrollToPos.to),
              op.scrollToPos.margin
            );
            maybeScrollWindow(cm, rect);
          }
          var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
          if (hidden) {
            for (var i2 = 0; i2 < hidden.length; ++i2) {
              if (!hidden[i2].lines.length) {
                signal7(hidden[i2], "hide");
              }
            }
          }
          if (unhidden) {
            for (var i$12 = 0; i$12 < unhidden.length; ++i$12) {
              if (unhidden[i$12].lines.length) {
                signal7(unhidden[i$12], "unhide");
              }
            }
          }
          if (display.wrapper.offsetHeight) {
            doc2.scrollTop = cm.display.scroller.scrollTop;
          }
          if (op.changeObjs) {
            signal7(cm, "changes", cm, op.changeObjs);
          }
          if (op.update) {
            op.update.finish();
          }
        }
        function runInOp(cm, f) {
          if (cm.curOp) {
            return f();
          }
          startOperation(cm);
          try {
            return f();
          } finally {
            endOperation(cm);
          }
        }
        function operation(cm, f) {
          return function() {
            if (cm.curOp) {
              return f.apply(cm, arguments);
            }
            startOperation(cm);
            try {
              return f.apply(cm, arguments);
            } finally {
              endOperation(cm);
            }
          };
        }
        function methodOp(f) {
          return function() {
            if (this.curOp) {
              return f.apply(this, arguments);
            }
            startOperation(this);
            try {
              return f.apply(this, arguments);
            } finally {
              endOperation(this);
            }
          };
        }
        function docMethodOp(f) {
          return function() {
            var cm = this.cm;
            if (!cm || cm.curOp) {
              return f.apply(this, arguments);
            }
            startOperation(cm);
            try {
              return f.apply(this, arguments);
            } finally {
              endOperation(cm);
            }
          };
        }
        function startWorker(cm, time) {
          if (cm.doc.highlightFrontier < cm.display.viewTo) {
            cm.state.highlight.set(time, bind(highlightWorker, cm));
          }
        }
        function highlightWorker(cm) {
          var doc2 = cm.doc;
          if (doc2.highlightFrontier >= cm.display.viewTo) {
            return;
          }
          var end = +/* @__PURE__ */ new Date() + cm.options.workTime;
          var context = getContextBefore(cm, doc2.highlightFrontier);
          var changedLines = [];
          doc2.iter(context.line, Math.min(doc2.first + doc2.size, cm.display.viewTo + 500), function(line) {
            if (context.line >= cm.display.viewFrom) {
              var oldStyles = line.styles;
              var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc2.mode, context.state) : null;
              var highlighted = highlightLine(cm, line, context, true);
              if (resetState) {
                context.state = resetState;
              }
              line.styles = highlighted.styles;
              var oldCls = line.styleClasses, newCls = highlighted.classes;
              if (newCls) {
                line.styleClasses = newCls;
              } else if (oldCls) {
                line.styleClasses = null;
              }
              var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
              for (var i2 = 0; !ischange && i2 < oldStyles.length; ++i2) {
                ischange = oldStyles[i2] != line.styles[i2];
              }
              if (ischange) {
                changedLines.push(context.line);
              }
              line.stateAfter = context.save();
              context.nextLine();
            } else {
              if (line.text.length <= cm.options.maxHighlightLength) {
                processLine(cm, line.text, context);
              }
              line.stateAfter = context.line % 5 == 0 ? context.save() : null;
              context.nextLine();
            }
            if (+/* @__PURE__ */ new Date() > end) {
              startWorker(cm, cm.options.workDelay);
              return true;
            }
          });
          doc2.highlightFrontier = context.line;
          doc2.modeFrontier = Math.max(doc2.modeFrontier, context.line);
          if (changedLines.length) {
            runInOp(cm, function() {
              for (var i2 = 0; i2 < changedLines.length; i2++) {
                regLineChange(cm, changedLines[i2], "text");
              }
            });
          }
        }
        var DisplayUpdate = function(cm, viewport, force) {
          var display = cm.display;
          this.viewport = viewport;
          this.visible = visibleLines(display, cm.doc, viewport);
          this.editorIsHidden = !display.wrapper.offsetWidth;
          this.wrapperHeight = display.wrapper.clientHeight;
          this.wrapperWidth = display.wrapper.clientWidth;
          this.oldDisplayWidth = displayWidth(cm);
          this.force = force;
          this.dims = getDimensions(cm);
          this.events = [];
        };
        DisplayUpdate.prototype.signal = function(emitter2, type) {
          if (hasHandler(emitter2, type)) {
            this.events.push(arguments);
          }
        };
        DisplayUpdate.prototype.finish = function() {
          for (var i2 = 0; i2 < this.events.length; i2++) {
            signal7.apply(null, this.events[i2]);
          }
        };
        function maybeClipScrollbars(cm) {
          var display = cm.display;
          if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
            display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
            display.heightForcer.style.height = scrollGap(cm) + "px";
            display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
            display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
            display.scrollbarsClipped = true;
          }
        }
        function selectionSnapshot(cm) {
          if (cm.hasFocus()) {
            return null;
          }
          var active = activeElt(root(cm));
          if (!active || !contains(cm.display.lineDiv, active)) {
            return null;
          }
          var result = { activeElt: active };
          if (window.getSelection) {
            var sel = win(cm).getSelection();
            if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
              result.anchorNode = sel.anchorNode;
              result.anchorOffset = sel.anchorOffset;
              result.focusNode = sel.focusNode;
              result.focusOffset = sel.focusOffset;
            }
          }
          return result;
        }
        function restoreSelection(snapshot) {
          if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt(rootNode(snapshot.activeElt))) {
            return;
          }
          snapshot.activeElt.focus();
          if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
            var doc2 = snapshot.activeElt.ownerDocument;
            var sel = doc2.defaultView.getSelection(), range2 = doc2.createRange();
            range2.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
            range2.collapse(false);
            sel.removeAllRanges();
            sel.addRange(range2);
            sel.extend(snapshot.focusNode, snapshot.focusOffset);
          }
        }
        function updateDisplayIfNeeded(cm, update) {
          var display = cm.display, doc2 = cm.doc;
          if (update.editorIsHidden) {
            resetView(cm);
            return false;
          }
          if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
            return false;
          }
          if (maybeUpdateLineNumberWidth(cm)) {
            resetView(cm);
            update.dims = getDimensions(cm);
          }
          var end = doc2.first + doc2.size;
          var from = Math.max(update.visible.from - cm.options.viewportMargin, doc2.first);
          var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
          if (display.viewFrom < from && from - display.viewFrom < 20) {
            from = Math.max(doc2.first, display.viewFrom);
          }
          if (display.viewTo > to && display.viewTo - to < 20) {
            to = Math.min(end, display.viewTo);
          }
          if (sawCollapsedSpans) {
            from = visualLineNo(cm.doc, from);
            to = visualLineEndNo(cm.doc, to);
          }
          var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
          adjustView(cm, from, to);
          display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
          cm.display.mover.style.top = display.viewOffset + "px";
          var toUpdate = countDirtyView(cm);
          if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
            return false;
          }
          var selSnapshot = selectionSnapshot(cm);
          if (toUpdate > 4) {
            display.lineDiv.style.display = "none";
          }
          patchDisplay(cm, display.updateLineNumbers, update.dims);
          if (toUpdate > 4) {
            display.lineDiv.style.display = "";
          }
          display.renderedView = display.view;
          restoreSelection(selSnapshot);
          removeChildren(display.cursorDiv);
          removeChildren(display.selectionDiv);
          display.gutters.style.height = display.sizer.style.minHeight = 0;
          if (different) {
            display.lastWrapHeight = update.wrapperHeight;
            display.lastWrapWidth = update.wrapperWidth;
            startWorker(cm, 400);
          }
          display.updateLineNumbers = null;
          return true;
        }
        function postUpdateDisplay(cm, update) {
          var viewport = update.viewport;
          for (var first = true; ; first = false) {
            if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
              if (viewport && viewport.top != null) {
                viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };
              }
              update.visible = visibleLines(cm.display, cm.doc, viewport);
              if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
                break;
              }
            } else if (first) {
              update.visible = visibleLines(cm.display, cm.doc, viewport);
            }
            if (!updateDisplayIfNeeded(cm, update)) {
              break;
            }
            updateHeightsInViewport(cm);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            updateScrollbars(cm, barMeasure);
            setDocumentHeight(cm, barMeasure);
            update.force = false;
          }
          update.signal(cm, "update", cm);
          if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
            update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
            cm.display.reportedViewFrom = cm.display.viewFrom;
            cm.display.reportedViewTo = cm.display.viewTo;
          }
        }
        function updateDisplaySimple(cm, viewport) {
          var update = new DisplayUpdate(cm, viewport);
          if (updateDisplayIfNeeded(cm, update)) {
            updateHeightsInViewport(cm);
            postUpdateDisplay(cm, update);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            updateScrollbars(cm, barMeasure);
            setDocumentHeight(cm, barMeasure);
            update.finish();
          }
        }
        function patchDisplay(cm, updateNumbersFrom, dims) {
          var display = cm.display, lineNumbers = cm.options.lineNumbers;
          var container = display.lineDiv, cur = container.firstChild;
          function rm(node2) {
            var next = node2.nextSibling;
            if (webkit && mac && cm.display.currentWheelTarget == node2) {
              node2.style.display = "none";
            } else {
              node2.parentNode.removeChild(node2);
            }
            return next;
          }
          var view = display.view, lineN = display.viewFrom;
          for (var i2 = 0; i2 < view.length; i2++) {
            var lineView = view[i2];
            if (lineView.hidden) ;
            else if (!lineView.node || lineView.node.parentNode != container) {
              var node = buildLineElement(cm, lineView, lineN, dims);
              container.insertBefore(node, cur);
            } else {
              while (cur != lineView.node) {
                cur = rm(cur);
              }
              var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
              if (lineView.changes) {
                if (indexOf(lineView.changes, "gutter") > -1) {
                  updateNumber = false;
                }
                updateLineForChanges(cm, lineView, lineN, dims);
              }
              if (updateNumber) {
                removeChildren(lineView.lineNumber);
                lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
              }
              cur = lineView.node.nextSibling;
            }
            lineN += lineView.size;
          }
          while (cur) {
            cur = rm(cur);
          }
        }
        function updateGutterSpace(display) {
          var width = display.gutters.offsetWidth;
          display.sizer.style.marginLeft = width + "px";
          signalLater(display, "gutterChanged", display);
        }
        function setDocumentHeight(cm, measure) {
          cm.display.sizer.style.minHeight = measure.docHeight + "px";
          cm.display.heightForcer.style.top = measure.docHeight + "px";
          cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
        }
        function alignHorizontally(cm) {
          var display = cm.display, view = display.view;
          if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
            return;
          }
          var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
          var gutterW = display.gutters.offsetWidth, left = comp + "px";
          for (var i2 = 0; i2 < view.length; i2++) {
            if (!view[i2].hidden) {
              if (cm.options.fixedGutter) {
                if (view[i2].gutter) {
                  view[i2].gutter.style.left = left;
                }
                if (view[i2].gutterBackground) {
                  view[i2].gutterBackground.style.left = left;
                }
              }
              var align = view[i2].alignable;
              if (align) {
                for (var j = 0; j < align.length; j++) {
                  align[j].style.left = left;
                }
              }
            }
          }
          if (cm.options.fixedGutter) {
            display.gutters.style.left = comp + gutterW + "px";
          }
        }
        function maybeUpdateLineNumberWidth(cm) {
          if (!cm.options.lineNumbers) {
            return false;
          }
          var doc2 = cm.doc, last = lineNumberFor(cm.options, doc2.first + doc2.size - 1), display = cm.display;
          if (last.length != display.lineNumChars) {
            var test = display.measure.appendChild(elt(
              "div",
              [elt("div", last)],
              "CodeMirror-linenumber CodeMirror-gutter-elt"
            ));
            var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
            display.lineGutter.style.width = "";
            display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
            display.lineNumWidth = display.lineNumInnerWidth + padding;
            display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
            display.lineGutter.style.width = display.lineNumWidth + "px";
            updateGutterSpace(cm.display);
            return true;
          }
          return false;
        }
        function getGutters(gutters, lineNumbers) {
          var result = [], sawLineNumbers = false;
          for (var i2 = 0; i2 < gutters.length; i2++) {
            var name2 = gutters[i2], style = null;
            if (typeof name2 != "string") {
              style = name2.style;
              name2 = name2.className;
            }
            if (name2 == "CodeMirror-linenumbers") {
              if (!lineNumbers) {
                continue;
              } else {
                sawLineNumbers = true;
              }
            }
            result.push({ className: name2, style });
          }
          if (lineNumbers && !sawLineNumbers) {
            result.push({ className: "CodeMirror-linenumbers", style: null });
          }
          return result;
        }
        function renderGutters(display) {
          var gutters = display.gutters, specs = display.gutterSpecs;
          removeChildren(gutters);
          display.lineGutter = null;
          for (var i2 = 0; i2 < specs.length; ++i2) {
            var ref = specs[i2];
            var className = ref.className;
            var style = ref.style;
            var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
            if (style) {
              gElt.style.cssText = style;
            }
            if (className == "CodeMirror-linenumbers") {
              display.lineGutter = gElt;
              gElt.style.width = (display.lineNumWidth || 1) + "px";
            }
          }
          gutters.style.display = specs.length ? "" : "none";
          updateGutterSpace(display);
        }
        function updateGutters(cm) {
          renderGutters(cm.display);
          regChange(cm);
          alignHorizontally(cm);
        }
        function Display(place, doc2, input, options2) {
          var d = this;
          this.input = input;
          d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
          d.scrollbarFiller.setAttribute("cm-not-content", "true");
          d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
          d.gutterFiller.setAttribute("cm-not-content", "true");
          d.lineDiv = eltP("div", null, "CodeMirror-code");
          d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
          d.cursorDiv = elt("div", null, "CodeMirror-cursors");
          d.measure = elt("div", null, "CodeMirror-measure");
          d.lineMeasure = elt("div", null, "CodeMirror-measure");
          d.lineSpace = eltP(
            "div",
            [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
            null,
            "position: relative; outline: none"
          );
          var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
          d.mover = elt("div", [lines], null, "position: relative");
          d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
          d.sizerWidth = null;
          d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
          d.gutters = elt("div", null, "CodeMirror-gutters");
          d.lineGutter = null;
          d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
          d.scroller.setAttribute("tabIndex", "-1");
          d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
          if (chrome && chrome_version >= 105) {
            d.wrapper.style.clipPath = "inset(0px)";
          }
          d.wrapper.setAttribute("translate", "no");
          if (ie && ie_version < 8) {
            d.gutters.style.zIndex = -1;
            d.scroller.style.paddingRight = 0;
          }
          if (!webkit && !(gecko && mobile)) {
            d.scroller.draggable = true;
          }
          if (place) {
            if (place.appendChild) {
              place.appendChild(d.wrapper);
            } else {
              place(d.wrapper);
            }
          }
          d.viewFrom = d.viewTo = doc2.first;
          d.reportedViewFrom = d.reportedViewTo = doc2.first;
          d.view = [];
          d.renderedView = null;
          d.externalMeasured = null;
          d.viewOffset = 0;
          d.lastWrapHeight = d.lastWrapWidth = 0;
          d.updateLineNumbers = null;
          d.nativeBarWidth = d.barHeight = d.barWidth = 0;
          d.scrollbarsClipped = false;
          d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
          d.alignWidgets = false;
          d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
          d.maxLine = null;
          d.maxLineLength = 0;
          d.maxLineChanged = false;
          d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
          d.shift = false;
          d.selForContextMenu = null;
          d.activeTouch = null;
          d.gutterSpecs = getGutters(options2.gutters, options2.lineNumbers);
          renderGutters(d);
          input.init(d);
        }
        var wheelSamples = 0, wheelPixelsPerUnit = null;
        if (ie) {
          wheelPixelsPerUnit = -0.53;
        } else if (gecko) {
          wheelPixelsPerUnit = 15;
        } else if (chrome) {
          wheelPixelsPerUnit = -0.7;
        } else if (safari) {
          wheelPixelsPerUnit = -1 / 3;
        }
        function wheelEventDelta(e) {
          var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
          if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
            dx = e.detail;
          }
          if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
            dy = e.detail;
          } else if (dy == null) {
            dy = e.wheelDelta;
          }
          return { x: dx, y: dy };
        }
        function wheelEventPixels(e) {
          var delta = wheelEventDelta(e);
          delta.x *= wheelPixelsPerUnit;
          delta.y *= wheelPixelsPerUnit;
          return delta;
        }
        function onScrollWheel(cm, e) {
          if (chrome && chrome_version == 102) {
            if (cm.display.chromeScrollHack == null) {
              cm.display.sizer.style.pointerEvents = "none";
            } else {
              clearTimeout(cm.display.chromeScrollHack);
            }
            cm.display.chromeScrollHack = setTimeout(function() {
              cm.display.chromeScrollHack = null;
              cm.display.sizer.style.pointerEvents = "";
            }, 100);
          }
          var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
          var pixelsPerUnit = wheelPixelsPerUnit;
          if (e.deltaMode === 0) {
            dx = e.deltaX;
            dy = e.deltaY;
            pixelsPerUnit = 1;
          }
          var display = cm.display, scroll = display.scroller;
          var canScrollX = scroll.scrollWidth > scroll.clientWidth;
          var canScrollY = scroll.scrollHeight > scroll.clientHeight;
          if (!(dx && canScrollX || dy && canScrollY)) {
            return;
          }
          if (dy && mac && webkit) {
            outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
              for (var i2 = 0; i2 < view.length; i2++) {
                if (view[i2].node == cur) {
                  cm.display.currentWheelTarget = cur;
                  break outer;
                }
              }
            }
          }
          if (dx && !gecko && !presto && pixelsPerUnit != null) {
            if (dy && canScrollY) {
              updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
            }
            setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
            if (!dy || dy && canScrollY) {
              e_preventDefault(e);
            }
            display.wheelStartX = null;
            return;
          }
          if (dy && pixelsPerUnit != null) {
            var pixels = dy * pixelsPerUnit;
            var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
            if (pixels < 0) {
              top = Math.max(0, top + pixels - 50);
            } else {
              bot = Math.min(cm.doc.height, bot + pixels + 50);
            }
            updateDisplaySimple(cm, { top, bottom: bot });
          }
          if (wheelSamples < 20 && e.deltaMode !== 0) {
            if (display.wheelStartX == null) {
              display.wheelStartX = scroll.scrollLeft;
              display.wheelStartY = scroll.scrollTop;
              display.wheelDX = dx;
              display.wheelDY = dy;
              setTimeout(function() {
                if (display.wheelStartX == null) {
                  return;
                }
                var movedX = scroll.scrollLeft - display.wheelStartX;
                var movedY = scroll.scrollTop - display.wheelStartY;
                var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                display.wheelStartX = display.wheelStartY = null;
                if (!sample) {
                  return;
                }
                wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
                ++wheelSamples;
              }, 200);
            } else {
              display.wheelDX += dx;
              display.wheelDY += dy;
            }
          }
        }
        var Selection = function(ranges, primIndex) {
          this.ranges = ranges;
          this.primIndex = primIndex;
        };
        Selection.prototype.primary = function() {
          return this.ranges[this.primIndex];
        };
        Selection.prototype.equals = function(other) {
          if (other == this) {
            return true;
          }
          if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
            return false;
          }
          for (var i2 = 0; i2 < this.ranges.length; i2++) {
            var here = this.ranges[i2], there = other.ranges[i2];
            if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
              return false;
            }
          }
          return true;
        };
        Selection.prototype.deepCopy = function() {
          var out = [];
          for (var i2 = 0; i2 < this.ranges.length; i2++) {
            out[i2] = new Range(copyPos(this.ranges[i2].anchor), copyPos(this.ranges[i2].head));
          }
          return new Selection(out, this.primIndex);
        };
        Selection.prototype.somethingSelected = function() {
          for (var i2 = 0; i2 < this.ranges.length; i2++) {
            if (!this.ranges[i2].empty()) {
              return true;
            }
          }
          return false;
        };
        Selection.prototype.contains = function(pos, end) {
          if (!end) {
            end = pos;
          }
          for (var i2 = 0; i2 < this.ranges.length; i2++) {
            var range2 = this.ranges[i2];
            if (cmp(end, range2.from()) >= 0 && cmp(pos, range2.to()) <= 0) {
              return i2;
            }
          }
          return -1;
        };
        var Range = function(anchor, head) {
          this.anchor = anchor;
          this.head = head;
        };
        Range.prototype.from = function() {
          return minPos(this.anchor, this.head);
        };
        Range.prototype.to = function() {
          return maxPos(this.anchor, this.head);
        };
        Range.prototype.empty = function() {
          return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
        };
        function normalizeSelection(cm, ranges, primIndex) {
          var mayTouch = cm && cm.options.selectionsMayTouch;
          var prim = ranges[primIndex];
          ranges.sort(function(a, b) {
            return cmp(a.from(), b.from());
          });
          primIndex = indexOf(ranges, prim);
          for (var i2 = 1; i2 < ranges.length; i2++) {
            var cur = ranges[i2], prev = ranges[i2 - 1];
            var diff = cmp(prev.to(), cur.from());
            if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
              var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
              var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
              if (i2 <= primIndex) {
                --primIndex;
              }
              ranges.splice(--i2, 2, new Range(inv ? to : from, inv ? from : to));
            }
          }
          return new Selection(ranges, primIndex);
        }
        function simpleSelection(anchor, head) {
          return new Selection([new Range(anchor, head || anchor)], 0);
        }
        function changeEnd(change) {
          if (!change.text) {
            return change.to;
          }
          return Pos(
            change.from.line + change.text.length - 1,
            lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0)
          );
        }
        function adjustForChange(pos, change) {
          if (cmp(pos, change.from) < 0) {
            return pos;
          }
          if (cmp(pos, change.to) <= 0) {
            return changeEnd(change);
          }
          var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
          if (pos.line == change.to.line) {
            ch += changeEnd(change).ch - change.to.ch;
          }
          return Pos(line, ch);
        }
        function computeSelAfterChange(doc2, change) {
          var out = [];
          for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
            var range2 = doc2.sel.ranges[i2];
            out.push(new Range(
              adjustForChange(range2.anchor, change),
              adjustForChange(range2.head, change)
            ));
          }
          return normalizeSelection(doc2.cm, out, doc2.sel.primIndex);
        }
        function offsetPos(pos, old, nw) {
          if (pos.line == old.line) {
            return Pos(nw.line, pos.ch - old.ch + nw.ch);
          } else {
            return Pos(nw.line + (pos.line - old.line), pos.ch);
          }
        }
        function computeReplacedSel(doc2, changes, hint) {
          var out = [];
          var oldPrev = Pos(doc2.first, 0), newPrev = oldPrev;
          for (var i2 = 0; i2 < changes.length; i2++) {
            var change = changes[i2];
            var from = offsetPos(change.from, oldPrev, newPrev);
            var to = offsetPos(changeEnd(change), oldPrev, newPrev);
            oldPrev = change.to;
            newPrev = to;
            if (hint == "around") {
              var range2 = doc2.sel.ranges[i2], inv = cmp(range2.head, range2.anchor) < 0;
              out[i2] = new Range(inv ? to : from, inv ? from : to);
            } else {
              out[i2] = new Range(from, from);
            }
          }
          return new Selection(out, doc2.sel.primIndex);
        }
        function loadMode(cm) {
          cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
          resetModeState(cm);
        }
        function resetModeState(cm) {
          cm.doc.iter(function(line) {
            if (line.stateAfter) {
              line.stateAfter = null;
            }
            if (line.styles) {
              line.styles = null;
            }
          });
          cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
          startWorker(cm, 100);
          cm.state.modeGen++;
          if (cm.curOp) {
            regChange(cm);
          }
        }
        function isWholeLineUpdate(doc2, change) {
          return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc2.cm || doc2.cm.options.wholeLineUpdateBefore);
        }
        function updateDoc(doc2, change, markedSpans, estimateHeight2) {
          function spansFor(n) {
            return markedSpans ? markedSpans[n] : null;
          }
          function update(line, text2, spans) {
            updateLine(line, text2, spans, estimateHeight2);
            signalLater(line, "change", line, change);
          }
          function linesFor(start, end) {
            var result = [];
            for (var i2 = start; i2 < end; ++i2) {
              result.push(new Line(text[i2], spansFor(i2), estimateHeight2));
            }
            return result;
          }
          var from = change.from, to = change.to, text = change.text;
          var firstLine = getLine(doc2, from.line), lastLine = getLine(doc2, to.line);
          var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
          if (change.full) {
            doc2.insert(0, linesFor(0, text.length));
            doc2.remove(text.length, doc2.size - text.length);
          } else if (isWholeLineUpdate(doc2, change)) {
            var added = linesFor(0, text.length - 1);
            update(lastLine, lastLine.text, lastSpans);
            if (nlines) {
              doc2.remove(from.line, nlines);
            }
            if (added.length) {
              doc2.insert(from.line, added);
            }
          } else if (firstLine == lastLine) {
            if (text.length == 1) {
              update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
            } else {
              var added$1 = linesFor(1, text.length - 1);
              added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));
              update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
              doc2.insert(from.line + 1, added$1);
            }
          } else if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
            doc2.remove(from.line + 1, nlines);
          } else {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
            var added$2 = linesFor(1, text.length - 1);
            if (nlines > 1) {
              doc2.remove(from.line + 1, nlines - 1);
            }
            doc2.insert(from.line + 1, added$2);
          }
          signalLater(doc2, "change", doc2, change);
        }
        function linkedDocs(doc2, f, sharedHistOnly) {
          function propagate(doc3, skip, sharedHist) {
            if (doc3.linked) {
              for (var i2 = 0; i2 < doc3.linked.length; ++i2) {
                var rel = doc3.linked[i2];
                if (rel.doc == skip) {
                  continue;
                }
                var shared = sharedHist && rel.sharedHist;
                if (sharedHistOnly && !shared) {
                  continue;
                }
                f(rel.doc, shared);
                propagate(rel.doc, doc3, shared);
              }
            }
          }
          propagate(doc2, null, true);
        }
        function attachDoc(cm, doc2) {
          if (doc2.cm) {
            throw new Error("This document is already in use.");
          }
          cm.doc = doc2;
          doc2.cm = cm;
          estimateLineHeights(cm);
          loadMode(cm);
          setDirectionClass(cm);
          cm.options.direction = doc2.direction;
          if (!cm.options.lineWrapping) {
            findMaxLine(cm);
          }
          cm.options.mode = doc2.modeOption;
          regChange(cm);
        }
        function setDirectionClass(cm) {
          (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
        }
        function directionChanged(cm) {
          runInOp(cm, function() {
            setDirectionClass(cm);
            regChange(cm);
          });
        }
        function History(prev) {
          this.done = [];
          this.undone = [];
          this.undoDepth = prev ? prev.undoDepth : Infinity;
          this.lastModTime = this.lastSelTime = 0;
          this.lastOp = this.lastSelOp = null;
          this.lastOrigin = this.lastSelOrigin = null;
          this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
        }
        function historyChangeFromChange(doc2, change) {
          var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc2, change.from, change.to) };
          attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);
          linkedDocs(doc2, function(doc3) {
            return attachLocalSpans(doc3, histChange, change.from.line, change.to.line + 1);
          }, true);
          return histChange;
        }
        function clearSelectionEvents(array) {
          while (array.length) {
            var last = lst(array);
            if (last.ranges) {
              array.pop();
            } else {
              break;
            }
          }
        }
        function lastChangeEvent(hist, force) {
          if (force) {
            clearSelectionEvents(hist.done);
            return lst(hist.done);
          } else if (hist.done.length && !lst(hist.done).ranges) {
            return lst(hist.done);
          } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
            hist.done.pop();
            return lst(hist.done);
          }
        }
        function addChangeToHistory(doc2, change, selAfter, opId) {
          var hist = doc2.history;
          hist.undone.length = 0;
          var time = +/* @__PURE__ */ new Date(), cur;
          var last;
          if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc2.cm ? doc2.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
            last = lst(cur.changes);
            if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
              last.to = changeEnd(change);
            } else {
              cur.changes.push(historyChangeFromChange(doc2, change));
            }
          } else {
            var before = lst(hist.done);
            if (!before || !before.ranges) {
              pushSelectionToHistory(doc2.sel, hist.done);
            }
            cur = {
              changes: [historyChangeFromChange(doc2, change)],
              generation: hist.generation
            };
            hist.done.push(cur);
            while (hist.done.length > hist.undoDepth) {
              hist.done.shift();
              if (!hist.done[0].ranges) {
                hist.done.shift();
              }
            }
          }
          hist.done.push(selAfter);
          hist.generation = ++hist.maxGeneration;
          hist.lastModTime = hist.lastSelTime = time;
          hist.lastOp = hist.lastSelOp = opId;
          hist.lastOrigin = hist.lastSelOrigin = change.origin;
          if (!last) {
            signal7(doc2, "historyAdded");
          }
        }
        function selectionEventCanBeMerged(doc2, origin, prev, sel) {
          var ch = origin.charAt(0);
          return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && /* @__PURE__ */ new Date() - doc2.history.lastSelTime <= (doc2.cm ? doc2.cm.options.historyEventDelay : 500);
        }
        function addSelectionToHistory(doc2, sel, opId, options2) {
          var hist = doc2.history, origin = options2 && options2.origin;
          if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc2, origin, lst(hist.done), sel))) {
            hist.done[hist.done.length - 1] = sel;
          } else {
            pushSelectionToHistory(sel, hist.done);
          }
          hist.lastSelTime = +/* @__PURE__ */ new Date();
          hist.lastSelOrigin = origin;
          hist.lastSelOp = opId;
          if (options2 && options2.clearRedo !== false) {
            clearSelectionEvents(hist.undone);
          }
        }
        function pushSelectionToHistory(sel, dest) {
          var top = lst(dest);
          if (!(top && top.ranges && top.equals(sel))) {
            dest.push(sel);
          }
        }
        function attachLocalSpans(doc2, change, from, to) {
          var existing = change["spans_" + doc2.id], n = 0;
          doc2.iter(Math.max(doc2.first, from), Math.min(doc2.first + doc2.size, to), function(line) {
            if (line.markedSpans) {
              (existing || (existing = change["spans_" + doc2.id] = {}))[n] = line.markedSpans;
            }
            ++n;
          });
        }
        function removeClearedSpans(spans) {
          if (!spans) {
            return null;
          }
          var out;
          for (var i2 = 0; i2 < spans.length; ++i2) {
            if (spans[i2].marker.explicitlyCleared) {
              if (!out) {
                out = spans.slice(0, i2);
              }
            } else if (out) {
              out.push(spans[i2]);
            }
          }
          return !out ? spans : out.length ? out : null;
        }
        function getOldSpans(doc2, change) {
          var found = change["spans_" + doc2.id];
          if (!found) {
            return null;
          }
          var nw = [];
          for (var i2 = 0; i2 < change.text.length; ++i2) {
            nw.push(removeClearedSpans(found[i2]));
          }
          return nw;
        }
        function mergeOldSpans(doc2, change) {
          var old = getOldSpans(doc2, change);
          var stretched = stretchSpansOverChange(doc2, change);
          if (!old) {
            return stretched;
          }
          if (!stretched) {
            return old;
          }
          for (var i2 = 0; i2 < old.length; ++i2) {
            var oldCur = old[i2], stretchCur = stretched[i2];
            if (oldCur && stretchCur) {
              spans: for (var j = 0; j < stretchCur.length; ++j) {
                var span = stretchCur[j];
                for (var k = 0; k < oldCur.length; ++k) {
                  if (oldCur[k].marker == span.marker) {
                    continue spans;
                  }
                }
                oldCur.push(span);
              }
            } else if (stretchCur) {
              old[i2] = stretchCur;
            }
          }
          return old;
        }
        function copyHistoryArray(events, newGroup, instantiateSel) {
          var copy = [];
          for (var i2 = 0; i2 < events.length; ++i2) {
            var event = events[i2];
            if (event.ranges) {
              copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
              continue;
            }
            var changes = event.changes, newChanges = [];
            copy.push({ changes: newChanges });
            for (var j = 0; j < changes.length; ++j) {
              var change = changes[j], m = void 0;
              newChanges.push({ from: change.from, to: change.to, text: change.text });
              if (newGroup) {
                for (var prop2 in change) {
                  if (m = prop2.match(/^spans_(\d+)$/)) {
                    if (indexOf(newGroup, Number(m[1])) > -1) {
                      lst(newChanges)[prop2] = change[prop2];
                      delete change[prop2];
                    }
                  }
                }
              }
            }
          }
          return copy;
        }
        function extendRange(range2, head, other, extend) {
          if (extend) {
            var anchor = range2.anchor;
            if (other) {
              var posBefore = cmp(head, anchor) < 0;
              if (posBefore != cmp(other, anchor) < 0) {
                anchor = head;
                head = other;
              } else if (posBefore != cmp(head, other) < 0) {
                head = other;
              }
            }
            return new Range(anchor, head);
          } else {
            return new Range(other || head, head);
          }
        }
        function extendSelection(doc2, head, other, options2, extend) {
          if (extend == null) {
            extend = doc2.cm && (doc2.cm.display.shift || doc2.extend);
          }
          setSelection(doc2, new Selection([extendRange(doc2.sel.primary(), head, other, extend)], 0), options2);
        }
        function extendSelections(doc2, heads, options2) {
          var out = [];
          var extend = doc2.cm && (doc2.cm.display.shift || doc2.extend);
          for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
            out[i2] = extendRange(doc2.sel.ranges[i2], heads[i2], null, extend);
          }
          var newSel = normalizeSelection(doc2.cm, out, doc2.sel.primIndex);
          setSelection(doc2, newSel, options2);
        }
        function replaceOneSelection(doc2, i2, range2, options2) {
          var ranges = doc2.sel.ranges.slice(0);
          ranges[i2] = range2;
          setSelection(doc2, normalizeSelection(doc2.cm, ranges, doc2.sel.primIndex), options2);
        }
        function setSimpleSelection(doc2, anchor, head, options2) {
          setSelection(doc2, simpleSelection(anchor, head), options2);
        }
        function filterSelectionChange(doc2, sel, options2) {
          var obj = {
            ranges: sel.ranges,
            update: function(ranges) {
              this.ranges = [];
              for (var i2 = 0; i2 < ranges.length; i2++) {
                this.ranges[i2] = new Range(
                  clipPos(doc2, ranges[i2].anchor),
                  clipPos(doc2, ranges[i2].head)
                );
              }
            },
            origin: options2 && options2.origin
          };
          signal7(doc2, "beforeSelectionChange", doc2, obj);
          if (doc2.cm) {
            signal7(doc2.cm, "beforeSelectionChange", doc2.cm, obj);
          }
          if (obj.ranges != sel.ranges) {
            return normalizeSelection(doc2.cm, obj.ranges, obj.ranges.length - 1);
          } else {
            return sel;
          }
        }
        function setSelectionReplaceHistory(doc2, sel, options2) {
          var done = doc2.history.done, last = lst(done);
          if (last && last.ranges) {
            done[done.length - 1] = sel;
            setSelectionNoUndo(doc2, sel, options2);
          } else {
            setSelection(doc2, sel, options2);
          }
        }
        function setSelection(doc2, sel, options2) {
          setSelectionNoUndo(doc2, sel, options2);
          addSelectionToHistory(doc2, doc2.sel, doc2.cm ? doc2.cm.curOp.id : NaN, options2);
        }
        function setSelectionNoUndo(doc2, sel, options2) {
          if (hasHandler(doc2, "beforeSelectionChange") || doc2.cm && hasHandler(doc2.cm, "beforeSelectionChange")) {
            sel = filterSelectionChange(doc2, sel, options2);
          }
          var bias = options2 && options2.bias || (cmp(sel.primary().head, doc2.sel.primary().head) < 0 ? -1 : 1);
          setSelectionInner(doc2, skipAtomicInSelection(doc2, sel, bias, true));
          if (!(options2 && options2.scroll === false) && doc2.cm && doc2.cm.getOption("readOnly") != "nocursor") {
            ensureCursorVisible(doc2.cm);
          }
        }
        function setSelectionInner(doc2, sel) {
          if (sel.equals(doc2.sel)) {
            return;
          }
          doc2.sel = sel;
          if (doc2.cm) {
            doc2.cm.curOp.updateInput = 1;
            doc2.cm.curOp.selectionChanged = true;
            signalCursorActivity(doc2.cm);
          }
          signalLater(doc2, "cursorActivity", doc2);
        }
        function reCheckSelection(doc2) {
          setSelectionInner(doc2, skipAtomicInSelection(doc2, doc2.sel, null, false));
        }
        function skipAtomicInSelection(doc2, sel, bias, mayClear) {
          var out;
          for (var i2 = 0; i2 < sel.ranges.length; i2++) {
            var range2 = sel.ranges[i2];
            var old = sel.ranges.length == doc2.sel.ranges.length && doc2.sel.ranges[i2];
            var newAnchor = skipAtomic(doc2, range2.anchor, old && old.anchor, bias, mayClear);
            var newHead = range2.head == range2.anchor ? newAnchor : skipAtomic(doc2, range2.head, old && old.head, bias, mayClear);
            if (out || newAnchor != range2.anchor || newHead != range2.head) {
              if (!out) {
                out = sel.ranges.slice(0, i2);
              }
              out[i2] = new Range(newAnchor, newHead);
            }
          }
          return out ? normalizeSelection(doc2.cm, out, sel.primIndex) : sel;
        }
        function skipAtomicInner(doc2, pos, oldPos, dir, mayClear) {
          var line = getLine(doc2, pos.line);
          if (line.markedSpans) {
            for (var i2 = 0; i2 < line.markedSpans.length; ++i2) {
              var sp = line.markedSpans[i2], m = sp.marker;
              var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
              var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;
              if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
                if (mayClear) {
                  signal7(m, "beforeCursorEnter");
                  if (m.explicitlyCleared) {
                    if (!line.markedSpans) {
                      break;
                    } else {
                      --i2;
                      continue;
                    }
                  }
                }
                if (!m.atomic) {
                  continue;
                }
                if (oldPos) {
                  var near = m.find(dir < 0 ? 1 : -1), diff = void 0;
                  if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                    near = movePos(doc2, near, -dir, near && near.line == pos.line ? line : null);
                  }
                  if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
                    return skipAtomicInner(doc2, near, pos, dir, mayClear);
                  }
                }
                var far = m.find(dir < 0 ? -1 : 1);
                if (dir < 0 ? preventCursorLeft : preventCursorRight) {
                  far = movePos(doc2, far, dir, far.line == pos.line ? line : null);
                }
                return far ? skipAtomicInner(doc2, far, pos, dir, mayClear) : null;
              }
            }
          }
          return pos;
        }
        function skipAtomic(doc2, pos, oldPos, bias, mayClear) {
          var dir = bias || 1;
          var found = skipAtomicInner(doc2, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, dir, true) || skipAtomicInner(doc2, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, -dir, true);
          if (!found) {
            doc2.cantEdit = true;
            return Pos(doc2.first, 0);
          }
          return found;
        }
        function movePos(doc2, pos, dir, line) {
          if (dir < 0 && pos.ch == 0) {
            if (pos.line > doc2.first) {
              return clipPos(doc2, Pos(pos.line - 1));
            } else {
              return null;
            }
          } else if (dir > 0 && pos.ch == (line || getLine(doc2, pos.line)).text.length) {
            if (pos.line < doc2.first + doc2.size - 1) {
              return Pos(pos.line + 1, 0);
            } else {
              return null;
            }
          } else {
            return new Pos(pos.line, pos.ch + dir);
          }
        }
        function selectAll(cm) {
          cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
        }
        function filterChange(doc2, change, update) {
          var obj = {
            canceled: false,
            from: change.from,
            to: change.to,
            text: change.text,
            origin: change.origin,
            cancel: function() {
              return obj.canceled = true;
            }
          };
          if (update) {
            obj.update = function(from, to, text, origin) {
              if (from) {
                obj.from = clipPos(doc2, from);
              }
              if (to) {
                obj.to = clipPos(doc2, to);
              }
              if (text) {
                obj.text = text;
              }
              if (origin !== void 0) {
                obj.origin = origin;
              }
            };
          }
          signal7(doc2, "beforeChange", doc2, obj);
          if (doc2.cm) {
            signal7(doc2.cm, "beforeChange", doc2.cm, obj);
          }
          if (obj.canceled) {
            if (doc2.cm) {
              doc2.cm.curOp.updateInput = 2;
            }
            return null;
          }
          return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
        }
        function makeChange(doc2, change, ignoreReadOnly) {
          if (doc2.cm) {
            if (!doc2.cm.curOp) {
              return operation(doc2.cm, makeChange)(doc2, change, ignoreReadOnly);
            }
            if (doc2.cm.state.suppressEdits) {
              return;
            }
          }
          if (hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange")) {
            change = filterChange(doc2, change, true);
            if (!change) {
              return;
            }
          }
          var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc2, change.from, change.to);
          if (split) {
            for (var i2 = split.length - 1; i2 >= 0; --i2) {
              makeChangeInner(doc2, { from: split[i2].from, to: split[i2].to, text: i2 ? [""] : change.text, origin: change.origin });
            }
          } else {
            makeChangeInner(doc2, change);
          }
        }
        function makeChangeInner(doc2, change) {
          if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
            return;
          }
          var selAfter = computeSelAfterChange(doc2, change);
          addChangeToHistory(doc2, change, selAfter, doc2.cm ? doc2.cm.curOp.id : NaN);
          makeChangeSingleDoc(doc2, change, selAfter, stretchSpansOverChange(doc2, change));
          var rebased = [];
          linkedDocs(doc2, function(doc3, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc3.history) == -1) {
              rebaseHist(doc3.history, change);
              rebased.push(doc3.history);
            }
            makeChangeSingleDoc(doc3, change, null, stretchSpansOverChange(doc3, change));
          });
        }
        function makeChangeFromHistory(doc2, type, allowSelectionOnly) {
          var suppress = doc2.cm && doc2.cm.state.suppressEdits;
          if (suppress && !allowSelectionOnly) {
            return;
          }
          var hist = doc2.history, event, selAfter = doc2.sel;
          var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;
          var i2 = 0;
          for (; i2 < source.length; i2++) {
            event = source[i2];
            if (allowSelectionOnly ? event.ranges && !event.equals(doc2.sel) : !event.ranges) {
              break;
            }
          }
          if (i2 == source.length) {
            return;
          }
          hist.lastOrigin = hist.lastSelOrigin = null;
          for (; ; ) {
            event = source.pop();
            if (event.ranges) {
              pushSelectionToHistory(event, dest);
              if (allowSelectionOnly && !event.equals(doc2.sel)) {
                setSelection(doc2, event, { clearRedo: false });
                return;
              }
              selAfter = event;
            } else if (suppress) {
              source.push(event);
              return;
            } else {
              break;
            }
          }
          var antiChanges = [];
          pushSelectionToHistory(selAfter, dest);
          dest.push({ changes: antiChanges, generation: hist.generation });
          hist.generation = event.generation || ++hist.maxGeneration;
          var filter = hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange");
          var loop = function(i3) {
            var change = event.changes[i3];
            change.origin = type;
            if (filter && !filterChange(doc2, change, false)) {
              source.length = 0;
              return {};
            }
            antiChanges.push(historyChangeFromChange(doc2, change));
            var after = i3 ? computeSelAfterChange(doc2, change) : lst(source);
            makeChangeSingleDoc(doc2, change, after, mergeOldSpans(doc2, change));
            if (!i3 && doc2.cm) {
              doc2.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
            }
            var rebased = [];
            linkedDocs(doc2, function(doc3, sharedHist) {
              if (!sharedHist && indexOf(rebased, doc3.history) == -1) {
                rebaseHist(doc3.history, change);
                rebased.push(doc3.history);
              }
              makeChangeSingleDoc(doc3, change, null, mergeOldSpans(doc3, change));
            });
          };
          for (var i$12 = event.changes.length - 1; i$12 >= 0; --i$12) {
            var returned = loop(i$12);
            if (returned) return returned.v;
          }
        }
        function shiftDoc(doc2, distance) {
          if (distance == 0) {
            return;
          }
          doc2.first += distance;
          doc2.sel = new Selection(map(doc2.sel.ranges, function(range2) {
            return new Range(
              Pos(range2.anchor.line + distance, range2.anchor.ch),
              Pos(range2.head.line + distance, range2.head.ch)
            );
          }), doc2.sel.primIndex);
          if (doc2.cm) {
            regChange(doc2.cm, doc2.first, doc2.first - distance, distance);
            for (var d = doc2.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
              regLineChange(doc2.cm, l, "gutter");
            }
          }
        }
        function makeChangeSingleDoc(doc2, change, selAfter, spans) {
          if (doc2.cm && !doc2.cm.curOp) {
            return operation(doc2.cm, makeChangeSingleDoc)(doc2, change, selAfter, spans);
          }
          if (change.to.line < doc2.first) {
            shiftDoc(doc2, change.text.length - 1 - (change.to.line - change.from.line));
            return;
          }
          if (change.from.line > doc2.lastLine()) {
            return;
          }
          if (change.from.line < doc2.first) {
            var shift = change.text.length - 1 - (doc2.first - change.from.line);
            shiftDoc(doc2, shift);
            change = {
              from: Pos(doc2.first, 0),
              to: Pos(change.to.line + shift, change.to.ch),
              text: [lst(change.text)],
              origin: change.origin
            };
          }
          var last = doc2.lastLine();
          if (change.to.line > last) {
            change = {
              from: change.from,
              to: Pos(last, getLine(doc2, last).text.length),
              text: [change.text[0]],
              origin: change.origin
            };
          }
          change.removed = getBetween(doc2, change.from, change.to);
          if (!selAfter) {
            selAfter = computeSelAfterChange(doc2, change);
          }
          if (doc2.cm) {
            makeChangeSingleDocInEditor(doc2.cm, change, spans);
          } else {
            updateDoc(doc2, change, spans);
          }
          setSelectionNoUndo(doc2, selAfter, sel_dontScroll);
          if (doc2.cantEdit && skipAtomic(doc2, Pos(doc2.firstLine(), 0))) {
            doc2.cantEdit = false;
          }
        }
        function makeChangeSingleDocInEditor(cm, change, spans) {
          var doc2 = cm.doc, display = cm.display, from = change.from, to = change.to;
          var recomputeMaxLength = false, checkWidthStart = from.line;
          if (!cm.options.lineWrapping) {
            checkWidthStart = lineNo(visualLine(getLine(doc2, from.line)));
            doc2.iter(checkWidthStart, to.line + 1, function(line) {
              if (line == display.maxLine) {
                recomputeMaxLength = true;
                return true;
              }
            });
          }
          if (doc2.sel.contains(change.from, change.to) > -1) {
            signalCursorActivity(cm);
          }
          updateDoc(doc2, change, spans, estimateHeight(cm));
          if (!cm.options.lineWrapping) {
            doc2.iter(checkWidthStart, from.line + change.text.length, function(line) {
              var len = lineLength(line);
              if (len > display.maxLineLength) {
                display.maxLine = line;
                display.maxLineLength = len;
                display.maxLineChanged = true;
                recomputeMaxLength = false;
              }
            });
            if (recomputeMaxLength) {
              cm.curOp.updateMaxLine = true;
            }
          }
          retreatFrontier(doc2, from.line);
          startWorker(cm, 400);
          var lendiff = change.text.length - (to.line - from.line) - 1;
          if (change.full) {
            regChange(cm);
          } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
            regLineChange(cm, from.line, "text");
          } else {
            regChange(cm, from.line, to.line + 1, lendiff);
          }
          var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
          if (changeHandler || changesHandler) {
            var obj = {
              from,
              to,
              text: change.text,
              removed: change.removed,
              origin: change.origin
            };
            if (changeHandler) {
              signalLater(cm, "change", cm, obj);
            }
            if (changesHandler) {
              (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
            }
          }
          cm.display.selForContextMenu = null;
        }
        function replaceRange(doc2, code, from, to, origin) {
          var assign;
          if (!to) {
            to = from;
          }
          if (cmp(to, from) < 0) {
            assign = [to, from], from = assign[0], to = assign[1];
          }
          if (typeof code == "string") {
            code = doc2.splitLines(code);
          }
          makeChange(doc2, { from, to, text: code, origin });
        }
        function rebaseHistSelSingle(pos, from, to, diff) {
          if (to < pos.line) {
            pos.line += diff;
          } else if (from < pos.line) {
            pos.line = from;
            pos.ch = 0;
          }
        }
        function rebaseHistArray(array, from, to, diff) {
          for (var i2 = 0; i2 < array.length; ++i2) {
            var sub = array[i2], ok = true;
            if (sub.ranges) {
              if (!sub.copied) {
                sub = array[i2] = sub.deepCopy();
                sub.copied = true;
              }
              for (var j = 0; j < sub.ranges.length; j++) {
                rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
                rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
              }
              continue;
            }
            for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
              var cur = sub.changes[j$1];
              if (to < cur.from.line) {
                cur.from = Pos(cur.from.line + diff, cur.from.ch);
                cur.to = Pos(cur.to.line + diff, cur.to.ch);
              } else if (from <= cur.to.line) {
                ok = false;
                break;
              }
            }
            if (!ok) {
              array.splice(0, i2 + 1);
              i2 = 0;
            }
          }
        }
        function rebaseHist(hist, change) {
          var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
          rebaseHistArray(hist.done, from, to, diff);
          rebaseHistArray(hist.undone, from, to, diff);
        }
        function changeLine(doc2, handle, changeType, op) {
          var no = handle, line = handle;
          if (typeof handle == "number") {
            line = getLine(doc2, clipLine(doc2, handle));
          } else {
            no = lineNo(handle);
          }
          if (no == null) {
            return null;
          }
          if (op(line, no) && doc2.cm) {
            regLineChange(doc2.cm, no, changeType);
          }
          return line;
        }
        function LeafChunk(lines) {
          this.lines = lines;
          this.parent = null;
          var height = 0;
          for (var i2 = 0; i2 < lines.length; ++i2) {
            lines[i2].parent = this;
            height += lines[i2].height;
          }
          this.height = height;
        }
        LeafChunk.prototype = {
          chunkSize: function() {
            return this.lines.length;
          },
          // Remove the n lines at offset 'at'.
          removeInner: function(at, n) {
            for (var i2 = at, e = at + n; i2 < e; ++i2) {
              var line = this.lines[i2];
              this.height -= line.height;
              cleanUpLine(line);
              signalLater(line, "delete");
            }
            this.lines.splice(at, n);
          },
          // Helper used to collapse a small branch into a single leaf.
          collapse: function(lines) {
            lines.push.apply(lines, this.lines);
          },
          // Insert the given array of lines at offset 'at', count them as
          // having the given height.
          insertInner: function(at, lines, height) {
            this.height += height;
            this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
            for (var i2 = 0; i2 < lines.length; ++i2) {
              lines[i2].parent = this;
            }
          },
          // Used to iterate over a part of the tree.
          iterN: function(at, n, op) {
            for (var e = at + n; at < e; ++at) {
              if (op(this.lines[at])) {
                return true;
              }
            }
          }
        };
        function BranchChunk(children2) {
          this.children = children2;
          var size = 0, height = 0;
          for (var i2 = 0; i2 < children2.length; ++i2) {
            var ch = children2[i2];
            size += ch.chunkSize();
            height += ch.height;
            ch.parent = this;
          }
          this.size = size;
          this.height = height;
          this.parent = null;
        }
        BranchChunk.prototype = {
          chunkSize: function() {
            return this.size;
          },
          removeInner: function(at, n) {
            this.size -= n;
            for (var i2 = 0; i2 < this.children.length; ++i2) {
              var child = this.children[i2], sz = child.chunkSize();
              if (at < sz) {
                var rm = Math.min(n, sz - at), oldHeight = child.height;
                child.removeInner(at, rm);
                this.height -= oldHeight - child.height;
                if (sz == rm) {
                  this.children.splice(i2--, 1);
                  child.parent = null;
                }
                if ((n -= rm) == 0) {
                  break;
                }
                at = 0;
              } else {
                at -= sz;
              }
            }
            if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
              var lines = [];
              this.collapse(lines);
              this.children = [new LeafChunk(lines)];
              this.children[0].parent = this;
            }
          },
          collapse: function(lines) {
            for (var i2 = 0; i2 < this.children.length; ++i2) {
              this.children[i2].collapse(lines);
            }
          },
          insertInner: function(at, lines, height) {
            this.size += lines.length;
            this.height += height;
            for (var i2 = 0; i2 < this.children.length; ++i2) {
              var child = this.children[i2], sz = child.chunkSize();
              if (at <= sz) {
                child.insertInner(at, lines, height);
                if (child.lines && child.lines.length > 50) {
                  var remaining = child.lines.length % 25 + 25;
                  for (var pos = remaining; pos < child.lines.length; ) {
                    var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                    child.height -= leaf.height;
                    this.children.splice(++i2, 0, leaf);
                    leaf.parent = this;
                  }
                  child.lines = child.lines.slice(0, remaining);
                  this.maybeSpill();
                }
                break;
              }
              at -= sz;
            }
          },
          // When a node has grown, check whether it should be split.
          maybeSpill: function() {
            if (this.children.length <= 10) {
              return;
            }
            var me = this;
            do {
              var spilled = me.children.splice(me.children.length - 5, 5);
              var sibling = new BranchChunk(spilled);
              if (!me.parent) {
                var copy = new BranchChunk(me.children);
                copy.parent = me;
                me.children = [copy, sibling];
                me = copy;
              } else {
                me.size -= sibling.size;
                me.height -= sibling.height;
                var myIndex = indexOf(me.parent.children, me);
                me.parent.children.splice(myIndex + 1, 0, sibling);
              }
              sibling.parent = me.parent;
            } while (me.children.length > 10);
            me.parent.maybeSpill();
          },
          iterN: function(at, n, op) {
            for (var i2 = 0; i2 < this.children.length; ++i2) {
              var child = this.children[i2], sz = child.chunkSize();
              if (at < sz) {
                var used = Math.min(n, sz - at);
                if (child.iterN(at, used, op)) {
                  return true;
                }
                if ((n -= used) == 0) {
                  break;
                }
                at = 0;
              } else {
                at -= sz;
              }
            }
          }
        };
        var LineWidget = function(doc2, node, options2) {
          if (options2) {
            for (var opt in options2) {
              if (options2.hasOwnProperty(opt)) {
                this[opt] = options2[opt];
              }
            }
          }
          this.doc = doc2;
          this.node = node;
        };
        LineWidget.prototype.clear = function() {
          var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
          if (no == null || !ws) {
            return;
          }
          for (var i2 = 0; i2 < ws.length; ++i2) {
            if (ws[i2] == this) {
              ws.splice(i2--, 1);
            }
          }
          if (!ws.length) {
            line.widgets = null;
          }
          var height = widgetHeight(this);
          updateLineHeight(line, Math.max(0, line.height - height));
          if (cm) {
            runInOp(cm, function() {
              adjustScrollWhenAboveVisible(cm, line, -height);
              regLineChange(cm, no, "widget");
            });
            signalLater(cm, "lineWidgetCleared", cm, this, no);
          }
        };
        LineWidget.prototype.changed = function() {
          var this$1 = this;
          var oldH = this.height, cm = this.doc.cm, line = this.line;
          this.height = null;
          var diff = widgetHeight(this) - oldH;
          if (!diff) {
            return;
          }
          if (!lineIsHidden(this.doc, line)) {
            updateLineHeight(line, line.height + diff);
          }
          if (cm) {
            runInOp(cm, function() {
              cm.curOp.forceUpdate = true;
              adjustScrollWhenAboveVisible(cm, line, diff);
              signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
            });
          }
        };
        eventMixin(LineWidget);
        function adjustScrollWhenAboveVisible(cm, line, diff) {
          if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
            addToScrollTop(cm, diff);
          }
        }
        function addLineWidget(doc2, handle, node, options2) {
          var widget = new LineWidget(doc2, node, options2);
          var cm = doc2.cm;
          if (cm && widget.noHScroll) {
            cm.display.alignWidgets = true;
          }
          changeLine(doc2, handle, "widget", function(line) {
            var widgets = line.widgets || (line.widgets = []);
            if (widget.insertAt == null) {
              widgets.push(widget);
            } else {
              widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
            }
            widget.line = line;
            if (cm && !lineIsHidden(doc2, line)) {
              var aboveVisible = heightAtLine(line) < doc2.scrollTop;
              updateLineHeight(line, line.height + widgetHeight(widget));
              if (aboveVisible) {
                addToScrollTop(cm, widget.height);
              }
              cm.curOp.forceUpdate = true;
            }
            return true;
          });
          if (cm) {
            signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
          }
          return widget;
        }
        var nextMarkerId = 0;
        var TextMarker = function(doc2, type) {
          this.lines = [];
          this.type = type;
          this.doc = doc2;
          this.id = ++nextMarkerId;
        };
        TextMarker.prototype.clear = function() {
          if (this.explicitlyCleared) {
            return;
          }
          var cm = this.doc.cm, withOp = cm && !cm.curOp;
          if (withOp) {
            startOperation(cm);
          }
          if (hasHandler(this, "clear")) {
            var found = this.find();
            if (found) {
              signalLater(this, "clear", found.from, found.to);
            }
          }
          var min = null, max = null;
          for (var i2 = 0; i2 < this.lines.length; ++i2) {
            var line = this.lines[i2];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (cm && !this.collapsed) {
              regLineChange(cm, lineNo(line), "text");
            } else if (cm) {
              if (span.to != null) {
                max = lineNo(line);
              }
              if (span.from != null) {
                min = lineNo(line);
              }
            }
            line.markedSpans = removeMarkedSpan(line.markedSpans, span);
            if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
              updateLineHeight(line, textHeight(cm.display));
            }
          }
          if (cm && this.collapsed && !cm.options.lineWrapping) {
            for (var i$12 = 0; i$12 < this.lines.length; ++i$12) {
              var visual = visualLine(this.lines[i$12]), len = lineLength(visual);
              if (len > cm.display.maxLineLength) {
                cm.display.maxLine = visual;
                cm.display.maxLineLength = len;
                cm.display.maxLineChanged = true;
              }
            }
          }
          if (min != null && cm && this.collapsed) {
            regChange(cm, min, max + 1);
          }
          this.lines.length = 0;
          this.explicitlyCleared = true;
          if (this.atomic && this.doc.cantEdit) {
            this.doc.cantEdit = false;
            if (cm) {
              reCheckSelection(cm.doc);
            }
          }
          if (cm) {
            signalLater(cm, "markerCleared", cm, this, min, max);
          }
          if (withOp) {
            endOperation(cm);
          }
          if (this.parent) {
            this.parent.clear();
          }
        };
        TextMarker.prototype.find = function(side, lineObj) {
          if (side == null && this.type == "bookmark") {
            side = 1;
          }
          var from, to;
          for (var i2 = 0; i2 < this.lines.length; ++i2) {
            var line = this.lines[i2];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (span.from != null) {
              from = Pos(lineObj ? line : lineNo(line), span.from);
              if (side == -1) {
                return from;
              }
            }
            if (span.to != null) {
              to = Pos(lineObj ? line : lineNo(line), span.to);
              if (side == 1) {
                return to;
              }
            }
          }
          return from && { from, to };
        };
        TextMarker.prototype.changed = function() {
          var this$1 = this;
          var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
          if (!pos || !cm) {
            return;
          }
          runInOp(cm, function() {
            var line = pos.line, lineN = lineNo(pos.line);
            var view = findViewForLine(cm, lineN);
            if (view) {
              clearLineMeasurementCacheFor(view);
              cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
            }
            cm.curOp.updateMaxLine = true;
            if (!lineIsHidden(widget.doc, line) && widget.height != null) {
              var oldHeight = widget.height;
              widget.height = null;
              var dHeight = widgetHeight(widget) - oldHeight;
              if (dHeight) {
                updateLineHeight(line, line.height + dHeight);
              }
            }
            signalLater(cm, "markerChanged", cm, this$1);
          });
        };
        TextMarker.prototype.attachLine = function(line) {
          if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
              (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
            }
          }
          this.lines.push(line);
        };
        TextMarker.prototype.detachLine = function(line) {
          this.lines.splice(indexOf(this.lines, line), 1);
          if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
          }
        };
        eventMixin(TextMarker);
        function markText(doc2, from, to, options2, type) {
          if (options2 && options2.shared) {
            return markTextShared(doc2, from, to, options2, type);
          }
          if (doc2.cm && !doc2.cm.curOp) {
            return operation(doc2.cm, markText)(doc2, from, to, options2, type);
          }
          var marker = new TextMarker(doc2, type), diff = cmp(from, to);
          if (options2) {
            copyObj(options2, marker, false);
          }
          if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
            return marker;
          }
          if (marker.replacedWith) {
            marker.collapsed = true;
            marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
            if (!options2.handleMouseEvents) {
              marker.widgetNode.setAttribute("cm-ignore-events", "true");
            }
            if (options2.insertLeft) {
              marker.widgetNode.insertLeft = true;
            }
          }
          if (marker.collapsed) {
            if (conflictingCollapsedRange(doc2, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc2, to.line, from, to, marker)) {
              throw new Error("Inserting collapsed marker partially overlapping an existing one");
            }
            seeCollapsedSpans();
          }
          if (marker.addToHistory) {
            addChangeToHistory(doc2, { from, to, origin: "markText" }, doc2.sel, NaN);
          }
          var curLine = from.line, cm = doc2.cm, updateMaxLine;
          doc2.iter(curLine, to.line + 1, function(line) {
            if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
              updateMaxLine = true;
            }
            if (marker.collapsed && curLine != from.line) {
              updateLineHeight(line, 0);
            }
            addMarkedSpan(line, new MarkedSpan(
              marker,
              curLine == from.line ? from.ch : null,
              curLine == to.line ? to.ch : null
            ), doc2.cm && doc2.cm.curOp);
            ++curLine;
          });
          if (marker.collapsed) {
            doc2.iter(from.line, to.line + 1, function(line) {
              if (lineIsHidden(doc2, line)) {
                updateLineHeight(line, 0);
              }
            });
          }
          if (marker.clearOnEnter) {
            on(marker, "beforeCursorEnter", function() {
              return marker.clear();
            });
          }
          if (marker.readOnly) {
            seeReadOnlySpans();
            if (doc2.history.done.length || doc2.history.undone.length) {
              doc2.clearHistory();
            }
          }
          if (marker.collapsed) {
            marker.id = ++nextMarkerId;
            marker.atomic = true;
          }
          if (cm) {
            if (updateMaxLine) {
              cm.curOp.updateMaxLine = true;
            }
            if (marker.collapsed) {
              regChange(cm, from.line, to.line + 1);
            } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
              for (var i2 = from.line; i2 <= to.line; i2++) {
                regLineChange(cm, i2, "text");
              }
            }
            if (marker.atomic) {
              reCheckSelection(cm.doc);
            }
            signalLater(cm, "markerAdded", cm, marker);
          }
          return marker;
        }
        var SharedTextMarker = function(markers, primary) {
          this.markers = markers;
          this.primary = primary;
          for (var i2 = 0; i2 < markers.length; ++i2) {
            markers[i2].parent = this;
          }
        };
        SharedTextMarker.prototype.clear = function() {
          if (this.explicitlyCleared) {
            return;
          }
          this.explicitlyCleared = true;
          for (var i2 = 0; i2 < this.markers.length; ++i2) {
            this.markers[i2].clear();
          }
          signalLater(this, "clear");
        };
        SharedTextMarker.prototype.find = function(side, lineObj) {
          return this.primary.find(side, lineObj);
        };
        eventMixin(SharedTextMarker);
        function markTextShared(doc2, from, to, options2, type) {
          options2 = copyObj(options2);
          options2.shared = false;
          var markers = [markText(doc2, from, to, options2, type)], primary = markers[0];
          var widget = options2.widgetNode;
          linkedDocs(doc2, function(doc3) {
            if (widget) {
              options2.widgetNode = widget.cloneNode(true);
            }
            markers.push(markText(doc3, clipPos(doc3, from), clipPos(doc3, to), options2, type));
            for (var i2 = 0; i2 < doc3.linked.length; ++i2) {
              if (doc3.linked[i2].isParent) {
                return;
              }
            }
            primary = lst(markers);
          });
          return new SharedTextMarker(markers, primary);
        }
        function findSharedMarkers(doc2) {
          return doc2.findMarks(Pos(doc2.first, 0), doc2.clipPos(Pos(doc2.lastLine())), function(m) {
            return m.parent;
          });
        }
        function copySharedMarkers(doc2, markers) {
          for (var i2 = 0; i2 < markers.length; i2++) {
            var marker = markers[i2], pos = marker.find();
            var mFrom = doc2.clipPos(pos.from), mTo = doc2.clipPos(pos.to);
            if (cmp(mFrom, mTo)) {
              var subMark = markText(doc2, mFrom, mTo, marker.primary, marker.primary.type);
              marker.markers.push(subMark);
              subMark.parent = marker;
            }
          }
        }
        function detachSharedMarkers(markers) {
          var loop = function(i3) {
            var marker = markers[i3], linked = [marker.primary.doc];
            linkedDocs(marker.primary.doc, function(d) {
              return linked.push(d);
            });
            for (var j = 0; j < marker.markers.length; j++) {
              var subMarker = marker.markers[j];
              if (indexOf(linked, subMarker.doc) == -1) {
                subMarker.parent = null;
                marker.markers.splice(j--, 1);
              }
            }
          };
          for (var i2 = 0; i2 < markers.length; i2++) loop(i2);
        }
        var nextDocId = 0;
        var Doc = function(text, mode, firstLine, lineSep, direction) {
          if (!(this instanceof Doc)) {
            return new Doc(text, mode, firstLine, lineSep, direction);
          }
          if (firstLine == null) {
            firstLine = 0;
          }
          BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
          this.first = firstLine;
          this.scrollTop = this.scrollLeft = 0;
          this.cantEdit = false;
          this.cleanGeneration = 1;
          this.modeFrontier = this.highlightFrontier = firstLine;
          var start = Pos(firstLine, 0);
          this.sel = simpleSelection(start);
          this.history = new History(null);
          this.id = ++nextDocId;
          this.modeOption = mode;
          this.lineSep = lineSep;
          this.direction = direction == "rtl" ? "rtl" : "ltr";
          this.extend = false;
          if (typeof text == "string") {
            text = this.splitLines(text);
          }
          updateDoc(this, { from: start, to: start, text });
          setSelection(this, simpleSelection(start), sel_dontScroll);
        };
        Doc.prototype = createObj(BranchChunk.prototype, {
          constructor: Doc,
          // Iterate over the document. Supports two forms -- with only one
          // argument, it calls that for each line in the document. With
          // three, it iterates over the range given by the first two (with
          // the second being non-inclusive).
          iter: function(from, to, op) {
            if (op) {
              this.iterN(from - this.first, to - from, op);
            } else {
              this.iterN(this.first, this.first + this.size, from);
            }
          },
          // Non-public interface for adding and removing lines.
          insert: function(at, lines) {
            var height = 0;
            for (var i2 = 0; i2 < lines.length; ++i2) {
              height += lines[i2].height;
            }
            this.insertInner(at - this.first, lines, height);
          },
          remove: function(at, n) {
            this.removeInner(at - this.first, n);
          },
          // From here, the methods are part of the public interface. Most
          // are also available from CodeMirror (editor) instances.
          getValue: function(lineSep) {
            var lines = getLines(this, this.first, this.first + this.size);
            if (lineSep === false) {
              return lines;
            }
            return lines.join(lineSep || this.lineSeparator());
          },
          setValue: docMethodOp(function(code) {
            var top = Pos(this.first, 0), last = this.first + this.size - 1;
            makeChange(this, {
              from: top,
              to: Pos(last, getLine(this, last).text.length),
              text: this.splitLines(code),
              origin: "setValue",
              full: true
            }, true);
            if (this.cm) {
              scrollToCoords(this.cm, 0, 0);
            }
            setSelection(this, simpleSelection(top), sel_dontScroll);
          }),
          replaceRange: function(code, from, to, origin) {
            from = clipPos(this, from);
            to = to ? clipPos(this, to) : from;
            replaceRange(this, code, from, to, origin);
          },
          getRange: function(from, to, lineSep) {
            var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
            if (lineSep === false) {
              return lines;
            }
            if (lineSep === "") {
              return lines.join("");
            }
            return lines.join(lineSep || this.lineSeparator());
          },
          getLine: function(line) {
            var l = this.getLineHandle(line);
            return l && l.text;
          },
          getLineHandle: function(line) {
            if (isLine(this, line)) {
              return getLine(this, line);
            }
          },
          getLineNumber: function(line) {
            return lineNo(line);
          },
          getLineHandleVisualStart: function(line) {
            if (typeof line == "number") {
              line = getLine(this, line);
            }
            return visualLine(line);
          },
          lineCount: function() {
            return this.size;
          },
          firstLine: function() {
            return this.first;
          },
          lastLine: function() {
            return this.first + this.size - 1;
          },
          clipPos: function(pos) {
            return clipPos(this, pos);
          },
          getCursor: function(start) {
            var range2 = this.sel.primary(), pos;
            if (start == null || start == "head") {
              pos = range2.head;
            } else if (start == "anchor") {
              pos = range2.anchor;
            } else if (start == "end" || start == "to" || start === false) {
              pos = range2.to();
            } else {
              pos = range2.from();
            }
            return pos;
          },
          listSelections: function() {
            return this.sel.ranges;
          },
          somethingSelected: function() {
            return this.sel.somethingSelected();
          },
          setCursor: docMethodOp(function(line, ch, options2) {
            setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options2);
          }),
          setSelection: docMethodOp(function(anchor, head, options2) {
            setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options2);
          }),
          extendSelection: docMethodOp(function(head, other, options2) {
            extendSelection(this, clipPos(this, head), other && clipPos(this, other), options2);
          }),
          extendSelections: docMethodOp(function(heads, options2) {
            extendSelections(this, clipPosArray(this, heads), options2);
          }),
          extendSelectionsBy: docMethodOp(function(f, options2) {
            var heads = map(this.sel.ranges, f);
            extendSelections(this, clipPosArray(this, heads), options2);
          }),
          setSelections: docMethodOp(function(ranges, primary, options2) {
            if (!ranges.length) {
              return;
            }
            var out = [];
            for (var i2 = 0; i2 < ranges.length; i2++) {
              out[i2] = new Range(
                clipPos(this, ranges[i2].anchor),
                clipPos(this, ranges[i2].head || ranges[i2].anchor)
              );
            }
            if (primary == null) {
              primary = Math.min(ranges.length - 1, this.sel.primIndex);
            }
            setSelection(this, normalizeSelection(this.cm, out, primary), options2);
          }),
          addSelection: docMethodOp(function(anchor, head, options2) {
            var ranges = this.sel.ranges.slice(0);
            ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
            setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options2);
          }),
          getSelection: function(lineSep) {
            var ranges = this.sel.ranges, lines;
            for (var i2 = 0; i2 < ranges.length; i2++) {
              var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
              lines = lines ? lines.concat(sel) : sel;
            }
            if (lineSep === false) {
              return lines;
            } else {
              return lines.join(lineSep || this.lineSeparator());
            }
          },
          getSelections: function(lineSep) {
            var parts = [], ranges = this.sel.ranges;
            for (var i2 = 0; i2 < ranges.length; i2++) {
              var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
              if (lineSep !== false) {
                sel = sel.join(lineSep || this.lineSeparator());
              }
              parts[i2] = sel;
            }
            return parts;
          },
          replaceSelection: function(code, collapse, origin) {
            var dup = [];
            for (var i2 = 0; i2 < this.sel.ranges.length; i2++) {
              dup[i2] = code;
            }
            this.replaceSelections(dup, collapse, origin || "+input");
          },
          replaceSelections: docMethodOp(function(code, collapse, origin) {
            var changes = [], sel = this.sel;
            for (var i2 = 0; i2 < sel.ranges.length; i2++) {
              var range2 = sel.ranges[i2];
              changes[i2] = { from: range2.from(), to: range2.to(), text: this.splitLines(code[i2]), origin };
            }
            var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
            for (var i$12 = changes.length - 1; i$12 >= 0; i$12--) {
              makeChange(this, changes[i$12]);
            }
            if (newSel) {
              setSelectionReplaceHistory(this, newSel);
            } else if (this.cm) {
              ensureCursorVisible(this.cm);
            }
          }),
          undo: docMethodOp(function() {
            makeChangeFromHistory(this, "undo");
          }),
          redo: docMethodOp(function() {
            makeChangeFromHistory(this, "redo");
          }),
          undoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "undo", true);
          }),
          redoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "redo", true);
          }),
          setExtending: function(val) {
            this.extend = val;
          },
          getExtending: function() {
            return this.extend;
          },
          historySize: function() {
            var hist = this.history, done = 0, undone = 0;
            for (var i2 = 0; i2 < hist.done.length; i2++) {
              if (!hist.done[i2].ranges) {
                ++done;
              }
            }
            for (var i$12 = 0; i$12 < hist.undone.length; i$12++) {
              if (!hist.undone[i$12].ranges) {
                ++undone;
              }
            }
            return { undo: done, redo: undone };
          },
          clearHistory: function() {
            var this$1 = this;
            this.history = new History(this.history);
            linkedDocs(this, function(doc2) {
              return doc2.history = this$1.history;
            }, true);
          },
          markClean: function() {
            this.cleanGeneration = this.changeGeneration(true);
          },
          changeGeneration: function(forceSplit) {
            if (forceSplit) {
              this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
            }
            return this.history.generation;
          },
          isClean: function(gen) {
            return this.history.generation == (gen || this.cleanGeneration);
          },
          getHistory: function() {
            return {
              done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)
            };
          },
          setHistory: function(histData) {
            var hist = this.history = new History(this.history);
            hist.done = copyHistoryArray(histData.done.slice(0), null, true);
            hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
          },
          setGutterMarker: docMethodOp(function(line, gutterID, value) {
            return changeLine(this, line, "gutter", function(line2) {
              var markers = line2.gutterMarkers || (line2.gutterMarkers = {});
              markers[gutterID] = value;
              if (!value && isEmpty(markers)) {
                line2.gutterMarkers = null;
              }
              return true;
            });
          }),
          clearGutter: docMethodOp(function(gutterID) {
            var this$1 = this;
            this.iter(function(line) {
              if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
                changeLine(this$1, line, "gutter", function() {
                  line.gutterMarkers[gutterID] = null;
                  if (isEmpty(line.gutterMarkers)) {
                    line.gutterMarkers = null;
                  }
                  return true;
                });
              }
            });
          }),
          lineInfo: function(line) {
            var n;
            if (typeof line == "number") {
              if (!isLine(this, line)) {
                return null;
              }
              n = line;
              line = getLine(this, line);
              if (!line) {
                return null;
              }
            } else {
              n = lineNo(line);
              if (n == null) {
                return null;
              }
            }
            return {
              line: n,
              handle: line,
              text: line.text,
              gutterMarkers: line.gutterMarkers,
              textClass: line.textClass,
              bgClass: line.bgClass,
              wrapClass: line.wrapClass,
              widgets: line.widgets
            };
          },
          addLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
              var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
              if (!line[prop2]) {
                line[prop2] = cls;
              } else if (classTest(cls).test(line[prop2])) {
                return false;
              } else {
                line[prop2] += " " + cls;
              }
              return true;
            });
          }),
          removeLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
              var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
              var cur = line[prop2];
              if (!cur) {
                return false;
              } else if (cls == null) {
                line[prop2] = null;
              } else {
                var found = cur.match(classTest(cls));
                if (!found) {
                  return false;
                }
                var end = found.index + found[0].length;
                line[prop2] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
              }
              return true;
            });
          }),
          addLineWidget: docMethodOp(function(handle, node, options2) {
            return addLineWidget(this, handle, node, options2);
          }),
          removeLineWidget: function(widget) {
            widget.clear();
          },
          markText: function(from, to, options2) {
            return markText(this, clipPos(this, from), clipPos(this, to), options2, options2 && options2.type || "range");
          },
          setBookmark: function(pos, options2) {
            var realOpts = {
              replacedWith: options2 && (options2.nodeType == null ? options2.widget : options2),
              insertLeft: options2 && options2.insertLeft,
              clearWhenEmpty: false,
              shared: options2 && options2.shared,
              handleMouseEvents: options2 && options2.handleMouseEvents
            };
            pos = clipPos(this, pos);
            return markText(this, pos, pos, realOpts, "bookmark");
          },
          findMarksAt: function(pos) {
            pos = clipPos(this, pos);
            var markers = [], spans = getLine(this, pos.line).markedSpans;
            if (spans) {
              for (var i2 = 0; i2 < spans.length; ++i2) {
                var span = spans[i2];
                if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
                  markers.push(span.marker.parent || span.marker);
                }
              }
            }
            return markers;
          },
          findMarks: function(from, to, filter) {
            from = clipPos(this, from);
            to = clipPos(this, to);
            var found = [], lineNo2 = from.line;
            this.iter(from.line, to.line + 1, function(line) {
              var spans = line.markedSpans;
              if (spans) {
                for (var i2 = 0; i2 < spans.length; i2++) {
                  var span = spans[i2];
                  if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
                    found.push(span.marker.parent || span.marker);
                  }
                }
              }
              ++lineNo2;
            });
            return found;
          },
          getAllMarks: function() {
            var markers = [];
            this.iter(function(line) {
              var sps = line.markedSpans;
              if (sps) {
                for (var i2 = 0; i2 < sps.length; ++i2) {
                  if (sps[i2].from != null) {
                    markers.push(sps[i2].marker);
                  }
                }
              }
            });
            return markers;
          },
          posFromIndex: function(off2) {
            var ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;
            this.iter(function(line) {
              var sz = line.text.length + sepSize;
              if (sz > off2) {
                ch = off2;
                return true;
              }
              off2 -= sz;
              ++lineNo2;
            });
            return clipPos(this, Pos(lineNo2, ch));
          },
          indexFromPos: function(coords) {
            coords = clipPos(this, coords);
            var index = coords.ch;
            if (coords.line < this.first || coords.ch < 0) {
              return 0;
            }
            var sepSize = this.lineSeparator().length;
            this.iter(this.first, coords.line, function(line) {
              index += line.text.length + sepSize;
            });
            return index;
          },
          copy: function(copyHistory) {
            var doc2 = new Doc(
              getLines(this, this.first, this.first + this.size),
              this.modeOption,
              this.first,
              this.lineSep,
              this.direction
            );
            doc2.scrollTop = this.scrollTop;
            doc2.scrollLeft = this.scrollLeft;
            doc2.sel = this.sel;
            doc2.extend = false;
            if (copyHistory) {
              doc2.history.undoDepth = this.history.undoDepth;
              doc2.setHistory(this.getHistory());
            }
            return doc2;
          },
          linkedDoc: function(options2) {
            if (!options2) {
              options2 = {};
            }
            var from = this.first, to = this.first + this.size;
            if (options2.from != null && options2.from > from) {
              from = options2.from;
            }
            if (options2.to != null && options2.to < to) {
              to = options2.to;
            }
            var copy = new Doc(getLines(this, from, to), options2.mode || this.modeOption, from, this.lineSep, this.direction);
            if (options2.sharedHist) {
              copy.history = this.history;
            }
            (this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options2.sharedHist });
            copy.linked = [{ doc: this, isParent: true, sharedHist: options2.sharedHist }];
            copySharedMarkers(copy, findSharedMarkers(this));
            return copy;
          },
          unlinkDoc: function(other) {
            if (other instanceof CodeMirror3) {
              other = other.doc;
            }
            if (this.linked) {
              for (var i2 = 0; i2 < this.linked.length; ++i2) {
                var link2 = this.linked[i2];
                if (link2.doc != other) {
                  continue;
                }
                this.linked.splice(i2, 1);
                other.unlinkDoc(this);
                detachSharedMarkers(findSharedMarkers(this));
                break;
              }
            }
            if (other.history == this.history) {
              var splitIds = [other.id];
              linkedDocs(other, function(doc2) {
                return splitIds.push(doc2.id);
              }, true);
              other.history = new History(null);
              other.history.done = copyHistoryArray(this.history.done, splitIds);
              other.history.undone = copyHistoryArray(this.history.undone, splitIds);
            }
          },
          iterLinkedDocs: function(f) {
            linkedDocs(this, f);
          },
          getMode: function() {
            return this.mode;
          },
          getEditor: function() {
            return this.cm;
          },
          splitLines: function(str) {
            if (this.lineSep) {
              return str.split(this.lineSep);
            }
            return splitLinesAuto(str);
          },
          lineSeparator: function() {
            return this.lineSep || "\n";
          },
          setDirection: docMethodOp(function(dir) {
            if (dir != "rtl") {
              dir = "ltr";
            }
            if (dir == this.direction) {
              return;
            }
            this.direction = dir;
            this.iter(function(line) {
              return line.order = null;
            });
            if (this.cm) {
              directionChanged(this.cm);
            }
          })
        });
        Doc.prototype.eachLine = Doc.prototype.iter;
        var lastDrop = 0;
        function onDrop(e) {
          var cm = this;
          clearDragCursor(cm);
          if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
            return;
          }
          e_preventDefault(e);
          if (ie) {
            lastDrop = +/* @__PURE__ */ new Date();
          }
          var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
          if (!pos || cm.isReadOnly()) {
            return;
          }
          if (files && files.length && window.FileReader && window.File) {
            var n = files.length, text = Array(n), read = 0;
            var markAsReadAndPasteIfAllFilesAreRead = function() {
              if (++read == n) {
                operation(cm, function() {
                  pos = clipPos(cm.doc, pos);
                  var change = {
                    from: pos,
                    to: pos,
                    text: cm.doc.splitLines(
                      text.filter(function(t) {
                        return t != null;
                      }).join(cm.doc.lineSeparator())
                    ),
                    origin: "paste"
                  };
                  makeChange(cm.doc, change);
                  setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
                })();
              }
            };
            var readTextFromFile = function(file, i3) {
              if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
                markAsReadAndPasteIfAllFilesAreRead();
                return;
              }
              var reader = new FileReader();
              reader.onerror = function() {
                return markAsReadAndPasteIfAllFilesAreRead();
              };
              reader.onload = function() {
                var content = reader.result;
                if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
                  markAsReadAndPasteIfAllFilesAreRead();
                  return;
                }
                text[i3] = content;
                markAsReadAndPasteIfAllFilesAreRead();
              };
              reader.readAsText(file);
            };
            for (var i2 = 0; i2 < files.length; i2++) {
              readTextFromFile(files[i2], i2);
            }
          } else {
            if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
              cm.state.draggingText(e);
              setTimeout(function() {
                return cm.display.input.focus();
              }, 20);
              return;
            }
            try {
              var text$1 = e.dataTransfer.getData("Text");
              if (text$1) {
                var selected;
                if (cm.state.draggingText && !cm.state.draggingText.copy) {
                  selected = cm.listSelections();
                }
                setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
                if (selected) {
                  for (var i$12 = 0; i$12 < selected.length; ++i$12) {
                    replaceRange(cm.doc, "", selected[i$12].anchor, selected[i$12].head, "drag");
                  }
                }
                cm.replaceSelection(text$1, "around", "paste");
                cm.display.input.focus();
              }
            } catch (e$1) {
            }
          }
        }
        function onDragStart(cm, e) {
          if (ie && (!cm.state.draggingText || +/* @__PURE__ */ new Date() - lastDrop < 100)) {
            e_stop(e);
            return;
          }
          if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
            return;
          }
          e.dataTransfer.setData("Text", cm.getSelection());
          e.dataTransfer.effectAllowed = "copyMove";
          if (e.dataTransfer.setDragImage && !safari) {
            var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
            img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
            if (presto) {
              img.width = img.height = 1;
              cm.display.wrapper.appendChild(img);
              img._top = img.offsetTop;
            }
            e.dataTransfer.setDragImage(img, 0, 0);
            if (presto) {
              img.parentNode.removeChild(img);
            }
          }
        }
        function onDragOver(cm, e) {
          var pos = posFromMouse(cm, e);
          if (!pos) {
            return;
          }
          var frag = document.createDocumentFragment();
          drawSelectionCursor(cm, pos, frag);
          if (!cm.display.dragCursor) {
            cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
            cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
          }
          removeChildrenAndAdd(cm.display.dragCursor, frag);
        }
        function clearDragCursor(cm) {
          if (cm.display.dragCursor) {
            cm.display.lineSpace.removeChild(cm.display.dragCursor);
            cm.display.dragCursor = null;
          }
        }
        function forEachCodeMirror(f) {
          if (!document.getElementsByClassName) {
            return;
          }
          var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
          for (var i2 = 0; i2 < byClass.length; i2++) {
            var cm = byClass[i2].CodeMirror;
            if (cm) {
              editors.push(cm);
            }
          }
          if (editors.length) {
            editors[0].operation(function() {
              for (var i3 = 0; i3 < editors.length; i3++) {
                f(editors[i3]);
              }
            });
          }
        }
        var globalsRegistered = false;
        function ensureGlobalHandlers() {
          if (globalsRegistered) {
            return;
          }
          registerGlobalHandlers();
          globalsRegistered = true;
        }
        function registerGlobalHandlers() {
          var resizeTimer;
          on(window, "resize", function() {
            if (resizeTimer == null) {
              resizeTimer = setTimeout(function() {
                resizeTimer = null;
                forEachCodeMirror(onResize);
              }, 100);
            }
          });
          on(window, "blur", function() {
            return forEachCodeMirror(onBlur);
          });
        }
        function onResize(cm) {
          var d = cm.display;
          d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
          d.scrollbarsClipped = false;
          cm.setSize();
        }
        var keyNames = {
          3: "Pause",
          8: "Backspace",
          9: "Tab",
          13: "Enter",
          16: "Shift",
          17: "Ctrl",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Esc",
          32: "Space",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "Left",
          38: "Up",
          39: "Right",
          40: "Down",
          44: "PrintScrn",
          45: "Insert",
          46: "Delete",
          59: ";",
          61: "=",
          91: "Mod",
          92: "Mod",
          93: "Mod",
          106: "*",
          107: "=",
          109: "-",
          110: ".",
          111: "/",
          145: "ScrollLock",
          173: "-",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'",
          224: "Mod",
          63232: "Up",
          63233: "Down",
          63234: "Left",
          63235: "Right",
          63272: "Delete",
          63273: "Home",
          63275: "End",
          63276: "PageUp",
          63277: "PageDown",
          63302: "Insert"
        };
        for (var i = 0; i < 10; i++) {
          keyNames[i + 48] = keyNames[i + 96] = String(i);
        }
        for (var i$1 = 65; i$1 <= 90; i$1++) {
          keyNames[i$1] = String.fromCharCode(i$1);
        }
        for (var i$2 = 1; i$2 <= 12; i$2++) {
          keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
        }
        var keyMap = {};
        keyMap.basic = {
          "Left": "goCharLeft",
          "Right": "goCharRight",
          "Up": "goLineUp",
          "Down": "goLineDown",
          "End": "goLineEnd",
          "Home": "goLineStartSmart",
          "PageUp": "goPageUp",
          "PageDown": "goPageDown",
          "Delete": "delCharAfter",
          "Backspace": "delCharBefore",
          "Shift-Backspace": "delCharBefore",
          "Tab": "defaultTab",
          "Shift-Tab": "indentAuto",
          "Enter": "newlineAndIndent",
          "Insert": "toggleOverwrite",
          "Esc": "singleSelection"
        };
        keyMap.pcDefault = {
          "Ctrl-A": "selectAll",
          "Ctrl-D": "deleteLine",
          "Ctrl-Z": "undo",
          "Shift-Ctrl-Z": "redo",
          "Ctrl-Y": "redo",
          "Ctrl-Home": "goDocStart",
          "Ctrl-End": "goDocEnd",
          "Ctrl-Up": "goLineUp",
          "Ctrl-Down": "goLineDown",
          "Ctrl-Left": "goGroupLeft",
          "Ctrl-Right": "goGroupRight",
          "Alt-Left": "goLineStart",
          "Alt-Right": "goLineEnd",
          "Ctrl-Backspace": "delGroupBefore",
          "Ctrl-Delete": "delGroupAfter",
          "Ctrl-S": "save",
          "Ctrl-F": "find",
          "Ctrl-G": "findNext",
          "Shift-Ctrl-G": "findPrev",
          "Shift-Ctrl-F": "replace",
          "Shift-Ctrl-R": "replaceAll",
          "Ctrl-[": "indentLess",
          "Ctrl-]": "indentMore",
          "Ctrl-U": "undoSelection",
          "Shift-Ctrl-U": "redoSelection",
          "Alt-U": "redoSelection",
          "fallthrough": "basic"
        };
        keyMap.emacsy = {
          "Ctrl-F": "goCharRight",
          "Ctrl-B": "goCharLeft",
          "Ctrl-P": "goLineUp",
          "Ctrl-N": "goLineDown",
          "Ctrl-A": "goLineStart",
          "Ctrl-E": "goLineEnd",
          "Ctrl-V": "goPageDown",
          "Shift-Ctrl-V": "goPageUp",
          "Ctrl-D": "delCharAfter",
          "Ctrl-H": "delCharBefore",
          "Alt-Backspace": "delWordBefore",
          "Ctrl-K": "killLine",
          "Ctrl-T": "transposeChars",
          "Ctrl-O": "openLine"
        };
        keyMap.macDefault = {
          "Cmd-A": "selectAll",
          "Cmd-D": "deleteLine",
          "Cmd-Z": "undo",
          "Shift-Cmd-Z": "redo",
          "Cmd-Y": "redo",
          "Cmd-Home": "goDocStart",
          "Cmd-Up": "goDocStart",
          "Cmd-End": "goDocEnd",
          "Cmd-Down": "goDocEnd",
          "Alt-Left": "goGroupLeft",
          "Alt-Right": "goGroupRight",
          "Cmd-Left": "goLineLeft",
          "Cmd-Right": "goLineRight",
          "Alt-Backspace": "delGroupBefore",
          "Ctrl-Alt-Backspace": "delGroupAfter",
          "Alt-Delete": "delGroupAfter",
          "Cmd-S": "save",
          "Cmd-F": "find",
          "Cmd-G": "findNext",
          "Shift-Cmd-G": "findPrev",
          "Cmd-Alt-F": "replace",
          "Shift-Cmd-Alt-F": "replaceAll",
          "Cmd-[": "indentLess",
          "Cmd-]": "indentMore",
          "Cmd-Backspace": "delWrappedLineLeft",
          "Cmd-Delete": "delWrappedLineRight",
          "Cmd-U": "undoSelection",
          "Shift-Cmd-U": "redoSelection",
          "Ctrl-Up": "goDocStart",
          "Ctrl-Down": "goDocEnd",
          "fallthrough": ["basic", "emacsy"]
        };
        keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
        function normalizeKeyName(name2) {
          var parts = name2.split(/-(?!$)/);
          name2 = parts[parts.length - 1];
          var alt, ctrl, shift, cmd;
          for (var i2 = 0; i2 < parts.length - 1; i2++) {
            var mod = parts[i2];
            if (/^(cmd|meta|m)$/i.test(mod)) {
              cmd = true;
            } else if (/^a(lt)?$/i.test(mod)) {
              alt = true;
            } else if (/^(c|ctrl|control)$/i.test(mod)) {
              ctrl = true;
            } else if (/^s(hift)?$/i.test(mod)) {
              shift = true;
            } else {
              throw new Error("Unrecognized modifier name: " + mod);
            }
          }
          if (alt) {
            name2 = "Alt-" + name2;
          }
          if (ctrl) {
            name2 = "Ctrl-" + name2;
          }
          if (cmd) {
            name2 = "Cmd-" + name2;
          }
          if (shift) {
            name2 = "Shift-" + name2;
          }
          return name2;
        }
        function normalizeKeyMap(keymap) {
          var copy = {};
          for (var keyname in keymap) {
            if (keymap.hasOwnProperty(keyname)) {
              var value = keymap[keyname];
              if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
                continue;
              }
              if (value == "...") {
                delete keymap[keyname];
                continue;
              }
              var keys = map(keyname.split(" "), normalizeKeyName);
              for (var i2 = 0; i2 < keys.length; i2++) {
                var val = void 0, name2 = void 0;
                if (i2 == keys.length - 1) {
                  name2 = keys.join(" ");
                  val = value;
                } else {
                  name2 = keys.slice(0, i2 + 1).join(" ");
                  val = "...";
                }
                var prev = copy[name2];
                if (!prev) {
                  copy[name2] = val;
                } else if (prev != val) {
                  throw new Error("Inconsistent bindings for " + name2);
                }
              }
              delete keymap[keyname];
            }
          }
          for (var prop2 in copy) {
            keymap[prop2] = copy[prop2];
          }
          return keymap;
        }
        function lookupKey(key, map2, handle, context) {
          map2 = getKeyMap(map2);
          var found = map2.call ? map2.call(key, context) : map2[key];
          if (found === false) {
            return "nothing";
          }
          if (found === "...") {
            return "multi";
          }
          if (found != null && handle(found)) {
            return "handled";
          }
          if (map2.fallthrough) {
            if (Object.prototype.toString.call(map2.fallthrough) != "[object Array]") {
              return lookupKey(key, map2.fallthrough, handle, context);
            }
            for (var i2 = 0; i2 < map2.fallthrough.length; i2++) {
              var result = lookupKey(key, map2.fallthrough[i2], handle, context);
              if (result) {
                return result;
              }
            }
          }
        }
        function isModifierKey(value) {
          var name2 = typeof value == "string" ? value : keyNames[value.keyCode];
          return name2 == "Ctrl" || name2 == "Alt" || name2 == "Shift" || name2 == "Mod";
        }
        function addModifierNames(name2, event, noShift) {
          var base = name2;
          if (event.altKey && base != "Alt") {
            name2 = "Alt-" + name2;
          }
          if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
            name2 = "Ctrl-" + name2;
          }
          if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") {
            name2 = "Cmd-" + name2;
          }
          if (!noShift && event.shiftKey && base != "Shift") {
            name2 = "Shift-" + name2;
          }
          return name2;
        }
        function keyName(event, noShift) {
          if (presto && event.keyCode == 34 && event["char"]) {
            return false;
          }
          var name2 = keyNames[event.keyCode];
          if (name2 == null || event.altGraphKey) {
            return false;
          }
          if (event.keyCode == 3 && event.code) {
            name2 = event.code;
          }
          return addModifierNames(name2, event, noShift);
        }
        function getKeyMap(val) {
          return typeof val == "string" ? keyMap[val] : val;
        }
        function deleteNearSelection(cm, compute) {
          var ranges = cm.doc.sel.ranges, kill = [];
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var toKill = compute(ranges[i2]);
            while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
              var replaced = kill.pop();
              if (cmp(replaced.from, toKill.from) < 0) {
                toKill.from = replaced.from;
                break;
              }
            }
            kill.push(toKill);
          }
          runInOp(cm, function() {
            for (var i3 = kill.length - 1; i3 >= 0; i3--) {
              replaceRange(cm.doc, "", kill[i3].from, kill[i3].to, "+delete");
            }
            ensureCursorVisible(cm);
          });
        }
        function moveCharLogically(line, ch, dir) {
          var target = skipExtendingChars(line.text, ch + dir, dir);
          return target < 0 || target > line.text.length ? null : target;
        }
        function moveLogically(line, start, dir) {
          var ch = moveCharLogically(line, start.ch, dir);
          return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
        }
        function endOfLine(visually, cm, lineObj, lineNo2, dir) {
          if (visually) {
            if (cm.doc.direction == "rtl") {
              dir = -dir;
            }
            var order = getOrder(lineObj, cm.doc.direction);
            if (order) {
              var part = dir < 0 ? lst(order) : order[0];
              var moveInStorageOrder = dir < 0 == (part.level == 1);
              var sticky = moveInStorageOrder ? "after" : "before";
              var ch;
              if (part.level > 0 || cm.doc.direction == "rtl") {
                var prep = prepareMeasureForLine(cm, lineObj);
                ch = dir < 0 ? lineObj.text.length - 1 : 0;
                var targetTop = measureCharPrepared(cm, prep, ch).top;
                ch = findFirst(function(ch2) {
                  return measureCharPrepared(cm, prep, ch2).top == targetTop;
                }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
                if (sticky == "before") {
                  ch = moveCharLogically(lineObj, ch, 1);
                }
              } else {
                ch = dir < 0 ? part.to : part.from;
              }
              return new Pos(lineNo2, ch, sticky);
            }
          }
          return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
        }
        function moveVisually(cm, line, start, dir) {
          var bidi = getOrder(line, cm.doc.direction);
          if (!bidi) {
            return moveLogically(line, start, dir);
          }
          if (start.ch >= line.text.length) {
            start.ch = line.text.length;
            start.sticky = "before";
          } else if (start.ch <= 0) {
            start.ch = 0;
            start.sticky = "after";
          }
          var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
          if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
            return moveLogically(line, start, dir);
          }
          var mv = function(pos, dir2) {
            return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);
          };
          var prep;
          var getWrappedLineExtent = function(ch2) {
            if (!cm.options.lineWrapping) {
              return { begin: 0, end: line.text.length };
            }
            prep = prep || prepareMeasureForLine(cm, line);
            return wrappedLineExtentChar(cm, line, prep, ch2);
          };
          var wrappedLineExtent2 = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);
          if (cm.doc.direction == "rtl" || part.level == 1) {
            var moveInStorageOrder = part.level == 1 == dir < 0;
            var ch = mv(start, moveInStorageOrder ? 1 : -1);
            if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent2.begin : ch <= part.to && ch <= wrappedLineExtent2.end)) {
              var sticky = moveInStorageOrder ? "before" : "after";
              return new Pos(start.line, ch, sticky);
            }
          }
          var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {
            var getRes = function(ch3, moveInStorageOrder3) {
              return moveInStorageOrder3 ? new Pos(start.line, mv(ch3, 1), "before") : new Pos(start.line, ch3, "after");
            };
            for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
              var part2 = bidi[partPos2];
              var moveInStorageOrder2 = dir2 > 0 == (part2.level != 1);
              var ch2 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
              if (part2.from <= ch2 && ch2 < part2.to) {
                return getRes(ch2, moveInStorageOrder2);
              }
              ch2 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);
              if (wrappedLineExtent3.begin <= ch2 && ch2 < wrappedLineExtent3.end) {
                return getRes(ch2, moveInStorageOrder2);
              }
            }
          };
          var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);
          if (res) {
            return res;
          }
          var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
          if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
            res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
            if (res) {
              return res;
            }
          }
          return null;
        }
        var commands = {
          selectAll,
          singleSelection: function(cm) {
            return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
          },
          killLine: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              if (range2.empty()) {
                var len = getLine(cm.doc, range2.head.line).text.length;
                if (range2.head.ch == len && range2.head.line < cm.lastLine()) {
                  return { from: range2.head, to: Pos(range2.head.line + 1, 0) };
                } else {
                  return { from: range2.head, to: Pos(range2.head.line, len) };
                }
              } else {
                return { from: range2.from(), to: range2.to() };
              }
            });
          },
          deleteLine: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              return {
                from: Pos(range2.from().line, 0),
                to: clipPos(cm.doc, Pos(range2.to().line + 1, 0))
              };
            });
          },
          delLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              return {
                from: Pos(range2.from().line, 0),
                to: range2.from()
              };
            });
          },
          delWrappedLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              var top = cm.charCoords(range2.head, "div").top + 5;
              var leftPos = cm.coordsChar({ left: 0, top }, "div");
              return { from: leftPos, to: range2.from() };
            });
          },
          delWrappedLineRight: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              var top = cm.charCoords(range2.head, "div").top + 5;
              var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
              return { from: range2.from(), to: rightPos };
            });
          },
          undo: function(cm) {
            return cm.undo();
          },
          redo: function(cm) {
            return cm.redo();
          },
          undoSelection: function(cm) {
            return cm.undoSelection();
          },
          redoSelection: function(cm) {
            return cm.redoSelection();
          },
          goDocStart: function(cm) {
            return cm.extendSelection(Pos(cm.firstLine(), 0));
          },
          goDocEnd: function(cm) {
            return cm.extendSelection(Pos(cm.lastLine()));
          },
          goLineStart: function(cm) {
            return cm.extendSelectionsBy(
              function(range2) {
                return lineStart(cm, range2.head.line);
              },
              { origin: "+move", bias: 1 }
            );
          },
          goLineStartSmart: function(cm) {
            return cm.extendSelectionsBy(
              function(range2) {
                return lineStartSmart(cm, range2.head);
              },
              { origin: "+move", bias: 1 }
            );
          },
          goLineEnd: function(cm) {
            return cm.extendSelectionsBy(
              function(range2) {
                return lineEnd(cm, range2.head.line);
              },
              { origin: "+move", bias: -1 }
            );
          },
          goLineRight: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              var top = cm.cursorCoords(range2.head, "div").top + 5;
              return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
            }, sel_move);
          },
          goLineLeft: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              var top = cm.cursorCoords(range2.head, "div").top + 5;
              return cm.coordsChar({ left: 0, top }, "div");
            }, sel_move);
          },
          goLineLeftSmart: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              var top = cm.cursorCoords(range2.head, "div").top + 5;
              var pos = cm.coordsChar({ left: 0, top }, "div");
              if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
                return lineStartSmart(cm, range2.head);
              }
              return pos;
            }, sel_move);
          },
          goLineUp: function(cm) {
            return cm.moveV(-1, "line");
          },
          goLineDown: function(cm) {
            return cm.moveV(1, "line");
          },
          goPageUp: function(cm) {
            return cm.moveV(-1, "page");
          },
          goPageDown: function(cm) {
            return cm.moveV(1, "page");
          },
          goCharLeft: function(cm) {
            return cm.moveH(-1, "char");
          },
          goCharRight: function(cm) {
            return cm.moveH(1, "char");
          },
          goColumnLeft: function(cm) {
            return cm.moveH(-1, "column");
          },
          goColumnRight: function(cm) {
            return cm.moveH(1, "column");
          },
          goWordLeft: function(cm) {
            return cm.moveH(-1, "word");
          },
          goGroupRight: function(cm) {
            return cm.moveH(1, "group");
          },
          goGroupLeft: function(cm) {
            return cm.moveH(-1, "group");
          },
          goWordRight: function(cm) {
            return cm.moveH(1, "word");
          },
          delCharBefore: function(cm) {
            return cm.deleteH(-1, "codepoint");
          },
          delCharAfter: function(cm) {
            return cm.deleteH(1, "char");
          },
          delWordBefore: function(cm) {
            return cm.deleteH(-1, "word");
          },
          delWordAfter: function(cm) {
            return cm.deleteH(1, "word");
          },
          delGroupBefore: function(cm) {
            return cm.deleteH(-1, "group");
          },
          delGroupAfter: function(cm) {
            return cm.deleteH(1, "group");
          },
          indentAuto: function(cm) {
            return cm.indentSelection("smart");
          },
          indentMore: function(cm) {
            return cm.indentSelection("add");
          },
          indentLess: function(cm) {
            return cm.indentSelection("subtract");
          },
          insertTab: function(cm) {
            return cm.replaceSelection("	");
          },
          insertSoftTab: function(cm) {
            var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
            for (var i2 = 0; i2 < ranges.length; i2++) {
              var pos = ranges[i2].from();
              var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
              spaces.push(spaceStr(tabSize - col % tabSize));
            }
            cm.replaceSelections(spaces);
          },
          defaultTab: function(cm) {
            if (cm.somethingSelected()) {
              cm.indentSelection("add");
            } else {
              cm.execCommand("insertTab");
            }
          },
          // Swap the two chars left and right of each selection's head.
          // Move cursor behind the two swapped characters afterwards.
          //
          // Doesn't consider line feeds a character.
          // Doesn't scan more than one line above to find a character.
          // Doesn't do anything on an empty line.
          // Doesn't do anything with non-empty selections.
          transposeChars: function(cm) {
            return runInOp(cm, function() {
              var ranges = cm.listSelections(), newSel = [];
              for (var i2 = 0; i2 < ranges.length; i2++) {
                if (!ranges[i2].empty()) {
                  continue;
                }
                var cur = ranges[i2].head, line = getLine(cm.doc, cur.line).text;
                if (line) {
                  if (cur.ch == line.length) {
                    cur = new Pos(cur.line, cur.ch - 1);
                  }
                  if (cur.ch > 0) {
                    cur = new Pos(cur.line, cur.ch + 1);
                    cm.replaceRange(
                      line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                      Pos(cur.line, cur.ch - 2),
                      cur,
                      "+transpose"
                    );
                  } else if (cur.line > cm.doc.first) {
                    var prev = getLine(cm.doc, cur.line - 1).text;
                    if (prev) {
                      cur = new Pos(cur.line, 1);
                      cm.replaceRange(
                        line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1),
                        Pos(cur.line - 1, prev.length - 1),
                        cur,
                        "+transpose"
                      );
                    }
                  }
                }
                newSel.push(new Range(cur, cur));
              }
              cm.setSelections(newSel);
            });
          },
          newlineAndIndent: function(cm) {
            return runInOp(cm, function() {
              var sels = cm.listSelections();
              for (var i2 = sels.length - 1; i2 >= 0; i2--) {
                cm.replaceRange(cm.doc.lineSeparator(), sels[i2].anchor, sels[i2].head, "+input");
              }
              sels = cm.listSelections();
              for (var i$12 = 0; i$12 < sels.length; i$12++) {
                cm.indentLine(sels[i$12].from().line, null, true);
              }
              ensureCursorVisible(cm);
            });
          },
          openLine: function(cm) {
            return cm.replaceSelection("\n", "start");
          },
          toggleOverwrite: function(cm) {
            return cm.toggleOverwrite();
          }
        };
        function lineStart(cm, lineN) {
          var line = getLine(cm.doc, lineN);
          var visual = visualLine(line);
          if (visual != line) {
            lineN = lineNo(visual);
          }
          return endOfLine(true, cm, visual, lineN, 1);
        }
        function lineEnd(cm, lineN) {
          var line = getLine(cm.doc, lineN);
          var visual = visualLineEnd(line);
          if (visual != line) {
            lineN = lineNo(visual);
          }
          return endOfLine(true, cm, line, lineN, -1);
        }
        function lineStartSmart(cm, pos) {
          var start = lineStart(cm, pos.line);
          var line = getLine(cm.doc, start.line);
          var order = getOrder(line, cm.doc.direction);
          if (!order || order[0].level == 0) {
            var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
            var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
            return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
          }
          return start;
        }
        function doHandleBinding(cm, bound, dropShift) {
          if (typeof bound == "string") {
            bound = commands[bound];
            if (!bound) {
              return false;
            }
          }
          cm.display.input.ensurePolled();
          var prevShift = cm.display.shift, done = false;
          try {
            if (cm.isReadOnly()) {
              cm.state.suppressEdits = true;
            }
            if (dropShift) {
              cm.display.shift = false;
            }
            done = bound(cm) != Pass;
          } finally {
            cm.display.shift = prevShift;
            cm.state.suppressEdits = false;
          }
          return done;
        }
        function lookupKeyForEditor(cm, name2, handle) {
          for (var i2 = 0; i2 < cm.state.keyMaps.length; i2++) {
            var result = lookupKey(name2, cm.state.keyMaps[i2], handle, cm);
            if (result) {
              return result;
            }
          }
          return cm.options.extraKeys && lookupKey(name2, cm.options.extraKeys, handle, cm) || lookupKey(name2, cm.options.keyMap, handle, cm);
        }
        var stopSeq = new Delayed();
        function dispatchKey(cm, name2, e, handle) {
          var seq = cm.state.keySeq;
          if (seq) {
            if (isModifierKey(name2)) {
              return "handled";
            }
            if (/\'$/.test(name2)) {
              cm.state.keySeq = null;
            } else {
              stopSeq.set(50, function() {
                if (cm.state.keySeq == seq) {
                  cm.state.keySeq = null;
                  cm.display.input.reset();
                }
              });
            }
            if (dispatchKeyInner(cm, seq + " " + name2, e, handle)) {
              return true;
            }
          }
          return dispatchKeyInner(cm, name2, e, handle);
        }
        function dispatchKeyInner(cm, name2, e, handle) {
          var result = lookupKeyForEditor(cm, name2, handle);
          if (result == "multi") {
            cm.state.keySeq = name2;
          }
          if (result == "handled") {
            signalLater(cm, "keyHandled", cm, name2, e);
          }
          if (result == "handled" || result == "multi") {
            e_preventDefault(e);
            restartBlink(cm);
          }
          return !!result;
        }
        function handleKeyBinding(cm, e) {
          var name2 = keyName(e, true);
          if (!name2) {
            return false;
          }
          if (e.shiftKey && !cm.state.keySeq) {
            return dispatchKey(cm, "Shift-" + name2, e, function(b) {
              return doHandleBinding(cm, b, true);
            }) || dispatchKey(cm, name2, e, function(b) {
              if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
                return doHandleBinding(cm, b);
              }
            });
          } else {
            return dispatchKey(cm, name2, e, function(b) {
              return doHandleBinding(cm, b);
            });
          }
        }
        function handleCharBinding(cm, e, ch) {
          return dispatchKey(cm, "'" + ch + "'", e, function(b) {
            return doHandleBinding(cm, b, true);
          });
        }
        var lastStoppedKey = null;
        function onKeyDown(e) {
          var cm = this;
          if (e.target && e.target != cm.display.input.getField()) {
            return;
          }
          cm.curOp.focus = activeElt(root(cm));
          if (signalDOMEvent(cm, e)) {
            return;
          }
          if (ie && ie_version < 11 && e.keyCode == 27) {
            e.returnValue = false;
          }
          var code = e.keyCode;
          cm.display.shift = code == 16 || e.shiftKey;
          var handled = handleKeyBinding(cm, e);
          if (presto) {
            lastStoppedKey = handled ? code : null;
            if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
              cm.replaceSelection("", null, "cut");
            }
          }
          if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
            document.execCommand("cut");
          }
          if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
            showCrossHair(cm);
          }
        }
        function showCrossHair(cm) {
          var lineDiv = cm.display.lineDiv;
          addClass(lineDiv, "CodeMirror-crosshair");
          function up(e) {
            if (e.keyCode == 18 || !e.altKey) {
              rmClass(lineDiv, "CodeMirror-crosshair");
              off(document, "keyup", up);
              off(document, "mouseover", up);
            }
          }
          on(document, "keyup", up);
          on(document, "mouseover", up);
        }
        function onKeyUp(e) {
          if (e.keyCode == 16) {
            this.doc.sel.shift = false;
          }
          signalDOMEvent(this, e);
        }
        function onKeyPress(e) {
          var cm = this;
          if (e.target && e.target != cm.display.input.getField()) {
            return;
          }
          if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
            return;
          }
          var keyCode = e.keyCode, charCode = e.charCode;
          if (presto && keyCode == lastStoppedKey) {
            lastStoppedKey = null;
            e_preventDefault(e);
            return;
          }
          if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
            return;
          }
          var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
          if (ch == "\b") {
            return;
          }
          if (handleCharBinding(cm, e, ch)) {
            return;
          }
          cm.display.input.onKeyPress(e);
        }
        var DOUBLECLICK_DELAY = 400;
        var PastClick = function(time, pos, button) {
          this.time = time;
          this.pos = pos;
          this.button = button;
        };
        PastClick.prototype.compare = function(time, pos, button) {
          return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
        };
        var lastClick, lastDoubleClick;
        function clickRepeat(pos, button) {
          var now = +/* @__PURE__ */ new Date();
          if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
            lastClick = lastDoubleClick = null;
            return "triple";
          } else if (lastClick && lastClick.compare(now, pos, button)) {
            lastDoubleClick = new PastClick(now, pos, button);
            lastClick = null;
            return "double";
          } else {
            lastClick = new PastClick(now, pos, button);
            lastDoubleClick = null;
            return "single";
          }
        }
        function onMouseDown(e) {
          var cm = this, display = cm.display;
          if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
            return;
          }
          display.input.ensurePolled();
          display.shift = e.shiftKey;
          if (eventInWidget(display, e)) {
            if (!webkit) {
              display.scroller.draggable = false;
              setTimeout(function() {
                return display.scroller.draggable = true;
              }, 100);
            }
            return;
          }
          if (clickInGutter(cm, e)) {
            return;
          }
          var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
          win(cm).focus();
          if (button == 1 && cm.state.selectingText) {
            cm.state.selectingText(e);
          }
          if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
            return;
          }
          if (button == 1) {
            if (pos) {
              leftButtonDown(cm, pos, repeat, e);
            } else if (e_target(e) == display.scroller) {
              e_preventDefault(e);
            }
          } else if (button == 2) {
            if (pos) {
              extendSelection(cm.doc, pos);
            }
            setTimeout(function() {
              return display.input.focus();
            }, 20);
          } else if (button == 3) {
            if (captureRightClick) {
              cm.display.input.onContextMenu(e);
            } else {
              delayBlurEvent(cm);
            }
          }
        }
        function handleMappedButton(cm, button, pos, repeat, event) {
          var name2 = "Click";
          if (repeat == "double") {
            name2 = "Double" + name2;
          } else if (repeat == "triple") {
            name2 = "Triple" + name2;
          }
          name2 = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name2;
          return dispatchKey(cm, addModifierNames(name2, event), event, function(bound) {
            if (typeof bound == "string") {
              bound = commands[bound];
            }
            if (!bound) {
              return false;
            }
            var done = false;
            try {
              if (cm.isReadOnly()) {
                cm.state.suppressEdits = true;
              }
              done = bound(cm, pos) != Pass;
            } finally {
              cm.state.suppressEdits = false;
            }
            return done;
          });
        }
        function configureMouse(cm, repeat, event) {
          var option = cm.getOption("configureMouse");
          var value = option ? option(cm, repeat, event) : {};
          if (value.unit == null) {
            var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
            value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
          }
          if (value.extend == null || cm.doc.extend) {
            value.extend = cm.doc.extend || event.shiftKey;
          }
          if (value.addNew == null) {
            value.addNew = mac ? event.metaKey : event.ctrlKey;
          }
          if (value.moveOnDrag == null) {
            value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
          }
          return value;
        }
        function leftButtonDown(cm, pos, repeat, event) {
          if (ie) {
            setTimeout(bind(ensureFocus, cm), 0);
          } else {
            cm.curOp.focus = activeElt(root(cm));
          }
          var behavior = configureMouse(cm, repeat, event);
          var sel = cm.doc.sel, contained;
          if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
            leftButtonStartDrag(cm, event, pos, behavior);
          } else {
            leftButtonSelect(cm, event, pos, behavior);
          }
        }
        function leftButtonStartDrag(cm, event, pos, behavior) {
          var display = cm.display, moved = false;
          var dragEnd = operation(cm, function(e) {
            if (webkit) {
              display.scroller.draggable = false;
            }
            cm.state.draggingText = false;
            if (cm.state.delayingBlurEvent) {
              if (cm.hasFocus()) {
                cm.state.delayingBlurEvent = false;
              } else {
                delayBlurEvent(cm);
              }
            }
            off(display.wrapper.ownerDocument, "mouseup", dragEnd);
            off(display.wrapper.ownerDocument, "mousemove", mouseMove);
            off(display.scroller, "dragstart", dragStart);
            off(display.scroller, "drop", dragEnd);
            if (!moved) {
              e_preventDefault(e);
              if (!behavior.addNew) {
                extendSelection(cm.doc, pos, null, null, behavior.extend);
              }
              if (webkit && !safari || ie && ie_version == 9) {
                setTimeout(function() {
                  display.wrapper.ownerDocument.body.focus({ preventScroll: true });
                  display.input.focus();
                }, 20);
              } else {
                display.input.focus();
              }
            }
          });
          var mouseMove = function(e2) {
            moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
          };
          var dragStart = function() {
            return moved = true;
          };
          if (webkit) {
            display.scroller.draggable = true;
          }
          cm.state.draggingText = dragEnd;
          dragEnd.copy = !behavior.moveOnDrag;
          on(display.wrapper.ownerDocument, "mouseup", dragEnd);
          on(display.wrapper.ownerDocument, "mousemove", mouseMove);
          on(display.scroller, "dragstart", dragStart);
          on(display.scroller, "drop", dragEnd);
          cm.state.delayingBlurEvent = true;
          setTimeout(function() {
            return display.input.focus();
          }, 20);
          if (display.scroller.dragDrop) {
            display.scroller.dragDrop();
          }
        }
        function rangeForUnit(cm, pos, unit) {
          if (unit == "char") {
            return new Range(pos, pos);
          }
          if (unit == "word") {
            return cm.findWordAt(pos);
          }
          if (unit == "line") {
            return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
          }
          var result = unit(cm, pos);
          return new Range(result.from, result.to);
        }
        function leftButtonSelect(cm, event, start, behavior) {
          if (ie) {
            delayBlurEvent(cm);
          }
          var display = cm.display, doc2 = cm.doc;
          e_preventDefault(event);
          var ourRange, ourIndex, startSel = doc2.sel, ranges = startSel.ranges;
          if (behavior.addNew && !behavior.extend) {
            ourIndex = doc2.sel.contains(start);
            if (ourIndex > -1) {
              ourRange = ranges[ourIndex];
            } else {
              ourRange = new Range(start, start);
            }
          } else {
            ourRange = doc2.sel.primary();
            ourIndex = doc2.sel.primIndex;
          }
          if (behavior.unit == "rectangle") {
            if (!behavior.addNew) {
              ourRange = new Range(start, start);
            }
            start = posFromMouse(cm, event, true, true);
            ourIndex = -1;
          } else {
            var range2 = rangeForUnit(cm, start, behavior.unit);
            if (behavior.extend) {
              ourRange = extendRange(ourRange, range2.anchor, range2.head, behavior.extend);
            } else {
              ourRange = range2;
            }
          }
          if (!behavior.addNew) {
            ourIndex = 0;
            setSelection(doc2, new Selection([ourRange], 0), sel_mouse);
            startSel = doc2.sel;
          } else if (ourIndex == -1) {
            ourIndex = ranges.length;
            setSelection(
              doc2,
              normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
              { scroll: false, origin: "*mouse" }
            );
          } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
            setSelection(
              doc2,
              normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
              { scroll: false, origin: "*mouse" }
            );
            startSel = doc2.sel;
          } else {
            replaceOneSelection(doc2, ourIndex, ourRange, sel_mouse);
          }
          var lastPos = start;
          function extendTo(pos) {
            if (cmp(lastPos, pos) == 0) {
              return;
            }
            lastPos = pos;
            if (behavior.unit == "rectangle") {
              var ranges2 = [], tabSize = cm.options.tabSize;
              var startCol = countColumn(getLine(doc2, start.line).text, start.ch, tabSize);
              var posCol = countColumn(getLine(doc2, pos.line).text, pos.ch, tabSize);
              var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
              for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
                var text = getLine(doc2, line).text, leftPos = findColumn(text, left, tabSize);
                if (left == right) {
                  ranges2.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
                } else if (text.length > leftPos) {
                  ranges2.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
                }
              }
              if (!ranges2.length) {
                ranges2.push(new Range(start, start));
              }
              setSelection(
                doc2,
                normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex),
                { origin: "*mouse", scroll: false }
              );
              cm.scrollIntoView(pos);
            } else {
              var oldRange = ourRange;
              var range3 = rangeForUnit(cm, pos, behavior.unit);
              var anchor = oldRange.anchor, head;
              if (cmp(range3.anchor, anchor) > 0) {
                head = range3.head;
                anchor = minPos(oldRange.from(), range3.anchor);
              } else {
                head = range3.anchor;
                anchor = maxPos(oldRange.to(), range3.head);
              }
              var ranges$1 = startSel.ranges.slice(0);
              ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc2, anchor), head));
              setSelection(doc2, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
            }
          }
          var editorSize = display.wrapper.getBoundingClientRect();
          var counter = 0;
          function extend(e) {
            var curCount = ++counter;
            var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
            if (!cur) {
              return;
            }
            if (cmp(cur, lastPos) != 0) {
              cm.curOp.focus = activeElt(root(cm));
              extendTo(cur);
              var visible = visibleLines(display, doc2);
              if (cur.line >= visible.to || cur.line < visible.from) {
                setTimeout(operation(cm, function() {
                  if (counter == curCount) {
                    extend(e);
                  }
                }), 150);
              }
            } else {
              var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
              if (outside) {
                setTimeout(operation(cm, function() {
                  if (counter != curCount) {
                    return;
                  }
                  display.scroller.scrollTop += outside;
                  extend(e);
                }), 50);
              }
            }
          }
          function done(e) {
            cm.state.selectingText = false;
            counter = Infinity;
            if (e) {
              e_preventDefault(e);
              display.input.focus();
            }
            off(display.wrapper.ownerDocument, "mousemove", move);
            off(display.wrapper.ownerDocument, "mouseup", up);
            doc2.history.lastSelOrigin = null;
          }
          var move = operation(cm, function(e) {
            if (e.buttons === 0 || !e_button(e)) {
              done(e);
            } else {
              extend(e);
            }
          });
          var up = operation(cm, done);
          cm.state.selectingText = up;
          on(display.wrapper.ownerDocument, "mousemove", move);
          on(display.wrapper.ownerDocument, "mouseup", up);
        }
        function bidiSimplify(cm, range2) {
          var anchor = range2.anchor;
          var head = range2.head;
          var anchorLine = getLine(cm.doc, anchor.line);
          if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
            return range2;
          }
          var order = getOrder(anchorLine);
          if (!order) {
            return range2;
          }
          var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
          if (part.from != anchor.ch && part.to != anchor.ch) {
            return range2;
          }
          var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
          if (boundary == 0 || boundary == order.length) {
            return range2;
          }
          var leftSide;
          if (head.line != anchor.line) {
            leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
          } else {
            var headIndex = getBidiPartAt(order, head.ch, head.sticky);
            var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
            if (headIndex == boundary - 1 || headIndex == boundary) {
              leftSide = dir < 0;
            } else {
              leftSide = dir > 0;
            }
          }
          var usePart = order[boundary + (leftSide ? -1 : 0)];
          var from = leftSide == (usePart.level == 1);
          var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
          return anchor.ch == ch && anchor.sticky == sticky ? range2 : new Range(new Pos(anchor.line, ch, sticky), head);
        }
        function gutterEvent(cm, e, type, prevent) {
          var mX, mY;
          if (e.touches) {
            mX = e.touches[0].clientX;
            mY = e.touches[0].clientY;
          } else {
            try {
              mX = e.clientX;
              mY = e.clientY;
            } catch (e$1) {
              return false;
            }
          }
          if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
            return false;
          }
          if (prevent) {
            e_preventDefault(e);
          }
          var display = cm.display;
          var lineBox = display.lineDiv.getBoundingClientRect();
          if (mY > lineBox.bottom || !hasHandler(cm, type)) {
            return e_defaultPrevented(e);
          }
          mY -= lineBox.top - display.viewOffset;
          for (var i2 = 0; i2 < cm.display.gutterSpecs.length; ++i2) {
            var g = display.gutters.childNodes[i2];
            if (g && g.getBoundingClientRect().right >= mX) {
              var line = lineAtHeight(cm.doc, mY);
              var gutter = cm.display.gutterSpecs[i2];
              signal7(cm, type, cm, line, gutter.className, e);
              return e_defaultPrevented(e);
            }
          }
        }
        function clickInGutter(cm, e) {
          return gutterEvent(cm, e, "gutterClick", true);
        }
        function onContextMenu(cm, e) {
          if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
            return;
          }
          if (signalDOMEvent(cm, e, "contextmenu")) {
            return;
          }
          if (!captureRightClick) {
            cm.display.input.onContextMenu(e);
          }
        }
        function contextMenuInGutter(cm, e) {
          if (!hasHandler(cm, "gutterContextMenu")) {
            return false;
          }
          return gutterEvent(cm, e, "gutterContextMenu", false);
        }
        function themeChanged(cm) {
          cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
          clearCaches(cm);
        }
        var Init = { toString: function() {
          return "CodeMirror.Init";
        } };
        var defaults = {};
        var optionHandlers = {};
        function defineOptions(CodeMirror4) {
          var optionHandlers2 = CodeMirror4.optionHandlers;
          function option(name2, deflt, handle, notOnInit) {
            CodeMirror4.defaults[name2] = deflt;
            if (handle) {
              optionHandlers2[name2] = notOnInit ? function(cm, val, old) {
                if (old != Init) {
                  handle(cm, val, old);
                }
              } : handle;
            }
          }
          CodeMirror4.defineOption = option;
          CodeMirror4.Init = Init;
          option("value", "", function(cm, val) {
            return cm.setValue(val);
          }, true);
          option("mode", null, function(cm, val) {
            cm.doc.modeOption = val;
            loadMode(cm);
          }, true);
          option("indentUnit", 2, loadMode, true);
          option("indentWithTabs", false);
          option("smartIndent", true);
          option("tabSize", 4, function(cm) {
            resetModeState(cm);
            clearCaches(cm);
            regChange(cm);
          }, true);
          option("lineSeparator", null, function(cm, val) {
            cm.doc.lineSep = val;
            if (!val) {
              return;
            }
            var newBreaks = [], lineNo2 = cm.doc.first;
            cm.doc.iter(function(line) {
              for (var pos = 0; ; ) {
                var found = line.text.indexOf(val, pos);
                if (found == -1) {
                  break;
                }
                pos = found + val.length;
                newBreaks.push(Pos(lineNo2, found));
              }
              lineNo2++;
            });
            for (var i2 = newBreaks.length - 1; i2 >= 0; i2--) {
              replaceRange(cm.doc, val, newBreaks[i2], Pos(newBreaks[i2].line, newBreaks[i2].ch + val.length));
            }
          });
          option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
            cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
            if (old != Init) {
              cm.refresh();
            }
          });
          option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
            return cm.refresh();
          }, true);
          option("electricChars", true);
          option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
            throw new Error("inputStyle can not (yet) be changed in a running editor");
          }, true);
          option("spellcheck", false, function(cm, val) {
            return cm.getInputField().spellcheck = val;
          }, true);
          option("autocorrect", false, function(cm, val) {
            return cm.getInputField().autocorrect = val;
          }, true);
          option("autocapitalize", false, function(cm, val) {
            return cm.getInputField().autocapitalize = val;
          }, true);
          option("rtlMoveVisually", !windows);
          option("wholeLineUpdateBefore", true);
          option("theme", "default", function(cm) {
            themeChanged(cm);
            updateGutters(cm);
          }, true);
          option("keyMap", "default", function(cm, val, old) {
            var next = getKeyMap(val);
            var prev = old != Init && getKeyMap(old);
            if (prev && prev.detach) {
              prev.detach(cm, next);
            }
            if (next.attach) {
              next.attach(cm, prev || null);
            }
          });
          option("extraKeys", null);
          option("configureMouse", null);
          option("lineWrapping", false, wrappingChanged, true);
          option("gutters", [], function(cm, val) {
            cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
            updateGutters(cm);
          }, true);
          option("fixedGutter", true, function(cm, val) {
            cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
            cm.refresh();
          }, true);
          option("coverGutterNextToScrollbar", false, function(cm) {
            return updateScrollbars(cm);
          }, true);
          option("scrollbarStyle", "native", function(cm) {
            initScrollbars(cm);
            updateScrollbars(cm);
            cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
            cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
          }, true);
          option("lineNumbers", false, function(cm, val) {
            cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
            updateGutters(cm);
          }, true);
          option("firstLineNumber", 1, updateGutters, true);
          option("lineNumberFormatter", function(integer) {
            return integer;
          }, updateGutters, true);
          option("showCursorWhenSelecting", false, updateSelection, true);
          option("resetSelectionOnContextMenu", true);
          option("lineWiseCopyCut", true);
          option("pasteLinesPerSelection", true);
          option("selectionsMayTouch", false);
          option("readOnly", false, function(cm, val) {
            if (val == "nocursor") {
              onBlur(cm);
              cm.display.input.blur();
            }
            cm.display.input.readOnlyChanged(val);
          });
          option("screenReaderLabel", null, function(cm, val) {
            val = val === "" ? null : val;
            cm.display.input.screenReaderLabelChanged(val);
          });
          option("disableInput", false, function(cm, val) {
            if (!val) {
              cm.display.input.reset();
            }
          }, true);
          option("dragDrop", true, dragDropChanged);
          option("allowDropFileTypes", null);
          option("cursorBlinkRate", 530);
          option("cursorScrollMargin", 0);
          option("cursorHeight", 1, updateSelection, true);
          option("singleCursorHeightPerLine", true, updateSelection, true);
          option("workTime", 100);
          option("workDelay", 100);
          option("flattenSpans", true, resetModeState, true);
          option("addModeClass", false, resetModeState, true);
          option("pollInterval", 100);
          option("undoDepth", 200, function(cm, val) {
            return cm.doc.history.undoDepth = val;
          });
          option("historyEventDelay", 1250);
          option("viewportMargin", 10, function(cm) {
            return cm.refresh();
          }, true);
          option("maxHighlightLength", 1e4, resetModeState, true);
          option("moveInputWithCursor", true, function(cm, val) {
            if (!val) {
              cm.display.input.resetPosition();
            }
          });
          option("tabindex", null, function(cm, val) {
            return cm.display.input.getField().tabIndex = val || "";
          });
          option("autofocus", null);
          option("direction", "ltr", function(cm, val) {
            return cm.doc.setDirection(val);
          }, true);
          option("phrases", null);
        }
        function dragDropChanged(cm, value, old) {
          var wasOn = old && old != Init;
          if (!value != !wasOn) {
            var funcs = cm.display.dragFunctions;
            var toggle = value ? on : off;
            toggle(cm.display.scroller, "dragstart", funcs.start);
            toggle(cm.display.scroller, "dragenter", funcs.enter);
            toggle(cm.display.scroller, "dragover", funcs.over);
            toggle(cm.display.scroller, "dragleave", funcs.leave);
            toggle(cm.display.scroller, "drop", funcs.drop);
          }
        }
        function wrappingChanged(cm) {
          if (cm.options.lineWrapping) {
            addClass(cm.display.wrapper, "CodeMirror-wrap");
            cm.display.sizer.style.minWidth = "";
            cm.display.sizerWidth = null;
          } else {
            rmClass(cm.display.wrapper, "CodeMirror-wrap");
            findMaxLine(cm);
          }
          estimateLineHeights(cm);
          regChange(cm);
          clearCaches(cm);
          setTimeout(function() {
            return updateScrollbars(cm);
          }, 100);
        }
        function CodeMirror3(place, options2) {
          var this$1 = this;
          if (!(this instanceof CodeMirror3)) {
            return new CodeMirror3(place, options2);
          }
          this.options = options2 = options2 ? copyObj(options2) : {};
          copyObj(defaults, options2, false);
          var doc2 = options2.value;
          if (typeof doc2 == "string") {
            doc2 = new Doc(doc2, options2.mode, null, options2.lineSeparator, options2.direction);
          } else if (options2.mode) {
            doc2.modeOption = options2.mode;
          }
          this.doc = doc2;
          var input = new CodeMirror3.inputStyles[options2.inputStyle](this);
          var display = this.display = new Display(place, doc2, input, options2);
          display.wrapper.CodeMirror = this;
          themeChanged(this);
          if (options2.lineWrapping) {
            this.display.wrapper.className += " CodeMirror-wrap";
          }
          initScrollbars(this);
          this.state = {
            keyMaps: [],
            // stores maps added by addKeyMap
            overlays: [],
            // highlighting overlays, as added by addOverlay
            modeGen: 0,
            // bumped when mode/overlay changes, used to invalidate highlighting info
            overwrite: false,
            delayingBlurEvent: false,
            focused: false,
            suppressEdits: false,
            // used to disable editing during key handlers when in readOnly mode
            pasteIncoming: -1,
            cutIncoming: -1,
            // help recognize paste/cut edits in input.poll
            selectingText: false,
            draggingText: false,
            highlight: new Delayed(),
            // stores highlight worker timeout
            keySeq: null,
            // Unfinished key sequence
            specialChars: null
          };
          if (options2.autofocus && !mobile) {
            display.input.focus();
          }
          if (ie && ie_version < 11) {
            setTimeout(function() {
              return this$1.display.input.reset(true);
            }, 20);
          }
          registerEventHandlers(this);
          ensureGlobalHandlers();
          startOperation(this);
          this.curOp.forceUpdate = true;
          attachDoc(this, doc2);
          if (options2.autofocus && !mobile || this.hasFocus()) {
            setTimeout(function() {
              if (this$1.hasFocus() && !this$1.state.focused) {
                onFocus(this$1);
              }
            }, 20);
          } else {
            onBlur(this);
          }
          for (var opt in optionHandlers) {
            if (optionHandlers.hasOwnProperty(opt)) {
              optionHandlers[opt](this, options2[opt], Init);
            }
          }
          maybeUpdateLineNumberWidth(this);
          if (options2.finishInit) {
            options2.finishInit(this);
          }
          for (var i2 = 0; i2 < initHooks.length; ++i2) {
            initHooks[i2](this);
          }
          endOperation(this);
          if (webkit && options2.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
            display.lineDiv.style.textRendering = "auto";
          }
        }
        CodeMirror3.defaults = defaults;
        CodeMirror3.optionHandlers = optionHandlers;
        function registerEventHandlers(cm) {
          var d = cm.display;
          on(d.scroller, "mousedown", operation(cm, onMouseDown));
          if (ie && ie_version < 11) {
            on(d.scroller, "dblclick", operation(cm, function(e) {
              if (signalDOMEvent(cm, e)) {
                return;
              }
              var pos = posFromMouse(cm, e);
              if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
                return;
              }
              e_preventDefault(e);
              var word = cm.findWordAt(pos);
              extendSelection(cm.doc, word.anchor, word.head);
            }));
          } else {
            on(d.scroller, "dblclick", function(e) {
              return signalDOMEvent(cm, e) || e_preventDefault(e);
            });
          }
          on(d.scroller, "contextmenu", function(e) {
            return onContextMenu(cm, e);
          });
          on(d.input.getField(), "contextmenu", function(e) {
            if (!d.scroller.contains(e.target)) {
              onContextMenu(cm, e);
            }
          });
          var touchFinished, prevTouch = { end: 0 };
          function finishTouch() {
            if (d.activeTouch) {
              touchFinished = setTimeout(function() {
                return d.activeTouch = null;
              }, 1e3);
              prevTouch = d.activeTouch;
              prevTouch.end = +/* @__PURE__ */ new Date();
            }
          }
          function isMouseLikeTouchEvent(e) {
            if (e.touches.length != 1) {
              return false;
            }
            var touch = e.touches[0];
            return touch.radiusX <= 1 && touch.radiusY <= 1;
          }
          function farAway(touch, other) {
            if (other.left == null) {
              return true;
            }
            var dx = other.left - touch.left, dy = other.top - touch.top;
            return dx * dx + dy * dy > 20 * 20;
          }
          on(d.scroller, "touchstart", function(e) {
            if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
              d.input.ensurePolled();
              clearTimeout(touchFinished);
              var now = +/* @__PURE__ */ new Date();
              d.activeTouch = {
                start: now,
                moved: false,
                prev: now - prevTouch.end <= 300 ? prevTouch : null
              };
              if (e.touches.length == 1) {
                d.activeTouch.left = e.touches[0].pageX;
                d.activeTouch.top = e.touches[0].pageY;
              }
            }
          });
          on(d.scroller, "touchmove", function() {
            if (d.activeTouch) {
              d.activeTouch.moved = true;
            }
          });
          on(d.scroller, "touchend", function(e) {
            var touch = d.activeTouch;
            if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && /* @__PURE__ */ new Date() - touch.start < 300) {
              var pos = cm.coordsChar(d.activeTouch, "page"), range2;
              if (!touch.prev || farAway(touch, touch.prev)) {
                range2 = new Range(pos, pos);
              } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
                range2 = cm.findWordAt(pos);
              } else {
                range2 = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
              }
              cm.setSelection(range2.anchor, range2.head);
              cm.focus();
              e_preventDefault(e);
            }
            finishTouch();
          });
          on(d.scroller, "touchcancel", finishTouch);
          on(d.scroller, "scroll", function() {
            if (d.scroller.clientHeight) {
              updateScrollTop(cm, d.scroller.scrollTop);
              setScrollLeft(cm, d.scroller.scrollLeft, true);
              signal7(cm, "scroll", cm);
            }
          });
          on(d.scroller, "mousewheel", function(e) {
            return onScrollWheel(cm, e);
          });
          on(d.scroller, "DOMMouseScroll", function(e) {
            return onScrollWheel(cm, e);
          });
          on(d.wrapper, "scroll", function() {
            return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
          });
          d.dragFunctions = {
            enter: function(e) {
              if (!signalDOMEvent(cm, e)) {
                e_stop(e);
              }
            },
            over: function(e) {
              if (!signalDOMEvent(cm, e)) {
                onDragOver(cm, e);
                e_stop(e);
              }
            },
            start: function(e) {
              return onDragStart(cm, e);
            },
            drop: operation(cm, onDrop),
            leave: function(e) {
              if (!signalDOMEvent(cm, e)) {
                clearDragCursor(cm);
              }
            }
          };
          var inp = d.input.getField();
          on(inp, "keyup", function(e) {
            return onKeyUp.call(cm, e);
          });
          on(inp, "keydown", operation(cm, onKeyDown));
          on(inp, "keypress", operation(cm, onKeyPress));
          on(inp, "focus", function(e) {
            return onFocus(cm, e);
          });
          on(inp, "blur", function(e) {
            return onBlur(cm, e);
          });
        }
        var initHooks = [];
        CodeMirror3.defineInitHook = function(f) {
          return initHooks.push(f);
        };
        function indentLine(cm, n, how, aggressive) {
          var doc2 = cm.doc, state;
          if (how == null) {
            how = "add";
          }
          if (how == "smart") {
            if (!doc2.mode.indent) {
              how = "prev";
            } else {
              state = getContextBefore(cm, n).state;
            }
          }
          var tabSize = cm.options.tabSize;
          var line = getLine(doc2, n), curSpace = countColumn(line.text, null, tabSize);
          if (line.stateAfter) {
            line.stateAfter = null;
          }
          var curSpaceString = line.text.match(/^\s*/)[0], indentation;
          if (!aggressive && !/\S/.test(line.text)) {
            indentation = 0;
            how = "not";
          } else if (how == "smart") {
            indentation = doc2.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
            if (indentation == Pass || indentation > 150) {
              if (!aggressive) {
                return;
              }
              how = "prev";
            }
          }
          if (how == "prev") {
            if (n > doc2.first) {
              indentation = countColumn(getLine(doc2, n - 1).text, null, tabSize);
            } else {
              indentation = 0;
            }
          } else if (how == "add") {
            indentation = curSpace + cm.options.indentUnit;
          } else if (how == "subtract") {
            indentation = curSpace - cm.options.indentUnit;
          } else if (typeof how == "number") {
            indentation = curSpace + how;
          }
          indentation = Math.max(0, indentation);
          var indentString = "", pos = 0;
          if (cm.options.indentWithTabs) {
            for (var i2 = Math.floor(indentation / tabSize); i2; --i2) {
              pos += tabSize;
              indentString += "	";
            }
          }
          if (pos < indentation) {
            indentString += spaceStr(indentation - pos);
          }
          if (indentString != curSpaceString) {
            replaceRange(doc2, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
            line.stateAfter = null;
            return true;
          } else {
            for (var i$12 = 0; i$12 < doc2.sel.ranges.length; i$12++) {
              var range2 = doc2.sel.ranges[i$12];
              if (range2.head.line == n && range2.head.ch < curSpaceString.length) {
                var pos$1 = Pos(n, curSpaceString.length);
                replaceOneSelection(doc2, i$12, new Range(pos$1, pos$1));
                break;
              }
            }
          }
        }
        var lastCopied = null;
        function setLastCopied(newLastCopied) {
          lastCopied = newLastCopied;
        }
        function applyTextInput(cm, inserted, deleted, sel, origin) {
          var doc2 = cm.doc;
          cm.display.shift = false;
          if (!sel) {
            sel = doc2.sel;
          }
          var recent = +/* @__PURE__ */ new Date() - 200;
          var paste = origin == "paste" || cm.state.pasteIncoming > recent;
          var textLines = splitLinesAuto(inserted), multiPaste = null;
          if (paste && sel.ranges.length > 1) {
            if (lastCopied && lastCopied.text.join("\n") == inserted) {
              if (sel.ranges.length % lastCopied.text.length == 0) {
                multiPaste = [];
                for (var i2 = 0; i2 < lastCopied.text.length; i2++) {
                  multiPaste.push(doc2.splitLines(lastCopied.text[i2]));
                }
              }
            } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
              multiPaste = map(textLines, function(l) {
                return [l];
              });
            }
          }
          var updateInput = cm.curOp.updateInput;
          for (var i$12 = sel.ranges.length - 1; i$12 >= 0; i$12--) {
            var range2 = sel.ranges[i$12];
            var from = range2.from(), to = range2.to();
            if (range2.empty()) {
              if (deleted && deleted > 0) {
                from = Pos(from.line, from.ch - deleted);
              } else if (cm.state.overwrite && !paste) {
                to = Pos(to.line, Math.min(getLine(doc2, to.line).text.length, to.ch + lst(textLines).length));
              } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
                from = to = Pos(from.line, 0);
              }
            }
            var changeEvent = {
              from,
              to,
              text: multiPaste ? multiPaste[i$12 % multiPaste.length] : textLines,
              origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
            };
            makeChange(cm.doc, changeEvent);
            signalLater(cm, "inputRead", cm, changeEvent);
          }
          if (inserted && !paste) {
            triggerElectric(cm, inserted);
          }
          ensureCursorVisible(cm);
          if (cm.curOp.updateInput < 2) {
            cm.curOp.updateInput = updateInput;
          }
          cm.curOp.typing = true;
          cm.state.pasteIncoming = cm.state.cutIncoming = -1;
        }
        function handlePaste(e, cm) {
          var pasted = e.clipboardData && e.clipboardData.getData("Text");
          if (pasted) {
            e.preventDefault();
            if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus()) {
              runInOp(cm, function() {
                return applyTextInput(cm, pasted, 0, null, "paste");
              });
            }
            return true;
          }
        }
        function triggerElectric(cm, inserted) {
          if (!cm.options.electricChars || !cm.options.smartIndent) {
            return;
          }
          var sel = cm.doc.sel;
          for (var i2 = sel.ranges.length - 1; i2 >= 0; i2--) {
            var range2 = sel.ranges[i2];
            if (range2.head.ch > 100 || i2 && sel.ranges[i2 - 1].head.line == range2.head.line) {
              continue;
            }
            var mode = cm.getModeAt(range2.head);
            var indented = false;
            if (mode.electricChars) {
              for (var j = 0; j < mode.electricChars.length; j++) {
                if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                  indented = indentLine(cm, range2.head.line, "smart");
                  break;
                }
              }
            } else if (mode.electricInput) {
              if (mode.electricInput.test(getLine(cm.doc, range2.head.line).text.slice(0, range2.head.ch))) {
                indented = indentLine(cm, range2.head.line, "smart");
              }
            }
            if (indented) {
              signalLater(cm, "electricInput", cm, range2.head.line);
            }
          }
        }
        function copyableRanges(cm) {
          var text = [], ranges = [];
          for (var i2 = 0; i2 < cm.doc.sel.ranges.length; i2++) {
            var line = cm.doc.sel.ranges[i2].head.line;
            var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
            ranges.push(lineRange);
            text.push(cm.getRange(lineRange.anchor, lineRange.head));
          }
          return { text, ranges };
        }
        function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
          field.setAttribute("autocorrect", autocorrect ? "on" : "off");
          field.setAttribute("autocapitalize", autocapitalize ? "on" : "off");
          field.setAttribute("spellcheck", !!spellcheck);
        }
        function hiddenTextarea() {
          var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
          var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
          if (webkit) {
            te.style.width = "1000px";
          } else {
            te.setAttribute("wrap", "off");
          }
          if (ios) {
            te.style.border = "1px solid black";
          }
          return div;
        }
        function addEditorMethods(CodeMirror4) {
          var optionHandlers2 = CodeMirror4.optionHandlers;
          var helpers = CodeMirror4.helpers = {};
          CodeMirror4.prototype = {
            constructor: CodeMirror4,
            focus: function() {
              win(this).focus();
              this.display.input.focus();
            },
            setOption: function(option, value) {
              var options2 = this.options, old = options2[option];
              if (options2[option] == value && option != "mode") {
                return;
              }
              options2[option] = value;
              if (optionHandlers2.hasOwnProperty(option)) {
                operation(this, optionHandlers2[option])(this, value, old);
              }
              signal7(this, "optionChange", this, option);
            },
            getOption: function(option) {
              return this.options[option];
            },
            getDoc: function() {
              return this.doc;
            },
            addKeyMap: function(map2, bottom) {
              this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map2));
            },
            removeKeyMap: function(map2) {
              var maps = this.state.keyMaps;
              for (var i2 = 0; i2 < maps.length; ++i2) {
                if (maps[i2] == map2 || maps[i2].name == map2) {
                  maps.splice(i2, 1);
                  return true;
                }
              }
            },
            addOverlay: methodOp(function(spec, options2) {
              var mode = spec.token ? spec : CodeMirror4.getMode(this.options, spec);
              if (mode.startState) {
                throw new Error("Overlays may not be stateful.");
              }
              insertSorted(
                this.state.overlays,
                {
                  mode,
                  modeSpec: spec,
                  opaque: options2 && options2.opaque,
                  priority: options2 && options2.priority || 0
                },
                function(overlay) {
                  return overlay.priority;
                }
              );
              this.state.modeGen++;
              regChange(this);
            }),
            removeOverlay: methodOp(function(spec) {
              var overlays = this.state.overlays;
              for (var i2 = 0; i2 < overlays.length; ++i2) {
                var cur = overlays[i2].modeSpec;
                if (cur == spec || typeof spec == "string" && cur.name == spec) {
                  overlays.splice(i2, 1);
                  this.state.modeGen++;
                  regChange(this);
                  return;
                }
              }
            }),
            indentLine: methodOp(function(n, dir, aggressive) {
              if (typeof dir != "string" && typeof dir != "number") {
                if (dir == null) {
                  dir = this.options.smartIndent ? "smart" : "prev";
                } else {
                  dir = dir ? "add" : "subtract";
                }
              }
              if (isLine(this.doc, n)) {
                indentLine(this, n, dir, aggressive);
              }
            }),
            indentSelection: methodOp(function(how) {
              var ranges = this.doc.sel.ranges, end = -1;
              for (var i2 = 0; i2 < ranges.length; i2++) {
                var range2 = ranges[i2];
                if (!range2.empty()) {
                  var from = range2.from(), to = range2.to();
                  var start = Math.max(end, from.line);
                  end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                  for (var j = start; j < end; ++j) {
                    indentLine(this, j, how);
                  }
                  var newRanges = this.doc.sel.ranges;
                  if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i2].from().ch > 0) {
                    replaceOneSelection(this.doc, i2, new Range(from, newRanges[i2].to()), sel_dontScroll);
                  }
                } else if (range2.head.line > end) {
                  indentLine(this, range2.head.line, how, true);
                  end = range2.head.line;
                  if (i2 == this.doc.sel.primIndex) {
                    ensureCursorVisible(this);
                  }
                }
              }
            }),
            // Fetch the parser token for a given character. Useful for hacks
            // that want to inspect the mode state (say, for completion).
            getTokenAt: function(pos, precise) {
              return takeToken(this, pos, precise);
            },
            getLineTokens: function(line, precise) {
              return takeToken(this, Pos(line), precise, true);
            },
            getTokenTypeAt: function(pos) {
              pos = clipPos(this.doc, pos);
              var styles = getLineStyles(this, getLine(this.doc, pos.line));
              var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
              var type;
              if (ch == 0) {
                type = styles[2];
              } else {
                for (; ; ) {
                  var mid = before + after >> 1;
                  if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
                    after = mid;
                  } else if (styles[mid * 2 + 1] < ch) {
                    before = mid + 1;
                  } else {
                    type = styles[mid * 2 + 2];
                    break;
                  }
                }
              }
              var cut = type ? type.indexOf("overlay ") : -1;
              return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
            },
            getModeAt: function(pos) {
              var mode = this.doc.mode;
              if (!mode.innerMode) {
                return mode;
              }
              return CodeMirror4.innerMode(mode, this.getTokenAt(pos).state).mode;
            },
            getHelper: function(pos, type) {
              return this.getHelpers(pos, type)[0];
            },
            getHelpers: function(pos, type) {
              var found = [];
              if (!helpers.hasOwnProperty(type)) {
                return found;
              }
              var help = helpers[type], mode = this.getModeAt(pos);
              if (typeof mode[type] == "string") {
                if (help[mode[type]]) {
                  found.push(help[mode[type]]);
                }
              } else if (mode[type]) {
                for (var i2 = 0; i2 < mode[type].length; i2++) {
                  var val = help[mode[type][i2]];
                  if (val) {
                    found.push(val);
                  }
                }
              } else if (mode.helperType && help[mode.helperType]) {
                found.push(help[mode.helperType]);
              } else if (help[mode.name]) {
                found.push(help[mode.name]);
              }
              for (var i$12 = 0; i$12 < help._global.length; i$12++) {
                var cur = help._global[i$12];
                if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
                  found.push(cur.val);
                }
              }
              return found;
            },
            getStateAfter: function(line, precise) {
              var doc2 = this.doc;
              line = clipLine(doc2, line == null ? doc2.first + doc2.size - 1 : line);
              return getContextBefore(this, line + 1, precise).state;
            },
            cursorCoords: function(start, mode) {
              var pos, range2 = this.doc.sel.primary();
              if (start == null) {
                pos = range2.head;
              } else if (typeof start == "object") {
                pos = clipPos(this.doc, start);
              } else {
                pos = start ? range2.from() : range2.to();
              }
              return cursorCoords(this, pos, mode || "page");
            },
            charCoords: function(pos, mode) {
              return charCoords(this, clipPos(this.doc, pos), mode || "page");
            },
            coordsChar: function(coords, mode) {
              coords = fromCoordSystem(this, coords, mode || "page");
              return coordsChar(this, coords.left, coords.top);
            },
            lineAtHeight: function(height, mode) {
              height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
              return lineAtHeight(this.doc, height + this.display.viewOffset);
            },
            heightAtLine: function(line, mode, includeWidgets) {
              var end = false, lineObj;
              if (typeof line == "number") {
                var last = this.doc.first + this.doc.size - 1;
                if (line < this.doc.first) {
                  line = this.doc.first;
                } else if (line > last) {
                  line = last;
                  end = true;
                }
                lineObj = getLine(this.doc, line);
              } else {
                lineObj = line;
              }
              return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
            },
            defaultTextHeight: function() {
              return textHeight(this.display);
            },
            defaultCharWidth: function() {
              return charWidth(this.display);
            },
            getViewport: function() {
              return { from: this.display.viewFrom, to: this.display.viewTo };
            },
            addWidget: function(pos, node, scroll, vert, horiz) {
              var display = this.display;
              pos = cursorCoords(this, clipPos(this.doc, pos));
              var top = pos.bottom, left = pos.left;
              node.style.position = "absolute";
              node.setAttribute("cm-ignore-events", "true");
              this.display.input.setUneditable(node);
              display.sizer.appendChild(node);
              if (vert == "over") {
                top = pos.top;
              } else if (vert == "above" || vert == "near") {
                var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
                  top = pos.top - node.offsetHeight;
                } else if (pos.bottom + node.offsetHeight <= vspace) {
                  top = pos.bottom;
                }
                if (left + node.offsetWidth > hspace) {
                  left = hspace - node.offsetWidth;
                }
              }
              node.style.top = top + "px";
              node.style.left = node.style.right = "";
              if (horiz == "right") {
                left = display.sizer.clientWidth - node.offsetWidth;
                node.style.right = "0px";
              } else {
                if (horiz == "left") {
                  left = 0;
                } else if (horiz == "middle") {
                  left = (display.sizer.clientWidth - node.offsetWidth) / 2;
                }
                node.style.left = left + "px";
              }
              if (scroll) {
                scrollIntoView(this, { left, top, right: left + node.offsetWidth, bottom: top + node.offsetHeight });
              }
            },
            triggerOnKeyDown: methodOp(onKeyDown),
            triggerOnKeyPress: methodOp(onKeyPress),
            triggerOnKeyUp: onKeyUp,
            triggerOnMouseDown: methodOp(onMouseDown),
            execCommand: function(cmd) {
              if (commands.hasOwnProperty(cmd)) {
                return commands[cmd].call(null, this);
              }
            },
            triggerElectric: methodOp(function(text) {
              triggerElectric(this, text);
            }),
            findPosH: function(from, amount, unit, visually) {
              var dir = 1;
              if (amount < 0) {
                dir = -1;
                amount = -amount;
              }
              var cur = clipPos(this.doc, from);
              for (var i2 = 0; i2 < amount; ++i2) {
                cur = findPosH(this.doc, cur, dir, unit, visually);
                if (cur.hitSide) {
                  break;
                }
              }
              return cur;
            },
            moveH: methodOp(function(dir, unit) {
              var this$1 = this;
              this.extendSelectionsBy(function(range2) {
                if (this$1.display.shift || this$1.doc.extend || range2.empty()) {
                  return findPosH(this$1.doc, range2.head, dir, unit, this$1.options.rtlMoveVisually);
                } else {
                  return dir < 0 ? range2.from() : range2.to();
                }
              }, sel_move);
            }),
            deleteH: methodOp(function(dir, unit) {
              var sel = this.doc.sel, doc2 = this.doc;
              if (sel.somethingSelected()) {
                doc2.replaceSelection("", null, "+delete");
              } else {
                deleteNearSelection(this, function(range2) {
                  var other = findPosH(doc2, range2.head, dir, unit, false);
                  return dir < 0 ? { from: other, to: range2.head } : { from: range2.head, to: other };
                });
              }
            }),
            findPosV: function(from, amount, unit, goalColumn) {
              var dir = 1, x = goalColumn;
              if (amount < 0) {
                dir = -1;
                amount = -amount;
              }
              var cur = clipPos(this.doc, from);
              for (var i2 = 0; i2 < amount; ++i2) {
                var coords = cursorCoords(this, cur, "div");
                if (x == null) {
                  x = coords.left;
                } else {
                  coords.left = x;
                }
                cur = findPosV(this, coords, dir, unit);
                if (cur.hitSide) {
                  break;
                }
              }
              return cur;
            },
            moveV: methodOp(function(dir, unit) {
              var this$1 = this;
              var doc2 = this.doc, goals = [];
              var collapse = !this.display.shift && !doc2.extend && doc2.sel.somethingSelected();
              doc2.extendSelectionsBy(function(range2) {
                if (collapse) {
                  return dir < 0 ? range2.from() : range2.to();
                }
                var headPos = cursorCoords(this$1, range2.head, "div");
                if (range2.goalColumn != null) {
                  headPos.left = range2.goalColumn;
                }
                goals.push(headPos.left);
                var pos = findPosV(this$1, headPos, dir, unit);
                if (unit == "page" && range2 == doc2.sel.primary()) {
                  addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top);
                }
                return pos;
              }, sel_move);
              if (goals.length) {
                for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
                  doc2.sel.ranges[i2].goalColumn = goals[i2];
                }
              }
            }),
            // Find the word at the given position (as returned by coordsChar).
            findWordAt: function(pos) {
              var doc2 = this.doc, line = getLine(doc2, pos.line).text;
              var start = pos.ch, end = pos.ch;
              if (line) {
                var helper = this.getHelper(pos, "wordChars");
                if ((pos.sticky == "before" || end == line.length) && start) {
                  --start;
                } else {
                  ++end;
                }
                var startChar = line.charAt(start);
                var check = isWordChar(startChar, helper) ? function(ch) {
                  return isWordChar(ch, helper);
                } : /\s/.test(startChar) ? function(ch) {
                  return /\s/.test(ch);
                } : function(ch) {
                  return !/\s/.test(ch) && !isWordChar(ch);
                };
                while (start > 0 && check(line.charAt(start - 1))) {
                  --start;
                }
                while (end < line.length && check(line.charAt(end))) {
                  ++end;
                }
              }
              return new Range(Pos(pos.line, start), Pos(pos.line, end));
            },
            toggleOverwrite: function(value) {
              if (value != null && value == this.state.overwrite) {
                return;
              }
              if (this.state.overwrite = !this.state.overwrite) {
                addClass(this.display.cursorDiv, "CodeMirror-overwrite");
              } else {
                rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
              }
              signal7(this, "overwriteToggle", this, this.state.overwrite);
            },
            hasFocus: function() {
              return this.display.input.getField() == activeElt(root(this));
            },
            isReadOnly: function() {
              return !!(this.options.readOnly || this.doc.cantEdit);
            },
            scrollTo: methodOp(function(x, y) {
              scrollToCoords(this, x, y);
            }),
            getScrollInfo: function() {
              var scroller = this.display.scroller;
              return {
                left: scroller.scrollLeft,
                top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this),
                clientWidth: displayWidth(this)
              };
            },
            scrollIntoView: methodOp(function(range2, margin) {
              if (range2 == null) {
                range2 = { from: this.doc.sel.primary().head, to: null };
                if (margin == null) {
                  margin = this.options.cursorScrollMargin;
                }
              } else if (typeof range2 == "number") {
                range2 = { from: Pos(range2, 0), to: null };
              } else if (range2.from == null) {
                range2 = { from: range2, to: null };
              }
              if (!range2.to) {
                range2.to = range2.from;
              }
              range2.margin = margin || 0;
              if (range2.from.line != null) {
                scrollToRange(this, range2);
              } else {
                scrollToCoordsRange(this, range2.from, range2.to, range2.margin);
              }
            }),
            setSize: methodOp(function(width, height) {
              var this$1 = this;
              var interpret = function(val) {
                return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
              };
              if (width != null) {
                this.display.wrapper.style.width = interpret(width);
              }
              if (height != null) {
                this.display.wrapper.style.height = interpret(height);
              }
              if (this.options.lineWrapping) {
                clearLineMeasurementCache(this);
              }
              var lineNo2 = this.display.viewFrom;
              this.doc.iter(lineNo2, this.display.viewTo, function(line) {
                if (line.widgets) {
                  for (var i2 = 0; i2 < line.widgets.length; i2++) {
                    if (line.widgets[i2].noHScroll) {
                      regLineChange(this$1, lineNo2, "widget");
                      break;
                    }
                  }
                }
                ++lineNo2;
              });
              this.curOp.forceUpdate = true;
              signal7(this, "refresh", this);
            }),
            operation: function(f) {
              return runInOp(this, f);
            },
            startOperation: function() {
              return startOperation(this);
            },
            endOperation: function() {
              return endOperation(this);
            },
            refresh: methodOp(function() {
              var oldHeight = this.display.cachedTextHeight;
              regChange(this);
              this.curOp.forceUpdate = true;
              clearCaches(this);
              scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
              updateGutterSpace(this.display);
              if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
                estimateLineHeights(this);
              }
              signal7(this, "refresh", this);
            }),
            swapDoc: methodOp(function(doc2) {
              var old = this.doc;
              old.cm = null;
              if (this.state.selectingText) {
                this.state.selectingText();
              }
              attachDoc(this, doc2);
              clearCaches(this);
              this.display.input.reset();
              scrollToCoords(this, doc2.scrollLeft, doc2.scrollTop);
              this.curOp.forceScroll = true;
              signalLater(this, "swapDoc", this, old);
              return old;
            }),
            phrase: function(phraseText) {
              var phrases = this.options.phrases;
              return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
            },
            getInputField: function() {
              return this.display.input.getField();
            },
            getWrapperElement: function() {
              return this.display.wrapper;
            },
            getScrollerElement: function() {
              return this.display.scroller;
            },
            getGutterElement: function() {
              return this.display.gutters;
            }
          };
          eventMixin(CodeMirror4);
          CodeMirror4.registerHelper = function(type, name2, value) {
            if (!helpers.hasOwnProperty(type)) {
              helpers[type] = CodeMirror4[type] = { _global: [] };
            }
            helpers[type][name2] = value;
          };
          CodeMirror4.registerGlobalHelper = function(type, name2, predicate, value) {
            CodeMirror4.registerHelper(type, name2, value);
            helpers[type]._global.push({ pred: predicate, val: value });
          };
        }
        function findPosH(doc2, pos, dir, unit, visually) {
          var oldPos = pos;
          var origDir = dir;
          var lineObj = getLine(doc2, pos.line);
          var lineDir = visually && doc2.direction == "rtl" ? -dir : dir;
          function findNextLine() {
            var l = pos.line + lineDir;
            if (l < doc2.first || l >= doc2.first + doc2.size) {
              return false;
            }
            pos = new Pos(l, pos.ch, pos.sticky);
            return lineObj = getLine(doc2, l);
          }
          function moveOnce(boundToLine) {
            var next;
            if (unit == "codepoint") {
              var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
              if (isNaN(ch)) {
                next = null;
              } else {
                var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
                next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
              }
            } else if (visually) {
              next = moveVisually(doc2.cm, lineObj, pos, dir);
            } else {
              next = moveLogically(lineObj, pos, dir);
            }
            if (next == null) {
              if (!boundToLine && findNextLine()) {
                pos = endOfLine(visually, doc2.cm, lineObj, pos.line, lineDir);
              } else {
                return false;
              }
            } else {
              pos = next;
            }
            return true;
          }
          if (unit == "char" || unit == "codepoint") {
            moveOnce();
          } else if (unit == "column") {
            moveOnce(true);
          } else if (unit == "word" || unit == "group") {
            var sawType = null, group = unit == "group";
            var helper = doc2.cm && doc2.cm.getHelper(pos, "wordChars");
            for (var first = true; ; first = false) {
              if (dir < 0 && !moveOnce(!first)) {
                break;
              }
              var cur = lineObj.text.charAt(pos.ch) || "\n";
              var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
              if (group && !first && !type) {
                type = "s";
              }
              if (sawType && sawType != type) {
                if (dir < 0) {
                  dir = 1;
                  moveOnce();
                  pos.sticky = "after";
                }
                break;
              }
              if (type) {
                sawType = type;
              }
              if (dir > 0 && !moveOnce(!first)) {
                break;
              }
            }
          }
          var result = skipAtomic(doc2, pos, oldPos, origDir, true);
          if (equalCursorPos(oldPos, result)) {
            result.hitSide = true;
          }
          return result;
        }
        function findPosV(cm, pos, dir, unit) {
          var doc2 = cm.doc, x = pos.left, y;
          if (unit == "page") {
            var pageSize = Math.min(cm.display.wrapper.clientHeight, win(cm).innerHeight || doc2(cm).documentElement.clientHeight);
            var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
            y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
          } else if (unit == "line") {
            y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
          }
          var target;
          for (; ; ) {
            target = coordsChar(cm, x, y);
            if (!target.outside) {
              break;
            }
            if (dir < 0 ? y <= 0 : y >= doc2.height) {
              target.hitSide = true;
              break;
            }
            y += dir * 5;
          }
          return target;
        }
        var ContentEditableInput = function(cm) {
          this.cm = cm;
          this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
          this.polling = new Delayed();
          this.composing = null;
          this.gracePeriod = false;
          this.readDOMTimeout = null;
        };
        ContentEditableInput.prototype.init = function(display) {
          var this$1 = this;
          var input = this, cm = input.cm;
          var div = input.div = display.lineDiv;
          div.contentEditable = true;
          disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
          function belongsToInput(e) {
            for (var t = e.target; t; t = t.parentNode) {
              if (t == div) {
                return true;
              }
              if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) {
                break;
              }
            }
            return false;
          }
          on(div, "paste", function(e) {
            if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {
              return;
            }
            if (ie_version <= 11) {
              setTimeout(operation(cm, function() {
                return this$1.updateFromDOM();
              }), 20);
            }
          });
          on(div, "compositionstart", function(e) {
            this$1.composing = { data: e.data, done: false };
          });
          on(div, "compositionupdate", function(e) {
            if (!this$1.composing) {
              this$1.composing = { data: e.data, done: false };
            }
          });
          on(div, "compositionend", function(e) {
            if (this$1.composing) {
              if (e.data != this$1.composing.data) {
                this$1.readFromDOMSoon();
              }
              this$1.composing.done = true;
            }
          });
          on(div, "touchstart", function() {
            return input.forceCompositionEnd();
          });
          on(div, "input", function() {
            if (!this$1.composing) {
              this$1.readFromDOMSoon();
            }
          });
          function onCopyCut(e) {
            if (!belongsToInput(e) || signalDOMEvent(cm, e)) {
              return;
            }
            if (cm.somethingSelected()) {
              setLastCopied({ lineWise: false, text: cm.getSelections() });
              if (e.type == "cut") {
                cm.replaceSelection("", null, "cut");
              }
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              setLastCopied({ lineWise: true, text: ranges.text });
              if (e.type == "cut") {
                cm.operation(function() {
                  cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                  cm.replaceSelection("", null, "cut");
                });
              }
            }
            if (e.clipboardData) {
              e.clipboardData.clearData();
              var content = lastCopied.text.join("\n");
              e.clipboardData.setData("Text", content);
              if (e.clipboardData.getData("Text") == content) {
                e.preventDefault();
                return;
              }
            }
            var kludge = hiddenTextarea(), te = kludge.firstChild;
            disableBrowserMagic(te);
            cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
            te.value = lastCopied.text.join("\n");
            var hadFocus = activeElt(rootNode(div));
            selectInput(te);
            setTimeout(function() {
              cm.display.lineSpace.removeChild(kludge);
              hadFocus.focus();
              if (hadFocus == div) {
                input.showPrimarySelection();
              }
            }, 50);
          }
          on(div, "copy", onCopyCut);
          on(div, "cut", onCopyCut);
        };
        ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
          if (label) {
            this.div.setAttribute("aria-label", label);
          } else {
            this.div.removeAttribute("aria-label");
          }
        };
        ContentEditableInput.prototype.prepareSelection = function() {
          var result = prepareSelection(this.cm, false);
          result.focus = activeElt(rootNode(this.div)) == this.div;
          return result;
        };
        ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
          if (!info || !this.cm.display.view.length) {
            return;
          }
          if (info.focus || takeFocus) {
            this.showPrimarySelection();
          }
          this.showMultipleSelections(info);
        };
        ContentEditableInput.prototype.getSelection = function() {
          return this.cm.display.wrapper.ownerDocument.getSelection();
        };
        ContentEditableInput.prototype.showPrimarySelection = function() {
          var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
          var from = prim.from(), to = prim.to();
          if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
            sel.removeAllRanges();
            return;
          }
          var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
          var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
          if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
            return;
          }
          var view = cm.display.view;
          var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };
          var end = to.line < cm.display.viewTo && posToDOM(cm, to);
          if (!end) {
            var measure = view[view.length - 1].measure;
            var map2 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
            end = { node: map2[map2.length - 1], offset: map2[map2.length - 2] - map2[map2.length - 3] };
          }
          if (!start || !end) {
            sel.removeAllRanges();
            return;
          }
          var old = sel.rangeCount && sel.getRangeAt(0), rng;
          try {
            rng = range(start.node, start.offset, end.offset, end.node);
          } catch (e) {
          }
          if (rng) {
            if (!gecko && cm.state.focused) {
              sel.collapse(start.node, start.offset);
              if (!rng.collapsed) {
                sel.removeAllRanges();
                sel.addRange(rng);
              }
            } else {
              sel.removeAllRanges();
              sel.addRange(rng);
            }
            if (old && sel.anchorNode == null) {
              sel.addRange(old);
            } else if (gecko) {
              this.startGracePeriod();
            }
          }
          this.rememberSelection();
        };
        ContentEditableInput.prototype.startGracePeriod = function() {
          var this$1 = this;
          clearTimeout(this.gracePeriod);
          this.gracePeriod = setTimeout(function() {
            this$1.gracePeriod = false;
            if (this$1.selectionChanged()) {
              this$1.cm.operation(function() {
                return this$1.cm.curOp.selectionChanged = true;
              });
            }
          }, 20);
        };
        ContentEditableInput.prototype.showMultipleSelections = function(info) {
          removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
          removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
        };
        ContentEditableInput.prototype.rememberSelection = function() {
          var sel = this.getSelection();
          this.lastAnchorNode = sel.anchorNode;
          this.lastAnchorOffset = sel.anchorOffset;
          this.lastFocusNode = sel.focusNode;
          this.lastFocusOffset = sel.focusOffset;
        };
        ContentEditableInput.prototype.selectionInEditor = function() {
          var sel = this.getSelection();
          if (!sel.rangeCount) {
            return false;
          }
          var node = sel.getRangeAt(0).commonAncestorContainer;
          return contains(this.div, node);
        };
        ContentEditableInput.prototype.focus = function() {
          if (this.cm.options.readOnly != "nocursor") {
            if (!this.selectionInEditor() || activeElt(rootNode(this.div)) != this.div) {
              this.showSelection(this.prepareSelection(), true);
            }
            this.div.focus();
          }
        };
        ContentEditableInput.prototype.blur = function() {
          this.div.blur();
        };
        ContentEditableInput.prototype.getField = function() {
          return this.div;
        };
        ContentEditableInput.prototype.supportsTouch = function() {
          return true;
        };
        ContentEditableInput.prototype.receivedFocus = function() {
          var this$1 = this;
          var input = this;
          if (this.selectionInEditor()) {
            setTimeout(function() {
              return this$1.pollSelection();
            }, 20);
          } else {
            runInOp(this.cm, function() {
              return input.cm.curOp.selectionChanged = true;
            });
          }
          function poll() {
            if (input.cm.state.focused) {
              input.pollSelection();
              input.polling.set(input.cm.options.pollInterval, poll);
            }
          }
          this.polling.set(this.cm.options.pollInterval, poll);
        };
        ContentEditableInput.prototype.selectionChanged = function() {
          var sel = this.getSelection();
          return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
        };
        ContentEditableInput.prototype.pollSelection = function() {
          if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
            return;
          }
          var sel = this.getSelection(), cm = this.cm;
          if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
            this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
            this.blur();
            this.focus();
            return;
          }
          if (this.composing) {
            return;
          }
          this.rememberSelection();
          var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
          var head = domToPos(cm, sel.focusNode, sel.focusOffset);
          if (anchor && head) {
            runInOp(cm, function() {
              setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
              if (anchor.bad || head.bad) {
                cm.curOp.selectionChanged = true;
              }
            });
          }
        };
        ContentEditableInput.prototype.pollContent = function() {
          if (this.readDOMTimeout != null) {
            clearTimeout(this.readDOMTimeout);
            this.readDOMTimeout = null;
          }
          var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
          var from = sel.from(), to = sel.to();
          if (from.ch == 0 && from.line > cm.firstLine()) {
            from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
          }
          if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
            to = Pos(to.line + 1, 0);
          }
          if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
            return false;
          }
          var fromIndex, fromLine, fromNode;
          if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
            fromLine = lineNo(display.view[0].line);
            fromNode = display.view[0].node;
          } else {
            fromLine = lineNo(display.view[fromIndex].line);
            fromNode = display.view[fromIndex - 1].node.nextSibling;
          }
          var toIndex = findViewIndex(cm, to.line);
          var toLine, toNode;
          if (toIndex == display.view.length - 1) {
            toLine = display.viewTo - 1;
            toNode = display.lineDiv.lastChild;
          } else {
            toLine = lineNo(display.view[toIndex + 1].line) - 1;
            toNode = display.view[toIndex + 1].node.previousSibling;
          }
          if (!fromNode) {
            return false;
          }
          var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
          var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
          while (newText.length > 1 && oldText.length > 1) {
            if (lst(newText) == lst(oldText)) {
              newText.pop();
              oldText.pop();
              toLine--;
            } else if (newText[0] == oldText[0]) {
              newText.shift();
              oldText.shift();
              fromLine++;
            } else {
              break;
            }
          }
          var cutFront = 0, cutEnd = 0;
          var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
          while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
            ++cutFront;
          }
          var newBot = lst(newText), oldBot = lst(oldText);
          var maxCutEnd = Math.min(
            newBot.length - (newText.length == 1 ? cutFront : 0),
            oldBot.length - (oldText.length == 1 ? cutFront : 0)
          );
          while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
            ++cutEnd;
          }
          if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
            while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
              cutFront--;
              cutEnd++;
            }
          }
          newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
          newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
          var chFrom = Pos(fromLine, cutFront);
          var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
          if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
            replaceRange(cm.doc, newText, chFrom, chTo, "+input");
            return true;
          }
        };
        ContentEditableInput.prototype.ensurePolled = function() {
          this.forceCompositionEnd();
        };
        ContentEditableInput.prototype.reset = function() {
          this.forceCompositionEnd();
        };
        ContentEditableInput.prototype.forceCompositionEnd = function() {
          if (!this.composing) {
            return;
          }
          clearTimeout(this.readDOMTimeout);
          this.composing = null;
          this.updateFromDOM();
          this.div.blur();
          this.div.focus();
        };
        ContentEditableInput.prototype.readFromDOMSoon = function() {
          var this$1 = this;
          if (this.readDOMTimeout != null) {
            return;
          }
          this.readDOMTimeout = setTimeout(function() {
            this$1.readDOMTimeout = null;
            if (this$1.composing) {
              if (this$1.composing.done) {
                this$1.composing = null;
              } else {
                return;
              }
            }
            this$1.updateFromDOM();
          }, 80);
        };
        ContentEditableInput.prototype.updateFromDOM = function() {
          var this$1 = this;
          if (this.cm.isReadOnly() || !this.pollContent()) {
            runInOp(this.cm, function() {
              return regChange(this$1.cm);
            });
          }
        };
        ContentEditableInput.prototype.setUneditable = function(node) {
          node.contentEditable = "false";
        };
        ContentEditableInput.prototype.onKeyPress = function(e) {
          if (e.charCode == 0 || this.composing) {
            return;
          }
          e.preventDefault();
          if (!this.cm.isReadOnly()) {
            operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
          }
        };
        ContentEditableInput.prototype.readOnlyChanged = function(val) {
          this.div.contentEditable = String(val != "nocursor");
        };
        ContentEditableInput.prototype.onContextMenu = function() {
        };
        ContentEditableInput.prototype.resetPosition = function() {
        };
        ContentEditableInput.prototype.needsContentAttribute = true;
        function posToDOM(cm, pos) {
          var view = findViewForLine(cm, pos.line);
          if (!view || view.hidden) {
            return null;
          }
          var line = getLine(cm.doc, pos.line);
          var info = mapFromLineView(view, line, pos.line);
          var order = getOrder(line, cm.doc.direction), side = "left";
          if (order) {
            var partPos = getBidiPartAt(order, pos.ch);
            side = partPos % 2 ? "right" : "left";
          }
          var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
          result.offset = result.collapse == "right" ? result.end : result.start;
          return result;
        }
        function isInGutter(node) {
          for (var scan = node; scan; scan = scan.parentNode) {
            if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
              return true;
            }
          }
          return false;
        }
        function badPos(pos, bad) {
          if (bad) {
            pos.bad = true;
          }
          return pos;
        }
        function domTextBetween(cm, from, to, fromLine, toLine) {
          var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
          function recognizeMarker(id) {
            return function(marker) {
              return marker.id == id;
            };
          }
          function close() {
            if (closing) {
              text += lineSep;
              if (extraLinebreak) {
                text += lineSep;
              }
              closing = extraLinebreak = false;
            }
          }
          function addText(str) {
            if (str) {
              close();
              text += str;
            }
          }
          function walk(node) {
            if (node.nodeType == 1) {
              var cmText = node.getAttribute("cm-text");
              if (cmText) {
                addText(cmText);
                return;
              }
              var markerID = node.getAttribute("cm-marker"), range2;
              if (markerID) {
                var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
                if (found.length && (range2 = found[0].find(0))) {
                  addText(getBetween(cm.doc, range2.from, range2.to).join(lineSep));
                }
                return;
              }
              if (node.getAttribute("contenteditable") == "false") {
                return;
              }
              var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
              if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
                return;
              }
              if (isBlock) {
                close();
              }
              for (var i2 = 0; i2 < node.childNodes.length; i2++) {
                walk(node.childNodes[i2]);
              }
              if (/^(pre|p)$/i.test(node.nodeName)) {
                extraLinebreak = true;
              }
              if (isBlock) {
                closing = true;
              }
            } else if (node.nodeType == 3) {
              addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
            }
          }
          for (; ; ) {
            walk(from);
            if (from == to) {
              break;
            }
            from = from.nextSibling;
            extraLinebreak = false;
          }
          return text;
        }
        function domToPos(cm, node, offset) {
          var lineNode;
          if (node == cm.display.lineDiv) {
            lineNode = cm.display.lineDiv.childNodes[offset];
            if (!lineNode) {
              return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
            }
            node = null;
            offset = 0;
          } else {
            for (lineNode = node; ; lineNode = lineNode.parentNode) {
              if (!lineNode || lineNode == cm.display.lineDiv) {
                return null;
              }
              if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
                break;
              }
            }
          }
          for (var i2 = 0; i2 < cm.display.view.length; i2++) {
            var lineView = cm.display.view[i2];
            if (lineView.node == lineNode) {
              return locateNodeInLineView(lineView, node, offset);
            }
          }
        }
        function locateNodeInLineView(lineView, node, offset) {
          var wrapper = lineView.text.firstChild, bad = false;
          if (!node || !contains(wrapper, node)) {
            return badPos(Pos(lineNo(lineView.line), 0), true);
          }
          if (node == wrapper) {
            bad = true;
            node = wrapper.childNodes[offset];
            offset = 0;
            if (!node) {
              var line = lineView.rest ? lst(lineView.rest) : lineView.line;
              return badPos(Pos(lineNo(line), line.text.length), bad);
            }
          }
          var textNode = node.nodeType == 3 ? node : null, topNode = node;
          if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
            textNode = node.firstChild;
            if (offset) {
              offset = textNode.nodeValue.length;
            }
          }
          while (topNode.parentNode != wrapper) {
            topNode = topNode.parentNode;
          }
          var measure = lineView.measure, maps = measure.maps;
          function find(textNode2, topNode2, offset2) {
            for (var i2 = -1; i2 < (maps ? maps.length : 0); i2++) {
              var map2 = i2 < 0 ? measure.map : maps[i2];
              for (var j = 0; j < map2.length; j += 3) {
                var curNode = map2[j + 2];
                if (curNode == textNode2 || curNode == topNode2) {
                  var line2 = lineNo(i2 < 0 ? lineView.line : lineView.rest[i2]);
                  var ch = map2[j] + offset2;
                  if (offset2 < 0 || curNode != textNode2) {
                    ch = map2[j + (offset2 ? 1 : 0)];
                  }
                  return Pos(line2, ch);
                }
              }
            }
          }
          var found = find(textNode, topNode, offset);
          if (found) {
            return badPos(found, bad);
          }
          for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
            found = find(after, after.firstChild, 0);
            if (found) {
              return badPos(Pos(found.line, found.ch - dist), bad);
            } else {
              dist += after.textContent.length;
            }
          }
          for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
            found = find(before, before.firstChild, -1);
            if (found) {
              return badPos(Pos(found.line, found.ch + dist$1), bad);
            } else {
              dist$1 += before.textContent.length;
            }
          }
        }
        var TextareaInput = function(cm) {
          this.cm = cm;
          this.prevInput = "";
          this.pollingFast = false;
          this.polling = new Delayed();
          this.hasSelection = false;
          this.composing = null;
          this.resetting = false;
        };
        TextareaInput.prototype.init = function(display) {
          var this$1 = this;
          var input = this, cm = this.cm;
          this.createField(display);
          var te = this.textarea;
          display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
          if (ios) {
            te.style.width = "0px";
          }
          on(te, "input", function() {
            if (ie && ie_version >= 9 && this$1.hasSelection) {
              this$1.hasSelection = null;
            }
            input.poll();
          });
          on(te, "paste", function(e) {
            if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
              return;
            }
            cm.state.pasteIncoming = +/* @__PURE__ */ new Date();
            input.fastPoll();
          });
          function prepareCopyCut(e) {
            if (signalDOMEvent(cm, e)) {
              return;
            }
            if (cm.somethingSelected()) {
              setLastCopied({ lineWise: false, text: cm.getSelections() });
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              setLastCopied({ lineWise: true, text: ranges.text });
              if (e.type == "cut") {
                cm.setSelections(ranges.ranges, null, sel_dontScroll);
              } else {
                input.prevInput = "";
                te.value = ranges.text.join("\n");
                selectInput(te);
              }
            }
            if (e.type == "cut") {
              cm.state.cutIncoming = +/* @__PURE__ */ new Date();
            }
          }
          on(te, "cut", prepareCopyCut);
          on(te, "copy", prepareCopyCut);
          on(display.scroller, "paste", function(e) {
            if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
              return;
            }
            if (!te.dispatchEvent) {
              cm.state.pasteIncoming = +/* @__PURE__ */ new Date();
              input.focus();
              return;
            }
            var event = new Event("paste");
            event.clipboardData = e.clipboardData;
            te.dispatchEvent(event);
          });
          on(display.lineSpace, "selectstart", function(e) {
            if (!eventInWidget(display, e)) {
              e_preventDefault(e);
            }
          });
          on(te, "compositionstart", function() {
            var start = cm.getCursor("from");
            if (input.composing) {
              input.composing.range.clear();
            }
            input.composing = {
              start,
              range: cm.markText(start, cm.getCursor("to"), { className: "CodeMirror-composing" })
            };
          });
          on(te, "compositionend", function() {
            if (input.composing) {
              input.poll();
              input.composing.range.clear();
              input.composing = null;
            }
          });
        };
        TextareaInput.prototype.createField = function(_display) {
          this.wrapper = hiddenTextarea();
          this.textarea = this.wrapper.firstChild;
          var opts = this.cm.options;
          disableBrowserMagic(this.textarea, opts.spellcheck, opts.autocorrect, opts.autocapitalize);
        };
        TextareaInput.prototype.screenReaderLabelChanged = function(label) {
          if (label) {
            this.textarea.setAttribute("aria-label", label);
          } else {
            this.textarea.removeAttribute("aria-label");
          }
        };
        TextareaInput.prototype.prepareSelection = function() {
          var cm = this.cm, display = cm.display, doc2 = cm.doc;
          var result = prepareSelection(cm);
          if (cm.options.moveInputWithCursor) {
            var headPos = cursorCoords(cm, doc2.sel.primary().head, "div");
            var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
            result.teTop = Math.max(0, Math.min(
              display.wrapper.clientHeight - 10,
              headPos.top + lineOff.top - wrapOff.top
            ));
            result.teLeft = Math.max(0, Math.min(
              display.wrapper.clientWidth - 10,
              headPos.left + lineOff.left - wrapOff.left
            ));
          }
          return result;
        };
        TextareaInput.prototype.showSelection = function(drawn) {
          var cm = this.cm, display = cm.display;
          removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
          removeChildrenAndAdd(display.selectionDiv, drawn.selection);
          if (drawn.teTop != null) {
            this.wrapper.style.top = drawn.teTop + "px";
            this.wrapper.style.left = drawn.teLeft + "px";
          }
        };
        TextareaInput.prototype.reset = function(typing) {
          if (this.contextMenuPending || this.composing && typing) {
            return;
          }
          var cm = this.cm;
          this.resetting = true;
          if (cm.somethingSelected()) {
            this.prevInput = "";
            var content = cm.getSelection();
            this.textarea.value = content;
            if (cm.state.focused) {
              selectInput(this.textarea);
            }
            if (ie && ie_version >= 9) {
              this.hasSelection = content;
            }
          } else if (!typing) {
            this.prevInput = this.textarea.value = "";
            if (ie && ie_version >= 9) {
              this.hasSelection = null;
            }
          }
          this.resetting = false;
        };
        TextareaInput.prototype.getField = function() {
          return this.textarea;
        };
        TextareaInput.prototype.supportsTouch = function() {
          return false;
        };
        TextareaInput.prototype.focus = function() {
          if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt(rootNode(this.textarea)) != this.textarea)) {
            try {
              this.textarea.focus();
            } catch (e) {
            }
          }
        };
        TextareaInput.prototype.blur = function() {
          this.textarea.blur();
        };
        TextareaInput.prototype.resetPosition = function() {
          this.wrapper.style.top = this.wrapper.style.left = 0;
        };
        TextareaInput.prototype.receivedFocus = function() {
          this.slowPoll();
        };
        TextareaInput.prototype.slowPoll = function() {
          var this$1 = this;
          if (this.pollingFast) {
            return;
          }
          this.polling.set(this.cm.options.pollInterval, function() {
            this$1.poll();
            if (this$1.cm.state.focused) {
              this$1.slowPoll();
            }
          });
        };
        TextareaInput.prototype.fastPoll = function() {
          var missed = false, input = this;
          input.pollingFast = true;
          function p() {
            var changed = input.poll();
            if (!changed && !missed) {
              missed = true;
              input.polling.set(60, p);
            } else {
              input.pollingFast = false;
              input.slowPoll();
            }
          }
          input.polling.set(20, p);
        };
        TextareaInput.prototype.poll = function() {
          var this$1 = this;
          var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
          if (this.contextMenuPending || this.resetting || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
            return false;
          }
          var text = input.value;
          if (text == prevInput && !cm.somethingSelected()) {
            return false;
          }
          if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
            cm.display.input.reset();
            return false;
          }
          if (cm.doc.sel == cm.display.selForContextMenu) {
            var first = text.charCodeAt(0);
            if (first == 8203 && !prevInput) {
              prevInput = "\u200B";
            }
            if (first == 8666) {
              this.reset();
              return this.cm.execCommand("undo");
            }
          }
          var same = 0, l = Math.min(prevInput.length, text.length);
          while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
            ++same;
          }
          runInOp(cm, function() {
            applyTextInput(
              cm,
              text.slice(same),
              prevInput.length - same,
              null,
              this$1.composing ? "*compose" : null
            );
            if (text.length > 1e3 || text.indexOf("\n") > -1) {
              input.value = this$1.prevInput = "";
            } else {
              this$1.prevInput = text;
            }
            if (this$1.composing) {
              this$1.composing.range.clear();
              this$1.composing.range = cm.markText(
                this$1.composing.start,
                cm.getCursor("to"),
                { className: "CodeMirror-composing" }
              );
            }
          });
          return true;
        };
        TextareaInput.prototype.ensurePolled = function() {
          if (this.pollingFast && this.poll()) {
            this.pollingFast = false;
          }
        };
        TextareaInput.prototype.onKeyPress = function() {
          if (ie && ie_version >= 9) {
            this.hasSelection = null;
          }
          this.fastPoll();
        };
        TextareaInput.prototype.onContextMenu = function(e) {
          var input = this, cm = input.cm, display = cm.display, te = input.textarea;
          if (input.contextMenuPending) {
            input.contextMenuPending();
          }
          var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
          if (!pos || presto) {
            return;
          }
          var reset = cm.options.resetSelectionOnContextMenu;
          if (reset && cm.doc.sel.contains(pos) == -1) {
            operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
          }
          var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
          var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
          input.wrapper.style.cssText = "position: static";
          te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
          var oldScrollY;
          if (webkit) {
            oldScrollY = te.ownerDocument.defaultView.scrollY;
          }
          display.input.focus();
          if (webkit) {
            te.ownerDocument.defaultView.scrollTo(null, oldScrollY);
          }
          display.input.reset();
          if (!cm.somethingSelected()) {
            te.value = input.prevInput = " ";
          }
          input.contextMenuPending = rehide;
          display.selForContextMenu = cm.doc.sel;
          clearTimeout(display.detectingSelectAll);
          function prepareSelectAllHack() {
            if (te.selectionStart != null) {
              var selected = cm.somethingSelected();
              var extval = "\u200B" + (selected ? te.value : "");
              te.value = "\u21DA";
              te.value = extval;
              input.prevInput = selected ? "" : "\u200B";
              te.selectionStart = 1;
              te.selectionEnd = extval.length;
              display.selForContextMenu = cm.doc.sel;
            }
          }
          function rehide() {
            if (input.contextMenuPending != rehide) {
              return;
            }
            input.contextMenuPending = false;
            input.wrapper.style.cssText = oldWrapperCSS;
            te.style.cssText = oldCSS;
            if (ie && ie_version < 9) {
              display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
            }
            if (te.selectionStart != null) {
              if (!ie || ie && ie_version < 9) {
                prepareSelectAllHack();
              }
              var i2 = 0, poll = function() {
                if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200B") {
                  operation(cm, selectAll)(cm);
                } else if (i2++ < 10) {
                  display.detectingSelectAll = setTimeout(poll, 500);
                } else {
                  display.selForContextMenu = null;
                  display.input.reset();
                }
              };
              display.detectingSelectAll = setTimeout(poll, 200);
            }
          }
          if (ie && ie_version >= 9) {
            prepareSelectAllHack();
          }
          if (captureRightClick) {
            e_stop(e);
            var mouseup = function() {
              off(window, "mouseup", mouseup);
              setTimeout(rehide, 20);
            };
            on(window, "mouseup", mouseup);
          } else {
            setTimeout(rehide, 50);
          }
        };
        TextareaInput.prototype.readOnlyChanged = function(val) {
          if (!val) {
            this.reset();
          }
          this.textarea.disabled = val == "nocursor";
          this.textarea.readOnly = !!val;
        };
        TextareaInput.prototype.setUneditable = function() {
        };
        TextareaInput.prototype.needsContentAttribute = false;
        function fromTextArea(textarea, options2) {
          options2 = options2 ? copyObj(options2) : {};
          options2.value = textarea.value;
          if (!options2.tabindex && textarea.tabIndex) {
            options2.tabindex = textarea.tabIndex;
          }
          if (!options2.placeholder && textarea.placeholder) {
            options2.placeholder = textarea.placeholder;
          }
          if (options2.autofocus == null) {
            var hasFocus = activeElt(rootNode(textarea));
            options2.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
          }
          function save() {
            textarea.value = cm.getValue();
          }
          var realSubmit;
          if (textarea.form) {
            on(textarea.form, "submit", save);
            if (!options2.leaveSubmitMethodAlone) {
              var form = textarea.form;
              realSubmit = form.submit;
              try {
                var wrappedSubmit = form.submit = function() {
                  save();
                  form.submit = realSubmit;
                  form.submit();
                  form.submit = wrappedSubmit;
                };
              } catch (e) {
              }
            }
          }
          options2.finishInit = function(cm2) {
            cm2.save = save;
            cm2.getTextArea = function() {
              return textarea;
            };
            cm2.toTextArea = function() {
              cm2.toTextArea = isNaN;
              save();
              textarea.parentNode.removeChild(cm2.getWrapperElement());
              textarea.style.display = "";
              if (textarea.form) {
                off(textarea.form, "submit", save);
                if (!options2.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
                  textarea.form.submit = realSubmit;
                }
              }
            };
          };
          textarea.style.display = "none";
          var cm = CodeMirror3(
            function(node) {
              return textarea.parentNode.insertBefore(node, textarea.nextSibling);
            },
            options2
          );
          return cm;
        }
        function addLegacyProps(CodeMirror4) {
          CodeMirror4.off = off;
          CodeMirror4.on = on;
          CodeMirror4.wheelEventPixels = wheelEventPixels;
          CodeMirror4.Doc = Doc;
          CodeMirror4.splitLines = splitLinesAuto;
          CodeMirror4.countColumn = countColumn;
          CodeMirror4.findColumn = findColumn;
          CodeMirror4.isWordChar = isWordCharBasic;
          CodeMirror4.Pass = Pass;
          CodeMirror4.signal = signal7;
          CodeMirror4.Line = Line;
          CodeMirror4.changeEnd = changeEnd;
          CodeMirror4.scrollbarModel = scrollbarModel;
          CodeMirror4.Pos = Pos;
          CodeMirror4.cmpPos = cmp;
          CodeMirror4.modes = modes;
          CodeMirror4.mimeModes = mimeModes;
          CodeMirror4.resolveMode = resolveMode;
          CodeMirror4.getMode = getMode;
          CodeMirror4.modeExtensions = modeExtensions;
          CodeMirror4.extendMode = extendMode;
          CodeMirror4.copyState = copyState;
          CodeMirror4.startState = startState;
          CodeMirror4.innerMode = innerMode;
          CodeMirror4.commands = commands;
          CodeMirror4.keyMap = keyMap;
          CodeMirror4.keyName = keyName;
          CodeMirror4.isModifierKey = isModifierKey;
          CodeMirror4.lookupKey = lookupKey;
          CodeMirror4.normalizeKeyMap = normalizeKeyMap;
          CodeMirror4.StringStream = StringStream;
          CodeMirror4.SharedTextMarker = SharedTextMarker;
          CodeMirror4.TextMarker = TextMarker;
          CodeMirror4.LineWidget = LineWidget;
          CodeMirror4.e_preventDefault = e_preventDefault;
          CodeMirror4.e_stopPropagation = e_stopPropagation;
          CodeMirror4.e_stop = e_stop;
          CodeMirror4.addClass = addClass;
          CodeMirror4.contains = contains;
          CodeMirror4.rmClass = rmClass;
          CodeMirror4.keyNames = keyNames;
        }
        defineOptions(CodeMirror3);
        addEditorMethods(CodeMirror3);
        var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
        for (var prop in Doc.prototype) {
          if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
            CodeMirror3.prototype[prop] = /* @__PURE__ */ function(method) {
              return function() {
                return method.apply(this.doc, arguments);
              };
            }(Doc.prototype[prop]);
          }
        }
        eventMixin(Doc);
        CodeMirror3.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };
        CodeMirror3.defineMode = function(name2) {
          if (!CodeMirror3.defaults.mode && name2 != "null") {
            CodeMirror3.defaults.mode = name2;
          }
          defineMode.apply(this, arguments);
        };
        CodeMirror3.defineMIME = defineMIME;
        CodeMirror3.defineMode("null", function() {
          return { token: function(stream) {
            return stream.skipToEnd();
          } };
        });
        CodeMirror3.defineMIME("text/plain", "null");
        CodeMirror3.defineExtension = function(name2, func) {
          CodeMirror3.prototype[name2] = func;
        };
        CodeMirror3.defineDocExtension = function(name2, func) {
          Doc.prototype[name2] = func;
        };
        CodeMirror3.fromTextArea = fromTextArea;
        addLegacyProps(CodeMirror3);
        CodeMirror3.version = "5.65.17";
        return CodeMirror3;
      });
    }
  });

  // ../../node_modules/codemirror/mode/xml/xml.js
  var require_xml = __commonJS({
    "../../node_modules/codemirror/mode/xml/xml.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        var htmlConfig = {
          autoSelfClosers: {
            "area": true,
            "base": true,
            "br": true,
            "col": true,
            "command": true,
            "embed": true,
            "frame": true,
            "hr": true,
            "img": true,
            "input": true,
            "keygen": true,
            "link": true,
            "meta": true,
            "param": true,
            "source": true,
            "track": true,
            "wbr": true,
            "menuitem": true
          },
          implicitlyClosed: {
            "dd": true,
            "li": true,
            "optgroup": true,
            "option": true,
            "p": true,
            "rp": true,
            "rt": true,
            "tbody": true,
            "td": true,
            "tfoot": true,
            "th": true,
            "tr": true
          },
          contextGrabbers: {
            "dd": { "dd": true, "dt": true },
            "dt": { "dd": true, "dt": true },
            "li": { "li": true },
            "option": { "option": true, "optgroup": true },
            "optgroup": { "optgroup": true },
            "p": {
              "address": true,
              "article": true,
              "aside": true,
              "blockquote": true,
              "dir": true,
              "div": true,
              "dl": true,
              "fieldset": true,
              "footer": true,
              "form": true,
              "h1": true,
              "h2": true,
              "h3": true,
              "h4": true,
              "h5": true,
              "h6": true,
              "header": true,
              "hgroup": true,
              "hr": true,
              "menu": true,
              "nav": true,
              "ol": true,
              "p": true,
              "pre": true,
              "section": true,
              "table": true,
              "ul": true
            },
            "rp": { "rp": true, "rt": true },
            "rt": { "rp": true, "rt": true },
            "tbody": { "tbody": true, "tfoot": true },
            "td": { "td": true, "th": true },
            "tfoot": { "tbody": true },
            "th": { "td": true, "th": true },
            "thead": { "tbody": true, "tfoot": true },
            "tr": { "tr": true }
          },
          doNotIndent: { "pre": true },
          allowUnquoted: true,
          allowMissing: true,
          caseFold: true
        };
        var xmlConfig = {
          autoSelfClosers: {},
          implicitlyClosed: {},
          contextGrabbers: {},
          doNotIndent: {},
          allowUnquoted: false,
          allowMissing: false,
          allowMissingTagName: false,
          caseFold: false
        };
        CodeMirror3.defineMode("xml", function(editorConf, config_) {
          var indentUnit = editorConf.indentUnit;
          var config = {};
          var defaults = config_.htmlMode ? htmlConfig : xmlConfig;
          for (var prop in defaults) config[prop] = defaults[prop];
          for (var prop in config_) config[prop] = config_[prop];
          var type, setStyle;
          function inText(stream, state) {
            function chain(parser2) {
              state.tokenize = parser2;
              return parser2(stream, state);
            }
            var ch = stream.next();
            if (ch == "<") {
              if (stream.eat("!")) {
                if (stream.eat("[")) {
                  if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
                  else return null;
                } else if (stream.match("--")) {
                  return chain(inBlock("comment", "-->"));
                } else if (stream.match("DOCTYPE", true, true)) {
                  stream.eatWhile(/[\w\._\-]/);
                  return chain(doctype(1));
                } else {
                  return null;
                }
              } else if (stream.eat("?")) {
                stream.eatWhile(/[\w\._\-]/);
                state.tokenize = inBlock("meta", "?>");
                return "meta";
              } else {
                type = stream.eat("/") ? "closeTag" : "openTag";
                state.tokenize = inTag;
                return "tag bracket";
              }
            } else if (ch == "&") {
              var ok;
              if (stream.eat("#")) {
                if (stream.eat("x")) {
                  ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
                } else {
                  ok = stream.eatWhile(/[\d]/) && stream.eat(";");
                }
              } else {
                ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
              }
              return ok ? "atom" : "error";
            } else {
              stream.eatWhile(/[^&<]/);
              return null;
            }
          }
          inText.isInText = true;
          function inTag(stream, state) {
            var ch = stream.next();
            if (ch == ">" || ch == "/" && stream.eat(">")) {
              state.tokenize = inText;
              type = ch == ">" ? "endTag" : "selfcloseTag";
              return "tag bracket";
            } else if (ch == "=") {
              type = "equals";
              return null;
            } else if (ch == "<") {
              state.tokenize = inText;
              state.state = baseState;
              state.tagName = state.tagStart = null;
              var next = state.tokenize(stream, state);
              return next ? next + " tag error" : "tag error";
            } else if (/[\'\"]/.test(ch)) {
              state.tokenize = inAttribute(ch);
              state.stringStartCol = stream.column();
              return state.tokenize(stream, state);
            } else {
              stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
              return "word";
            }
          }
          function inAttribute(quote) {
            var closure = function(stream, state) {
              while (!stream.eol()) {
                if (stream.next() == quote) {
                  state.tokenize = inTag;
                  break;
                }
              }
              return "string";
            };
            closure.isInAttribute = true;
            return closure;
          }
          function inBlock(style, terminator) {
            return function(stream, state) {
              while (!stream.eol()) {
                if (stream.match(terminator)) {
                  state.tokenize = inText;
                  break;
                }
                stream.next();
              }
              return style;
            };
          }
          function doctype(depth) {
            return function(stream, state) {
              var ch;
              while ((ch = stream.next()) != null) {
                if (ch == "<") {
                  state.tokenize = doctype(depth + 1);
                  return state.tokenize(stream, state);
                } else if (ch == ">") {
                  if (depth == 1) {
                    state.tokenize = inText;
                    break;
                  } else {
                    state.tokenize = doctype(depth - 1);
                    return state.tokenize(stream, state);
                  }
                }
              }
              return "meta";
            };
          }
          function lower(tagName) {
            return tagName && tagName.toLowerCase();
          }
          function Context(state, tagName, startOfLine) {
            this.prev = state.context;
            this.tagName = tagName || "";
            this.indent = state.indented;
            this.startOfLine = startOfLine;
            if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent)
              this.noIndent = true;
          }
          function popContext(state) {
            if (state.context) state.context = state.context.prev;
          }
          function maybePopContext(state, nextTagName) {
            var parentTagName;
            while (true) {
              if (!state.context) {
                return;
              }
              parentTagName = state.context.tagName;
              if (!config.contextGrabbers.hasOwnProperty(lower(parentTagName)) || !config.contextGrabbers[lower(parentTagName)].hasOwnProperty(lower(nextTagName))) {
                return;
              }
              popContext(state);
            }
          }
          function baseState(type2, stream, state) {
            if (type2 == "openTag") {
              state.tagStart = stream.column();
              return tagNameState;
            } else if (type2 == "closeTag") {
              return closeTagNameState;
            } else {
              return baseState;
            }
          }
          function tagNameState(type2, stream, state) {
            if (type2 == "word") {
              state.tagName = stream.current();
              setStyle = "tag";
              return attrState;
            } else if (config.allowMissingTagName && type2 == "endTag") {
              setStyle = "tag bracket";
              return attrState(type2, stream, state);
            } else {
              setStyle = "error";
              return tagNameState;
            }
          }
          function closeTagNameState(type2, stream, state) {
            if (type2 == "word") {
              var tagName = stream.current();
              if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(lower(state.context.tagName)))
                popContext(state);
              if (state.context && state.context.tagName == tagName || config.matchClosing === false) {
                setStyle = "tag";
                return closeState;
              } else {
                setStyle = "tag error";
                return closeStateErr;
              }
            } else if (config.allowMissingTagName && type2 == "endTag") {
              setStyle = "tag bracket";
              return closeState(type2, stream, state);
            } else {
              setStyle = "error";
              return closeStateErr;
            }
          }
          function closeState(type2, _stream, state) {
            if (type2 != "endTag") {
              setStyle = "error";
              return closeState;
            }
            popContext(state);
            return baseState;
          }
          function closeStateErr(type2, stream, state) {
            setStyle = "error";
            return closeState(type2, stream, state);
          }
          function attrState(type2, _stream, state) {
            if (type2 == "word") {
              setStyle = "attribute";
              return attrEqState;
            } else if (type2 == "endTag" || type2 == "selfcloseTag") {
              var tagName = state.tagName, tagStart = state.tagStart;
              state.tagName = state.tagStart = null;
              if (type2 == "selfcloseTag" || config.autoSelfClosers.hasOwnProperty(lower(tagName))) {
                maybePopContext(state, tagName);
              } else {
                maybePopContext(state, tagName);
                state.context = new Context(state, tagName, tagStart == state.indented);
              }
              return baseState;
            }
            setStyle = "error";
            return attrState;
          }
          function attrEqState(type2, stream, state) {
            if (type2 == "equals") return attrValueState;
            if (!config.allowMissing) setStyle = "error";
            return attrState(type2, stream, state);
          }
          function attrValueState(type2, stream, state) {
            if (type2 == "string") return attrContinuedState;
            if (type2 == "word" && config.allowUnquoted) {
              setStyle = "string";
              return attrState;
            }
            setStyle = "error";
            return attrState(type2, stream, state);
          }
          function attrContinuedState(type2, stream, state) {
            if (type2 == "string") return attrContinuedState;
            return attrState(type2, stream, state);
          }
          return {
            startState: function(baseIndent) {
              var state = {
                tokenize: inText,
                state: baseState,
                indented: baseIndent || 0,
                tagName: null,
                tagStart: null,
                context: null
              };
              if (baseIndent != null) state.baseIndent = baseIndent;
              return state;
            },
            token: function(stream, state) {
              if (!state.tagName && stream.sol())
                state.indented = stream.indentation();
              if (stream.eatSpace()) return null;
              type = null;
              var style = state.tokenize(stream, state);
              if ((style || type) && style != "comment") {
                setStyle = null;
                state.state = state.state(type || style, stream, state);
                if (setStyle)
                  style = setStyle == "error" ? style + " error" : setStyle;
              }
              return style;
            },
            indent: function(state, textAfter, fullLine) {
              var context = state.context;
              if (state.tokenize.isInAttribute) {
                if (state.tagStart == state.indented)
                  return state.stringStartCol + 1;
                else
                  return state.indented + indentUnit;
              }
              if (context && context.noIndent) return CodeMirror3.Pass;
              if (state.tokenize != inTag && state.tokenize != inText)
                return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
              if (state.tagName) {
                if (config.multilineTagIndentPastTag !== false)
                  return state.tagStart + state.tagName.length + 2;
                else
                  return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
              }
              if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
              var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
              if (tagAfter && tagAfter[1]) {
                while (context) {
                  if (context.tagName == tagAfter[2]) {
                    context = context.prev;
                    break;
                  } else if (config.implicitlyClosed.hasOwnProperty(lower(context.tagName))) {
                    context = context.prev;
                  } else {
                    break;
                  }
                }
              } else if (tagAfter) {
                while (context) {
                  var grabbers = config.contextGrabbers[lower(context.tagName)];
                  if (grabbers && grabbers.hasOwnProperty(lower(tagAfter[2])))
                    context = context.prev;
                  else
                    break;
                }
              }
              while (context && context.prev && !context.startOfLine)
                context = context.prev;
              if (context) return context.indent + indentUnit;
              else return state.baseIndent || 0;
            },
            electricInput: /<\/[\s\w:]+>$/,
            blockCommentStart: "<!--",
            blockCommentEnd: "-->",
            configuration: config.htmlMode ? "html" : "xml",
            helperType: config.htmlMode ? "html" : "xml",
            skipAttribute: function(state) {
              if (state.state == attrValueState)
                state.state = attrState;
            },
            xmlCurrentTag: function(state) {
              return state.tagName ? { name: state.tagName, close: state.type == "closeTag" } : null;
            },
            xmlCurrentContext: function(state) {
              var context = [];
              for (var cx = state.context; cx; cx = cx.prev)
                context.push(cx.tagName);
              return context.reverse();
            }
          };
        });
        CodeMirror3.defineMIME("text/xml", "xml");
        CodeMirror3.defineMIME("application/xml", "xml");
        if (!CodeMirror3.mimeModes.hasOwnProperty("text/html"))
          CodeMirror3.defineMIME("text/html", { name: "xml", htmlMode: true });
      });
    }
  });

  // ../../node_modules/codemirror/mode/meta.js
  var require_meta = __commonJS({
    "../../node_modules/codemirror/mode/meta.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.modeInfo = [
          { name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"] },
          { name: "PGP", mimes: ["application/pgp", "application/pgp-encrypted", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["asc", "pgp", "sig"] },
          { name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"] },
          { name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i },
          { name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"] },
          { name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h", "ino"] },
          { name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"] },
          { name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy", "cbl"] },
          { name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp", "cs"] },
          { name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"] },
          { name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"] },
          { name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"] },
          { name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists\.txt$/ },
          { name: "CoffeeScript", mimes: ["application/vnd.coffeescript", "text/coffeescript", "text/x-coffeescript"], mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"] },
          { name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"] },
          { name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"] },
          { name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"] },
          { name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"] },
          { name: "CSS", mime: "text/css", mode: "css", ext: ["css"] },
          { name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"] },
          { name: "D", mime: "text/x-d", mode: "d", ext: ["d"] },
          { name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"] },
          { name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"] },
          { name: "Django", mime: "text/x-django", mode: "django" },
          { name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/ },
          { name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"] },
          { name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"] },
          { name: "EBNF", mime: "text/x-ebnf", mode: "ebnf" },
          { name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"] },
          { name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"] },
          { name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"] },
          { name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"] },
          { name: "Embedded JavaScript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"] },
          { name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"] },
          { name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"] },
          { name: "Esper", mime: "text/x-esper", mode: "sql" },
          { name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"] },
          { name: "FCL", mime: "text/x-fcl", mode: "fcl" },
          { name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"] },
          { name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90", "f95"] },
          { name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"] },
          { name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"] },
          { name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"] },
          { name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history)\.md$/i },
          { name: "Go", mime: "text/x-go", mode: "go", ext: ["go"] },
          { name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"], file: /^Jenkinsfile$/ },
          { name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"] },
          { name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"] },
          { name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"] },
          { name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"] },
          { name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"] },
          { name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"] },
          { name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm", "handlebars", "hbs"], alias: ["xhtml"] },
          { name: "HTTP", mime: "message/http", mode: "http" },
          { name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"] },
          { name: "Pug", mime: "text/x-pug", mode: "pug", ext: ["jade", "pug"], alias: ["jade"] },
          { name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"] },
          { name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"] },
          {
            name: "JavaScript",
            mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
            mode: "javascript",
            ext: ["js"],
            alias: ["ecmascript", "js", "node"]
          },
          { name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"] },
          { name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"] },
          { name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"] },
          { name: "Jinja2", mime: "text/jinja2", mode: "jinja2", ext: ["j2", "jinja", "jinja2"] },
          { name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"], alias: ["jl"] },
          { name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"] },
          { name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"] },
          { name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"] },
          { name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"] },
          { name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"] },
          { name: "mIRC", mime: "text/mirc", mode: "mirc" },
          { name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql" },
          { name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb", "wl", "wls"] },
          { name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"] },
          { name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"] },
          { name: "MS SQL", mime: "text/x-mssql", mode: "sql" },
          { name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"] },
          { name: "MySQL", mime: "text/x-mysql", mode: "sql" },
          { name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i },
          { name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"] },
          {
            name: "NTriples",
            mimes: ["application/n-triples", "application/n-quads", "text/n-triples"],
            mode: "ntriples",
            ext: ["nt", "nq"]
          },
          { name: "Objective-C", mime: "text/x-objectivec", mode: "clike", ext: ["m"], alias: ["objective-c", "objc"] },
          { name: "Objective-C++", mime: "text/x-objectivec++", mode: "clike", ext: ["mm"], alias: ["objective-c++", "objc++"] },
          { name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"] },
          { name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"] },
          { name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"] },
          { name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"] },
          { name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"] },
          { name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"] },
          { name: "PHP", mimes: ["text/x-php", "application/x-httpd-php", "application/x-httpd-php-open"], mode: "php", ext: ["php", "php3", "php4", "php5", "php7", "phtml"] },
          { name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"] },
          { name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"] },
          { name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"] },
          { name: "PostgreSQL", mime: "text/x-pgsql", mode: "sql" },
          { name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"] },
          { name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"] },
          { name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"] },
          { name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/ },
          { name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"] },
          { name: "Q", mime: "text/x-q", mode: "q", ext: ["q"] },
          { name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r", "R"], alias: ["rscript"] },
          { name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"] },
          { name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm" },
          { name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"] },
          { name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"] },
          { name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"] },
          { name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"] },
          { name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"] },
          { name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"] },
          { name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"] },
          { name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"] },
          { name: "Shell", mimes: ["text/x-sh", "application/x-sh"], mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/ },
          { name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"] },
          { name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"] },
          { name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"] },
          { name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"] },
          { name: "Solr", mime: "text/x-solr", mode: "solr" },
          { name: "SML", mime: "text/x-sml", mode: "mllike", ext: ["sml", "sig", "fun", "smackspec"] },
          { name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"] },
          { name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"] },
          { name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"] },
          { name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"] },
          { name: "SQLite", mime: "text/x-sqlite", mode: "sql" },
          { name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"] },
          { name: "Stylus", mime: "text/x-styl", mode: "stylus", ext: ["styl"] },
          { name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"] },
          { name: "sTeX", mime: "text/x-stex", mode: "stex" },
          { name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx", "tex"], alias: ["tex"] },
          { name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v", "sv", "svh"] },
          { name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"] },
          { name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"] },
          { name: "TiddlyWiki", mime: "text/x-tiddlywiki", mode: "tiddlywiki" },
          { name: "Tiki wiki", mime: "text/tiki", mode: "tiki" },
          { name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"] },
          { name: "Tornado", mime: "text/x-tornado", mode: "tornado" },
          { name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"] },
          { name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"] },
          { name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"] },
          { name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"] },
          { name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"] },
          { name: "TypeScript-JSX", mime: "text/typescript-jsx", mode: "jsx", ext: ["tsx"], alias: ["tsx"] },
          { name: "Twig", mime: "text/x-twig", mode: "twig" },
          { name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"] },
          { name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"] },
          { name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"] },
          { name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"] },
          { name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"] },
          { name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"] },
          { name: "Vue.js Component", mimes: ["script/x-vue", "text/x-vue"], mode: "vue", ext: ["vue"] },
          { name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd", "svg"], alias: ["rss", "wsdl", "xsd"] },
          { name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"] },
          { name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"] },
          { name: "YAML", mimes: ["text/x-yaml", "text/yaml"], mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"] },
          { name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"] },
          { name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"] },
          { name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"] },
          { name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"] },
          { name: "WebAssembly", mime: "text/webassembly", mode: "wast", ext: ["wat", "wast"] }
        ];
        for (var i = 0; i < CodeMirror3.modeInfo.length; i++) {
          var info = CodeMirror3.modeInfo[i];
          if (info.mimes) info.mime = info.mimes[0];
        }
        CodeMirror3.findModeByMIME = function(mime) {
          mime = mime.toLowerCase();
          for (var i2 = 0; i2 < CodeMirror3.modeInfo.length; i2++) {
            var info2 = CodeMirror3.modeInfo[i2];
            if (info2.mime == mime) return info2;
            if (info2.mimes) {
              for (var j = 0; j < info2.mimes.length; j++)
                if (info2.mimes[j] == mime) return info2;
            }
          }
          if (/\+xml$/.test(mime)) return CodeMirror3.findModeByMIME("application/xml");
          if (/\+json$/.test(mime)) return CodeMirror3.findModeByMIME("application/json");
        };
        CodeMirror3.findModeByExtension = function(ext) {
          ext = ext.toLowerCase();
          for (var i2 = 0; i2 < CodeMirror3.modeInfo.length; i2++) {
            var info2 = CodeMirror3.modeInfo[i2];
            if (info2.ext) {
              for (var j = 0; j < info2.ext.length; j++)
                if (info2.ext[j] == ext) return info2;
            }
          }
        };
        CodeMirror3.findModeByFileName = function(filename) {
          for (var i2 = 0; i2 < CodeMirror3.modeInfo.length; i2++) {
            var info2 = CodeMirror3.modeInfo[i2];
            if (info2.file && info2.file.test(filename)) return info2;
          }
          var dot = filename.lastIndexOf(".");
          var ext = dot > -1 && filename.substring(dot + 1, filename.length);
          if (ext) return CodeMirror3.findModeByExtension(ext);
        };
        CodeMirror3.findModeByName = function(name2) {
          name2 = name2.toLowerCase();
          for (var i2 = 0; i2 < CodeMirror3.modeInfo.length; i2++) {
            var info2 = CodeMirror3.modeInfo[i2];
            if (info2.name.toLowerCase() == name2) return info2;
            if (info2.alias) {
              for (var j = 0; j < info2.alias.length; j++)
                if (info2.alias[j].toLowerCase() == name2) return info2;
            }
          }
        };
      });
    }
  });

  // ../../node_modules/codemirror/mode/markdown/markdown.js
  var require_markdown = __commonJS({
    "../../node_modules/codemirror/mode/markdown/markdown.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror(), require_xml(), require_meta());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror", "../xml/xml", "../meta"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("markdown", function(cmCfg, modeCfg) {
          var htmlMode = CodeMirror3.getMode(cmCfg, "text/html");
          var htmlModeMissing = htmlMode.name == "null";
          function getMode(name2) {
            if (CodeMirror3.findModeByName) {
              var found = CodeMirror3.findModeByName(name2);
              if (found) name2 = found.mime || found.mimes[0];
            }
            var mode2 = CodeMirror3.getMode(cmCfg, name2);
            return mode2.name == "null" ? null : mode2;
          }
          if (modeCfg.highlightFormatting === void 0)
            modeCfg.highlightFormatting = false;
          if (modeCfg.maxBlockquoteDepth === void 0)
            modeCfg.maxBlockquoteDepth = 0;
          if (modeCfg.taskLists === void 0) modeCfg.taskLists = false;
          if (modeCfg.strikethrough === void 0)
            modeCfg.strikethrough = false;
          if (modeCfg.emoji === void 0)
            modeCfg.emoji = false;
          if (modeCfg.fencedCodeBlockHighlighting === void 0)
            modeCfg.fencedCodeBlockHighlighting = true;
          if (modeCfg.fencedCodeBlockDefaultMode === void 0)
            modeCfg.fencedCodeBlockDefaultMode = "text/plain";
          if (modeCfg.xml === void 0)
            modeCfg.xml = true;
          if (modeCfg.tokenTypeOverrides === void 0)
            modeCfg.tokenTypeOverrides = {};
          var tokenTypes = {
            header: "header",
            code: "comment",
            quote: "quote",
            list1: "variable-2",
            list2: "variable-3",
            list3: "keyword",
            hr: "hr",
            image: "image",
            imageAltText: "image-alt-text",
            imageMarker: "image-marker",
            formatting: "formatting",
            linkInline: "link",
            linkEmail: "link",
            linkText: "link",
            linkHref: "string",
            em: "em",
            strong: "strong",
            strikethrough: "strikethrough",
            emoji: "builtin"
          };
          for (var tokenType in tokenTypes) {
            if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {
              tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];
            }
          }
          var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/, listRE = /^(?:[*\-+]|^[0-9]+([.)]))\s+/, taskListRE = /^\[(x| )\](?=\s)/i, atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/, setextHeaderRE = /^ {0,3}(?:\={1,}|-{2,})\s*$/, textRE = /^[^#!\[\]*_\\<>` "'(~:]+/, fencedCodeRE = /^(~~~+|```+)[ \t]*([\w\/+#-]*)[^\n`]*$/, linkDefRE = /^\s*\[[^\]]+?\]:.*$/, punctuation2 = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/, expandedTab = "    ";
          function switchInline(stream, state, f) {
            state.f = state.inline = f;
            return f(stream, state);
          }
          function switchBlock(stream, state, f) {
            state.f = state.block = f;
            return f(stream, state);
          }
          function lineIsEmpty(line) {
            return !line || !/\S/.test(line.string);
          }
          function blankLine(state) {
            state.linkTitle = false;
            state.linkHref = false;
            state.linkText = false;
            state.em = false;
            state.strong = false;
            state.strikethrough = false;
            state.quote = 0;
            state.indentedCode = false;
            if (state.f == htmlBlock) {
              var exit = htmlModeMissing;
              if (!exit) {
                var inner = CodeMirror3.innerMode(htmlMode, state.htmlState);
                exit = inner.mode.name == "xml" && inner.state.tagStart === null && (!inner.state.context && inner.state.tokenize.isInText);
              }
              if (exit) {
                state.f = inlineNormal2;
                state.block = blockNormal2;
                state.htmlState = null;
              }
            }
            state.trailingSpace = 0;
            state.trailingSpaceNewLine = false;
            state.prevLine = state.thisLine;
            state.thisLine = { stream: null };
            return null;
          }
          function blockNormal2(stream, state) {
            var firstTokenOnLine = stream.column() === state.indentation;
            var prevLineLineIsEmpty = lineIsEmpty(state.prevLine.stream);
            var prevLineIsIndentedCode = state.indentedCode;
            var prevLineIsHr = state.prevLine.hr;
            var prevLineIsList = state.list !== false;
            var maxNonCodeIndentation = (state.listStack[state.listStack.length - 1] || 0) + 3;
            state.indentedCode = false;
            var lineIndentation = state.indentation;
            if (state.indentationDiff === null) {
              state.indentationDiff = state.indentation;
              if (prevLineIsList) {
                state.list = null;
                while (lineIndentation < state.listStack[state.listStack.length - 1]) {
                  state.listStack.pop();
                  if (state.listStack.length) {
                    state.indentation = state.listStack[state.listStack.length - 1];
                  } else {
                    state.list = false;
                  }
                }
                if (state.list !== false) {
                  state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1];
                }
              }
            }
            var allowsInlineContinuation = !prevLineLineIsEmpty && !prevLineIsHr && !state.prevLine.header && (!prevLineIsList || !prevLineIsIndentedCode) && !state.prevLine.fencedCodeEnd;
            var isHr = (state.list === false || prevLineIsHr || prevLineLineIsEmpty) && state.indentation <= maxNonCodeIndentation && stream.match(hrRE);
            var match = null;
            if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || state.prevLine.fencedCodeEnd || state.prevLine.header || prevLineLineIsEmpty)) {
              stream.skipToEnd();
              state.indentedCode = true;
              return tokenTypes.code;
            } else if (stream.eatSpace()) {
              return null;
            } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(atxHeaderRE)) && match[1].length <= 6) {
              state.quote = 0;
              state.header = match[1].length;
              state.thisLine.header = true;
              if (modeCfg.highlightFormatting) state.formatting = "header";
              state.f = state.inline;
              return getType(state);
            } else if (state.indentation <= maxNonCodeIndentation && stream.eat(">")) {
              state.quote = firstTokenOnLine ? 1 : state.quote + 1;
              if (modeCfg.highlightFormatting) state.formatting = "quote";
              stream.eatSpace();
              return getType(state);
            } else if (!isHr && !state.setext && firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(listRE))) {
              var listType = match[1] ? "ol" : "ul";
              state.indentation = lineIndentation + stream.current().length;
              state.list = true;
              state.quote = 0;
              state.listStack.push(state.indentation);
              state.em = false;
              state.strong = false;
              state.code = false;
              state.strikethrough = false;
              if (modeCfg.taskLists && stream.match(taskListRE, false)) {
                state.taskList = true;
              }
              state.f = state.inline;
              if (modeCfg.highlightFormatting) state.formatting = ["list", "list-" + listType];
              return getType(state);
            } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(fencedCodeRE, true))) {
              state.quote = 0;
              state.fencedEndRE = new RegExp(match[1] + "+ *$");
              state.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match[2] || modeCfg.fencedCodeBlockDefaultMode);
              if (state.localMode) state.localState = CodeMirror3.startState(state.localMode);
              state.f = state.block = local;
              if (modeCfg.highlightFormatting) state.formatting = "code-block";
              state.code = -1;
              return getType(state);
            } else if (
              // if setext set, indicates line after ---/===
              state.setext || // line before ---/===
              (!allowsInlineContinuation || !prevLineIsList) && !state.quote && state.list === false && !state.code && !isHr && !linkDefRE.test(stream.string) && (match = stream.lookAhead(1)) && (match = match.match(setextHeaderRE))
            ) {
              if (!state.setext) {
                state.header = match[0].charAt(0) == "=" ? 1 : 2;
                state.setext = state.header;
              } else {
                state.header = state.setext;
                state.setext = 0;
                stream.skipToEnd();
                if (modeCfg.highlightFormatting) state.formatting = "header";
              }
              state.thisLine.header = true;
              state.f = state.inline;
              return getType(state);
            } else if (isHr) {
              stream.skipToEnd();
              state.hr = true;
              state.thisLine.hr = true;
              return tokenTypes.hr;
            } else if (stream.peek() === "[") {
              return switchInline(stream, state, footnoteLink);
            }
            return switchInline(stream, state, state.inline);
          }
          function htmlBlock(stream, state) {
            var style = htmlMode.token(stream, state.htmlState);
            if (!htmlModeMissing) {
              var inner = CodeMirror3.innerMode(htmlMode, state.htmlState);
              if (inner.mode.name == "xml" && inner.state.tagStart === null && (!inner.state.context && inner.state.tokenize.isInText) || state.md_inside && stream.current().indexOf(">") > -1) {
                state.f = inlineNormal2;
                state.block = blockNormal2;
                state.htmlState = null;
              }
            }
            return style;
          }
          function local(stream, state) {
            var currListInd = state.listStack[state.listStack.length - 1] || 0;
            var hasExitedList = state.indentation < currListInd;
            var maxFencedEndInd = currListInd + 3;
            if (state.fencedEndRE && state.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state.fencedEndRE))) {
              if (modeCfg.highlightFormatting) state.formatting = "code-block";
              var returnType;
              if (!hasExitedList) returnType = getType(state);
              state.localMode = state.localState = null;
              state.block = blockNormal2;
              state.f = inlineNormal2;
              state.fencedEndRE = null;
              state.code = 0;
              state.thisLine.fencedCodeEnd = true;
              if (hasExitedList) return switchBlock(stream, state, state.block);
              return returnType;
            } else if (state.localMode) {
              return state.localMode.token(stream, state.localState);
            } else {
              stream.skipToEnd();
              return tokenTypes.code;
            }
          }
          function getType(state) {
            var styles = [];
            if (state.formatting) {
              styles.push(tokenTypes.formatting);
              if (typeof state.formatting === "string") state.formatting = [state.formatting];
              for (var i = 0; i < state.formatting.length; i++) {
                styles.push(tokenTypes.formatting + "-" + state.formatting[i]);
                if (state.formatting[i] === "header") {
                  styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.header);
                }
                if (state.formatting[i] === "quote") {
                  if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                    styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.quote);
                  } else {
                    styles.push("error");
                  }
                }
              }
            }
            if (state.taskOpen) {
              styles.push("meta");
              return styles.length ? styles.join(" ") : null;
            }
            if (state.taskClosed) {
              styles.push("property");
              return styles.length ? styles.join(" ") : null;
            }
            if (state.linkHref) {
              styles.push(tokenTypes.linkHref, "url");
            } else {
              if (state.strong) {
                styles.push(tokenTypes.strong);
              }
              if (state.em) {
                styles.push(tokenTypes.em);
              }
              if (state.strikethrough) {
                styles.push(tokenTypes.strikethrough);
              }
              if (state.emoji) {
                styles.push(tokenTypes.emoji);
              }
              if (state.linkText) {
                styles.push(tokenTypes.linkText);
              }
              if (state.code) {
                styles.push(tokenTypes.code);
              }
              if (state.image) {
                styles.push(tokenTypes.image);
              }
              if (state.imageAltText) {
                styles.push(tokenTypes.imageAltText, "link");
              }
              if (state.imageMarker) {
                styles.push(tokenTypes.imageMarker);
              }
            }
            if (state.header) {
              styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header);
            }
            if (state.quote) {
              styles.push(tokenTypes.quote);
              if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                styles.push(tokenTypes.quote + "-" + state.quote);
              } else {
                styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);
              }
            }
            if (state.list !== false) {
              var listMod = (state.listStack.length - 1) % 3;
              if (!listMod) {
                styles.push(tokenTypes.list1);
              } else if (listMod === 1) {
                styles.push(tokenTypes.list2);
              } else {
                styles.push(tokenTypes.list3);
              }
            }
            if (state.trailingSpaceNewLine) {
              styles.push("trailing-space-new-line");
            } else if (state.trailingSpace) {
              styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
            }
            return styles.length ? styles.join(" ") : null;
          }
          function handleText(stream, state) {
            if (stream.match(textRE, true)) {
              return getType(state);
            }
            return void 0;
          }
          function inlineNormal2(stream, state) {
            var style = state.text(stream, state);
            if (typeof style !== "undefined")
              return style;
            if (state.list) {
              state.list = null;
              return getType(state);
            }
            if (state.taskList) {
              var taskOpen = stream.match(taskListRE, true)[1] === " ";
              if (taskOpen) state.taskOpen = true;
              else state.taskClosed = true;
              if (modeCfg.highlightFormatting) state.formatting = "task";
              state.taskList = false;
              return getType(state);
            }
            state.taskOpen = false;
            state.taskClosed = false;
            if (state.header && stream.match(/^#+$/, true)) {
              if (modeCfg.highlightFormatting) state.formatting = "header";
              return getType(state);
            }
            var ch = stream.next();
            if (state.linkTitle) {
              state.linkTitle = false;
              var matchCh = ch;
              if (ch === "(") {
                matchCh = ")";
              }
              matchCh = (matchCh + "").replace(/([.?*+^\[\]\\(){}|-])/g, "\\$1");
              var regex = "^\\s*(?:[^" + matchCh + "\\\\]+|\\\\\\\\|\\\\.)" + matchCh;
              if (stream.match(new RegExp(regex), true)) {
                return tokenTypes.linkHref;
              }
            }
            if (ch === "`") {
              var previousFormatting = state.formatting;
              if (modeCfg.highlightFormatting) state.formatting = "code";
              stream.eatWhile("`");
              var count = stream.current().length;
              if (state.code == 0 && (!state.quote || count == 1)) {
                state.code = count;
                return getType(state);
              } else if (count == state.code) {
                var t = getType(state);
                state.code = 0;
                return t;
              } else {
                state.formatting = previousFormatting;
                return getType(state);
              }
            } else if (state.code) {
              return getType(state);
            }
            if (ch === "\\") {
              stream.next();
              if (modeCfg.highlightFormatting) {
                var type = getType(state);
                var formattingEscape = tokenTypes.formatting + "-escape";
                return type ? type + " " + formattingEscape : formattingEscape;
              }
            }
            if (ch === "!" && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
              state.imageMarker = true;
              state.image = true;
              if (modeCfg.highlightFormatting) state.formatting = "image";
              return getType(state);
            }
            if (ch === "[" && state.imageMarker && stream.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, false)) {
              state.imageMarker = false;
              state.imageAltText = true;
              if (modeCfg.highlightFormatting) state.formatting = "image";
              return getType(state);
            }
            if (ch === "]" && state.imageAltText) {
              if (modeCfg.highlightFormatting) state.formatting = "image";
              var type = getType(state);
              state.imageAltText = false;
              state.image = false;
              state.inline = state.f = linkHref;
              return type;
            }
            if (ch === "[" && !state.image) {
              if (state.linkText && stream.match(/^.*?\]/)) return getType(state);
              state.linkText = true;
              if (modeCfg.highlightFormatting) state.formatting = "link";
              return getType(state);
            }
            if (ch === "]" && state.linkText) {
              if (modeCfg.highlightFormatting) state.formatting = "link";
              var type = getType(state);
              state.linkText = false;
              state.inline = state.f = stream.match(/\(.*?\)| ?\[.*?\]/, false) ? linkHref : inlineNormal2;
              return type;
            }
            if (ch === "<" && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
              state.f = state.inline = linkInline;
              if (modeCfg.highlightFormatting) state.formatting = "link";
              var type = getType(state);
              if (type) {
                type += " ";
              } else {
                type = "";
              }
              return type + tokenTypes.linkInline;
            }
            if (ch === "<" && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
              state.f = state.inline = linkInline;
              if (modeCfg.highlightFormatting) state.formatting = "link";
              var type = getType(state);
              if (type) {
                type += " ";
              } else {
                type = "";
              }
              return type + tokenTypes.linkEmail;
            }
            if (modeCfg.xml && ch === "<" && stream.match(/^(!--|\?|!\[CDATA\[|[a-z][a-z0-9-]*(?:\s+[a-z_:.\-]+(?:\s*=\s*[^>]+)?)*\s*(?:>|$))/i, false)) {
              var end = stream.string.indexOf(">", stream.pos);
              if (end != -1) {
                var atts = stream.string.substring(stream.start, end);
                if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) state.md_inside = true;
              }
              stream.backUp(1);
              state.htmlState = CodeMirror3.startState(htmlMode);
              return switchBlock(stream, state, htmlBlock);
            }
            if (modeCfg.xml && ch === "<" && stream.match(/^\/\w*?>/)) {
              state.md_inside = false;
              return "tag";
            } else if (ch === "*" || ch === "_") {
              var len = 1, before = stream.pos == 1 ? " " : stream.string.charAt(stream.pos - 2);
              while (len < 3 && stream.eat(ch)) len++;
              var after = stream.peek() || " ";
              var leftFlanking = !/\s/.test(after) && (!punctuation2.test(after) || /\s/.test(before) || punctuation2.test(before));
              var rightFlanking = !/\s/.test(before) && (!punctuation2.test(before) || /\s/.test(after) || punctuation2.test(after));
              var setEm = null, setStrong = null;
              if (len % 2) {
                if (!state.em && leftFlanking && (ch === "*" || !rightFlanking || punctuation2.test(before)))
                  setEm = true;
                else if (state.em == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation2.test(after)))
                  setEm = false;
              }
              if (len > 1) {
                if (!state.strong && leftFlanking && (ch === "*" || !rightFlanking || punctuation2.test(before)))
                  setStrong = true;
                else if (state.strong == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation2.test(after)))
                  setStrong = false;
              }
              if (setStrong != null || setEm != null) {
                if (modeCfg.highlightFormatting) state.formatting = setEm == null ? "strong" : setStrong == null ? "em" : "strong em";
                if (setEm === true) state.em = ch;
                if (setStrong === true) state.strong = ch;
                var t = getType(state);
                if (setEm === false) state.em = false;
                if (setStrong === false) state.strong = false;
                return t;
              }
            } else if (ch === " ") {
              if (stream.eat("*") || stream.eat("_")) {
                if (stream.peek() === " ") {
                  return getType(state);
                } else {
                  stream.backUp(1);
                }
              }
            }
            if (modeCfg.strikethrough) {
              if (ch === "~" && stream.eatWhile(ch)) {
                if (state.strikethrough) {
                  if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
                  var t = getType(state);
                  state.strikethrough = false;
                  return t;
                } else if (stream.match(/^[^\s]/, false)) {
                  state.strikethrough = true;
                  if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
                  return getType(state);
                }
              } else if (ch === " ") {
                if (stream.match("~~", true)) {
                  if (stream.peek() === " ") {
                    return getType(state);
                  } else {
                    stream.backUp(2);
                  }
                }
              }
            }
            if (modeCfg.emoji && ch === ":" && stream.match(/^(?:[a-z_\d+][a-z_\d+-]*|\-[a-z_\d+][a-z_\d+-]*):/)) {
              state.emoji = true;
              if (modeCfg.highlightFormatting) state.formatting = "emoji";
              var retType = getType(state);
              state.emoji = false;
              return retType;
            }
            if (ch === " ") {
              if (stream.match(/^ +$/, false)) {
                state.trailingSpace++;
              } else if (state.trailingSpace) {
                state.trailingSpaceNewLine = true;
              }
            }
            return getType(state);
          }
          function linkInline(stream, state) {
            var ch = stream.next();
            if (ch === ">") {
              state.f = state.inline = inlineNormal2;
              if (modeCfg.highlightFormatting) state.formatting = "link";
              var type = getType(state);
              if (type) {
                type += " ";
              } else {
                type = "";
              }
              return type + tokenTypes.linkInline;
            }
            stream.match(/^[^>]+/, true);
            return tokenTypes.linkInline;
          }
          function linkHref(stream, state) {
            if (stream.eatSpace()) {
              return null;
            }
            var ch = stream.next();
            if (ch === "(" || ch === "[") {
              state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
              if (modeCfg.highlightFormatting) state.formatting = "link-string";
              state.linkHref = true;
              return getType(state);
            }
            return "error";
          }
          var linkRE = {
            ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
            "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/
          };
          function getLinkHrefInside(endChar) {
            return function(stream, state) {
              var ch = stream.next();
              if (ch === endChar) {
                state.f = state.inline = inlineNormal2;
                if (modeCfg.highlightFormatting) state.formatting = "link-string";
                var returnState = getType(state);
                state.linkHref = false;
                return returnState;
              }
              stream.match(linkRE[endChar]);
              state.linkHref = true;
              return getType(state);
            };
          }
          function footnoteLink(stream, state) {
            if (stream.match(/^([^\]\\]|\\.)*\]:/, false)) {
              state.f = footnoteLinkInside;
              stream.next();
              if (modeCfg.highlightFormatting) state.formatting = "link";
              state.linkText = true;
              return getType(state);
            }
            return switchInline(stream, state, inlineNormal2);
          }
          function footnoteLinkInside(stream, state) {
            if (stream.match("]:", true)) {
              state.f = state.inline = footnoteUrl;
              if (modeCfg.highlightFormatting) state.formatting = "link";
              var returnType = getType(state);
              state.linkText = false;
              return returnType;
            }
            stream.match(/^([^\]\\]|\\.)+/, true);
            return tokenTypes.linkText;
          }
          function footnoteUrl(stream, state) {
            if (stream.eatSpace()) {
              return null;
            }
            stream.match(/^[^\s]+/, true);
            if (stream.peek() === void 0) {
              state.linkTitle = true;
            } else {
              stream.match(/^(?:\s+(?:"(?:[^"\\]|\\.)+"|'(?:[^'\\]|\\.)+'|\((?:[^)\\]|\\.)+\)))?/, true);
            }
            state.f = state.inline = inlineNormal2;
            return tokenTypes.linkHref + " url";
          }
          var mode = {
            startState: function() {
              return {
                f: blockNormal2,
                prevLine: { stream: null },
                thisLine: { stream: null },
                block: blockNormal2,
                htmlState: null,
                indentation: 0,
                inline: inlineNormal2,
                text: handleText,
                formatting: false,
                linkText: false,
                linkHref: false,
                linkTitle: false,
                code: 0,
                em: false,
                strong: false,
                header: 0,
                setext: 0,
                hr: false,
                taskList: false,
                list: false,
                listStack: [],
                quote: 0,
                trailingSpace: 0,
                trailingSpaceNewLine: false,
                strikethrough: false,
                emoji: false,
                fencedEndRE: null
              };
            },
            copyState: function(s) {
              return {
                f: s.f,
                prevLine: s.prevLine,
                thisLine: s.thisLine,
                block: s.block,
                htmlState: s.htmlState && CodeMirror3.copyState(htmlMode, s.htmlState),
                indentation: s.indentation,
                localMode: s.localMode,
                localState: s.localMode ? CodeMirror3.copyState(s.localMode, s.localState) : null,
                inline: s.inline,
                text: s.text,
                formatting: false,
                linkText: s.linkText,
                linkTitle: s.linkTitle,
                linkHref: s.linkHref,
                code: s.code,
                em: s.em,
                strong: s.strong,
                strikethrough: s.strikethrough,
                emoji: s.emoji,
                header: s.header,
                setext: s.setext,
                hr: s.hr,
                taskList: s.taskList,
                list: s.list,
                listStack: s.listStack.slice(0),
                quote: s.quote,
                indentedCode: s.indentedCode,
                trailingSpace: s.trailingSpace,
                trailingSpaceNewLine: s.trailingSpaceNewLine,
                md_inside: s.md_inside,
                fencedEndRE: s.fencedEndRE
              };
            },
            token: function(stream, state) {
              state.formatting = false;
              if (stream != state.thisLine.stream) {
                state.header = 0;
                state.hr = false;
                if (stream.match(/^\s*$/, true)) {
                  blankLine(state);
                  return null;
                }
                state.prevLine = state.thisLine;
                state.thisLine = { stream };
                state.taskList = false;
                state.trailingSpace = 0;
                state.trailingSpaceNewLine = false;
                if (!state.localState) {
                  state.f = state.block;
                  if (state.f != htmlBlock) {
                    var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, expandedTab).length;
                    state.indentation = indentation;
                    state.indentationDiff = null;
                    if (indentation > 0) return null;
                  }
                }
              }
              return state.f(stream, state);
            },
            innerMode: function(state) {
              if (state.block == htmlBlock) return { state: state.htmlState, mode: htmlMode };
              if (state.localState) return { state: state.localState, mode: state.localMode };
              return { state, mode };
            },
            indent: function(state, textAfter, line) {
              if (state.block == htmlBlock && htmlMode.indent) return htmlMode.indent(state.htmlState, textAfter, line);
              if (state.localState && state.localMode.indent) return state.localMode.indent(state.localState, textAfter, line);
              return CodeMirror3.Pass;
            },
            blankLine,
            getType,
            blockCommentStart: "<!--",
            blockCommentEnd: "-->",
            closeBrackets: "()[]{}''\"\"``",
            fold: "markdown"
          };
          return mode;
        }, "xml");
        CodeMirror3.defineMIME("text/markdown", "markdown");
        CodeMirror3.defineMIME("text/x-markdown", "markdown");
      });
    }
  });

  // ../../node_modules/codemirror/mode/css/css.js
  var require_css = __commonJS({
    "../../node_modules/codemirror/mode/css/css.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("css", function(config, parserConfig) {
          var inline2 = parserConfig.inline;
          if (!parserConfig.propertyKeywords) parserConfig = CodeMirror3.resolveMode("text/css");
          var indentUnit = config.indentUnit, tokenHooks = parserConfig.tokenHooks, documentTypes2 = parserConfig.documentTypes || {}, mediaTypes2 = parserConfig.mediaTypes || {}, mediaFeatures2 = parserConfig.mediaFeatures || {}, mediaValueKeywords2 = parserConfig.mediaValueKeywords || {}, propertyKeywords2 = parserConfig.propertyKeywords || {}, nonStandardPropertyKeywords2 = parserConfig.nonStandardPropertyKeywords || {}, fontProperties2 = parserConfig.fontProperties || {}, counterDescriptors2 = parserConfig.counterDescriptors || {}, colorKeywords2 = parserConfig.colorKeywords || {}, valueKeywords2 = parserConfig.valueKeywords || {}, allowNested = parserConfig.allowNested, lineComment = parserConfig.lineComment, supportsAtComponent = parserConfig.supportsAtComponent === true, highlightNonStandardPropertyKeywords = config.highlightNonStandardPropertyKeywords !== false;
          var type, override;
          function ret(style, tp) {
            type = tp;
            return style;
          }
          function tokenBase(stream, state) {
            var ch = stream.next();
            if (tokenHooks[ch]) {
              var result = tokenHooks[ch](stream, state);
              if (result !== false) return result;
            }
            if (ch == "@") {
              stream.eatWhile(/[\w\\\-]/);
              return ret("def", stream.current());
            } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
              return ret(null, "compare");
            } else if (ch == '"' || ch == "'") {
              state.tokenize = tokenString(ch);
              return state.tokenize(stream, state);
            } else if (ch == "#") {
              stream.eatWhile(/[\w\\\-]/);
              return ret("atom", "hash");
            } else if (ch == "!") {
              stream.match(/^\s*\w*/);
              return ret("keyword", "important");
            } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
              stream.eatWhile(/[\w.%]/);
              return ret("number", "unit");
            } else if (ch === "-") {
              if (/[\d.]/.test(stream.peek())) {
                stream.eatWhile(/[\w.%]/);
                return ret("number", "unit");
              } else if (stream.match(/^-[\w\\\-]*/)) {
                stream.eatWhile(/[\w\\\-]/);
                if (stream.match(/^\s*:/, false))
                  return ret("variable-2", "variable-definition");
                return ret("variable-2", "variable");
              } else if (stream.match(/^\w+-/)) {
                return ret("meta", "meta");
              }
            } else if (/[,+>*\/]/.test(ch)) {
              return ret(null, "select-op");
            } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
              return ret("qualifier", "qualifier");
            } else if (/[:;{}\[\]\(\)]/.test(ch)) {
              return ret(null, ch);
            } else if (stream.match(/^[\w-.]+(?=\()/)) {
              if (/^(url(-prefix)?|domain|regexp)$/i.test(stream.current())) {
                state.tokenize = tokenParenthesized;
              }
              return ret("variable callee", "variable");
            } else if (/[\w\\\-]/.test(ch)) {
              stream.eatWhile(/[\w\\\-]/);
              return ret("property", "word");
            } else {
              return ret(null, null);
            }
          }
          function tokenString(quote) {
            return function(stream, state) {
              var escaped = false, ch;
              while ((ch = stream.next()) != null) {
                if (ch == quote && !escaped) {
                  if (quote == ")") stream.backUp(1);
                  break;
                }
                escaped = !escaped && ch == "\\";
              }
              if (ch == quote || !escaped && quote != ")") state.tokenize = null;
              return ret("string", "string");
            };
          }
          function tokenParenthesized(stream, state) {
            stream.next();
            if (!stream.match(/^\s*[\"\')]/, false))
              state.tokenize = tokenString(")");
            else
              state.tokenize = null;
            return ret(null, "(");
          }
          function Context(type2, indent, prev) {
            this.type = type2;
            this.indent = indent;
            this.prev = prev;
          }
          function pushContext(state, stream, type2, indent) {
            state.context = new Context(type2, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
            return type2;
          }
          function popContext(state) {
            if (state.context.prev)
              state.context = state.context.prev;
            return state.context.type;
          }
          function pass(type2, stream, state) {
            return states[state.context.type](type2, stream, state);
          }
          function popAndPass(type2, stream, state, n) {
            for (var i = n || 1; i > 0; i--)
              state.context = state.context.prev;
            return pass(type2, stream, state);
          }
          function wordAsValue(stream) {
            var word = stream.current().toLowerCase();
            if (valueKeywords2.hasOwnProperty(word))
              override = "atom";
            else if (colorKeywords2.hasOwnProperty(word))
              override = "keyword";
            else
              override = "variable";
          }
          var states = {};
          states.top = function(type2, stream, state) {
            if (type2 == "{") {
              return pushContext(state, stream, "block");
            } else if (type2 == "}" && state.context.prev) {
              return popContext(state);
            } else if (supportsAtComponent && /@component/i.test(type2)) {
              return pushContext(state, stream, "atComponentBlock");
            } else if (/^@(-moz-)?document$/i.test(type2)) {
              return pushContext(state, stream, "documentTypes");
            } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type2)) {
              return pushContext(state, stream, "atBlock");
            } else if (/^@(font-face|counter-style)/i.test(type2)) {
              state.stateArg = type2;
              return "restricted_atBlock_before";
            } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type2)) {
              return "keyframes";
            } else if (type2 && type2.charAt(0) == "@") {
              return pushContext(state, stream, "at");
            } else if (type2 == "hash") {
              override = "builtin";
            } else if (type2 == "word") {
              override = "tag";
            } else if (type2 == "variable-definition") {
              return "maybeprop";
            } else if (type2 == "interpolation") {
              return pushContext(state, stream, "interpolation");
            } else if (type2 == ":") {
              return "pseudo";
            } else if (allowNested && type2 == "(") {
              return pushContext(state, stream, "parens");
            }
            return state.context.type;
          };
          states.block = function(type2, stream, state) {
            if (type2 == "word") {
              var word = stream.current().toLowerCase();
              if (propertyKeywords2.hasOwnProperty(word)) {
                override = "property";
                return "maybeprop";
              } else if (nonStandardPropertyKeywords2.hasOwnProperty(word)) {
                override = highlightNonStandardPropertyKeywords ? "string-2" : "property";
                return "maybeprop";
              } else if (allowNested) {
                override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
                return "block";
              } else {
                override += " error";
                return "maybeprop";
              }
            } else if (type2 == "meta") {
              return "block";
            } else if (!allowNested && (type2 == "hash" || type2 == "qualifier")) {
              override = "error";
              return "block";
            } else {
              return states.top(type2, stream, state);
            }
          };
          states.maybeprop = function(type2, stream, state) {
            if (type2 == ":") return pushContext(state, stream, "prop");
            return pass(type2, stream, state);
          };
          states.prop = function(type2, stream, state) {
            if (type2 == ";") return popContext(state);
            if (type2 == "{" && allowNested) return pushContext(state, stream, "propBlock");
            if (type2 == "}" || type2 == "{") return popAndPass(type2, stream, state);
            if (type2 == "(") return pushContext(state, stream, "parens");
            if (type2 == "hash" && !/^#([0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/.test(stream.current())) {
              override += " error";
            } else if (type2 == "word") {
              wordAsValue(stream);
            } else if (type2 == "interpolation") {
              return pushContext(state, stream, "interpolation");
            }
            return "prop";
          };
          states.propBlock = function(type2, _stream, state) {
            if (type2 == "}") return popContext(state);
            if (type2 == "word") {
              override = "property";
              return "maybeprop";
            }
            return state.context.type;
          };
          states.parens = function(type2, stream, state) {
            if (type2 == "{" || type2 == "}") return popAndPass(type2, stream, state);
            if (type2 == ")") return popContext(state);
            if (type2 == "(") return pushContext(state, stream, "parens");
            if (type2 == "interpolation") return pushContext(state, stream, "interpolation");
            if (type2 == "word") wordAsValue(stream);
            return "parens";
          };
          states.pseudo = function(type2, stream, state) {
            if (type2 == "meta") return "pseudo";
            if (type2 == "word") {
              override = "variable-3";
              return state.context.type;
            }
            return pass(type2, stream, state);
          };
          states.documentTypes = function(type2, stream, state) {
            if (type2 == "word" && documentTypes2.hasOwnProperty(stream.current())) {
              override = "tag";
              return state.context.type;
            } else {
              return states.atBlock(type2, stream, state);
            }
          };
          states.atBlock = function(type2, stream, state) {
            if (type2 == "(") return pushContext(state, stream, "atBlock_parens");
            if (type2 == "}" || type2 == ";") return popAndPass(type2, stream, state);
            if (type2 == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");
            if (type2 == "interpolation") return pushContext(state, stream, "interpolation");
            if (type2 == "word") {
              var word = stream.current().toLowerCase();
              if (word == "only" || word == "not" || word == "and" || word == "or")
                override = "keyword";
              else if (mediaTypes2.hasOwnProperty(word))
                override = "attribute";
              else if (mediaFeatures2.hasOwnProperty(word))
                override = "property";
              else if (mediaValueKeywords2.hasOwnProperty(word))
                override = "keyword";
              else if (propertyKeywords2.hasOwnProperty(word))
                override = "property";
              else if (nonStandardPropertyKeywords2.hasOwnProperty(word))
                override = highlightNonStandardPropertyKeywords ? "string-2" : "property";
              else if (valueKeywords2.hasOwnProperty(word))
                override = "atom";
              else if (colorKeywords2.hasOwnProperty(word))
                override = "keyword";
              else
                override = "error";
            }
            return state.context.type;
          };
          states.atComponentBlock = function(type2, stream, state) {
            if (type2 == "}")
              return popAndPass(type2, stream, state);
            if (type2 == "{")
              return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
            if (type2 == "word")
              override = "error";
            return state.context.type;
          };
          states.atBlock_parens = function(type2, stream, state) {
            if (type2 == ")") return popContext(state);
            if (type2 == "{" || type2 == "}") return popAndPass(type2, stream, state, 2);
            return states.atBlock(type2, stream, state);
          };
          states.restricted_atBlock_before = function(type2, stream, state) {
            if (type2 == "{")
              return pushContext(state, stream, "restricted_atBlock");
            if (type2 == "word" && state.stateArg == "@counter-style") {
              override = "variable";
              return "restricted_atBlock_before";
            }
            return pass(type2, stream, state);
          };
          states.restricted_atBlock = function(type2, stream, state) {
            if (type2 == "}") {
              state.stateArg = null;
              return popContext(state);
            }
            if (type2 == "word") {
              if (state.stateArg == "@font-face" && !fontProperties2.hasOwnProperty(stream.current().toLowerCase()) || state.stateArg == "@counter-style" && !counterDescriptors2.hasOwnProperty(stream.current().toLowerCase()))
                override = "error";
              else
                override = "property";
              return "maybeprop";
            }
            return "restricted_atBlock";
          };
          states.keyframes = function(type2, stream, state) {
            if (type2 == "word") {
              override = "variable";
              return "keyframes";
            }
            if (type2 == "{") return pushContext(state, stream, "top");
            return pass(type2, stream, state);
          };
          states.at = function(type2, stream, state) {
            if (type2 == ";") return popContext(state);
            if (type2 == "{" || type2 == "}") return popAndPass(type2, stream, state);
            if (type2 == "word") override = "tag";
            else if (type2 == "hash") override = "builtin";
            return "at";
          };
          states.interpolation = function(type2, stream, state) {
            if (type2 == "}") return popContext(state);
            if (type2 == "{" || type2 == ";") return popAndPass(type2, stream, state);
            if (type2 == "word") override = "variable";
            else if (type2 != "variable" && type2 != "(" && type2 != ")") override = "error";
            return "interpolation";
          };
          return {
            startState: function(base) {
              return {
                tokenize: null,
                state: inline2 ? "block" : "top",
                stateArg: null,
                context: new Context(inline2 ? "block" : "top", base || 0, null)
              };
            },
            token: function(stream, state) {
              if (!state.tokenize && stream.eatSpace()) return null;
              var style = (state.tokenize || tokenBase)(stream, state);
              if (style && typeof style == "object") {
                type = style[1];
                style = style[0];
              }
              override = style;
              if (type != "comment")
                state.state = states[state.state](type, stream, state);
              return override;
            },
            indent: function(state, textAfter) {
              var cx = state.context, ch = textAfter && textAfter.charAt(0);
              var indent = cx.indent;
              if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
              if (cx.prev) {
                if (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
                  cx = cx.prev;
                  indent = cx.indent;
                } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") || ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
                  indent = Math.max(0, cx.indent - indentUnit);
                }
              }
              return indent;
            },
            electricChars: "}",
            blockCommentStart: "/*",
            blockCommentEnd: "*/",
            blockCommentContinue: " * ",
            lineComment,
            fold: "brace"
          };
        });
        function keySet(array) {
          var keys = {};
          for (var i = 0; i < array.length; ++i) {
            keys[array[i].toLowerCase()] = true;
          }
          return keys;
        }
        var documentTypes_ = [
          "domain",
          "regexp",
          "url",
          "url-prefix"
        ], documentTypes = keySet(documentTypes_);
        var mediaTypes_ = [
          "all",
          "aural",
          "braille",
          "handheld",
          "print",
          "projection",
          "screen",
          "tty",
          "tv",
          "embossed"
        ], mediaTypes = keySet(mediaTypes_);
        var mediaFeatures_ = [
          "width",
          "min-width",
          "max-width",
          "height",
          "min-height",
          "max-height",
          "device-width",
          "min-device-width",
          "max-device-width",
          "device-height",
          "min-device-height",
          "max-device-height",
          "aspect-ratio",
          "min-aspect-ratio",
          "max-aspect-ratio",
          "device-aspect-ratio",
          "min-device-aspect-ratio",
          "max-device-aspect-ratio",
          "color",
          "min-color",
          "max-color",
          "color-index",
          "min-color-index",
          "max-color-index",
          "monochrome",
          "min-monochrome",
          "max-monochrome",
          "resolution",
          "min-resolution",
          "max-resolution",
          "scan",
          "grid",
          "orientation",
          "device-pixel-ratio",
          "min-device-pixel-ratio",
          "max-device-pixel-ratio",
          "pointer",
          "any-pointer",
          "hover",
          "any-hover",
          "prefers-color-scheme",
          "dynamic-range",
          "video-dynamic-range"
        ], mediaFeatures = keySet(mediaFeatures_);
        var mediaValueKeywords_ = [
          "landscape",
          "portrait",
          "none",
          "coarse",
          "fine",
          "on-demand",
          "hover",
          "interlace",
          "progressive",
          "dark",
          "light",
          "standard",
          "high"
        ], mediaValueKeywords = keySet(mediaValueKeywords_);
        var propertyKeywords_ = [
          "align-content",
          "align-items",
          "align-self",
          "alignment-adjust",
          "alignment-baseline",
          "all",
          "anchor-point",
          "animation",
          "animation-delay",
          "animation-direction",
          "animation-duration",
          "animation-fill-mode",
          "animation-iteration-count",
          "animation-name",
          "animation-play-state",
          "animation-timing-function",
          "appearance",
          "azimuth",
          "backdrop-filter",
          "backface-visibility",
          "background",
          "background-attachment",
          "background-blend-mode",
          "background-clip",
          "background-color",
          "background-image",
          "background-origin",
          "background-position",
          "background-position-x",
          "background-position-y",
          "background-repeat",
          "background-size",
          "baseline-shift",
          "binding",
          "bleed",
          "block-size",
          "bookmark-label",
          "bookmark-level",
          "bookmark-state",
          "bookmark-target",
          "border",
          "border-bottom",
          "border-bottom-color",
          "border-bottom-left-radius",
          "border-bottom-right-radius",
          "border-bottom-style",
          "border-bottom-width",
          "border-collapse",
          "border-color",
          "border-image",
          "border-image-outset",
          "border-image-repeat",
          "border-image-slice",
          "border-image-source",
          "border-image-width",
          "border-left",
          "border-left-color",
          "border-left-style",
          "border-left-width",
          "border-radius",
          "border-right",
          "border-right-color",
          "border-right-style",
          "border-right-width",
          "border-spacing",
          "border-style",
          "border-top",
          "border-top-color",
          "border-top-left-radius",
          "border-top-right-radius",
          "border-top-style",
          "border-top-width",
          "border-width",
          "bottom",
          "box-decoration-break",
          "box-shadow",
          "box-sizing",
          "break-after",
          "break-before",
          "break-inside",
          "caption-side",
          "caret-color",
          "clear",
          "clip",
          "color",
          "color-profile",
          "column-count",
          "column-fill",
          "column-gap",
          "column-rule",
          "column-rule-color",
          "column-rule-style",
          "column-rule-width",
          "column-span",
          "column-width",
          "columns",
          "contain",
          "content",
          "counter-increment",
          "counter-reset",
          "crop",
          "cue",
          "cue-after",
          "cue-before",
          "cursor",
          "direction",
          "display",
          "dominant-baseline",
          "drop-initial-after-adjust",
          "drop-initial-after-align",
          "drop-initial-before-adjust",
          "drop-initial-before-align",
          "drop-initial-size",
          "drop-initial-value",
          "elevation",
          "empty-cells",
          "fit",
          "fit-content",
          "fit-position",
          "flex",
          "flex-basis",
          "flex-direction",
          "flex-flow",
          "flex-grow",
          "flex-shrink",
          "flex-wrap",
          "float",
          "float-offset",
          "flow-from",
          "flow-into",
          "font",
          "font-family",
          "font-feature-settings",
          "font-kerning",
          "font-language-override",
          "font-optical-sizing",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-synthesis",
          "font-variant",
          "font-variant-alternates",
          "font-variant-caps",
          "font-variant-east-asian",
          "font-variant-ligatures",
          "font-variant-numeric",
          "font-variant-position",
          "font-variation-settings",
          "font-weight",
          "gap",
          "grid",
          "grid-area",
          "grid-auto-columns",
          "grid-auto-flow",
          "grid-auto-rows",
          "grid-column",
          "grid-column-end",
          "grid-column-gap",
          "grid-column-start",
          "grid-gap",
          "grid-row",
          "grid-row-end",
          "grid-row-gap",
          "grid-row-start",
          "grid-template",
          "grid-template-areas",
          "grid-template-columns",
          "grid-template-rows",
          "hanging-punctuation",
          "height",
          "hyphens",
          "icon",
          "image-orientation",
          "image-rendering",
          "image-resolution",
          "inline-box-align",
          "inset",
          "inset-block",
          "inset-block-end",
          "inset-block-start",
          "inset-inline",
          "inset-inline-end",
          "inset-inline-start",
          "isolation",
          "justify-content",
          "justify-items",
          "justify-self",
          "left",
          "letter-spacing",
          "line-break",
          "line-height",
          "line-height-step",
          "line-stacking",
          "line-stacking-ruby",
          "line-stacking-shift",
          "line-stacking-strategy",
          "list-style",
          "list-style-image",
          "list-style-position",
          "list-style-type",
          "margin",
          "margin-bottom",
          "margin-left",
          "margin-right",
          "margin-top",
          "marks",
          "marquee-direction",
          "marquee-loop",
          "marquee-play-count",
          "marquee-speed",
          "marquee-style",
          "mask-clip",
          "mask-composite",
          "mask-image",
          "mask-mode",
          "mask-origin",
          "mask-position",
          "mask-repeat",
          "mask-size",
          "mask-type",
          "max-block-size",
          "max-height",
          "max-inline-size",
          "max-width",
          "min-block-size",
          "min-height",
          "min-inline-size",
          "min-width",
          "mix-blend-mode",
          "move-to",
          "nav-down",
          "nav-index",
          "nav-left",
          "nav-right",
          "nav-up",
          "object-fit",
          "object-position",
          "offset",
          "offset-anchor",
          "offset-distance",
          "offset-path",
          "offset-position",
          "offset-rotate",
          "opacity",
          "order",
          "orphans",
          "outline",
          "outline-color",
          "outline-offset",
          "outline-style",
          "outline-width",
          "overflow",
          "overflow-style",
          "overflow-wrap",
          "overflow-x",
          "overflow-y",
          "padding",
          "padding-bottom",
          "padding-left",
          "padding-right",
          "padding-top",
          "page",
          "page-break-after",
          "page-break-before",
          "page-break-inside",
          "page-policy",
          "pause",
          "pause-after",
          "pause-before",
          "perspective",
          "perspective-origin",
          "pitch",
          "pitch-range",
          "place-content",
          "place-items",
          "place-self",
          "play-during",
          "position",
          "presentation-level",
          "punctuation-trim",
          "quotes",
          "region-break-after",
          "region-break-before",
          "region-break-inside",
          "region-fragment",
          "rendering-intent",
          "resize",
          "rest",
          "rest-after",
          "rest-before",
          "richness",
          "right",
          "rotate",
          "rotation",
          "rotation-point",
          "row-gap",
          "ruby-align",
          "ruby-overhang",
          "ruby-position",
          "ruby-span",
          "scale",
          "scroll-behavior",
          "scroll-margin",
          "scroll-margin-block",
          "scroll-margin-block-end",
          "scroll-margin-block-start",
          "scroll-margin-bottom",
          "scroll-margin-inline",
          "scroll-margin-inline-end",
          "scroll-margin-inline-start",
          "scroll-margin-left",
          "scroll-margin-right",
          "scroll-margin-top",
          "scroll-padding",
          "scroll-padding-block",
          "scroll-padding-block-end",
          "scroll-padding-block-start",
          "scroll-padding-bottom",
          "scroll-padding-inline",
          "scroll-padding-inline-end",
          "scroll-padding-inline-start",
          "scroll-padding-left",
          "scroll-padding-right",
          "scroll-padding-top",
          "scroll-snap-align",
          "scroll-snap-type",
          "shape-image-threshold",
          "shape-inside",
          "shape-margin",
          "shape-outside",
          "size",
          "speak",
          "speak-as",
          "speak-header",
          "speak-numeral",
          "speak-punctuation",
          "speech-rate",
          "stress",
          "string-set",
          "tab-size",
          "table-layout",
          "target",
          "target-name",
          "target-new",
          "target-position",
          "text-align",
          "text-align-last",
          "text-combine-upright",
          "text-decoration",
          "text-decoration-color",
          "text-decoration-line",
          "text-decoration-skip",
          "text-decoration-skip-ink",
          "text-decoration-style",
          "text-emphasis",
          "text-emphasis-color",
          "text-emphasis-position",
          "text-emphasis-style",
          "text-height",
          "text-indent",
          "text-justify",
          "text-orientation",
          "text-outline",
          "text-overflow",
          "text-rendering",
          "text-shadow",
          "text-size-adjust",
          "text-space-collapse",
          "text-transform",
          "text-underline-position",
          "text-wrap",
          "top",
          "touch-action",
          "transform",
          "transform-origin",
          "transform-style",
          "transition",
          "transition-delay",
          "transition-duration",
          "transition-property",
          "transition-timing-function",
          "translate",
          "unicode-bidi",
          "user-select",
          "vertical-align",
          "visibility",
          "voice-balance",
          "voice-duration",
          "voice-family",
          "voice-pitch",
          "voice-range",
          "voice-rate",
          "voice-stress",
          "voice-volume",
          "volume",
          "white-space",
          "widows",
          "width",
          "will-change",
          "word-break",
          "word-spacing",
          "word-wrap",
          "writing-mode",
          "z-index",
          // SVG-specific
          "clip-path",
          "clip-rule",
          "mask",
          "enable-background",
          "filter",
          "flood-color",
          "flood-opacity",
          "lighting-color",
          "stop-color",
          "stop-opacity",
          "pointer-events",
          "color-interpolation",
          "color-interpolation-filters",
          "color-rendering",
          "fill",
          "fill-opacity",
          "fill-rule",
          "image-rendering",
          "marker",
          "marker-end",
          "marker-mid",
          "marker-start",
          "paint-order",
          "shape-rendering",
          "stroke",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-rendering",
          "baseline-shift",
          "dominant-baseline",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "text-anchor",
          "writing-mode"
        ], propertyKeywords = keySet(propertyKeywords_);
        var nonStandardPropertyKeywords_ = [
          "accent-color",
          "aspect-ratio",
          "border-block",
          "border-block-color",
          "border-block-end",
          "border-block-end-color",
          "border-block-end-style",
          "border-block-end-width",
          "border-block-start",
          "border-block-start-color",
          "border-block-start-style",
          "border-block-start-width",
          "border-block-style",
          "border-block-width",
          "border-inline",
          "border-inline-color",
          "border-inline-end",
          "border-inline-end-color",
          "border-inline-end-style",
          "border-inline-end-width",
          "border-inline-start",
          "border-inline-start-color",
          "border-inline-start-style",
          "border-inline-start-width",
          "border-inline-style",
          "border-inline-width",
          "content-visibility",
          "margin-block",
          "margin-block-end",
          "margin-block-start",
          "margin-inline",
          "margin-inline-end",
          "margin-inline-start",
          "overflow-anchor",
          "overscroll-behavior",
          "padding-block",
          "padding-block-end",
          "padding-block-start",
          "padding-inline",
          "padding-inline-end",
          "padding-inline-start",
          "scroll-snap-stop",
          "scrollbar-3d-light-color",
          "scrollbar-arrow-color",
          "scrollbar-base-color",
          "scrollbar-dark-shadow-color",
          "scrollbar-face-color",
          "scrollbar-highlight-color",
          "scrollbar-shadow-color",
          "scrollbar-track-color",
          "searchfield-cancel-button",
          "searchfield-decoration",
          "searchfield-results-button",
          "searchfield-results-decoration",
          "shape-inside",
          "zoom"
        ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);
        var fontProperties_ = [
          "font-display",
          "font-family",
          "src",
          "unicode-range",
          "font-variant",
          "font-feature-settings",
          "font-stretch",
          "font-weight",
          "font-style"
        ], fontProperties = keySet(fontProperties_);
        var counterDescriptors_ = [
          "additive-symbols",
          "fallback",
          "negative",
          "pad",
          "prefix",
          "range",
          "speak-as",
          "suffix",
          "symbols",
          "system"
        ], counterDescriptors = keySet(counterDescriptors_);
        var colorKeywords_ = [
          "aliceblue",
          "antiquewhite",
          "aqua",
          "aquamarine",
          "azure",
          "beige",
          "bisque",
          "black",
          "blanchedalmond",
          "blue",
          "blueviolet",
          "brown",
          "burlywood",
          "cadetblue",
          "chartreuse",
          "chocolate",
          "coral",
          "cornflowerblue",
          "cornsilk",
          "crimson",
          "cyan",
          "darkblue",
          "darkcyan",
          "darkgoldenrod",
          "darkgray",
          "darkgreen",
          "darkgrey",
          "darkkhaki",
          "darkmagenta",
          "darkolivegreen",
          "darkorange",
          "darkorchid",
          "darkred",
          "darksalmon",
          "darkseagreen",
          "darkslateblue",
          "darkslategray",
          "darkslategrey",
          "darkturquoise",
          "darkviolet",
          "deeppink",
          "deepskyblue",
          "dimgray",
          "dimgrey",
          "dodgerblue",
          "firebrick",
          "floralwhite",
          "forestgreen",
          "fuchsia",
          "gainsboro",
          "ghostwhite",
          "gold",
          "goldenrod",
          "gray",
          "grey",
          "green",
          "greenyellow",
          "honeydew",
          "hotpink",
          "indianred",
          "indigo",
          "ivory",
          "khaki",
          "lavender",
          "lavenderblush",
          "lawngreen",
          "lemonchiffon",
          "lightblue",
          "lightcoral",
          "lightcyan",
          "lightgoldenrodyellow",
          "lightgray",
          "lightgreen",
          "lightgrey",
          "lightpink",
          "lightsalmon",
          "lightseagreen",
          "lightskyblue",
          "lightslategray",
          "lightslategrey",
          "lightsteelblue",
          "lightyellow",
          "lime",
          "limegreen",
          "linen",
          "magenta",
          "maroon",
          "mediumaquamarine",
          "mediumblue",
          "mediumorchid",
          "mediumpurple",
          "mediumseagreen",
          "mediumslateblue",
          "mediumspringgreen",
          "mediumturquoise",
          "mediumvioletred",
          "midnightblue",
          "mintcream",
          "mistyrose",
          "moccasin",
          "navajowhite",
          "navy",
          "oldlace",
          "olive",
          "olivedrab",
          "orange",
          "orangered",
          "orchid",
          "palegoldenrod",
          "palegreen",
          "paleturquoise",
          "palevioletred",
          "papayawhip",
          "peachpuff",
          "peru",
          "pink",
          "plum",
          "powderblue",
          "purple",
          "rebeccapurple",
          "red",
          "rosybrown",
          "royalblue",
          "saddlebrown",
          "salmon",
          "sandybrown",
          "seagreen",
          "seashell",
          "sienna",
          "silver",
          "skyblue",
          "slateblue",
          "slategray",
          "slategrey",
          "snow",
          "springgreen",
          "steelblue",
          "tan",
          "teal",
          "thistle",
          "tomato",
          "turquoise",
          "violet",
          "wheat",
          "white",
          "whitesmoke",
          "yellow",
          "yellowgreen"
        ], colorKeywords = keySet(colorKeywords_);
        var valueKeywords_ = [
          "above",
          "absolute",
          "activeborder",
          "additive",
          "activecaption",
          "afar",
          "after-white-space",
          "ahead",
          "alias",
          "all",
          "all-scroll",
          "alphabetic",
          "alternate",
          "always",
          "amharic",
          "amharic-abegede",
          "antialiased",
          "appworkspace",
          "arabic-indic",
          "armenian",
          "asterisks",
          "attr",
          "auto",
          "auto-flow",
          "avoid",
          "avoid-column",
          "avoid-page",
          "avoid-region",
          "axis-pan",
          "background",
          "backwards",
          "baseline",
          "below",
          "bidi-override",
          "binary",
          "bengali",
          "blink",
          "block",
          "block-axis",
          "blur",
          "bold",
          "bolder",
          "border",
          "border-box",
          "both",
          "bottom",
          "break",
          "break-all",
          "break-word",
          "brightness",
          "bullets",
          "button",
          "buttonface",
          "buttonhighlight",
          "buttonshadow",
          "buttontext",
          "calc",
          "cambodian",
          "capitalize",
          "caps-lock-indicator",
          "caption",
          "captiontext",
          "caret",
          "cell",
          "center",
          "checkbox",
          "circle",
          "cjk-decimal",
          "cjk-earthly-branch",
          "cjk-heavenly-stem",
          "cjk-ideographic",
          "clear",
          "clip",
          "close-quote",
          "col-resize",
          "collapse",
          "color",
          "color-burn",
          "color-dodge",
          "column",
          "column-reverse",
          "compact",
          "condensed",
          "conic-gradient",
          "contain",
          "content",
          "contents",
          "content-box",
          "context-menu",
          "continuous",
          "contrast",
          "copy",
          "counter",
          "counters",
          "cover",
          "crop",
          "cross",
          "crosshair",
          "cubic-bezier",
          "currentcolor",
          "cursive",
          "cyclic",
          "darken",
          "dashed",
          "decimal",
          "decimal-leading-zero",
          "default",
          "default-button",
          "dense",
          "destination-atop",
          "destination-in",
          "destination-out",
          "destination-over",
          "devanagari",
          "difference",
          "disc",
          "discard",
          "disclosure-closed",
          "disclosure-open",
          "document",
          "dot-dash",
          "dot-dot-dash",
          "dotted",
          "double",
          "down",
          "drop-shadow",
          "e-resize",
          "ease",
          "ease-in",
          "ease-in-out",
          "ease-out",
          "element",
          "ellipse",
          "ellipsis",
          "embed",
          "end",
          "ethiopic",
          "ethiopic-abegede",
          "ethiopic-abegede-am-et",
          "ethiopic-abegede-gez",
          "ethiopic-abegede-ti-er",
          "ethiopic-abegede-ti-et",
          "ethiopic-halehame-aa-er",
          "ethiopic-halehame-aa-et",
          "ethiopic-halehame-am-et",
          "ethiopic-halehame-gez",
          "ethiopic-halehame-om-et",
          "ethiopic-halehame-sid-et",
          "ethiopic-halehame-so-et",
          "ethiopic-halehame-ti-er",
          "ethiopic-halehame-ti-et",
          "ethiopic-halehame-tig",
          "ethiopic-numeric",
          "ew-resize",
          "exclusion",
          "expanded",
          "extends",
          "extra-condensed",
          "extra-expanded",
          "fantasy",
          "fast",
          "fill",
          "fill-box",
          "fixed",
          "flat",
          "flex",
          "flex-end",
          "flex-start",
          "footnotes",
          "forwards",
          "from",
          "geometricPrecision",
          "georgian",
          "grayscale",
          "graytext",
          "grid",
          "groove",
          "gujarati",
          "gurmukhi",
          "hand",
          "hangul",
          "hangul-consonant",
          "hard-light",
          "hebrew",
          "help",
          "hidden",
          "hide",
          "higher",
          "highlight",
          "highlighttext",
          "hiragana",
          "hiragana-iroha",
          "horizontal",
          "hsl",
          "hsla",
          "hue",
          "hue-rotate",
          "icon",
          "ignore",
          "inactiveborder",
          "inactivecaption",
          "inactivecaptiontext",
          "infinite",
          "infobackground",
          "infotext",
          "inherit",
          "initial",
          "inline",
          "inline-axis",
          "inline-block",
          "inline-flex",
          "inline-grid",
          "inline-table",
          "inset",
          "inside",
          "intrinsic",
          "invert",
          "italic",
          "japanese-formal",
          "japanese-informal",
          "justify",
          "kannada",
          "katakana",
          "katakana-iroha",
          "keep-all",
          "khmer",
          "korean-hangul-formal",
          "korean-hanja-formal",
          "korean-hanja-informal",
          "landscape",
          "lao",
          "large",
          "larger",
          "left",
          "level",
          "lighter",
          "lighten",
          "line-through",
          "linear",
          "linear-gradient",
          "lines",
          "list-item",
          "listbox",
          "listitem",
          "local",
          "logical",
          "loud",
          "lower",
          "lower-alpha",
          "lower-armenian",
          "lower-greek",
          "lower-hexadecimal",
          "lower-latin",
          "lower-norwegian",
          "lower-roman",
          "lowercase",
          "ltr",
          "luminosity",
          "malayalam",
          "manipulation",
          "match",
          "matrix",
          "matrix3d",
          "media-play-button",
          "media-slider",
          "media-sliderthumb",
          "media-volume-slider",
          "media-volume-sliderthumb",
          "medium",
          "menu",
          "menulist",
          "menulist-button",
          "menutext",
          "message-box",
          "middle",
          "min-intrinsic",
          "mix",
          "mongolian",
          "monospace",
          "move",
          "multiple",
          "multiple_mask_images",
          "multiply",
          "myanmar",
          "n-resize",
          "narrower",
          "ne-resize",
          "nesw-resize",
          "no-close-quote",
          "no-drop",
          "no-open-quote",
          "no-repeat",
          "none",
          "normal",
          "not-allowed",
          "nowrap",
          "ns-resize",
          "numbers",
          "numeric",
          "nw-resize",
          "nwse-resize",
          "oblique",
          "octal",
          "opacity",
          "open-quote",
          "optimizeLegibility",
          "optimizeSpeed",
          "oriya",
          "oromo",
          "outset",
          "outside",
          "outside-shape",
          "overlay",
          "overline",
          "padding",
          "padding-box",
          "painted",
          "page",
          "paused",
          "persian",
          "perspective",
          "pinch-zoom",
          "plus-darker",
          "plus-lighter",
          "pointer",
          "polygon",
          "portrait",
          "pre",
          "pre-line",
          "pre-wrap",
          "preserve-3d",
          "progress",
          "push-button",
          "radial-gradient",
          "radio",
          "read-only",
          "read-write",
          "read-write-plaintext-only",
          "rectangle",
          "region",
          "relative",
          "repeat",
          "repeating-linear-gradient",
          "repeating-radial-gradient",
          "repeating-conic-gradient",
          "repeat-x",
          "repeat-y",
          "reset",
          "reverse",
          "rgb",
          "rgba",
          "ridge",
          "right",
          "rotate",
          "rotate3d",
          "rotateX",
          "rotateY",
          "rotateZ",
          "round",
          "row",
          "row-resize",
          "row-reverse",
          "rtl",
          "run-in",
          "running",
          "s-resize",
          "sans-serif",
          "saturate",
          "saturation",
          "scale",
          "scale3d",
          "scaleX",
          "scaleY",
          "scaleZ",
          "screen",
          "scroll",
          "scrollbar",
          "scroll-position",
          "se-resize",
          "searchfield",
          "searchfield-cancel-button",
          "searchfield-decoration",
          "searchfield-results-button",
          "searchfield-results-decoration",
          "self-start",
          "self-end",
          "semi-condensed",
          "semi-expanded",
          "separate",
          "sepia",
          "serif",
          "show",
          "sidama",
          "simp-chinese-formal",
          "simp-chinese-informal",
          "single",
          "skew",
          "skewX",
          "skewY",
          "skip-white-space",
          "slide",
          "slider-horizontal",
          "slider-vertical",
          "sliderthumb-horizontal",
          "sliderthumb-vertical",
          "slow",
          "small",
          "small-caps",
          "small-caption",
          "smaller",
          "soft-light",
          "solid",
          "somali",
          "source-atop",
          "source-in",
          "source-out",
          "source-over",
          "space",
          "space-around",
          "space-between",
          "space-evenly",
          "spell-out",
          "square",
          "square-button",
          "start",
          "static",
          "status-bar",
          "stretch",
          "stroke",
          "stroke-box",
          "sub",
          "subpixel-antialiased",
          "svg_masks",
          "super",
          "sw-resize",
          "symbolic",
          "symbols",
          "system-ui",
          "table",
          "table-caption",
          "table-cell",
          "table-column",
          "table-column-group",
          "table-footer-group",
          "table-header-group",
          "table-row",
          "table-row-group",
          "tamil",
          "telugu",
          "text",
          "text-bottom",
          "text-top",
          "textarea",
          "textfield",
          "thai",
          "thick",
          "thin",
          "threeddarkshadow",
          "threedface",
          "threedhighlight",
          "threedlightshadow",
          "threedshadow",
          "tibetan",
          "tigre",
          "tigrinya-er",
          "tigrinya-er-abegede",
          "tigrinya-et",
          "tigrinya-et-abegede",
          "to",
          "top",
          "trad-chinese-formal",
          "trad-chinese-informal",
          "transform",
          "translate",
          "translate3d",
          "translateX",
          "translateY",
          "translateZ",
          "transparent",
          "ultra-condensed",
          "ultra-expanded",
          "underline",
          "unidirectional-pan",
          "unset",
          "up",
          "upper-alpha",
          "upper-armenian",
          "upper-greek",
          "upper-hexadecimal",
          "upper-latin",
          "upper-norwegian",
          "upper-roman",
          "uppercase",
          "urdu",
          "url",
          "var",
          "vertical",
          "vertical-text",
          "view-box",
          "visible",
          "visibleFill",
          "visiblePainted",
          "visibleStroke",
          "visual",
          "w-resize",
          "wait",
          "wave",
          "wider",
          "window",
          "windowframe",
          "windowtext",
          "words",
          "wrap",
          "wrap-reverse",
          "x-large",
          "x-small",
          "xor",
          "xx-large",
          "xx-small"
        ], valueKeywords = keySet(valueKeywords_);
        var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);
        CodeMirror3.registerHelper("hintWords", "css", allWords);
        function tokenCComment(stream, state) {
          var maybeEnd = false, ch;
          while ((ch = stream.next()) != null) {
            if (maybeEnd && ch == "/") {
              state.tokenize = null;
              break;
            }
            maybeEnd = ch == "*";
          }
          return ["comment", "comment"];
        }
        CodeMirror3.defineMIME("text/css", {
          documentTypes,
          mediaTypes,
          mediaFeatures,
          mediaValueKeywords,
          propertyKeywords,
          nonStandardPropertyKeywords,
          fontProperties,
          counterDescriptors,
          colorKeywords,
          valueKeywords,
          tokenHooks: {
            "/": function(stream, state) {
              if (!stream.eat("*")) return false;
              state.tokenize = tokenCComment;
              return tokenCComment(stream, state);
            }
          },
          name: "css"
        });
        CodeMirror3.defineMIME("text/x-scss", {
          mediaTypes,
          mediaFeatures,
          mediaValueKeywords,
          propertyKeywords,
          nonStandardPropertyKeywords,
          colorKeywords,
          valueKeywords,
          fontProperties,
          allowNested: true,
          lineComment: "//",
          tokenHooks: {
            "/": function(stream, state) {
              if (stream.eat("/")) {
                stream.skipToEnd();
                return ["comment", "comment"];
              } else if (stream.eat("*")) {
                state.tokenize = tokenCComment;
                return tokenCComment(stream, state);
              } else {
                return ["operator", "operator"];
              }
            },
            ":": function(stream) {
              if (stream.match(/^\s*\{/, false))
                return [null, null];
              return false;
            },
            "$": function(stream) {
              stream.match(/^[\w-]+/);
              if (stream.match(/^\s*:/, false))
                return ["variable-2", "variable-definition"];
              return ["variable-2", "variable"];
            },
            "#": function(stream) {
              if (!stream.eat("{")) return false;
              return [null, "interpolation"];
            }
          },
          name: "css",
          helperType: "scss"
        });
        CodeMirror3.defineMIME("text/x-less", {
          mediaTypes,
          mediaFeatures,
          mediaValueKeywords,
          propertyKeywords,
          nonStandardPropertyKeywords,
          colorKeywords,
          valueKeywords,
          fontProperties,
          allowNested: true,
          lineComment: "//",
          tokenHooks: {
            "/": function(stream, state) {
              if (stream.eat("/")) {
                stream.skipToEnd();
                return ["comment", "comment"];
              } else if (stream.eat("*")) {
                state.tokenize = tokenCComment;
                return tokenCComment(stream, state);
              } else {
                return ["operator", "operator"];
              }
            },
            "@": function(stream) {
              if (stream.eat("{")) return [null, "interpolation"];
              if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false)) return false;
              stream.eatWhile(/[\w\\\-]/);
              if (stream.match(/^\s*:/, false))
                return ["variable-2", "variable-definition"];
              return ["variable-2", "variable"];
            },
            "&": function() {
              return ["atom", "atom"];
            }
          },
          name: "css",
          helperType: "less"
        });
        CodeMirror3.defineMIME("text/x-gss", {
          documentTypes,
          mediaTypes,
          mediaFeatures,
          propertyKeywords,
          nonStandardPropertyKeywords,
          fontProperties,
          counterDescriptors,
          colorKeywords,
          valueKeywords,
          supportsAtComponent: true,
          tokenHooks: {
            "/": function(stream, state) {
              if (!stream.eat("*")) return false;
              state.tokenize = tokenCComment;
              return tokenCComment(stream, state);
            }
          },
          name: "css",
          helperType: "gss"
        });
      });
    }
  });

  // ../../node_modules/codemirror/mode/javascript/javascript.js
  var require_javascript = __commonJS({
    "../../node_modules/codemirror/mode/javascript/javascript.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("javascript", function(config, parserConfig) {
          var indentUnit = config.indentUnit;
          var statementIndent = parserConfig.statementIndent;
          var jsonldMode = parserConfig.jsonld;
          var jsonMode = parserConfig.json || jsonldMode;
          var trackScope = parserConfig.trackScope !== false;
          var isTS = parserConfig.typescript;
          var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
          var keywords = function() {
            function kw(type2) {
              return { type: type2, style: "keyword" };
            }
            var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
            var operator = kw("operator"), atom = { type: "atom", style: "atom" };
            return {
              "if": kw("if"),
              "while": A,
              "with": A,
              "else": B,
              "do": B,
              "try": B,
              "finally": B,
              "return": D,
              "break": D,
              "continue": D,
              "new": kw("new"),
              "delete": C,
              "void": C,
              "throw": C,
              "debugger": kw("debugger"),
              "var": kw("var"),
              "const": kw("var"),
              "let": kw("var"),
              "function": kw("function"),
              "catch": kw("catch"),
              "for": kw("for"),
              "switch": kw("switch"),
              "case": kw("case"),
              "default": kw("default"),
              "in": operator,
              "typeof": operator,
              "instanceof": operator,
              "true": atom,
              "false": atom,
              "null": atom,
              "undefined": atom,
              "NaN": atom,
              "Infinity": atom,
              "this": kw("this"),
              "class": kw("class"),
              "super": kw("atom"),
              "yield": C,
              "export": kw("export"),
              "import": kw("import"),
              "extends": C,
              "await": C
            };
          }();
          var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
          var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
          function readRegexp(stream) {
            var escaped = false, next, inSet = false;
            while ((next = stream.next()) != null) {
              if (!escaped) {
                if (next == "/" && !inSet) return;
                if (next == "[") inSet = true;
                else if (inSet && next == "]") inSet = false;
              }
              escaped = !escaped && next == "\\";
            }
          }
          var type, content;
          function ret(tp, style, cont2) {
            type = tp;
            content = cont2;
            return style;
          }
          function tokenBase(stream, state) {
            var ch = stream.next();
            if (ch == '"' || ch == "'") {
              state.tokenize = tokenString(ch);
              return state.tokenize(stream, state);
            } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
              return ret("number", "number");
            } else if (ch == "." && stream.match("..")) {
              return ret("spread", "meta");
            } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
              return ret(ch);
            } else if (ch == "=" && stream.eat(">")) {
              return ret("=>", "operator");
            } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
              return ret("number", "number");
            } else if (/\d/.test(ch)) {
              stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
              return ret("number", "number");
            } else if (ch == "/") {
              if (stream.eat("*")) {
                state.tokenize = tokenComment;
                return tokenComment(stream, state);
              } else if (stream.eat("/")) {
                stream.skipToEnd();
                return ret("comment", "comment");
              } else if (expressionAllowed(stream, state, 1)) {
                readRegexp(stream);
                stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
                return ret("regexp", "string-2");
              } else {
                stream.eat("=");
                return ret("operator", "operator", stream.current());
              }
            } else if (ch == "`") {
              state.tokenize = tokenQuasi;
              return tokenQuasi(stream, state);
            } else if (ch == "#" && stream.peek() == "!") {
              stream.skipToEnd();
              return ret("meta", "meta");
            } else if (ch == "#" && stream.eatWhile(wordRE)) {
              return ret("variable", "property");
            } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start))) {
              stream.skipToEnd();
              return ret("comment", "comment");
            } else if (isOperatorChar.test(ch)) {
              if (ch != ">" || !state.lexical || state.lexical.type != ">") {
                if (stream.eat("=")) {
                  if (ch == "!" || ch == "=") stream.eat("=");
                } else if (/[<>*+\-|&?]/.test(ch)) {
                  stream.eat(ch);
                  if (ch == ">") stream.eat(ch);
                }
              }
              if (ch == "?" && stream.eat(".")) return ret(".");
              return ret("operator", "operator", stream.current());
            } else if (wordRE.test(ch)) {
              stream.eatWhile(wordRE);
              var word = stream.current();
              if (state.lastType != ".") {
                if (keywords.propertyIsEnumerable(word)) {
                  var kw = keywords[word];
                  return ret(kw.type, kw.style, word);
                }
                if (word == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
                  return ret("async", "keyword", word);
              }
              return ret("variable", "variable", word);
            }
          }
          function tokenString(quote) {
            return function(stream, state) {
              var escaped = false, next;
              if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
                state.tokenize = tokenBase;
                return ret("jsonld-keyword", "meta");
              }
              while ((next = stream.next()) != null) {
                if (next == quote && !escaped) break;
                escaped = !escaped && next == "\\";
              }
              if (!escaped) state.tokenize = tokenBase;
              return ret("string", "string");
            };
          }
          function tokenComment(stream, state) {
            var maybeEnd = false, ch;
            while (ch = stream.next()) {
              if (ch == "/" && maybeEnd) {
                state.tokenize = tokenBase;
                break;
              }
              maybeEnd = ch == "*";
            }
            return ret("comment", "comment");
          }
          function tokenQuasi(stream, state) {
            var escaped = false, next;
            while ((next = stream.next()) != null) {
              if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
                state.tokenize = tokenBase;
                break;
              }
              escaped = !escaped && next == "\\";
            }
            return ret("quasi", "string-2", stream.current());
          }
          var brackets = "([{}])";
          function findFatArrow(stream, state) {
            if (state.fatArrowAt) state.fatArrowAt = null;
            var arrow = stream.string.indexOf("=>", stream.start);
            if (arrow < 0) return;
            if (isTS) {
              var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
              if (m) arrow = m.index;
            }
            var depth = 0, sawSomething = false;
            for (var pos = arrow - 1; pos >= 0; --pos) {
              var ch = stream.string.charAt(pos);
              var bracket = brackets.indexOf(ch);
              if (bracket >= 0 && bracket < 3) {
                if (!depth) {
                  ++pos;
                  break;
                }
                if (--depth == 0) {
                  if (ch == "(") sawSomething = true;
                  break;
                }
              } else if (bracket >= 3 && bracket < 6) {
                ++depth;
              } else if (wordRE.test(ch)) {
                sawSomething = true;
              } else if (/["'\/`]/.test(ch)) {
                for (; ; --pos) {
                  if (pos == 0) return;
                  var next = stream.string.charAt(pos - 1);
                  if (next == ch && stream.string.charAt(pos - 2) != "\\") {
                    pos--;
                    break;
                  }
                }
              } else if (sawSomething && !depth) {
                ++pos;
                break;
              }
            }
            if (sawSomething && !depth) state.fatArrowAt = pos;
          }
          var atomicTypes = {
            "atom": true,
            "number": true,
            "variable": true,
            "string": true,
            "regexp": true,
            "this": true,
            "import": true,
            "jsonld-keyword": true
          };
          function JSLexical(indented, column, type2, align, prev, info) {
            this.indented = indented;
            this.column = column;
            this.type = type2;
            this.prev = prev;
            this.info = info;
            if (align != null) this.align = align;
          }
          function inScope(state, varname) {
            if (!trackScope) return false;
            for (var v = state.localVars; v; v = v.next)
              if (v.name == varname) return true;
            for (var cx2 = state.context; cx2; cx2 = cx2.prev) {
              for (var v = cx2.vars; v; v = v.next)
                if (v.name == varname) return true;
            }
          }
          function parseJS(state, style, type2, content2, stream) {
            var cc = state.cc;
            cx.state = state;
            cx.stream = stream;
            cx.marked = null, cx.cc = cc;
            cx.style = style;
            if (!state.lexical.hasOwnProperty("align"))
              state.lexical.align = true;
            while (true) {
              var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
              if (combinator(type2, content2)) {
                while (cc.length && cc[cc.length - 1].lex)
                  cc.pop()();
                if (cx.marked) return cx.marked;
                if (type2 == "variable" && inScope(state, content2)) return "variable-2";
                return style;
              }
            }
          }
          var cx = { state: null, column: null, marked: null, cc: null };
          function pass() {
            for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
          }
          function cont() {
            pass.apply(null, arguments);
            return true;
          }
          function inList(name2, list2) {
            for (var v = list2; v; v = v.next) if (v.name == name2) return true;
            return false;
          }
          function register(varname) {
            var state = cx.state;
            cx.marked = "def";
            if (!trackScope) return;
            if (state.context) {
              if (state.lexical.info == "var" && state.context && state.context.block) {
                var newContext = registerVarScoped(varname, state.context);
                if (newContext != null) {
                  state.context = newContext;
                  return;
                }
              } else if (!inList(varname, state.localVars)) {
                state.localVars = new Var(varname, state.localVars);
                return;
              }
            }
            if (parserConfig.globalVars && !inList(varname, state.globalVars))
              state.globalVars = new Var(varname, state.globalVars);
          }
          function registerVarScoped(varname, context) {
            if (!context) {
              return null;
            } else if (context.block) {
              var inner = registerVarScoped(varname, context.prev);
              if (!inner) return null;
              if (inner == context.prev) return context;
              return new Context(inner, context.vars, true);
            } else if (inList(varname, context.vars)) {
              return context;
            } else {
              return new Context(context.prev, new Var(varname, context.vars), false);
            }
          }
          function isModifier(name2) {
            return name2 == "public" || name2 == "private" || name2 == "protected" || name2 == "abstract" || name2 == "readonly";
          }
          function Context(prev, vars, block3) {
            this.prev = prev;
            this.vars = vars;
            this.block = block3;
          }
          function Var(name2, next) {
            this.name = name2;
            this.next = next;
          }
          var defaultVars = new Var("this", new Var("arguments", null));
          function pushcontext() {
            cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
            cx.state.localVars = defaultVars;
          }
          function pushblockcontext() {
            cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
            cx.state.localVars = null;
          }
          pushcontext.lex = pushblockcontext.lex = true;
          function popcontext() {
            cx.state.localVars = cx.state.context.vars;
            cx.state.context = cx.state.context.prev;
          }
          popcontext.lex = true;
          function pushlex(type2, info) {
            var result = function() {
              var state = cx.state, indent = state.indented;
              if (state.lexical.type == "stat") indent = state.lexical.indented;
              else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
                indent = outer.indented;
              state.lexical = new JSLexical(indent, cx.stream.column(), type2, null, state.lexical, info);
            };
            result.lex = true;
            return result;
          }
          function poplex() {
            var state = cx.state;
            if (state.lexical.prev) {
              if (state.lexical.type == ")")
                state.indented = state.lexical.indented;
              state.lexical = state.lexical.prev;
            }
          }
          poplex.lex = true;
          function expect(wanted) {
            function exp(type2) {
              if (type2 == wanted) return cont();
              else if (wanted == ";" || type2 == "}" || type2 == ")" || type2 == "]") return pass();
              else return cont(exp);
            }
            ;
            return exp;
          }
          function statement(type2, value) {
            if (type2 == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
            if (type2 == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
            if (type2 == "keyword b") return cont(pushlex("form"), statement, poplex);
            if (type2 == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
            if (type2 == "debugger") return cont(expect(";"));
            if (type2 == "{") return cont(pushlex("}"), pushblockcontext, block2, poplex, popcontext);
            if (type2 == ";") return cont();
            if (type2 == "if") {
              if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
                cx.state.cc.pop()();
              return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
            }
            if (type2 == "function") return cont(functiondef);
            if (type2 == "for") return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);
            if (type2 == "class" || isTS && value == "interface") {
              cx.marked = "keyword";
              return cont(pushlex("form", type2 == "class" ? type2 : value), className, poplex);
            }
            if (type2 == "variable") {
              if (isTS && value == "declare") {
                cx.marked = "keyword";
                return cont(statement);
              } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
                cx.marked = "keyword";
                if (value == "enum") return cont(enumdef);
                else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));
                else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block2, poplex, poplex);
              } else if (isTS && value == "namespace") {
                cx.marked = "keyword";
                return cont(pushlex("form"), expression, statement, poplex);
              } else if (isTS && value == "abstract") {
                cx.marked = "keyword";
                return cont(statement);
              } else {
                return cont(pushlex("stat"), maybelabel);
              }
            }
            if (type2 == "switch") return cont(
              pushlex("form"),
              parenExpr,
              expect("{"),
              pushlex("}", "switch"),
              pushblockcontext,
              block2,
              poplex,
              poplex,
              popcontext
            );
            if (type2 == "case") return cont(expression, expect(":"));
            if (type2 == "default") return cont(expect(":"));
            if (type2 == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
            if (type2 == "export") return cont(pushlex("stat"), afterExport, poplex);
            if (type2 == "import") return cont(pushlex("stat"), afterImport, poplex);
            if (type2 == "async") return cont(statement);
            if (value == "@") return cont(expression, statement);
            return pass(pushlex("stat"), expression, expect(";"), poplex);
          }
          function maybeCatchBinding(type2) {
            if (type2 == "(") return cont(funarg, expect(")"));
          }
          function expression(type2, value) {
            return expressionInner(type2, value, false);
          }
          function expressionNoComma(type2, value) {
            return expressionInner(type2, value, true);
          }
          function parenExpr(type2) {
            if (type2 != "(") return pass();
            return cont(pushlex(")"), maybeexpression, expect(")"), poplex);
          }
          function expressionInner(type2, value, noComma) {
            if (cx.state.fatArrowAt == cx.stream.start) {
              var body = noComma ? arrowBodyNoComma : arrowBody;
              if (type2 == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
              else if (type2 == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
            }
            var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
            if (atomicTypes.hasOwnProperty(type2)) return cont(maybeop);
            if (type2 == "function") return cont(functiondef, maybeop);
            if (type2 == "class" || isTS && value == "interface") {
              cx.marked = "keyword";
              return cont(pushlex("form"), classExpression, poplex);
            }
            if (type2 == "keyword c" || type2 == "async") return cont(noComma ? expressionNoComma : expression);
            if (type2 == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
            if (type2 == "operator" || type2 == "spread") return cont(noComma ? expressionNoComma : expression);
            if (type2 == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
            if (type2 == "{") return contCommasep(objprop, "}", null, maybeop);
            if (type2 == "quasi") return pass(quasi, maybeop);
            if (type2 == "new") return cont(maybeTarget(noComma));
            return cont();
          }
          function maybeexpression(type2) {
            if (type2.match(/[;\}\)\],]/)) return pass();
            return pass(expression);
          }
          function maybeoperatorComma(type2, value) {
            if (type2 == ",") return cont(maybeexpression);
            return maybeoperatorNoComma(type2, value, false);
          }
          function maybeoperatorNoComma(type2, value, noComma) {
            var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
            var expr = noComma == false ? expression : expressionNoComma;
            if (type2 == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
            if (type2 == "operator") {
              if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
              if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false))
                return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
              if (value == "?") return cont(expression, expect(":"), expr);
              return cont(expr);
            }
            if (type2 == "quasi") {
              return pass(quasi, me);
            }
            if (type2 == ";") return;
            if (type2 == "(") return contCommasep(expressionNoComma, ")", "call", me);
            if (type2 == ".") return cont(property, me);
            if (type2 == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
            if (isTS && value == "as") {
              cx.marked = "keyword";
              return cont(typeexpr, me);
            }
            if (type2 == "regexp") {
              cx.state.lastType = cx.marked = "operator";
              cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
              return cont(expr);
            }
          }
          function quasi(type2, value) {
            if (type2 != "quasi") return pass();
            if (value.slice(value.length - 2) != "${") return cont(quasi);
            return cont(maybeexpression, continueQuasi);
          }
          function continueQuasi(type2) {
            if (type2 == "}") {
              cx.marked = "string-2";
              cx.state.tokenize = tokenQuasi;
              return cont(quasi);
            }
          }
          function arrowBody(type2) {
            findFatArrow(cx.stream, cx.state);
            return pass(type2 == "{" ? statement : expression);
          }
          function arrowBodyNoComma(type2) {
            findFatArrow(cx.stream, cx.state);
            return pass(type2 == "{" ? statement : expressionNoComma);
          }
          function maybeTarget(noComma) {
            return function(type2) {
              if (type2 == ".") return cont(noComma ? targetNoComma : target);
              else if (type2 == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);
              else return pass(noComma ? expressionNoComma : expression);
            };
          }
          function target(_2, value) {
            if (value == "target") {
              cx.marked = "keyword";
              return cont(maybeoperatorComma);
            }
          }
          function targetNoComma(_2, value) {
            if (value == "target") {
              cx.marked = "keyword";
              return cont(maybeoperatorNoComma);
            }
          }
          function maybelabel(type2) {
            if (type2 == ":") return cont(poplex, statement);
            return pass(maybeoperatorComma, expect(";"), poplex);
          }
          function property(type2) {
            if (type2 == "variable") {
              cx.marked = "property";
              return cont();
            }
          }
          function objprop(type2, value) {
            if (type2 == "async") {
              cx.marked = "property";
              return cont(objprop);
            } else if (type2 == "variable" || cx.style == "keyword") {
              cx.marked = "property";
              if (value == "get" || value == "set") return cont(getterSetter);
              var m;
              if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
                cx.state.fatArrowAt = cx.stream.pos + m[0].length;
              return cont(afterprop);
            } else if (type2 == "number" || type2 == "string") {
              cx.marked = jsonldMode ? "property" : cx.style + " property";
              return cont(afterprop);
            } else if (type2 == "jsonld-keyword") {
              return cont(afterprop);
            } else if (isTS && isModifier(value)) {
              cx.marked = "keyword";
              return cont(objprop);
            } else if (type2 == "[") {
              return cont(expression, maybetype, expect("]"), afterprop);
            } else if (type2 == "spread") {
              return cont(expressionNoComma, afterprop);
            } else if (value == "*") {
              cx.marked = "keyword";
              return cont(objprop);
            } else if (type2 == ":") {
              return pass(afterprop);
            }
          }
          function getterSetter(type2) {
            if (type2 != "variable") return pass(afterprop);
            cx.marked = "property";
            return cont(functiondef);
          }
          function afterprop(type2) {
            if (type2 == ":") return cont(expressionNoComma);
            if (type2 == "(") return pass(functiondef);
          }
          function commasep(what, end, sep) {
            function proceed(type2, value) {
              if (sep ? sep.indexOf(type2) > -1 : type2 == ",") {
                var lex = cx.state.lexical;
                if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
                return cont(function(type3, value2) {
                  if (type3 == end || value2 == end) return pass();
                  return pass(what);
                }, proceed);
              }
              if (type2 == end || value == end) return cont();
              if (sep && sep.indexOf(";") > -1) return pass(what);
              return cont(expect(end));
            }
            return function(type2, value) {
              if (type2 == end || value == end) return cont();
              return pass(what, proceed);
            };
          }
          function contCommasep(what, end, info) {
            for (var i = 3; i < arguments.length; i++)
              cx.cc.push(arguments[i]);
            return cont(pushlex(end, info), commasep(what, end), poplex);
          }
          function block2(type2) {
            if (type2 == "}") return cont();
            return pass(statement, block2);
          }
          function maybetype(type2, value) {
            if (isTS) {
              if (type2 == ":") return cont(typeexpr);
              if (value == "?") return cont(maybetype);
            }
          }
          function maybetypeOrIn(type2, value) {
            if (isTS && (type2 == ":" || value == "in")) return cont(typeexpr);
          }
          function mayberettype(type2) {
            if (isTS && type2 == ":") {
              if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr);
              else return cont(typeexpr);
            }
          }
          function isKW(_2, value) {
            if (value == "is") {
              cx.marked = "keyword";
              return cont();
            }
          }
          function typeexpr(type2, value) {
            if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
              cx.marked = "keyword";
              return cont(value == "typeof" ? expressionNoComma : typeexpr);
            }
            if (type2 == "variable" || value == "void") {
              cx.marked = "type";
              return cont(afterType);
            }
            if (value == "|" || value == "&") return cont(typeexpr);
            if (type2 == "string" || type2 == "number" || type2 == "atom") return cont(afterType);
            if (type2 == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
            if (type2 == "{") return cont(pushlex("}"), typeprops, poplex, afterType);
            if (type2 == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType);
            if (type2 == "<") return cont(commasep(typeexpr, ">"), typeexpr);
            if (type2 == "quasi") {
              return pass(quasiType, afterType);
            }
          }
          function maybeReturnType(type2) {
            if (type2 == "=>") return cont(typeexpr);
          }
          function typeprops(type2) {
            if (type2.match(/[\}\)\]]/)) return cont();
            if (type2 == "," || type2 == ";") return cont(typeprops);
            return pass(typeprop, typeprops);
          }
          function typeprop(type2, value) {
            if (type2 == "variable" || cx.style == "keyword") {
              cx.marked = "property";
              return cont(typeprop);
            } else if (value == "?" || type2 == "number" || type2 == "string") {
              return cont(typeprop);
            } else if (type2 == ":") {
              return cont(typeexpr);
            } else if (type2 == "[") {
              return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);
            } else if (type2 == "(") {
              return pass(functiondecl, typeprop);
            } else if (!type2.match(/[;\}\)\],]/)) {
              return cont();
            }
          }
          function quasiType(type2, value) {
            if (type2 != "quasi") return pass();
            if (value.slice(value.length - 2) != "${") return cont(quasiType);
            return cont(typeexpr, continueQuasiType);
          }
          function continueQuasiType(type2) {
            if (type2 == "}") {
              cx.marked = "string-2";
              cx.state.tokenize = tokenQuasi;
              return cont(quasiType);
            }
          }
          function typearg(type2, value) {
            if (type2 == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg);
            if (type2 == ":") return cont(typeexpr);
            if (type2 == "spread") return cont(typearg);
            return pass(typeexpr);
          }
          function afterType(type2, value) {
            if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
            if (value == "|" || type2 == "." || value == "&") return cont(typeexpr);
            if (type2 == "[") return cont(typeexpr, expect("]"), afterType);
            if (value == "extends" || value == "implements") {
              cx.marked = "keyword";
              return cont(typeexpr);
            }
            if (value == "?") return cont(typeexpr, expect(":"), typeexpr);
          }
          function maybeTypeArgs(_2, value) {
            if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
          }
          function typeparam() {
            return pass(typeexpr, maybeTypeDefault);
          }
          function maybeTypeDefault(_2, value) {
            if (value == "=") return cont(typeexpr);
          }
          function vardef(_2, value) {
            if (value == "enum") {
              cx.marked = "keyword";
              return cont(enumdef);
            }
            return pass(pattern, maybetype, maybeAssign, vardefCont);
          }
          function pattern(type2, value) {
            if (isTS && isModifier(value)) {
              cx.marked = "keyword";
              return cont(pattern);
            }
            if (type2 == "variable") {
              register(value);
              return cont();
            }
            if (type2 == "spread") return cont(pattern);
            if (type2 == "[") return contCommasep(eltpattern, "]");
            if (type2 == "{") return contCommasep(proppattern, "}");
          }
          function proppattern(type2, value) {
            if (type2 == "variable" && !cx.stream.match(/^\s*:/, false)) {
              register(value);
              return cont(maybeAssign);
            }
            if (type2 == "variable") cx.marked = "property";
            if (type2 == "spread") return cont(pattern);
            if (type2 == "}") return pass();
            if (type2 == "[") return cont(expression, expect("]"), expect(":"), proppattern);
            return cont(expect(":"), pattern, maybeAssign);
          }
          function eltpattern() {
            return pass(pattern, maybeAssign);
          }
          function maybeAssign(_type, value) {
            if (value == "=") return cont(expressionNoComma);
          }
          function vardefCont(type2) {
            if (type2 == ",") return cont(vardef);
          }
          function maybeelse(type2, value) {
            if (type2 == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
          }
          function forspec(type2, value) {
            if (value == "await") return cont(forspec);
            if (type2 == "(") return cont(pushlex(")"), forspec1, poplex);
          }
          function forspec1(type2) {
            if (type2 == "var") return cont(vardef, forspec2);
            if (type2 == "variable") return cont(forspec2);
            return pass(forspec2);
          }
          function forspec2(type2, value) {
            if (type2 == ")") return cont();
            if (type2 == ";") return cont(forspec2);
            if (value == "in" || value == "of") {
              cx.marked = "keyword";
              return cont(expression, forspec2);
            }
            return pass(expression, forspec2);
          }
          function functiondef(type2, value) {
            if (value == "*") {
              cx.marked = "keyword";
              return cont(functiondef);
            }
            if (type2 == "variable") {
              register(value);
              return cont(functiondef);
            }
            if (type2 == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
            if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
          }
          function functiondecl(type2, value) {
            if (value == "*") {
              cx.marked = "keyword";
              return cont(functiondecl);
            }
            if (type2 == "variable") {
              register(value);
              return cont(functiondecl);
            }
            if (type2 == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
            if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
          }
          function typename(type2, value) {
            if (type2 == "keyword" || type2 == "variable") {
              cx.marked = "type";
              return cont(typename);
            } else if (value == "<") {
              return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
            }
          }
          function funarg(type2, value) {
            if (value == "@") cont(expression, funarg);
            if (type2 == "spread") return cont(funarg);
            if (isTS && isModifier(value)) {
              cx.marked = "keyword";
              return cont(funarg);
            }
            if (isTS && type2 == "this") return cont(maybetype, maybeAssign);
            return pass(pattern, maybetype, maybeAssign);
          }
          function classExpression(type2, value) {
            if (type2 == "variable") return className(type2, value);
            return classNameAfter(type2, value);
          }
          function className(type2, value) {
            if (type2 == "variable") {
              register(value);
              return cont(classNameAfter);
            }
          }
          function classNameAfter(type2, value) {
            if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);
            if (value == "extends" || value == "implements" || isTS && type2 == ",") {
              if (value == "implements") cx.marked = "keyword";
              return cont(isTS ? typeexpr : expression, classNameAfter);
            }
            if (type2 == "{") return cont(pushlex("}"), classBody, poplex);
          }
          function classBody(type2, value) {
            if (type2 == "async" || type2 == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\s+#?[\w$\xa1-\uffff]/, false)) {
              cx.marked = "keyword";
              return cont(classBody);
            }
            if (type2 == "variable" || cx.style == "keyword") {
              cx.marked = "property";
              return cont(classfield, classBody);
            }
            if (type2 == "number" || type2 == "string") return cont(classfield, classBody);
            if (type2 == "[")
              return cont(expression, maybetype, expect("]"), classfield, classBody);
            if (value == "*") {
              cx.marked = "keyword";
              return cont(classBody);
            }
            if (isTS && type2 == "(") return pass(functiondecl, classBody);
            if (type2 == ";" || type2 == ",") return cont(classBody);
            if (type2 == "}") return cont();
            if (value == "@") return cont(expression, classBody);
          }
          function classfield(type2, value) {
            if (value == "!") return cont(classfield);
            if (value == "?") return cont(classfield);
            if (type2 == ":") return cont(typeexpr, maybeAssign);
            if (value == "=") return cont(expressionNoComma);
            var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
            return pass(isInterface ? functiondecl : functiondef);
          }
          function afterExport(type2, value) {
            if (value == "*") {
              cx.marked = "keyword";
              return cont(maybeFrom, expect(";"));
            }
            if (value == "default") {
              cx.marked = "keyword";
              return cont(expression, expect(";"));
            }
            if (type2 == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
            return pass(statement);
          }
          function exportField(type2, value) {
            if (value == "as") {
              cx.marked = "keyword";
              return cont(expect("variable"));
            }
            if (type2 == "variable") return pass(expressionNoComma, exportField);
          }
          function afterImport(type2) {
            if (type2 == "string") return cont();
            if (type2 == "(") return pass(expression);
            if (type2 == ".") return pass(maybeoperatorComma);
            return pass(importSpec, maybeMoreImports, maybeFrom);
          }
          function importSpec(type2, value) {
            if (type2 == "{") return contCommasep(importSpec, "}");
            if (type2 == "variable") register(value);
            if (value == "*") cx.marked = "keyword";
            return cont(maybeAs);
          }
          function maybeMoreImports(type2) {
            if (type2 == ",") return cont(importSpec, maybeMoreImports);
          }
          function maybeAs(_type, value) {
            if (value == "as") {
              cx.marked = "keyword";
              return cont(importSpec);
            }
          }
          function maybeFrom(_type, value) {
            if (value == "from") {
              cx.marked = "keyword";
              return cont(expression);
            }
          }
          function arrayLiteral(type2) {
            if (type2 == "]") return cont();
            return pass(commasep(expressionNoComma, "]"));
          }
          function enumdef() {
            return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
          }
          function enummember() {
            return pass(pattern, maybeAssign);
          }
          function isContinuedStatement(state, textAfter) {
            return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
          }
          function expressionAllowed(stream, state, backUp) {
            return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
          }
          return {
            startState: function(basecolumn) {
              var state = {
                tokenize: tokenBase,
                lastType: "sof",
                cc: [],
                lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
                localVars: parserConfig.localVars,
                context: parserConfig.localVars && new Context(null, null, false),
                indented: basecolumn || 0
              };
              if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
                state.globalVars = parserConfig.globalVars;
              return state;
            },
            token: function(stream, state) {
              if (stream.sol()) {
                if (!state.lexical.hasOwnProperty("align"))
                  state.lexical.align = false;
                state.indented = stream.indentation();
                findFatArrow(stream, state);
              }
              if (state.tokenize != tokenComment && stream.eatSpace()) return null;
              var style = state.tokenize(stream, state);
              if (type == "comment") return style;
              state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
              return parseJS(state, style, type, content, stream);
            },
            indent: function(state, textAfter) {
              if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror3.Pass;
              if (state.tokenize != tokenBase) return 0;
              var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top;
              if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
                var c = state.cc[i];
                if (c == poplex) lexical = lexical.prev;
                else if (c != maybeelse && c != popcontext) break;
              }
              while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter)))
                lexical = lexical.prev;
              if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
                lexical = lexical.prev;
              var type2 = lexical.type, closing = firstChar == type2;
              if (type2 == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
              else if (type2 == "form" && firstChar == "{") return lexical.indented;
              else if (type2 == "form") return lexical.indented + indentUnit;
              else if (type2 == "stat")
                return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
              else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
                return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
              else if (lexical.align) return lexical.column + (closing ? 0 : 1);
              else return lexical.indented + (closing ? 0 : indentUnit);
            },
            electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
            blockCommentStart: jsonMode ? null : "/*",
            blockCommentEnd: jsonMode ? null : "*/",
            blockCommentContinue: jsonMode ? null : " * ",
            lineComment: jsonMode ? null : "//",
            fold: "brace",
            closeBrackets: "()[]{}''\"\"``",
            helperType: jsonMode ? "json" : "javascript",
            jsonldMode,
            jsonMode,
            expressionAllowed,
            skipExpression: function(state) {
              parseJS(state, "atom", "atom", "true", new CodeMirror3.StringStream("", 2, null));
            }
          };
        });
        CodeMirror3.registerHelper("wordChars", "javascript", /[\w$]/);
        CodeMirror3.defineMIME("text/javascript", "javascript");
        CodeMirror3.defineMIME("text/ecmascript", "javascript");
        CodeMirror3.defineMIME("application/javascript", "javascript");
        CodeMirror3.defineMIME("application/x-javascript", "javascript");
        CodeMirror3.defineMIME("application/ecmascript", "javascript");
        CodeMirror3.defineMIME("application/json", { name: "javascript", json: true });
        CodeMirror3.defineMIME("application/x-json", { name: "javascript", json: true });
        CodeMirror3.defineMIME("application/manifest+json", { name: "javascript", json: true });
        CodeMirror3.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
        CodeMirror3.defineMIME("text/typescript", { name: "javascript", typescript: true });
        CodeMirror3.defineMIME("application/typescript", { name: "javascript", typescript: true });
      });
    }
  });

  // ../../node_modules/codemirror/mode/htmlmixed/htmlmixed.js
  var require_htmlmixed = __commonJS({
    "../../node_modules/codemirror/mode/htmlmixed/htmlmixed.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror(), require_xml(), require_javascript(), require_css());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript", "../css/css"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        var defaultTags = {
          script: [
            ["lang", /(javascript|babel)/i, "javascript"],
            ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
            ["type", /./, "text/plain"],
            [null, null, "javascript"]
          ],
          style: [
            ["lang", /^css$/i, "css"],
            ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
            ["type", /./, "text/plain"],
            [null, null, "css"]
          ]
        };
        function maybeBackup(stream, pat, style) {
          var cur = stream.current(), close = cur.search(pat);
          if (close > -1) {
            stream.backUp(cur.length - close);
          } else if (cur.match(/<\/?$/)) {
            stream.backUp(cur.length);
            if (!stream.match(pat, false)) stream.match(cur);
          }
          return style;
        }
        var attrRegexpCache = {};
        function getAttrRegexp(attr) {
          var regexp = attrRegexpCache[attr];
          if (regexp) return regexp;
          return attrRegexpCache[attr] = new RegExp("\\s+" + attr + `\\s*=\\s*('|")?([^'"]+)('|")?\\s*`);
        }
        function getAttrValue(text, attr) {
          var match = text.match(getAttrRegexp(attr));
          return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : "";
        }
        function getTagRegexp(tagName, anchored) {
          return new RegExp((anchored ? "^" : "") + "</\\s*" + tagName + "\\s*>", "i");
        }
        function addTags(from, to) {
          for (var tag2 in from) {
            var dest = to[tag2] || (to[tag2] = []);
            var source = from[tag2];
            for (var i = source.length - 1; i >= 0; i--)
              dest.unshift(source[i]);
          }
        }
        function findMatchingMode(tagInfo, tagText) {
          for (var i = 0; i < tagInfo.length; i++) {
            var spec = tagInfo[i];
            if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
          }
        }
        CodeMirror3.defineMode("htmlmixed", function(config, parserConfig) {
          var htmlMode = CodeMirror3.getMode(config, {
            name: "xml",
            htmlMode: true,
            multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
            multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag,
            allowMissingTagName: parserConfig.allowMissingTagName
          });
          var tags = {};
          var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
          addTags(defaultTags, tags);
          if (configTags) addTags(configTags, tags);
          if (configScript) for (var i = configScript.length - 1; i >= 0; i--)
            tags.script.unshift(["type", configScript[i].matches, configScript[i].mode]);
          function html2(stream, state) {
            var style = htmlMode.token(stream, state.htmlState), tag2 = /\btag\b/.test(style), tagName;
            if (tag2 && !/[<>\s\/]/.test(stream.current()) && (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) && tags.hasOwnProperty(tagName)) {
              state.inTag = tagName + " ";
            } else if (state.inTag && tag2 && />$/.test(stream.current())) {
              var inTag = /^([\S]+) (.*)/.exec(state.inTag);
              state.inTag = null;
              var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2]);
              var mode = CodeMirror3.getMode(config, modeSpec);
              var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
              state.token = function(stream2, state2) {
                if (stream2.match(endTagA, false)) {
                  state2.token = html2;
                  state2.localState = state2.localMode = null;
                  return null;
                }
                return maybeBackup(stream2, endTag, state2.localMode.token(stream2, state2.localState));
              };
              state.localMode = mode;
              state.localState = CodeMirror3.startState(mode, htmlMode.indent(state.htmlState, "", ""));
            } else if (state.inTag) {
              state.inTag += stream.current();
              if (stream.eol()) state.inTag += " ";
            }
            return style;
          }
          ;
          return {
            startState: function() {
              var state = CodeMirror3.startState(htmlMode);
              return { token: html2, inTag: null, localMode: null, localState: null, htmlState: state };
            },
            copyState: function(state) {
              var local;
              if (state.localState) {
                local = CodeMirror3.copyState(state.localMode, state.localState);
              }
              return {
                token: state.token,
                inTag: state.inTag,
                localMode: state.localMode,
                localState: local,
                htmlState: CodeMirror3.copyState(htmlMode, state.htmlState)
              };
            },
            token: function(stream, state) {
              return state.token(stream, state);
            },
            indent: function(state, textAfter, line) {
              if (!state.localMode || /^\s*<\//.test(textAfter))
                return htmlMode.indent(state.htmlState, textAfter, line);
              else if (state.localMode.indent)
                return state.localMode.indent(state.localState, textAfter, line);
              else
                return CodeMirror3.Pass;
            },
            innerMode: function(state) {
              return { state: state.localState || state.htmlState, mode: state.localMode || htmlMode };
            }
          };
        }, "xml", "javascript", "css");
        CodeMirror3.defineMIME("text/html", "htmlmixed");
      });
    }
  });

  // ../../node_modules/inputmask/dist/inputmask.js
  var require_inputmask = __commonJS({
    "../../node_modules/inputmask/dist/inputmask.js"(exports, module) {
      !function(e, t) {
        if ("object" == typeof exports && "object" == typeof module) module.exports = t();
        else if ("function" == typeof define && define.amd) define([], t);
        else {
          var n = t();
          for (var i in n) ("object" == typeof exports ? exports : e)[i] = n[i];
        }
      }("undefined" != typeof self ? self : exports, function() {
        return function() {
          "use strict";
          var e = {
            3976: function(e2, t2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = void 0;
              t2.default = {
                _maxTestPos: 500,
                placeholder: "_",
                optionalmarker: ["[", "]"],
                quantifiermarker: ["{", "}"],
                groupmarker: ["(", ")"],
                alternatormarker: "|",
                escapeChar: "\\",
                mask: null,
                regex: null,
                oncomplete: function() {
                },
                onincomplete: function() {
                },
                oncleared: function() {
                },
                repeat: 0,
                greedy: false,
                autoUnmask: false,
                removeMaskOnSubmit: false,
                clearMaskOnLostFocus: true,
                insertMode: true,
                insertModeVisual: true,
                clearIncomplete: false,
                alias: null,
                onKeyDown: function() {
                },
                onBeforeMask: null,
                onBeforePaste: function(e3, t3) {
                  return "function" == typeof t3.onBeforeMask ? t3.onBeforeMask.call(this, e3, t3) : e3;
                },
                onBeforeWrite: null,
                onUnMask: null,
                showMaskOnFocus: true,
                showMaskOnHover: true,
                onKeyValidation: function() {
                },
                skipOptionalPartCharacter: " ",
                numericInput: false,
                rightAlign: false,
                undoOnEscape: true,
                radixPoint: "",
                _radixDance: false,
                groupSeparator: "",
                keepStatic: null,
                positionCaretOnTab: true,
                tabThrough: false,
                supportsInputType: ["text", "tel", "url", "password", "search"],
                isComplete: null,
                preValidation: null,
                postValidation: null,
                staticDefinitionSymbol: void 0,
                jitMasking: false,
                nullable: true,
                inputEventOnly: false,
                noValuePatching: false,
                positionCaretOnClick: "lvp",
                casing: null,
                inputmode: "text",
                importDataAttributes: true,
                shiftPositions: true,
                usePrototypeDefinitions: true,
                validationEventTimeOut: 3e3,
                substitutes: {}
              };
            },
            7392: function(e2, t2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = void 0;
              t2.default = {
                9: {
                  validator: "[0-9\uFF10-\uFF19]",
                  definitionSymbol: "*"
                },
                a: {
                  validator: "[A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]",
                  definitionSymbol: "*"
                },
                "*": {
                  validator: "[0-9\uFF10-\uFF19A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]"
                }
              };
            },
            253: function(e2, t2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = function(e3, t3, n2) {
                if (void 0 === n2) return e3.__data ? e3.__data[t3] : null;
                e3.__data = e3.__data || {}, e3.__data[t3] = n2;
              };
            },
            3776: function(e2, t2, n2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.Event = void 0, t2.off = function(e3, t3) {
                var n3, i3;
                u(this[0]) && e3 && (n3 = this[0].eventRegistry, i3 = this[0], e3.split(" ").forEach(function(e4) {
                  var a2 = o(e4.split("."), 2);
                  (function(e5, i4) {
                    var a3, r2, o2 = [];
                    if (e5.length > 0) if (void 0 === t3) for (a3 = 0, r2 = n3[e5][i4].length; a3 < r2; a3++) o2.push({
                      ev: e5,
                      namespace: i4 && i4.length > 0 ? i4 : "global",
                      handler: n3[e5][i4][a3]
                    });
                    else o2.push({
                      ev: e5,
                      namespace: i4 && i4.length > 0 ? i4 : "global",
                      handler: t3
                    });
                    else if (i4.length > 0) {
                      for (var l2 in n3) for (var s2 in n3[l2]) if (s2 === i4) if (void 0 === t3) for (a3 = 0, r2 = n3[l2][s2].length; a3 < r2; a3++) o2.push({
                        ev: l2,
                        namespace: s2,
                        handler: n3[l2][s2][a3]
                      });
                      else o2.push({
                        ev: l2,
                        namespace: s2,
                        handler: t3
                      });
                    }
                    return o2;
                  })(a2[0], a2[1]).forEach(function(e5) {
                    var t4 = e5.ev, a3 = e5.handler;
                    !function(e6, t5, a4) {
                      if (e6 in n3 == 1) if (i3.removeEventListener ? i3.removeEventListener(e6, a4, false) : i3.detachEvent && i3.detachEvent("on".concat(e6), a4), "global" === t5) for (var r2 in n3[e6]) n3[e6][r2].splice(n3[e6][r2].indexOf(a4), 1);
                      else n3[e6][t5].splice(n3[e6][t5].indexOf(a4), 1);
                    }(t4, e5.namespace, a3);
                  });
                }));
                return this;
              }, t2.on = function(e3, t3) {
                if (u(this[0])) {
                  var n3 = this[0].eventRegistry, i3 = this[0];
                  e3.split(" ").forEach(function(e4) {
                    var a2 = o(e4.split("."), 2), r2 = a2[0], l2 = a2[1];
                    !function(e5, a3) {
                      i3.addEventListener ? i3.addEventListener(e5, t3, false) : i3.attachEvent && i3.attachEvent("on".concat(e5), t3), n3[e5] = n3[e5] || {}, n3[e5][a3] = n3[e5][a3] || [], n3[e5][a3].push(t3);
                    }(r2, void 0 === l2 ? "global" : l2);
                  });
                }
                return this;
              }, t2.trigger = function(e3) {
                var t3 = arguments;
                if (u(this[0])) for (var n3 = this[0].eventRegistry, i3 = this[0], o2 = "string" == typeof e3 ? e3.split(" ") : [e3.type], l2 = 0; l2 < o2.length; l2++) {
                  var s2 = o2[l2].split("."), f2 = s2[0], p = s2[1] || "global";
                  if (void 0 !== c && "global" === p) {
                    var d, h = {
                      bubbles: true,
                      cancelable: true,
                      composed: true,
                      detail: arguments[1]
                    };
                    if (c.createEvent) {
                      try {
                        if ("input" === f2) h.inputType = "insertText", d = new InputEvent(f2, h);
                        else d = new CustomEvent(f2, h);
                      } catch (e4) {
                        (d = c.createEvent("CustomEvent")).initCustomEvent(f2, h.bubbles, h.cancelable, h.detail);
                      }
                      e3.type && (0, a.default)(d, e3), i3.dispatchEvent(d);
                    } else (d = c.createEventObject()).eventType = f2, d.detail = arguments[1], e3.type && (0, a.default)(d, e3), i3.fireEvent("on" + d.eventType, d);
                  } else if (void 0 !== n3[f2]) {
                    arguments[0] = arguments[0].type ? arguments[0] : r.default.Event(arguments[0]), arguments[0].detail = arguments.slice(1);
                    var v = n3[f2];
                    ("global" === p ? Object.values(v).flat() : v[p]).forEach(function(e4) {
                      return e4.apply(i3, t3);
                    });
                  }
                }
                return this;
              };
              var i2 = s(n2(9380)), a = s(n2(600)), r = s(n2(4963));
              function o(e3, t3) {
                return function(e4) {
                  if (Array.isArray(e4)) return e4;
                }(e3) || function(e4, t4) {
                  var n3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
                  if (null != n3) {
                    var i3, a2, r2, o2, l2 = [], s2 = true, c2 = false;
                    try {
                      if (r2 = (n3 = n3.call(e4)).next, 0 === t4) {
                        if (Object(n3) !== n3) return;
                        s2 = false;
                      } else for (; !(s2 = (i3 = r2.call(n3)).done) && (l2.push(i3.value), l2.length !== t4); s2 = true) ;
                    } catch (e5) {
                      c2 = true, a2 = e5;
                    } finally {
                      try {
                        if (!s2 && null != n3.return && (o2 = n3.return(), Object(o2) !== o2)) return;
                      } finally {
                        if (c2) throw a2;
                      }
                    }
                    return l2;
                  }
                }(e3, t3) || function(e4, t4) {
                  if (!e4) return;
                  if ("string" == typeof e4) return l(e4, t4);
                  var n3 = Object.prototype.toString.call(e4).slice(8, -1);
                  "Object" === n3 && e4.constructor && (n3 = e4.constructor.name);
                  if ("Map" === n3 || "Set" === n3) return Array.from(e4);
                  if ("Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return l(e4, t4);
                }(e3, t3) || function() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }();
              }
              function l(e3, t3) {
                (null == t3 || t3 > e3.length) && (t3 = e3.length);
                for (var n3 = 0, i3 = new Array(t3); n3 < t3; n3++) i3[n3] = e3[n3];
                return i3;
              }
              function s(e3) {
                return e3 && e3.__esModule ? e3 : {
                  default: e3
                };
              }
              var c = i2.default.document;
              function u(e3) {
                return e3 instanceof Element;
              }
              var f = t2.Event = void 0;
              "function" == typeof i2.default.CustomEvent ? t2.Event = f = i2.default.CustomEvent : i2.default.Event && c && c.createEvent ? (t2.Event = f = function(e3, t3) {
                t3 = t3 || {
                  bubbles: false,
                  cancelable: false,
                  composed: true,
                  detail: void 0
                };
                var n3 = c.createEvent("CustomEvent");
                return n3.initCustomEvent(e3, t3.bubbles, t3.cancelable, t3.detail), n3;
              }, f.prototype = i2.default.Event.prototype) : "undefined" != typeof Event && (t2.Event = f = Event);
            },
            600: function(e2, t2) {
              function n2(e3) {
                return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
                  return typeof e4;
                } : function(e4) {
                  return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
                }, n2(e3);
              }
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = function e3() {
                var t3, i2, a, r, o, l, s = arguments[0] || {}, c = 1, u = arguments.length, f = false;
                "boolean" == typeof s && (f = s, s = arguments[c] || {}, c++);
                "object" !== n2(s) && "function" != typeof s && (s = {});
                for (; c < u; c++) if (null != (t3 = arguments[c])) for (i2 in t3) a = s[i2], s !== (r = t3[i2]) && (f && r && ("[object Object]" === Object.prototype.toString.call(r) || (o = Array.isArray(r))) ? (o ? (o = false, l = a && Array.isArray(a) ? a : []) : l = a && "[object Object]" === Object.prototype.toString.call(a) ? a : {}, s[i2] = e3(f, l, r)) : void 0 !== r && (s[i2] = r));
                return s;
              };
            },
            4963: function(e2, t2, n2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = void 0;
              var i2 = l(n2(9380)), a = l(n2(253)), r = n2(3776), o = l(n2(600));
              function l(e3) {
                return e3 && e3.__esModule ? e3 : {
                  default: e3
                };
              }
              var s = i2.default.document;
              function c(e3) {
                return e3 instanceof c ? e3 : this instanceof c ? void (null != e3 && e3 !== i2.default && (this[0] = e3.nodeName ? e3 : void 0 !== e3[0] && e3[0].nodeName ? e3[0] : s.querySelector(e3), void 0 !== this[0] && null !== this[0] && (this[0].eventRegistry = this[0].eventRegistry || {}))) : new c(e3);
              }
              c.prototype = {
                on: r.on,
                off: r.off,
                trigger: r.trigger
              }, c.extend = o.default, c.data = a.default, c.Event = r.Event;
              t2.default = c;
            },
            9845: function(e2, t2, n2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.mobile = t2.iphone = t2.ie = void 0;
              var i2, a = (i2 = n2(9380)) && i2.__esModule ? i2 : {
                default: i2
              };
              var r = a.default.navigator && a.default.navigator.userAgent || "";
              t2.ie = r.indexOf("MSIE ") > 0 || r.indexOf("Trident/") > 0, t2.mobile = a.default.navigator && a.default.navigator.userAgentData && a.default.navigator.userAgentData.mobile || a.default.navigator && a.default.navigator.maxTouchPoints || "ontouchstart" in a.default, t2.iphone = /iphone/i.test(r);
            },
            7184: function(e2, t2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = function(e3) {
                return e3.replace(n2, "\\$1");
              };
              var n2 = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"].join("|\\") + ")", "gim");
            },
            6030: function(e2, t2, n2) {
              function i2(e3) {
                return i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
                  return typeof e4;
                } : function(e4) {
                  return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
                }, i2(e3);
              }
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.EventHandlers = void 0;
              var a, r = n2(9845), o = (a = n2(9380)) && a.__esModule ? a : {
                default: a
              }, l = n2(7760), s = n2(2839), c = n2(8711), u = n2(7215), f = n2(4713);
              function p() {
                p = function() {
                  return t3;
                };
                var e3, t3 = {}, n3 = Object.prototype, a2 = n3.hasOwnProperty, r2 = Object.defineProperty || function(e4, t4, n4) {
                  e4[t4] = n4.value;
                }, o2 = "function" == typeof Symbol ? Symbol : {}, l2 = o2.iterator || "@@iterator", s2 = o2.asyncIterator || "@@asyncIterator", c2 = o2.toStringTag || "@@toStringTag";
                function u2(e4, t4, n4) {
                  return Object.defineProperty(e4, t4, {
                    value: n4,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  }), e4[t4];
                }
                try {
                  u2({}, "");
                } catch (e4) {
                  u2 = function(e5, t4, n4) {
                    return e5[t4] = n4;
                  };
                }
                function f2(e4, t4, n4, i3) {
                  var a3 = t4 && t4.prototype instanceof k ? t4 : k, o3 = Object.create(a3.prototype), l3 = new D(i3 || []);
                  return r2(o3, "_invoke", {
                    value: E(e4, n4, l3)
                  }), o3;
                }
                function d2(e4, t4, n4) {
                  try {
                    return {
                      type: "normal",
                      arg: e4.call(t4, n4)
                    };
                  } catch (e5) {
                    return {
                      type: "throw",
                      arg: e5
                    };
                  }
                }
                t3.wrap = f2;
                var h2 = "suspendedStart", v2 = "suspendedYield", m2 = "executing", g2 = "completed", y2 = {};
                function k() {
                }
                function b() {
                }
                function x() {
                }
                var w = {};
                u2(w, l2, function() {
                  return this;
                });
                var P = Object.getPrototypeOf, S = P && P(P(L([])));
                S && S !== n3 && a2.call(S, l2) && (w = S);
                var O = x.prototype = k.prototype = Object.create(w);
                function _2(e4) {
                  ["next", "throw", "return"].forEach(function(t4) {
                    u2(e4, t4, function(e5) {
                      return this._invoke(t4, e5);
                    });
                  });
                }
                function M(e4, t4) {
                  function n4(r3, o4, l3, s3) {
                    var c3 = d2(e4[r3], e4, o4);
                    if ("throw" !== c3.type) {
                      var u3 = c3.arg, f3 = u3.value;
                      return f3 && "object" == i2(f3) && a2.call(f3, "__await") ? t4.resolve(f3.__await).then(function(e5) {
                        n4("next", e5, l3, s3);
                      }, function(e5) {
                        n4("throw", e5, l3, s3);
                      }) : t4.resolve(f3).then(function(e5) {
                        u3.value = e5, l3(u3);
                      }, function(e5) {
                        return n4("throw", e5, l3, s3);
                      });
                    }
                    s3(c3.arg);
                  }
                  var o3;
                  r2(this, "_invoke", {
                    value: function(e5, i3) {
                      function a3() {
                        return new t4(function(t5, a4) {
                          n4(e5, i3, t5, a4);
                        });
                      }
                      return o3 = o3 ? o3.then(a3, a3) : a3();
                    }
                  });
                }
                function E(t4, n4, i3) {
                  var a3 = h2;
                  return function(r3, o3) {
                    if (a3 === m2) throw new Error("Generator is already running");
                    if (a3 === g2) {
                      if ("throw" === r3) throw o3;
                      return {
                        value: e3,
                        done: true
                      };
                    }
                    for (i3.method = r3, i3.arg = o3; ; ) {
                      var l3 = i3.delegate;
                      if (l3) {
                        var s3 = j(l3, i3);
                        if (s3) {
                          if (s3 === y2) continue;
                          return s3;
                        }
                      }
                      if ("next" === i3.method) i3.sent = i3._sent = i3.arg;
                      else if ("throw" === i3.method) {
                        if (a3 === h2) throw a3 = g2, i3.arg;
                        i3.dispatchException(i3.arg);
                      } else "return" === i3.method && i3.abrupt("return", i3.arg);
                      a3 = m2;
                      var c3 = d2(t4, n4, i3);
                      if ("normal" === c3.type) {
                        if (a3 = i3.done ? g2 : v2, c3.arg === y2) continue;
                        return {
                          value: c3.arg,
                          done: i3.done
                        };
                      }
                      "throw" === c3.type && (a3 = g2, i3.method = "throw", i3.arg = c3.arg);
                    }
                  };
                }
                function j(t4, n4) {
                  var i3 = n4.method, a3 = t4.iterator[i3];
                  if (a3 === e3) return n4.delegate = null, "throw" === i3 && t4.iterator.return && (n4.method = "return", n4.arg = e3, j(t4, n4), "throw" === n4.method) || "return" !== i3 && (n4.method = "throw", n4.arg = new TypeError("The iterator does not provide a '" + i3 + "' method")), y2;
                  var r3 = d2(a3, t4.iterator, n4.arg);
                  if ("throw" === r3.type) return n4.method = "throw", n4.arg = r3.arg, n4.delegate = null, y2;
                  var o3 = r3.arg;
                  return o3 ? o3.done ? (n4[t4.resultName] = o3.value, n4.next = t4.nextLoc, "return" !== n4.method && (n4.method = "next", n4.arg = e3), n4.delegate = null, y2) : o3 : (n4.method = "throw", n4.arg = new TypeError("iterator result is not an object"), n4.delegate = null, y2);
                }
                function T(e4) {
                  var t4 = {
                    tryLoc: e4[0]
                  };
                  1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
                }
                function A(e4) {
                  var t4 = e4.completion || {};
                  t4.type = "normal", delete t4.arg, e4.completion = t4;
                }
                function D(e4) {
                  this.tryEntries = [{
                    tryLoc: "root"
                  }], e4.forEach(T, this), this.reset(true);
                }
                function L(t4) {
                  if (t4 || "" === t4) {
                    var n4 = t4[l2];
                    if (n4) return n4.call(t4);
                    if ("function" == typeof t4.next) return t4;
                    if (!isNaN(t4.length)) {
                      var r3 = -1, o3 = function n5() {
                        for (; ++r3 < t4.length; ) if (a2.call(t4, r3)) return n5.value = t4[r3], n5.done = false, n5;
                        return n5.value = e3, n5.done = true, n5;
                      };
                      return o3.next = o3;
                    }
                  }
                  throw new TypeError(i2(t4) + " is not iterable");
                }
                return b.prototype = x, r2(O, "constructor", {
                  value: x,
                  configurable: true
                }), r2(x, "constructor", {
                  value: b,
                  configurable: true
                }), b.displayName = u2(x, c2, "GeneratorFunction"), t3.isGeneratorFunction = function(e4) {
                  var t4 = "function" == typeof e4 && e4.constructor;
                  return !!t4 && (t4 === b || "GeneratorFunction" === (t4.displayName || t4.name));
                }, t3.mark = function(e4) {
                  return Object.setPrototypeOf ? Object.setPrototypeOf(e4, x) : (e4.__proto__ = x, u2(e4, c2, "GeneratorFunction")), e4.prototype = Object.create(O), e4;
                }, t3.awrap = function(e4) {
                  return {
                    __await: e4
                  };
                }, _2(M.prototype), u2(M.prototype, s2, function() {
                  return this;
                }), t3.AsyncIterator = M, t3.async = function(e4, n4, i3, a3, r3) {
                  void 0 === r3 && (r3 = Promise);
                  var o3 = new M(f2(e4, n4, i3, a3), r3);
                  return t3.isGeneratorFunction(n4) ? o3 : o3.next().then(function(e5) {
                    return e5.done ? e5.value : o3.next();
                  });
                }, _2(O), u2(O, c2, "Generator"), u2(O, l2, function() {
                  return this;
                }), u2(O, "toString", function() {
                  return "[object Generator]";
                }), t3.keys = function(e4) {
                  var t4 = Object(e4), n4 = [];
                  for (var i3 in t4) n4.push(i3);
                  return n4.reverse(), function e5() {
                    for (; n4.length; ) {
                      var i4 = n4.pop();
                      if (i4 in t4) return e5.value = i4, e5.done = false, e5;
                    }
                    return e5.done = true, e5;
                  };
                }, t3.values = L, D.prototype = {
                  constructor: D,
                  reset: function(t4) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = e3, this.done = false, this.delegate = null, this.method = "next", this.arg = e3, this.tryEntries.forEach(A), !t4) for (var n4 in this) "t" === n4.charAt(0) && a2.call(this, n4) && !isNaN(+n4.slice(1)) && (this[n4] = e3);
                  },
                  stop: function() {
                    this.done = true;
                    var e4 = this.tryEntries[0].completion;
                    if ("throw" === e4.type) throw e4.arg;
                    return this.rval;
                  },
                  dispatchException: function(t4) {
                    if (this.done) throw t4;
                    var n4 = this;
                    function i3(i4, a3) {
                      return l3.type = "throw", l3.arg = t4, n4.next = i4, a3 && (n4.method = "next", n4.arg = e3), !!a3;
                    }
                    for (var r3 = this.tryEntries.length - 1; r3 >= 0; --r3) {
                      var o3 = this.tryEntries[r3], l3 = o3.completion;
                      if ("root" === o3.tryLoc) return i3("end");
                      if (o3.tryLoc <= this.prev) {
                        var s3 = a2.call(o3, "catchLoc"), c3 = a2.call(o3, "finallyLoc");
                        if (s3 && c3) {
                          if (this.prev < o3.catchLoc) return i3(o3.catchLoc, true);
                          if (this.prev < o3.finallyLoc) return i3(o3.finallyLoc);
                        } else if (s3) {
                          if (this.prev < o3.catchLoc) return i3(o3.catchLoc, true);
                        } else {
                          if (!c3) throw new Error("try statement without catch or finally");
                          if (this.prev < o3.finallyLoc) return i3(o3.finallyLoc);
                        }
                      }
                    }
                  },
                  abrupt: function(e4, t4) {
                    for (var n4 = this.tryEntries.length - 1; n4 >= 0; --n4) {
                      var i3 = this.tryEntries[n4];
                      if (i3.tryLoc <= this.prev && a2.call(i3, "finallyLoc") && this.prev < i3.finallyLoc) {
                        var r3 = i3;
                        break;
                      }
                    }
                    r3 && ("break" === e4 || "continue" === e4) && r3.tryLoc <= t4 && t4 <= r3.finallyLoc && (r3 = null);
                    var o3 = r3 ? r3.completion : {};
                    return o3.type = e4, o3.arg = t4, r3 ? (this.method = "next", this.next = r3.finallyLoc, y2) : this.complete(o3);
                  },
                  complete: function(e4, t4) {
                    if ("throw" === e4.type) throw e4.arg;
                    return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), y2;
                  },
                  finish: function(e4) {
                    for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
                      var n4 = this.tryEntries[t4];
                      if (n4.finallyLoc === e4) return this.complete(n4.completion, n4.afterLoc), A(n4), y2;
                    }
                  },
                  catch: function(e4) {
                    for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
                      var n4 = this.tryEntries[t4];
                      if (n4.tryLoc === e4) {
                        var i3 = n4.completion;
                        if ("throw" === i3.type) {
                          var a3 = i3.arg;
                          A(n4);
                        }
                        return a3;
                      }
                    }
                    throw new Error("illegal catch attempt");
                  },
                  delegateYield: function(t4, n4, i3) {
                    return this.delegate = {
                      iterator: L(t4),
                      resultName: n4,
                      nextLoc: i3
                    }, "next" === this.method && (this.arg = e3), y2;
                  }
                }, t3;
              }
              function d(e3, t3) {
                var n3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
                if (!n3) {
                  if (Array.isArray(e3) || (n3 = function(e4, t4) {
                    if (!e4) return;
                    if ("string" == typeof e4) return h(e4, t4);
                    var n4 = Object.prototype.toString.call(e4).slice(8, -1);
                    "Object" === n4 && e4.constructor && (n4 = e4.constructor.name);
                    if ("Map" === n4 || "Set" === n4) return Array.from(e4);
                    if ("Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4)) return h(e4, t4);
                  }(e3)) || t3 && e3 && "number" == typeof e3.length) {
                    n3 && (e3 = n3);
                    var i3 = 0, a2 = function() {
                    };
                    return {
                      s: a2,
                      n: function() {
                        return i3 >= e3.length ? {
                          done: true
                        } : {
                          done: false,
                          value: e3[i3++]
                        };
                      },
                      e: function(e4) {
                        throw e4;
                      },
                      f: a2
                    };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var r2, o2 = true, l2 = false;
                return {
                  s: function() {
                    n3 = n3.call(e3);
                  },
                  n: function() {
                    var e4 = n3.next();
                    return o2 = e4.done, e4;
                  },
                  e: function(e4) {
                    l2 = true, r2 = e4;
                  },
                  f: function() {
                    try {
                      o2 || null == n3.return || n3.return();
                    } finally {
                      if (l2) throw r2;
                    }
                  }
                };
              }
              function h(e3, t3) {
                (null == t3 || t3 > e3.length) && (t3 = e3.length);
                for (var n3 = 0, i3 = new Array(t3); n3 < t3; n3++) i3[n3] = e3[n3];
                return i3;
              }
              function v(e3, t3, n3, i3, a2, r2, o2) {
                try {
                  var l2 = e3[r2](o2), s2 = l2.value;
                } catch (e4) {
                  return void n3(e4);
                }
                l2.done ? t3(s2) : Promise.resolve(s2).then(i3, a2);
              }
              var m, g, y = t2.EventHandlers = {
                keyEvent: function(e3, t3, n3, i3, a2) {
                  var o2 = this.inputmask, p2 = o2.opts, d2 = o2.dependencyLib, h2 = o2.maskset, v2 = this, m2 = d2(v2), g2 = e3.key, k = c.caret.call(o2, v2), b = p2.onKeyDown.call(this, e3, c.getBuffer.call(o2), k, p2);
                  if (void 0 !== b) return b;
                  if (g2 === s.keys.Backspace || g2 === s.keys.Delete || r.iphone && g2 === s.keys.BACKSPACE_SAFARI || e3.ctrlKey && g2 === s.keys.x && !("oncut" in v2)) e3.preventDefault(), u.handleRemove.call(o2, v2, g2, k), (0, l.writeBuffer)(v2, c.getBuffer.call(o2, true), h2.p, e3, v2.inputmask._valueGet() !== c.getBuffer.call(o2).join(""));
                  else if (g2 === s.keys.End || g2 === s.keys.PageDown) {
                    e3.preventDefault();
                    var x = c.seekNext.call(o2, c.getLastValidPosition.call(o2));
                    c.caret.call(o2, v2, e3.shiftKey ? k.begin : x, x, true);
                  } else g2 === s.keys.Home && !e3.shiftKey || g2 === s.keys.PageUp ? (e3.preventDefault(), c.caret.call(o2, v2, 0, e3.shiftKey ? k.begin : 0, true)) : p2.undoOnEscape && g2 === s.keys.Escape && true !== e3.altKey ? ((0, l.checkVal)(v2, true, false, o2.undoValue.split("")), m2.trigger("click")) : g2 !== s.keys.Insert || e3.shiftKey || e3.ctrlKey || void 0 !== o2.userOptions.insertMode ? true === p2.tabThrough && g2 === s.keys.Tab ? true === e3.shiftKey ? (k.end = c.seekPrevious.call(o2, k.end, true), true === f.getTest.call(o2, k.end - 1).match.static && k.end--, k.begin = c.seekPrevious.call(o2, k.end, true), k.begin >= 0 && k.end > 0 && (e3.preventDefault(), c.caret.call(o2, v2, k.begin, k.end))) : (k.begin = c.seekNext.call(o2, k.begin, true), k.end = c.seekNext.call(o2, k.begin, true), k.end < h2.maskLength && k.end--, k.begin <= h2.maskLength && (e3.preventDefault(), c.caret.call(o2, v2, k.begin, k.end))) : e3.shiftKey || (p2.insertModeVisual && false === p2.insertMode ? g2 === s.keys.ArrowRight ? setTimeout(function() {
                    var e4 = c.caret.call(o2, v2);
                    c.caret.call(o2, v2, e4.begin);
                  }, 0) : g2 === s.keys.ArrowLeft && setTimeout(function() {
                    var e4 = c.translatePosition.call(o2, v2.inputmask.caretPos.begin);
                    c.translatePosition.call(o2, v2.inputmask.caretPos.end);
                    o2.isRTL ? c.caret.call(o2, v2, e4 + (e4 === h2.maskLength ? 0 : 1)) : c.caret.call(o2, v2, e4 - (0 === e4 ? 0 : 1));
                  }, 0) : void 0 === o2.keyEventHook || o2.keyEventHook(e3)) : u.isSelection.call(o2, k) ? p2.insertMode = !p2.insertMode : (p2.insertMode = !p2.insertMode, c.caret.call(o2, v2, k.begin, k.begin));
                  return o2.isComposing = g2 == s.keys.Process || g2 == s.keys.Unidentified, o2.ignorable = g2.length > 1 && !("textarea" === v2.tagName.toLowerCase() && g2 == s.keys.Enter), y.keypressEvent.call(this, e3, t3, n3, i3, a2);
                },
                keypressEvent: function(e3, t3, n3, i3, a2) {
                  var r2 = this.inputmask || this, o2 = r2.opts, f2 = r2.dependencyLib, p2 = r2.maskset, d2 = r2.el, h2 = f2(d2), v2 = e3.key;
                  if (true === t3 || e3.ctrlKey && e3.altKey && !r2.ignorable || !(e3.ctrlKey || e3.metaKey || r2.ignorable)) {
                    if (v2) {
                      var m2, g2 = t3 ? {
                        begin: a2,
                        end: a2
                      } : c.caret.call(r2, d2);
                      t3 || (v2 = o2.substitutes[v2] || v2), p2.writeOutBuffer = true;
                      var y2 = u.isValid.call(r2, g2, v2, i3, void 0, void 0, void 0, t3);
                      if (false !== y2 && (c.resetMaskSet.call(r2, true), m2 = void 0 !== y2.caret ? y2.caret : c.seekNext.call(r2, y2.pos.begin ? y2.pos.begin : y2.pos), p2.p = m2), m2 = o2.numericInput && void 0 === y2.caret ? c.seekPrevious.call(r2, m2) : m2, false !== n3 && (setTimeout(function() {
                        o2.onKeyValidation.call(d2, v2, y2);
                      }, 0), p2.writeOutBuffer && false !== y2)) {
                        var k = c.getBuffer.call(r2);
                        (0, l.writeBuffer)(d2, k, m2, e3, true !== t3);
                      }
                      if (e3.preventDefault(), t3) return false !== y2 && (y2.forwardPosition = m2), y2;
                    }
                  } else v2 === s.keys.Enter && r2.undoValue !== r2._valueGet(true) && (r2.undoValue = r2._valueGet(true), setTimeout(function() {
                    h2.trigger("change");
                  }, 0));
                },
                pasteEvent: (m = p().mark(function e3(t3) {
                  var n3, i3, a2, r2, s2, u2;
                  return p().wrap(function(e4) {
                    for (; ; ) switch (e4.prev = e4.next) {
                      case 0:
                        n3 = function(e5, n4, i4, a3, o2) {
                          var s3 = c.caret.call(e5, n4, void 0, void 0, true), u3 = i4.substr(0, s3.begin), f2 = i4.substr(s3.end, i4.length);
                          if (u3 == (e5.isRTL ? c.getBufferTemplate.call(e5).slice().reverse() : c.getBufferTemplate.call(e5)).slice(0, s3.begin).join("") && (u3 = ""), f2 == (e5.isRTL ? c.getBufferTemplate.call(e5).slice().reverse() : c.getBufferTemplate.call(e5)).slice(s3.end).join("") && (f2 = ""), a3 = u3 + a3 + f2, e5.isRTL && true !== r2.numericInput) {
                            a3 = a3.split("");
                            var p2, h2 = d(c.getBufferTemplate.call(e5));
                            try {
                              for (h2.s(); !(p2 = h2.n()).done; ) {
                                var v2 = p2.value;
                                a3[0] === v2 && a3.shift();
                              }
                            } catch (e6) {
                              h2.e(e6);
                            } finally {
                              h2.f();
                            }
                            a3 = a3.reverse().join("");
                          }
                          var m2 = a3;
                          if ("function" == typeof o2) {
                            if (false === (m2 = o2.call(e5, m2, r2))) return false;
                            m2 || (m2 = i4);
                          }
                          (0, l.checkVal)(n4, true, false, m2.toString().split(""), t3);
                        }, i3 = this, a2 = this.inputmask, r2 = a2.opts, s2 = a2._valueGet(true), a2.skipInputEvent = true, t3.clipboardData && t3.clipboardData.getData ? u2 = t3.clipboardData.getData("text/plain") : o.default.clipboardData && o.default.clipboardData.getData && (u2 = o.default.clipboardData.getData("Text")), n3(a2, i3, s2, u2, r2.onBeforePaste), t3.preventDefault();
                      case 7:
                      case "end":
                        return e4.stop();
                    }
                  }, e3, this);
                }), g = function() {
                  var e3 = this, t3 = arguments;
                  return new Promise(function(n3, i3) {
                    var a2 = m.apply(e3, t3);
                    function r2(e4) {
                      v(a2, n3, i3, r2, o2, "next", e4);
                    }
                    function o2(e4) {
                      v(a2, n3, i3, r2, o2, "throw", e4);
                    }
                    r2(void 0);
                  });
                }, function(e3) {
                  return g.apply(this, arguments);
                }),
                inputFallBackEvent: function(e3) {
                  var t3 = this.inputmask, n3 = t3.opts, i3 = t3.dependencyLib;
                  var a2, o2 = this, u2 = o2.inputmask._valueGet(true), p2 = (t3.isRTL ? c.getBuffer.call(t3).slice().reverse() : c.getBuffer.call(t3)).join(""), d2 = c.caret.call(t3, o2, void 0, void 0, true);
                  if (p2 !== u2) {
                    if (a2 = function(e4, i4, a3) {
                      for (var r2, o3, l2, s2 = e4.substr(0, a3.begin).split(""), u3 = e4.substr(a3.begin).split(""), p3 = i4.substr(0, a3.begin).split(""), d3 = i4.substr(a3.begin).split(""), h3 = s2.length >= p3.length ? s2.length : p3.length, v2 = u3.length >= d3.length ? u3.length : d3.length, m2 = "", g2 = [], y2 = "~"; s2.length < h3; ) s2.push(y2);
                      for (; p3.length < h3; ) p3.push(y2);
                      for (; u3.length < v2; ) u3.unshift(y2);
                      for (; d3.length < v2; ) d3.unshift(y2);
                      var k = s2.concat(u3), b = p3.concat(d3);
                      for (o3 = 0, r2 = k.length; o3 < r2; o3++) switch (l2 = f.getPlaceholder.call(t3, c.translatePosition.call(t3, o3)), m2) {
                        case "insertText":
                          b[o3 - 1] === k[o3] && a3.begin == k.length - 1 && g2.push(k[o3]), o3 = r2;
                          break;
                        case "insertReplacementText":
                        case "deleteContentBackward":
                          k[o3] === y2 ? a3.end++ : o3 = r2;
                          break;
                        default:
                          k[o3] !== b[o3] && (k[o3 + 1] !== y2 && k[o3 + 1] !== l2 && void 0 !== k[o3 + 1] || (b[o3] !== l2 || b[o3 + 1] !== y2) && b[o3] !== y2 ? b[o3 + 1] === y2 && b[o3] === k[o3 + 1] ? (m2 = "insertText", g2.push(k[o3]), a3.begin--, a3.end--) : k[o3] !== l2 && k[o3] !== y2 && (k[o3 + 1] === y2 || b[o3] !== k[o3] && b[o3 + 1] === k[o3 + 1]) ? (m2 = "insertReplacementText", g2.push(k[o3]), a3.begin--) : k[o3] === y2 ? (m2 = "deleteContentBackward", (c.isMask.call(t3, c.translatePosition.call(t3, o3), true) || b[o3] === n3.radixPoint) && a3.end++) : o3 = r2 : (m2 = "insertText", g2.push(k[o3]), a3.begin--, a3.end--));
                      }
                      return {
                        action: m2,
                        data: g2,
                        caret: a3
                      };
                    }(u2, p2, d2), (o2.inputmask.shadowRoot || o2.ownerDocument).activeElement !== o2 && o2.focus(), (0, l.writeBuffer)(o2, c.getBuffer.call(t3)), c.caret.call(t3, o2, d2.begin, d2.end, true), !r.mobile && t3.skipNextInsert && "insertText" === e3.inputType && "insertText" === a2.action && t3.isComposing) return false;
                    switch ("insertCompositionText" === e3.inputType && "insertText" === a2.action && t3.isComposing ? t3.skipNextInsert = true : t3.skipNextInsert = false, a2.action) {
                      case "insertText":
                      case "insertReplacementText":
                        a2.data.forEach(function(e4, n4) {
                          var a3 = new i3.Event("keypress");
                          a3.key = e4, t3.ignorable = false, y.keypressEvent.call(o2, a3);
                        }), setTimeout(function() {
                          t3.$el.trigger("keyup");
                        }, 0);
                        break;
                      case "deleteContentBackward":
                        var h2 = new i3.Event("keydown");
                        h2.key = s.keys.Backspace, y.keyEvent.call(o2, h2);
                        break;
                      default:
                        (0, l.applyInputValue)(o2, u2), c.caret.call(t3, o2, d2.begin, d2.end, true);
                    }
                    e3.preventDefault();
                  }
                },
                setValueEvent: function(e3) {
                  var t3 = this.inputmask, n3 = t3.dependencyLib, i3 = this, a2 = e3 && e3.detail ? e3.detail[0] : arguments[1];
                  void 0 === a2 && (a2 = i3.inputmask._valueGet(true)), (0, l.applyInputValue)(i3, a2, new n3.Event("input")), (e3.detail && void 0 !== e3.detail[1] || void 0 !== arguments[2]) && c.caret.call(t3, i3, e3.detail ? e3.detail[1] : arguments[2]);
                },
                focusEvent: function(e3) {
                  var t3 = this.inputmask, n3 = t3.opts, i3 = t3 && t3._valueGet();
                  n3.showMaskOnFocus && i3 !== c.getBuffer.call(t3).join("") && (0, l.writeBuffer)(this, c.getBuffer.call(t3), c.seekNext.call(t3, c.getLastValidPosition.call(t3))), true !== n3.positionCaretOnTab || false !== t3.mouseEnter || u.isComplete.call(t3, c.getBuffer.call(t3)) && -1 !== c.getLastValidPosition.call(t3) || y.clickEvent.apply(this, [e3, true]), t3.undoValue = t3 && t3._valueGet(true);
                },
                invalidEvent: function(e3) {
                  this.inputmask.validationEvent = true;
                },
                mouseleaveEvent: function() {
                  var e3 = this.inputmask, t3 = e3.opts, n3 = this;
                  e3.mouseEnter = false, t3.clearMaskOnLostFocus && (n3.inputmask.shadowRoot || n3.ownerDocument).activeElement !== n3 && (0, l.HandleNativePlaceholder)(n3, e3.originalPlaceholder);
                },
                clickEvent: function(e3, t3) {
                  var n3 = this.inputmask;
                  n3.clicked++;
                  var i3 = this;
                  if ((i3.inputmask.shadowRoot || i3.ownerDocument).activeElement === i3) {
                    var a2 = c.determineNewCaretPosition.call(n3, c.caret.call(n3, i3), t3);
                    void 0 !== a2 && c.caret.call(n3, i3, a2);
                  }
                },
                cutEvent: function(e3) {
                  var t3 = this.inputmask, n3 = t3.maskset, i3 = this, a2 = c.caret.call(t3, i3), r2 = t3.isRTL ? c.getBuffer.call(t3).slice(a2.end, a2.begin) : c.getBuffer.call(t3).slice(a2.begin, a2.end), f2 = t3.isRTL ? r2.reverse().join("") : r2.join("");
                  o.default.navigator && o.default.navigator.clipboard ? o.default.navigator.clipboard.writeText(f2) : o.default.clipboardData && o.default.clipboardData.getData && o.default.clipboardData.setData("Text", f2), u.handleRemove.call(t3, i3, s.keys.Delete, a2), (0, l.writeBuffer)(i3, c.getBuffer.call(t3), n3.p, e3, t3.undoValue !== t3._valueGet(true));
                },
                blurEvent: function(e3) {
                  var t3 = this.inputmask, n3 = t3.opts, i3 = t3.dependencyLib;
                  t3.clicked = 0;
                  var a2 = i3(this), r2 = this;
                  if (r2.inputmask) {
                    (0, l.HandleNativePlaceholder)(r2, t3.originalPlaceholder);
                    var o2 = r2.inputmask._valueGet(), s2 = c.getBuffer.call(t3).slice();
                    "" !== o2 && (n3.clearMaskOnLostFocus && (-1 === c.getLastValidPosition.call(t3) && o2 === c.getBufferTemplate.call(t3).join("") ? s2 = [] : l.clearOptionalTail.call(t3, s2)), false === u.isComplete.call(t3, s2) && (setTimeout(function() {
                      a2.trigger("incomplete");
                    }, 0), n3.clearIncomplete && (c.resetMaskSet.call(t3, false), s2 = n3.clearMaskOnLostFocus ? [] : c.getBufferTemplate.call(t3).slice())), (0, l.writeBuffer)(r2, s2, void 0, e3)), o2 = t3._valueGet(true), t3.undoValue !== o2 && ("" != o2 || t3.undoValue != c.getBufferTemplate.call(t3).join("") || t3.undoValue == c.getBufferTemplate.call(t3).join("") && t3.maskset.validPositions.length > 0) && (t3.undoValue = o2, a2.trigger("change"));
                  }
                },
                mouseenterEvent: function() {
                  var e3 = this.inputmask, t3 = e3.opts.showMaskOnHover, n3 = this;
                  if (e3.mouseEnter = true, (n3.inputmask.shadowRoot || n3.ownerDocument).activeElement !== n3) {
                    var i3 = (e3.isRTL ? c.getBufferTemplate.call(e3).slice().reverse() : c.getBufferTemplate.call(e3)).join("");
                    t3 && (0, l.HandleNativePlaceholder)(n3, i3);
                  }
                },
                submitEvent: function() {
                  var e3 = this.inputmask, t3 = e3.opts;
                  e3.undoValue !== e3._valueGet(true) && e3.$el.trigger("change"), -1 === c.getLastValidPosition.call(e3) && e3._valueGet && e3._valueGet() === c.getBufferTemplate.call(e3).join("") && e3._valueSet(""), t3.clearIncomplete && false === u.isComplete.call(e3, c.getBuffer.call(e3)) && e3._valueSet(""), t3.removeMaskOnSubmit && (e3._valueSet(e3.unmaskedvalue(), true), setTimeout(function() {
                    (0, l.writeBuffer)(e3.el, c.getBuffer.call(e3));
                  }, 0));
                },
                resetEvent: function() {
                  var e3 = this.inputmask;
                  e3.refreshValue = true, setTimeout(function() {
                    (0, l.applyInputValue)(e3.el, e3._valueGet(true));
                  }, 0);
                }
              };
            },
            9716: function(e2, t2, n2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.EventRuler = void 0;
              var i2, a = n2(7760), r = (i2 = n2(2394)) && i2.__esModule ? i2 : {
                default: i2
              }, o = n2(2839), l = n2(8711);
              t2.EventRuler = {
                on: function(e3, t3, n3) {
                  var i3 = e3.inputmask.dependencyLib, s = function(t4) {
                    t4.originalEvent && (t4 = t4.originalEvent || t4, arguments[0] = t4);
                    var s2, c = this, u = c.inputmask, f = u ? u.opts : void 0;
                    if (void 0 === u && "FORM" !== this.nodeName) {
                      var p = i3.data(c, "_inputmask_opts");
                      i3(c).off(), p && new r.default(p).mask(c);
                    } else {
                      if (["submit", "reset", "setvalue"].includes(t4.type) || "FORM" === this.nodeName || !(c.disabled || c.readOnly && !("keydown" === t4.type && t4.ctrlKey && t4.key === o.keys.c || false === f.tabThrough && t4.key === o.keys.Tab))) {
                        switch (t4.type) {
                          case "input":
                            if (true === u.skipInputEvent) return u.skipInputEvent = false, t4.preventDefault();
                            break;
                          case "click":
                          case "focus":
                            return u.validationEvent ? (u.validationEvent = false, e3.blur(), (0, a.HandleNativePlaceholder)(e3, (u.isRTL ? l.getBufferTemplate.call(u).slice().reverse() : l.getBufferTemplate.call(u)).join("")), setTimeout(function() {
                              e3.focus();
                            }, f.validationEventTimeOut), false) : (s2 = arguments, void setTimeout(function() {
                              e3.inputmask && n3.apply(c, s2);
                            }, 0));
                        }
                        var d = n3.apply(c, arguments);
                        return false === d && (t4.preventDefault(), t4.stopPropagation()), d;
                      }
                      t4.preventDefault();
                    }
                  };
                  ["submit", "reset"].includes(t3) ? (s = s.bind(e3), null !== e3.form && i3(e3.form).on(t3, s)) : i3(e3).on(t3, s), e3.inputmask.events[t3] = e3.inputmask.events[t3] || [], e3.inputmask.events[t3].push(s);
                },
                off: function(e3, t3) {
                  if (e3.inputmask && e3.inputmask.events) {
                    var n3 = e3.inputmask.dependencyLib, i3 = e3.inputmask.events;
                    for (var a2 in t3 && ((i3 = [])[t3] = e3.inputmask.events[t3]), i3) {
                      for (var r2 = i3[a2]; r2.length > 0; ) {
                        var o2 = r2.pop();
                        ["submit", "reset"].includes(a2) ? null !== e3.form && n3(e3.form).off(a2, o2) : n3(e3).off(a2, o2);
                      }
                      delete e3.inputmask.events[a2];
                    }
                  }
                }
              };
            },
            219: function(e2, t2, n2) {
              var i2 = p(n2(7184)), a = p(n2(2394)), r = n2(2839), o = n2(8711), l = n2(4713);
              function s(e3, t3) {
                return function(e4) {
                  if (Array.isArray(e4)) return e4;
                }(e3) || function(e4, t4) {
                  var n3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
                  if (null != n3) {
                    var i3, a2, r2, o2, l2 = [], s2 = true, c2 = false;
                    try {
                      if (r2 = (n3 = n3.call(e4)).next, 0 === t4) {
                        if (Object(n3) !== n3) return;
                        s2 = false;
                      } else for (; !(s2 = (i3 = r2.call(n3)).done) && (l2.push(i3.value), l2.length !== t4); s2 = true) ;
                    } catch (e5) {
                      c2 = true, a2 = e5;
                    } finally {
                      try {
                        if (!s2 && null != n3.return && (o2 = n3.return(), Object(o2) !== o2)) return;
                      } finally {
                        if (c2) throw a2;
                      }
                    }
                    return l2;
                  }
                }(e3, t3) || function(e4, t4) {
                  if (!e4) return;
                  if ("string" == typeof e4) return c(e4, t4);
                  var n3 = Object.prototype.toString.call(e4).slice(8, -1);
                  "Object" === n3 && e4.constructor && (n3 = e4.constructor.name);
                  if ("Map" === n3 || "Set" === n3) return Array.from(e4);
                  if ("Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return c(e4, t4);
                }(e3, t3) || function() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }();
              }
              function c(e3, t3) {
                (null == t3 || t3 > e3.length) && (t3 = e3.length);
                for (var n3 = 0, i3 = new Array(t3); n3 < t3; n3++) i3[n3] = e3[n3];
                return i3;
              }
              function u(e3) {
                return u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
                  return typeof e4;
                } : function(e4) {
                  return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
                }, u(e3);
              }
              function f(e3, t3) {
                for (var n3 = 0; n3 < t3.length; n3++) {
                  var i3 = t3[n3];
                  i3.enumerable = i3.enumerable || false, i3.configurable = true, "value" in i3 && (i3.writable = true), Object.defineProperty(e3, (a2 = i3.key, r2 = void 0, r2 = function(e4, t4) {
                    if ("object" !== u(e4) || null === e4) return e4;
                    var n4 = e4[Symbol.toPrimitive];
                    if (void 0 !== n4) {
                      var i4 = n4.call(e4, t4 || "default");
                      if ("object" !== u(i4)) return i4;
                      throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === t4 ? String : Number)(e4);
                  }(a2, "string"), "symbol" === u(r2) ? r2 : String(r2)), i3);
                }
                var a2, r2;
              }
              function p(e3) {
                return e3 && e3.__esModule ? e3 : {
                  default: e3
                };
              }
              n2(1313);
              var d = a.default.dependencyLib, h = function() {
                function e3(t4, n4, i4, a2) {
                  !function(e4, t5) {
                    if (!(e4 instanceof t5)) throw new TypeError("Cannot call a class as a function");
                  }(this, e3), this.mask = t4, this.format = n4, this.opts = i4, this.inputmask = a2, this._date = new Date(1, 0, 1), this.initDateObject(t4, this.opts, this.inputmask);
                }
                var t3, n3, i3;
                return t3 = e3, (n3 = [{
                  key: "date",
                  get: function() {
                    return void 0 === this._date && (this._date = new Date(1, 0, 1), this.initDateObject(void 0, this.opts, this.inputmask)), this._date;
                  }
                }, {
                  key: "initDateObject",
                  value: function(e4, t4, n4) {
                    var i4;
                    for (P(t4).lastIndex = 0; i4 = P(t4).exec(this.format); ) {
                      var a2 = /\d+$/.exec(i4[0]), r2 = a2 ? i4[0][0] + "x" : i4[0], o2 = void 0;
                      if (void 0 !== e4) {
                        if (a2) {
                          var s2 = P(t4).lastIndex, c2 = j.call(n4, i4.index, t4, n4 && n4.maskset);
                          P(t4).lastIndex = s2, o2 = e4.slice(0, e4.indexOf(c2.nextMatch[0]));
                        } else {
                          for (var u2 = i4[0][0], f2 = i4.index; n4 && (t4.placeholder[l.getTest.call(n4, f2).match.placeholder] || l.getTest.call(n4, f2).match.placeholder) === u2; ) f2++;
                          var p2 = f2 - i4.index;
                          o2 = e4.slice(0, p2 || y[r2] && y[r2][4] || r2.length);
                        }
                        e4 = e4.slice(o2.length);
                      }
                      Object.prototype.hasOwnProperty.call(y, r2) && this.setValue(this, o2, r2, y[r2][2], y[r2][1]);
                    }
                  }
                }, {
                  key: "setValue",
                  value: function(e4, t4, n4, i4, a2) {
                    if (void 0 !== t4) switch (i4) {
                      case "ampm":
                        e4[i4] = t4, e4["raw" + i4] = t4.replace(/\s/g, "_");
                        break;
                      case "month":
                        if ("mmm" === n4 || "mmmm" === n4) {
                          e4[i4] = _2("mmm" === n4 ? m.monthNames.slice(0, 12).findIndex(function(e5) {
                            return t4.toLowerCase() === e5.toLowerCase();
                          }) + 1 : m.monthNames.slice(12, 24).findIndex(function(e5) {
                            return t4.toLowerCase() === e5.toLowerCase();
                          }) + 1, 2), e4[i4] = "00" === e4[i4] ? "" : e4[i4].toString(), e4["raw" + i4] = e4[i4];
                          break;
                        }
                      default:
                        e4[i4] = t4.replace(/[^0-9]/g, "0"), e4["raw" + i4] = t4.replace(/\s/g, "_");
                    }
                    if (void 0 !== a2) {
                      var r2 = e4[i4];
                      ("day" === i4 && 29 === parseInt(r2) || "month" === i4 && 2 === parseInt(r2)) && (29 !== parseInt(e4.day) || 2 !== parseInt(e4.month) || "" !== e4.year && void 0 !== e4.year || e4._date.setFullYear(2012, 1, 29)), "day" === i4 && (g = true, 0 === parseInt(r2) && (r2 = 1)), "month" === i4 && (g = true), "year" === i4 && (g = true, r2.length < y[n4][4] && (r2 = _2(r2, y[n4][4], true))), ("" !== r2 && !isNaN(r2) || "ampm" === i4) && a2.call(e4._date, r2);
                    }
                  }
                }, {
                  key: "reset",
                  value: function() {
                    this._date = new Date(1, 0, 1);
                  }
                }, {
                  key: "reInit",
                  value: function() {
                    this._date = void 0, this.date;
                  }
                }]) && f(t3.prototype, n3), i3 && f(t3, i3), Object.defineProperty(t3, "prototype", {
                  writable: false
                }), e3;
              }(), v = (/* @__PURE__ */ new Date()).getFullYear(), m = a.default.prototype.i18n, g = false, y = {
                d: ["[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", Date.prototype.getDate],
                dd: ["0[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", function() {
                  return _2(Date.prototype.getDate.call(this), 2);
                }],
                ddd: [""],
                dddd: [""],
                m: ["[1-9]|1[012]", function(e3) {
                  var t3 = e3 ? parseInt(e3) : 0;
                  return t3 > 0 && t3--, Date.prototype.setMonth.call(this, t3);
                }, "month", function() {
                  return Date.prototype.getMonth.call(this) + 1;
                }],
                mm: ["0[1-9]|1[012]", function(e3) {
                  var t3 = e3 ? parseInt(e3) : 0;
                  return t3 > 0 && t3--, Date.prototype.setMonth.call(this, t3);
                }, "month", function() {
                  return _2(Date.prototype.getMonth.call(this) + 1, 2);
                }],
                mmm: [m.monthNames.slice(0, 12).join("|"), function(e3) {
                  var t3 = m.monthNames.slice(0, 12).findIndex(function(t4) {
                    return e3.toLowerCase() === t4.toLowerCase();
                  });
                  return -1 !== t3 && Date.prototype.setMonth.call(this, t3);
                }, "month", function() {
                  return m.monthNames.slice(0, 12)[Date.prototype.getMonth.call(this)];
                }],
                mmmm: [m.monthNames.slice(12, 24).join("|"), function(e3) {
                  var t3 = m.monthNames.slice(12, 24).findIndex(function(t4) {
                    return e3.toLowerCase() === t4.toLowerCase();
                  });
                  return -1 !== t3 && Date.prototype.setMonth.call(this, t3);
                }, "month", function() {
                  return m.monthNames.slice(12, 24)[Date.prototype.getMonth.call(this)];
                }],
                yy: ["[0-9]{2}", function(e3) {
                  var t3 = (/* @__PURE__ */ new Date()).getFullYear().toString().slice(0, 2);
                  Date.prototype.setFullYear.call(this, "".concat(t3).concat(e3));
                }, "year", function() {
                  return _2(Date.prototype.getFullYear.call(this), 2);
                }, 2],
                yyyy: ["[0-9]{4}", Date.prototype.setFullYear, "year", function() {
                  return _2(Date.prototype.getFullYear.call(this), 4);
                }, 4],
                h: ["[1-9]|1[0-2]", Date.prototype.setHours, "hours", Date.prototype.getHours],
                hh: ["0[1-9]|1[0-2]", Date.prototype.setHours, "hours", function() {
                  return _2(Date.prototype.getHours.call(this), 2);
                }],
                hx: [function(e3) {
                  return "[0-9]{".concat(e3, "}");
                }, Date.prototype.setHours, "hours", function(e3) {
                  return Date.prototype.getHours;
                }],
                H: ["1?[0-9]|2[0-3]", Date.prototype.setHours, "hours", Date.prototype.getHours],
                HH: ["0[0-9]|1[0-9]|2[0-3]", Date.prototype.setHours, "hours", function() {
                  return _2(Date.prototype.getHours.call(this), 2);
                }],
                Hx: [function(e3) {
                  return "[0-9]{".concat(e3, "}");
                }, Date.prototype.setHours, "hours", function(e3) {
                  return function() {
                    return _2(Date.prototype.getHours.call(this), e3);
                  };
                }],
                M: ["[1-5]?[0-9]", Date.prototype.setMinutes, "minutes", Date.prototype.getMinutes],
                MM: ["0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setMinutes, "minutes", function() {
                  return _2(Date.prototype.getMinutes.call(this), 2);
                }],
                s: ["[1-5]?[0-9]", Date.prototype.setSeconds, "seconds", Date.prototype.getSeconds],
                ss: ["0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setSeconds, "seconds", function() {
                  return _2(Date.prototype.getSeconds.call(this), 2);
                }],
                l: ["[0-9]{3}", Date.prototype.setMilliseconds, "milliseconds", function() {
                  return _2(Date.prototype.getMilliseconds.call(this), 3);
                }, 3],
                L: ["[0-9]{2}", Date.prototype.setMilliseconds, "milliseconds", function() {
                  return _2(Date.prototype.getMilliseconds.call(this), 2);
                }, 2],
                t: ["[ap]", b, "ampm", x, 1],
                tt: ["[ap]m", b, "ampm", x, 2],
                T: ["[AP]", b, "ampm", x, 1],
                TT: ["[AP]M", b, "ampm", x, 2],
                Z: [".*", void 0, "Z", function() {
                  var e3 = this.toString().match(/\((.+)\)/)[1];
                  e3.includes(" ") && (e3 = (e3 = e3.replace("-", " ").toUpperCase()).split(" ").map(function(e4) {
                    return s(e4, 1)[0];
                  }).join(""));
                  return e3;
                }],
                o: [""],
                S: [""]
              }, k = {
                isoDate: "yyyy-mm-dd",
                isoTime: "HH:MM:ss",
                isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
                isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
              };
              function b(e3) {
                var t3 = this.getHours();
                e3.toLowerCase().includes("p") ? this.setHours(t3 + 12) : e3.toLowerCase().includes("a") && t3 >= 12 && this.setHours(t3 - 12);
              }
              function x() {
                var e3 = this.getHours();
                return (e3 = e3 || 12) >= 12 ? "PM" : "AM";
              }
              function w(e3) {
                var t3 = /\d+$/.exec(e3[0]);
                if (t3 && void 0 !== t3[0]) {
                  var n3 = y[e3[0][0] + "x"].slice("");
                  return n3[0] = n3[0](t3[0]), n3[3] = n3[3](t3[0]), n3;
                }
                if (y[e3[0]]) return y[e3[0]];
              }
              function P(e3) {
                if (!e3.tokenizer) {
                  var t3 = [], n3 = [];
                  for (var i3 in y) if (/\.*x$/.test(i3)) {
                    var a2 = i3[0] + "\\d+";
                    -1 === n3.indexOf(a2) && n3.push(a2);
                  } else -1 === t3.indexOf(i3[0]) && t3.push(i3[0]);
                  e3.tokenizer = "(" + (n3.length > 0 ? n3.join("|") + "|" : "") + t3.join("+|") + ")+?|.", e3.tokenizer = new RegExp(e3.tokenizer, "g");
                }
                return e3.tokenizer;
              }
              function S(e3, t3, n3) {
                if (!g) return true;
                if (void 0 === e3.rawday || !isFinite(e3.rawday) && new Date(e3.date.getFullYear(), isFinite(e3.rawmonth) ? e3.month : e3.date.getMonth() + 1, 0).getDate() >= e3.day || "29" == e3.day && (!isFinite(e3.rawyear) || void 0 === e3.rawyear || "" === e3.rawyear) || new Date(e3.date.getFullYear(), isFinite(e3.rawmonth) ? e3.month : e3.date.getMonth() + 1, 0).getDate() >= e3.day) return t3;
                if ("29" == e3.day) {
                  var i3 = j.call(this, t3.pos, n3, this.maskset);
                  if (i3.targetMatch && "yyyy" === i3.targetMatch[0] && t3.pos - i3.targetMatchIndex == 2) return t3.remove = t3.pos + 1, t3;
                } else if (2 == e3.date.getMonth() && "30" == e3.day && void 0 !== t3.c) return e3.day = "03", e3.date.setDate(3), e3.date.setMonth(1), t3.insert = [{
                  pos: t3.pos,
                  c: "0"
                }, {
                  pos: t3.pos + 1,
                  c: t3.c
                }], t3.caret = o.seekNext.call(this, t3.pos + 1), t3;
                return false;
              }
              function O(e3, t3, n3, a2) {
                var r2, o2, l2 = "", s2 = 0, c2 = {};
                for (P(n3).lastIndex = 0; r2 = P(n3).exec(e3); ) {
                  if (void 0 === t3) if (o2 = w(r2)) l2 += "(" + o2[0] + ")", n3.placeholder && "" !== n3.placeholder ? (c2[s2] = n3.placeholder[r2.index % n3.placeholder.length], c2[n3.placeholder[r2.index % n3.placeholder.length]] = r2[0].charAt(0)) : c2[s2] = r2[0].charAt(0);
                  else switch (r2[0]) {
                    case "[":
                      l2 += "(";
                      break;
                    case "]":
                      l2 += ")?";
                      break;
                    default:
                      l2 += (0, i2.default)(r2[0]), c2[s2] = r2[0].charAt(0);
                  }
                  else if (o2 = w(r2)) if (true !== a2 && o2[3]) l2 += o2[3].call(t3.date);
                  else o2[2] ? l2 += t3["raw" + o2[2]] : l2 += r2[0];
                  else l2 += r2[0];
                  s2++;
                }
                return void 0 === t3 && (n3.placeholder = c2), l2;
              }
              function _2(e3, t3, n3) {
                for (e3 = String(e3), t3 = t3 || 2; e3.length < t3; ) e3 = n3 ? e3 + "0" : "0" + e3;
                return e3;
              }
              function M(e3, t3, n3) {
                return "string" == typeof e3 ? new h(e3, t3, n3, this) : e3 && "object" === u(e3) && Object.prototype.hasOwnProperty.call(e3, "date") ? e3 : void 0;
              }
              function E(e3, t3) {
                return O(t3.inputFormat, {
                  date: e3
                }, t3);
              }
              function j(e3, t3, n3) {
                var i3, a2, r2 = this, o2 = n3 && n3.tests[e3] ? t3.placeholder[n3.tests[e3][0].match.placeholder] || n3.tests[e3][0].match.placeholder : "", s2 = 0, c2 = 0;
                for (P(t3).lastIndex = 0; a2 = P(t3).exec(t3.inputFormat); ) {
                  var u2 = /\d+$/.exec(a2[0]);
                  if (u2) c2 = parseInt(u2[0]);
                  else {
                    for (var f2 = a2[0][0], p2 = s2; r2 && (t3.placeholder[l.getTest.call(r2, p2).match.placeholder] || l.getTest.call(r2, p2).match.placeholder) === f2; ) p2++;
                    0 === (c2 = p2 - s2) && (c2 = a2[0].length);
                  }
                  if (s2 += c2, -1 != a2[0].indexOf(o2) || s2 >= e3 + 1) {
                    i3 = a2, a2 = P(t3).exec(t3.inputFormat);
                    break;
                  }
                }
                return {
                  targetMatchIndex: s2 - c2,
                  nextMatch: a2,
                  targetMatch: i3
                };
              }
              a.default.extendAliases({
                datetime: {
                  mask: function(e3) {
                    return e3.numericInput = false, y.S = m.ordinalSuffix.join("|"), e3.inputFormat = k[e3.inputFormat] || e3.inputFormat, e3.displayFormat = k[e3.displayFormat] || e3.displayFormat || e3.inputFormat, e3.outputFormat = k[e3.outputFormat] || e3.outputFormat || e3.inputFormat, e3.regex = O(e3.inputFormat, void 0, e3), e3.min = M(e3.min, e3.inputFormat, e3), e3.max = M(e3.max, e3.inputFormat, e3), null;
                  },
                  placeholder: "",
                  inputFormat: "isoDateTime",
                  displayFormat: null,
                  outputFormat: null,
                  min: null,
                  max: null,
                  skipOptionalPartCharacter: "",
                  preValidation: function(e3, t3, n3, i3, a2, r2, o2, l2) {
                    if (l2) return true;
                    if (isNaN(n3) && e3[t3] !== n3) {
                      var s2 = j.call(this, t3, a2, r2);
                      if (s2.nextMatch && s2.nextMatch[0] === n3 && s2.targetMatch[0].length > 1) {
                        var c2 = w(s2.targetMatch)[0];
                        if (new RegExp(c2).test("0" + e3[t3 - 1])) return e3[t3] = e3[t3 - 1], e3[t3 - 1] = "0", {
                          fuzzy: true,
                          buffer: e3,
                          refreshFromBuffer: {
                            start: t3 - 1,
                            end: t3 + 1
                          },
                          pos: t3 + 1
                        };
                      }
                    }
                    return true;
                  },
                  postValidation: function(e3, t3, n3, i3, a2, r2, o2, s2) {
                    var c2, u2, f2 = this;
                    if (o2) return true;
                    if (false === i3 && (((c2 = j.call(f2, t3 + 1, a2, r2)).targetMatch && c2.targetMatchIndex === t3 && c2.targetMatch[0].length > 1 && void 0 !== y[c2.targetMatch[0]] || (c2 = j.call(f2, t3 + 2, a2, r2)).targetMatch && c2.targetMatchIndex === t3 + 1 && c2.targetMatch[0].length > 1 && void 0 !== y[c2.targetMatch[0]]) && (u2 = w(c2.targetMatch)[0]), void 0 !== u2 && (void 0 !== r2.validPositions[t3 + 1] && new RegExp(u2).test(n3 + "0") ? (e3[t3] = n3, e3[t3 + 1] = "0", i3 = {
                      pos: t3 + 2,
                      caret: t3
                    }) : new RegExp(u2).test("0" + n3) && (e3[t3] = "0", e3[t3 + 1] = n3, i3 = {
                      pos: t3 + 2
                    })), false === i3)) return i3;
                    if (i3.fuzzy && (e3 = i3.buffer, t3 = i3.pos), (c2 = j.call(f2, t3, a2, r2)).targetMatch && c2.targetMatch[0] && void 0 !== y[c2.targetMatch[0]]) {
                      var p2 = w(c2.targetMatch);
                      u2 = p2[0];
                      var d2 = e3.slice(c2.targetMatchIndex, c2.targetMatchIndex + c2.targetMatch[0].length);
                      if (false === new RegExp(u2).test(d2.join("")) && 2 === c2.targetMatch[0].length && r2.validPositions[c2.targetMatchIndex] && r2.validPositions[c2.targetMatchIndex + 1] && (r2.validPositions[c2.targetMatchIndex + 1].input = "0"), "year" == p2[2]) for (var h2 = l.getMaskTemplate.call(f2, false, 1, void 0, true), m2 = t3 + 1; m2 < e3.length; m2++) e3[m2] = h2[m2], r2.validPositions.splice(t3 + 1, 1);
                    }
                    var g2 = i3, k2 = M.call(f2, e3.join(""), a2.inputFormat, a2);
                    return g2 && !isNaN(k2.date.getTime()) && (a2.prefillYear && (g2 = function(e4, t4, n4) {
                      if (e4.year !== e4.rawyear) {
                        var i4 = v.toString(), a3 = e4.rawyear.replace(/[^0-9]/g, ""), r3 = i4.slice(0, a3.length), o3 = i4.slice(a3.length);
                        if (2 === a3.length && a3 === r3) {
                          var l2 = new Date(v, e4.month - 1, e4.day);
                          e4.day == l2.getDate() && (!n4.max || n4.max.date.getTime() >= l2.getTime()) && (e4.date.setFullYear(v), e4.year = i4, t4.insert = [{
                            pos: t4.pos + 1,
                            c: o3[0]
                          }, {
                            pos: t4.pos + 2,
                            c: o3[1]
                          }]);
                        }
                      }
                      return t4;
                    }(k2, g2, a2)), g2 = function(e4, t4, n4, i4, a3) {
                      if (!t4) return t4;
                      if (t4 && n4.min && !isNaN(n4.min.date.getTime())) {
                        var r3;
                        for (e4.reset(), P(n4).lastIndex = 0; r3 = P(n4).exec(n4.inputFormat); ) {
                          var o3;
                          if ((o3 = w(r3)) && o3[3]) {
                            for (var l2 = o3[1], s3 = e4[o3[2]], c3 = n4.min[o3[2]], u3 = n4.max ? n4.max[o3[2]] : c3 + 1, f3 = [], p3 = false, d3 = 0; d3 < c3.length; d3++) void 0 !== i4.validPositions[d3 + r3.index] || p3 ? (f3[d3] = s3[d3], p3 = p3 || s3[d3] > c3[d3]) : (d3 + r3.index == 0 && s3[d3] < c3[d3] ? (f3[d3] = s3[d3], p3 = true) : f3[d3] = c3[d3], "year" === o3[2] && s3.length - 1 == d3 && c3 != u3 && (f3 = (parseInt(f3.join("")) + 1).toString().split("")), "ampm" === o3[2] && c3 != u3 && n4.min.date.getTime() > e4.date.getTime() && (f3[d3] = u3[d3]));
                            l2.call(e4._date, f3.join(""));
                          }
                        }
                        t4 = n4.min.date.getTime() <= e4.date.getTime(), e4.reInit();
                      }
                      return t4 && n4.max && (isNaN(n4.max.date.getTime()) || (t4 = n4.max.date.getTime() >= e4.date.getTime())), t4;
                    }(k2, g2 = S.call(f2, k2, g2, a2), a2, r2)), void 0 !== t3 && g2 && i3.pos !== t3 ? {
                      buffer: O(a2.inputFormat, k2, a2).split(""),
                      refreshFromBuffer: {
                        start: t3,
                        end: i3.pos
                      },
                      pos: i3.caret || i3.pos
                    } : g2;
                  },
                  onKeyDown: function(e3, t3, n3, i3) {
                    e3.ctrlKey && e3.key === r.keys.ArrowRight && (this.inputmask._valueSet(E(/* @__PURE__ */ new Date(), i3)), d(this).trigger("setvalue"));
                  },
                  onUnMask: function(e3, t3, n3) {
                    return t3 ? O(n3.outputFormat, M.call(this, e3, n3.inputFormat, n3), n3, true) : t3;
                  },
                  casing: function(e3, t3, n3, i3) {
                    if (0 == t3.nativeDef.indexOf("[ap]")) return e3.toLowerCase();
                    if (0 == t3.nativeDef.indexOf("[AP]")) return e3.toUpperCase();
                    var a2 = l.getTest.call(this, [n3 - 1]);
                    return 0 == a2.match.def.indexOf("[AP]") || 0 === n3 || a2 && a2.input === String.fromCharCode(r.keyCode.Space) || a2 && a2.match.def === String.fromCharCode(r.keyCode.Space) ? e3.toUpperCase() : e3.toLowerCase();
                  },
                  onBeforeMask: function(e3, t3) {
                    return "[object Date]" === Object.prototype.toString.call(e3) && (e3 = E(e3, t3)), e3;
                  },
                  insertMode: false,
                  insertModeVisual: false,
                  shiftPositions: false,
                  keepStatic: false,
                  inputmode: "numeric",
                  prefillYear: true
                }
              });
            },
            1313: function(e2, t2, n2) {
              var i2, a = (i2 = n2(2394)) && i2.__esModule ? i2 : {
                default: i2
              };
              a.default.dependencyLib.extend(true, a.default.prototype.i18n, {
                dayNames: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
                monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                ordinalSuffix: ["st", "nd", "rd", "th"]
              });
            },
            3851: function(e2, t2, n2) {
              var i2, a = (i2 = n2(2394)) && i2.__esModule ? i2 : {
                default: i2
              }, r = n2(8711), o = n2(4713);
              function l(e3) {
                return function(e4) {
                  if (Array.isArray(e4)) return s(e4);
                }(e3) || function(e4) {
                  if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"]) return Array.from(e4);
                }(e3) || function(e4, t3) {
                  if (!e4) return;
                  if ("string" == typeof e4) return s(e4, t3);
                  var n3 = Object.prototype.toString.call(e4).slice(8, -1);
                  "Object" === n3 && e4.constructor && (n3 = e4.constructor.name);
                  if ("Map" === n3 || "Set" === n3) return Array.from(e4);
                  if ("Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return s(e4, t3);
                }(e3) || function() {
                  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }();
              }
              function s(e3, t3) {
                (null == t3 || t3 > e3.length) && (t3 = e3.length);
                for (var n3 = 0, i3 = new Array(t3); n3 < t3; n3++) i3[n3] = e3[n3];
                return i3;
              }
              a.default.extendDefinitions({
                A: {
                  validator: "[A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]",
                  casing: "upper"
                },
                "&": {
                  validator: "[0-9A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]",
                  casing: "upper"
                },
                "#": {
                  validator: "[0-9A-Fa-f]",
                  casing: "upper"
                }
              });
              var c = /25[0-5]|2[0-4][0-9]|[01][0-9][0-9]/;
              function u(e3, t3, n3, i3, a2) {
                if (n3 - 1 > -1 && "." !== t3.buffer[n3 - 1] ? (e3 = t3.buffer[n3 - 1] + e3, e3 = n3 - 2 > -1 && "." !== t3.buffer[n3 - 2] ? t3.buffer[n3 - 2] + e3 : "0" + e3) : e3 = "00" + e3, a2.greedy && parseInt(e3) > 255 && c.test("00" + e3.charAt(2))) {
                  var r2 = [].concat(l(t3.buffer.slice(0, n3)), [".", e3.charAt(2)]);
                  if (r2.join("").match(/\./g).length < 4) return {
                    refreshFromBuffer: true,
                    buffer: r2,
                    caret: n3 + 2
                  };
                }
                return c.test(e3);
              }
              a.default.extendAliases({
                cssunit: {
                  regex: "[+-]?[0-9]+\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)"
                },
                url: {
                  regex: "(https?|ftp)://.*",
                  autoUnmask: false,
                  keepStatic: false,
                  tabThrough: true
                },
                ip: {
                  mask: "i{1,3}.j{1,3}.k{1,3}.l{1,3}",
                  definitions: {
                    i: {
                      validator: u
                    },
                    j: {
                      validator: u
                    },
                    k: {
                      validator: u
                    },
                    l: {
                      validator: u
                    }
                  },
                  onUnMask: function(e3, t3, n3) {
                    return e3;
                  },
                  inputmode: "decimal",
                  substitutes: {
                    ",": "."
                  }
                },
                email: {
                  mask: function(e3) {
                    var t3 = e3.separator, n3 = e3.quantifier, i3 = "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]", a2 = i3;
                    if (t3) for (var r2 = 0; r2 < n3; r2++) a2 += "[".concat(t3).concat(i3, "]");
                    return a2;
                  },
                  greedy: false,
                  casing: "lower",
                  separator: null,
                  quantifier: 5,
                  skipOptionalPartCharacter: "",
                  onBeforePaste: function(e3, t3) {
                    return (e3 = e3.toLowerCase()).replace("mailto:", "");
                  },
                  definitions: {
                    "*": {
                      validator: "[0-9\uFF11-\uFF19A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5!#$%&'*+/=?^_`{|}~-]"
                    },
                    "-": {
                      validator: "[0-9A-Za-z-]"
                    }
                  },
                  onUnMask: function(e3, t3, n3) {
                    return e3;
                  },
                  inputmode: "email"
                },
                mac: {
                  mask: "##:##:##:##:##:##"
                },
                vin: {
                  mask: "V{13}9{4}",
                  definitions: {
                    V: {
                      validator: "[A-HJ-NPR-Za-hj-npr-z\\d]",
                      casing: "upper"
                    }
                  },
                  clearIncomplete: true,
                  autoUnmask: true
                },
                ssn: {
                  mask: "999-99-9999",
                  postValidation: function(e3, t3, n3, i3, a2, l2, s2) {
                    var c2 = o.getMaskTemplate.call(this, true, r.getLastValidPosition.call(this), true, true);
                    return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(c2.join(""));
                  }
                }
              });
            },
            207: function(e2, t2, n2) {
              var i2 = l(n2(7184)), a = l(n2(2394)), r = n2(2839), o = n2(8711);
              function l(e3) {
                return e3 && e3.__esModule ? e3 : {
                  default: e3
                };
              }
              var s = a.default.dependencyLib;
              function c(e3, t3) {
                for (var n3 = "", i3 = 0; i3 < e3.length; i3++) a.default.prototype.definitions[e3.charAt(i3)] || t3.definitions[e3.charAt(i3)] || t3.optionalmarker[0] === e3.charAt(i3) || t3.optionalmarker[1] === e3.charAt(i3) || t3.quantifiermarker[0] === e3.charAt(i3) || t3.quantifiermarker[1] === e3.charAt(i3) || t3.groupmarker[0] === e3.charAt(i3) || t3.groupmarker[1] === e3.charAt(i3) || t3.alternatormarker === e3.charAt(i3) ? n3 += "\\" + e3.charAt(i3) : n3 += e3.charAt(i3);
                return n3;
              }
              function u(e3, t3, n3, i3) {
                if (e3.length > 0 && t3 > 0 && (!n3.digitsOptional || i3)) {
                  var a2 = e3.indexOf(n3.radixPoint), r2 = false;
                  n3.negationSymbol.back === e3[e3.length - 1] && (r2 = true, e3.length--), -1 === a2 && (e3.push(n3.radixPoint), a2 = e3.length - 1);
                  for (var o2 = 1; o2 <= t3; o2++) isFinite(e3[a2 + o2]) || (e3[a2 + o2] = "0");
                }
                return r2 && e3.push(n3.negationSymbol.back), e3;
              }
              function f(e3, t3) {
                var n3 = 0;
                for (var i3 in "+" === e3 && (n3 = o.seekNext.call(this, t3.validPositions.length - 1)), t3.tests) if ((i3 = parseInt(i3)) >= n3) {
                  for (var a2 = 0, r2 = t3.tests[i3].length; a2 < r2; a2++) if ((void 0 === t3.validPositions[i3] || "-" === e3) && t3.tests[i3][a2].match.def === e3) return i3 + (void 0 !== t3.validPositions[i3] && "-" !== e3 ? 1 : 0);
                }
                return n3;
              }
              function p(e3, t3) {
                for (var n3 = -1, i3 = 0, a2 = t3.validPositions.length; i3 < a2; i3++) {
                  var r2 = t3.validPositions[i3];
                  if (r2 && r2.match.def === e3) {
                    n3 = i3;
                    break;
                  }
                }
                return n3;
              }
              function d(e3, t3, n3, i3, a2) {
                var r2 = t3.buffer ? t3.buffer.indexOf(a2.radixPoint) : -1, o2 = (-1 !== r2 || i3 && a2.jitMasking) && new RegExp(a2.definitions[9].validator).test(e3);
                return !i3 && a2._radixDance && -1 !== r2 && o2 && null == t3.validPositions[r2] ? {
                  insert: {
                    pos: r2 === n3 ? r2 + 1 : r2,
                    c: a2.radixPoint
                  },
                  pos: n3
                } : o2;
              }
              a.default.extendAliases({
                numeric: {
                  mask: function(e3) {
                    e3.repeat = 0, e3.groupSeparator === e3.radixPoint && e3.digits && "0" !== e3.digits && ("." === e3.radixPoint ? e3.groupSeparator = "," : "," === e3.radixPoint ? e3.groupSeparator = "." : e3.groupSeparator = ""), " " === e3.groupSeparator && (e3.skipOptionalPartCharacter = void 0), e3.placeholder.length > 1 && (e3.placeholder = e3.placeholder.charAt(0)), "radixFocus" === e3.positionCaretOnClick && "" === e3.placeholder && (e3.positionCaretOnClick = "lvp");
                    var t3 = "0", n3 = e3.radixPoint;
                    true === e3.numericInput && void 0 === e3.__financeInput ? (t3 = "1", e3.positionCaretOnClick = "radixFocus" === e3.positionCaretOnClick ? "lvp" : e3.positionCaretOnClick, e3.digitsOptional = false, isNaN(e3.digits) && (e3.digits = 2), e3._radixDance = false, n3 = "," === e3.radixPoint ? "?" : "!", "" !== e3.radixPoint && void 0 === e3.definitions[n3] && (e3.definitions[n3] = {}, e3.definitions[n3].validator = "[" + e3.radixPoint + "]", e3.definitions[n3].placeholder = e3.radixPoint, e3.definitions[n3].static = true, e3.definitions[n3].generated = true)) : (e3.__financeInput = false, e3.numericInput = true);
                    var a2, r2 = "[+]";
                    if (r2 += c(e3.prefix, e3), "" !== e3.groupSeparator ? (void 0 === e3.definitions[e3.groupSeparator] && (e3.definitions[e3.groupSeparator] = {}, e3.definitions[e3.groupSeparator].validator = "[" + e3.groupSeparator + "]", e3.definitions[e3.groupSeparator].placeholder = e3.groupSeparator, e3.definitions[e3.groupSeparator].static = true, e3.definitions[e3.groupSeparator].generated = true), r2 += e3._mask(e3)) : r2 += "9{+}", void 0 !== e3.digits && 0 !== e3.digits) {
                      var o2 = e3.digits.toString().split(",");
                      isFinite(o2[0]) && o2[1] && isFinite(o2[1]) ? r2 += n3 + t3 + "{" + e3.digits + "}" : (isNaN(e3.digits) || parseInt(e3.digits) > 0) && (e3.digitsOptional || e3.jitMasking ? (a2 = r2 + n3 + t3 + "{0," + e3.digits + "}", e3.keepStatic = true) : r2 += n3 + t3 + "{" + e3.digits + "}");
                    } else e3.inputmode = "numeric";
                    return r2 += c(e3.suffix, e3), r2 += "[-]", a2 && (r2 = [a2 + c(e3.suffix, e3) + "[-]", r2]), e3.greedy = false, function(e4) {
                      void 0 === e4.parseMinMaxOptions && (null !== e4.min && (e4.min = e4.min.toString().replace(new RegExp((0, i2.default)(e4.groupSeparator), "g"), ""), "," === e4.radixPoint && (e4.min = e4.min.replace(e4.radixPoint, ".")), e4.min = isFinite(e4.min) ? parseFloat(e4.min) : NaN, isNaN(e4.min) && (e4.min = Number.MIN_VALUE)), null !== e4.max && (e4.max = e4.max.toString().replace(new RegExp((0, i2.default)(e4.groupSeparator), "g"), ""), "," === e4.radixPoint && (e4.max = e4.max.replace(e4.radixPoint, ".")), e4.max = isFinite(e4.max) ? parseFloat(e4.max) : NaN, isNaN(e4.max) && (e4.max = Number.MAX_VALUE)), e4.parseMinMaxOptions = "done");
                    }(e3), "" !== e3.radixPoint && e3.substituteRadixPoint && (e3.substitutes["." == e3.radixPoint ? "," : "."] = e3.radixPoint), r2;
                  },
                  _mask: function(e3) {
                    return "(" + e3.groupSeparator + "999){+|1}";
                  },
                  digits: "*",
                  digitsOptional: true,
                  enforceDigitsOnBlur: false,
                  radixPoint: ".",
                  positionCaretOnClick: "radixFocus",
                  _radixDance: true,
                  groupSeparator: "",
                  allowMinus: true,
                  negationSymbol: {
                    front: "-",
                    back: ""
                  },
                  prefix: "",
                  suffix: "",
                  min: null,
                  max: null,
                  SetMaxOnOverflow: false,
                  step: 1,
                  inputType: "text",
                  unmaskAsNumber: false,
                  roundingFN: Math.round,
                  inputmode: "decimal",
                  shortcuts: {
                    k: "1000",
                    m: "1000000"
                  },
                  placeholder: "0",
                  greedy: false,
                  rightAlign: true,
                  insertMode: true,
                  autoUnmask: false,
                  skipOptionalPartCharacter: "",
                  usePrototypeDefinitions: false,
                  stripLeadingZeroes: true,
                  substituteRadixPoint: true,
                  definitions: {
                    0: {
                      validator: d
                    },
                    1: {
                      validator: d,
                      definitionSymbol: "9"
                    },
                    9: {
                      validator: "[0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9]",
                      definitionSymbol: "*"
                    },
                    "+": {
                      validator: function(e3, t3, n3, i3, a2) {
                        return a2.allowMinus && ("-" === e3 || e3 === a2.negationSymbol.front);
                      }
                    },
                    "-": {
                      validator: function(e3, t3, n3, i3, a2) {
                        return a2.allowMinus && e3 === a2.negationSymbol.back;
                      }
                    }
                  },
                  preValidation: function(e3, t3, n3, i3, a2, r2, o2, l2) {
                    var s2 = this;
                    if (false !== a2.__financeInput && n3 === a2.radixPoint) return false;
                    var c2 = e3.indexOf(a2.radixPoint), u2 = t3;
                    if (t3 = function(e4, t4, n4, i4, a3) {
                      return a3._radixDance && a3.numericInput && t4 !== a3.negationSymbol.back && e4 <= n4 && (n4 > 0 || t4 == a3.radixPoint) && (void 0 === i4.validPositions[e4 - 1] || i4.validPositions[e4 - 1].input !== a3.negationSymbol.back) && (e4 -= 1), e4;
                    }(t3, n3, c2, r2, a2), "-" === n3 || n3 === a2.negationSymbol.front) {
                      if (true !== a2.allowMinus) return false;
                      var d2 = false, h = p("+", r2), v = p("-", r2);
                      return -1 !== h && (d2 = [h], -1 !== v && d2.push(v)), false !== d2 ? {
                        remove: d2,
                        caret: u2 - a2.negationSymbol.back.length
                      } : {
                        insert: [{
                          pos: f.call(s2, "+", r2),
                          c: a2.negationSymbol.front,
                          fromIsValid: true
                        }, {
                          pos: f.call(s2, "-", r2),
                          c: a2.negationSymbol.back,
                          fromIsValid: void 0
                        }],
                        caret: u2 + a2.negationSymbol.back.length
                      };
                    }
                    if (n3 === a2.groupSeparator) return {
                      caret: u2
                    };
                    if (l2) return true;
                    if (-1 !== c2 && true === a2._radixDance && false === i3 && n3 === a2.radixPoint && void 0 !== a2.digits && (isNaN(a2.digits) || parseInt(a2.digits) > 0) && c2 !== t3) {
                      var m = f.call(s2, a2.radixPoint, r2);
                      return r2.validPositions[m] && (r2.validPositions[m].generatedInput = r2.validPositions[m].generated || false), {
                        caret: a2._radixDance && t3 === c2 - 1 ? c2 + 1 : c2
                      };
                    }
                    if (false === a2.__financeInput) {
                      if (i3) {
                        if (a2.digitsOptional) return {
                          rewritePosition: o2.end
                        };
                        if (!a2.digitsOptional) {
                          if (o2.begin > c2 && o2.end <= c2) return n3 === a2.radixPoint ? {
                            insert: {
                              pos: c2 + 1,
                              c: "0",
                              fromIsValid: true
                            },
                            rewritePosition: c2
                          } : {
                            rewritePosition: c2 + 1
                          };
                          if (o2.begin < c2) return {
                            rewritePosition: o2.begin - 1
                          };
                        }
                      } else if (!a2.showMaskOnHover && !a2.showMaskOnFocus && !a2.digitsOptional && a2.digits > 0 && "" === this.__valueGet.call(this.el)) return {
                        rewritePosition: c2
                      };
                    }
                    return {
                      rewritePosition: t3
                    };
                  },
                  postValidation: function(e3, t3, n3, i3, a2, r2, o2) {
                    if (false === i3) return i3;
                    if (o2) return true;
                    if (null !== a2.min || null !== a2.max) {
                      var l2 = a2.onUnMask(e3.slice().reverse().join(""), void 0, s.extend({}, a2, {
                        unmaskAsNumber: true
                      }));
                      if (null !== a2.min && l2 < a2.min && (l2.toString().length > a2.min.toString().length || l2 < 0)) return false;
                      if (null !== a2.max && l2 > a2.max) return !!a2.SetMaxOnOverflow && {
                        refreshFromBuffer: true,
                        buffer: u(a2.max.toString().replace(".", a2.radixPoint).split(""), a2.digits, a2).reverse()
                      };
                    }
                    return i3;
                  },
                  onUnMask: function(e3, t3, n3) {
                    if ("" === t3 && true === n3.nullable) return t3;
                    var a2 = e3.replace(n3.prefix, "");
                    return a2 = (a2 = a2.replace(n3.suffix, "")).replace(new RegExp((0, i2.default)(n3.groupSeparator), "g"), ""), "" !== n3.placeholder.charAt(0) && (a2 = a2.replace(new RegExp(n3.placeholder.charAt(0), "g"), "0")), n3.unmaskAsNumber ? ("" !== n3.radixPoint && -1 !== a2.indexOf(n3.radixPoint) && (a2 = a2.replace(i2.default.call(this, n3.radixPoint), ".")), a2 = (a2 = a2.replace(new RegExp("^" + (0, i2.default)(n3.negationSymbol.front)), "-")).replace(new RegExp((0, i2.default)(n3.negationSymbol.back) + "$"), ""), Number(a2)) : a2;
                  },
                  isComplete: function(e3, t3) {
                    var n3 = (t3.numericInput ? e3.slice().reverse() : e3).join("");
                    return n3 = (n3 = (n3 = (n3 = (n3 = n3.replace(new RegExp("^" + (0, i2.default)(t3.negationSymbol.front)), "-")).replace(new RegExp((0, i2.default)(t3.negationSymbol.back) + "$"), "")).replace(t3.prefix, "")).replace(t3.suffix, "")).replace(new RegExp((0, i2.default)(t3.groupSeparator) + "([0-9]{3})", "g"), "$1"), "," === t3.radixPoint && (n3 = n3.replace((0, i2.default)(t3.radixPoint), ".")), isFinite(n3);
                  },
                  onBeforeMask: function(e3, t3) {
                    var n3;
                    e3 = null !== (n3 = e3) && void 0 !== n3 ? n3 : "";
                    var a2 = t3.radixPoint || ",";
                    isFinite(t3.digits) && (t3.digits = parseInt(t3.digits)), "number" != typeof e3 && "number" !== t3.inputType || "" === a2 || (e3 = e3.toString().replace(".", a2));
                    var r2 = "-" === e3.charAt(0) || e3.charAt(0) === t3.negationSymbol.front, o2 = e3.split(a2), l2 = o2[0].replace(/[^\-0-9]/g, ""), s2 = o2.length > 1 ? o2[1].replace(/[^0-9]/g, "") : "", c2 = o2.length > 1;
                    e3 = l2 + ("" !== s2 ? a2 + s2 : s2);
                    var f2 = 0;
                    if ("" !== a2 && (f2 = t3.digitsOptional ? t3.digits < s2.length ? t3.digits : s2.length : t3.digits, "" !== s2 || !t3.digitsOptional)) {
                      var p2 = Math.pow(10, f2 || 1);
                      e3 = e3.replace((0, i2.default)(a2), "."), isNaN(parseFloat(e3)) || (e3 = (t3.roundingFN(parseFloat(e3) * p2) / p2).toFixed(f2)), e3 = e3.toString().replace(".", a2);
                    }
                    if (0 === t3.digits && -1 !== e3.indexOf(a2) && (e3 = e3.substring(0, e3.indexOf(a2))), null !== t3.min || null !== t3.max) {
                      var d2 = e3.toString().replace(a2, ".");
                      null !== t3.min && d2 < t3.min ? e3 = t3.min.toString().replace(".", a2) : null !== t3.max && d2 > t3.max && (e3 = t3.max.toString().replace(".", a2));
                    }
                    return r2 && "-" !== e3.charAt(0) && (e3 = "-" + e3), u(e3.toString().split(""), f2, t3, c2).join("");
                  },
                  onBeforeWrite: function(e3, t3, n3, a2) {
                    function r2(e4, t4) {
                      if (false !== a2.__financeInput || t4) {
                        var n4 = e4.indexOf(a2.radixPoint);
                        -1 !== n4 && e4.splice(n4, 1);
                      }
                      if ("" !== a2.groupSeparator) for (; -1 !== (n4 = e4.indexOf(a2.groupSeparator)); ) e4.splice(n4, 1);
                      return e4;
                    }
                    var o2, l2;
                    if (a2.stripLeadingZeroes && (l2 = function(e4, t4) {
                      var n4 = new RegExp("(^" + ("" !== t4.negationSymbol.front ? (0, i2.default)(t4.negationSymbol.front) + "?" : "") + (0, i2.default)(t4.prefix) + ")(.*)(" + (0, i2.default)(t4.suffix) + ("" != t4.negationSymbol.back ? (0, i2.default)(t4.negationSymbol.back) + "?" : "") + "$)").exec(e4.slice().reverse().join("")), a3 = n4 ? n4[2] : "", r3 = false;
                      return a3 && (a3 = a3.split(t4.radixPoint.charAt(0))[0], r3 = new RegExp("^[0" + t4.groupSeparator + "]*").exec(a3)), !(!r3 || !(r3[0].length > 1 || r3[0].length > 0 && r3[0].length < a3.length)) && r3;
                    }(t3, a2))) for (var c2 = t3.join("").lastIndexOf(l2[0].split("").reverse().join("")) - (l2[0] == l2.input ? 0 : 1), f2 = l2[0] == l2.input ? 1 : 0, p2 = l2[0].length - f2; p2 > 0; p2--) this.maskset.validPositions.splice(c2 + p2, 1), delete t3[c2 + p2];
                    if (e3) switch (e3.type) {
                      case "blur":
                      case "checkval":
                        if (null !== a2.min) {
                          var d2 = a2.onUnMask(t3.slice().reverse().join(""), void 0, s.extend({}, a2, {
                            unmaskAsNumber: true
                          }));
                          if (null !== a2.min && d2 < a2.min) return {
                            refreshFromBuffer: true,
                            buffer: u(a2.min.toString().replace(".", a2.radixPoint).split(""), a2.digits, a2).reverse()
                          };
                        }
                        if (t3[t3.length - 1] === a2.negationSymbol.front) {
                          var h = new RegExp("(^" + ("" != a2.negationSymbol.front ? (0, i2.default)(a2.negationSymbol.front) + "?" : "") + (0, i2.default)(a2.prefix) + ")(.*)(" + (0, i2.default)(a2.suffix) + ("" != a2.negationSymbol.back ? (0, i2.default)(a2.negationSymbol.back) + "?" : "") + "$)").exec(r2(t3.slice(), true).reverse().join(""));
                          0 == (h ? h[2] : "") && (o2 = {
                            refreshFromBuffer: true,
                            buffer: [0]
                          });
                        } else if ("" !== a2.radixPoint) {
                          t3.indexOf(a2.radixPoint) === a2.suffix.length && (o2 && o2.buffer ? o2.buffer.splice(0, 1 + a2.suffix.length) : (t3.splice(0, 1 + a2.suffix.length), o2 = {
                            refreshFromBuffer: true,
                            buffer: r2(t3)
                          }));
                        }
                        if (a2.enforceDigitsOnBlur) {
                          var v = (o2 = o2 || {}) && o2.buffer || t3.slice().reverse();
                          o2.refreshFromBuffer = true, o2.buffer = u(v, a2.digits, a2, true).reverse();
                        }
                    }
                    return o2;
                  },
                  onKeyDown: function(e3, t3, n3, i3) {
                    var a2, o2 = s(this);
                    if (3 != e3.location) {
                      var l2, c2 = e3.key;
                      if ((l2 = i3.shortcuts && i3.shortcuts[c2]) && l2.length > 1) return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) * parseInt(l2)), o2.trigger("setvalue"), false;
                    }
                    if (e3.ctrlKey) switch (e3.key) {
                      case r.keys.ArrowUp:
                        return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(i3.step)), o2.trigger("setvalue"), false;
                      case r.keys.ArrowDown:
                        return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(i3.step)), o2.trigger("setvalue"), false;
                    }
                    if (!e3.shiftKey && (e3.key === r.keys.Delete || e3.key === r.keys.Backspace || e3.key === r.keys.BACKSPACE_SAFARI) && n3.begin !== t3.length) {
                      if (t3[e3.key === r.keys.Delete ? n3.begin - 1 : n3.end] === i3.negationSymbol.front) return a2 = t3.slice().reverse(), "" !== i3.negationSymbol.front && a2.shift(), "" !== i3.negationSymbol.back && a2.pop(), o2.trigger("setvalue", [a2.join(""), n3.begin]), false;
                      if (true === i3._radixDance) {
                        var f2, p2 = t3.indexOf(i3.radixPoint);
                        if (i3.digitsOptional) {
                          if (0 === p2) return (a2 = t3.slice().reverse()).pop(), o2.trigger("setvalue", [a2.join(""), n3.begin >= a2.length ? a2.length : n3.begin]), false;
                        } else if (-1 !== p2 && (n3.begin < p2 || n3.end < p2 || e3.key === r.keys.Delete && (n3.begin === p2 || n3.begin - 1 === p2))) return n3.begin === n3.end && (e3.key === r.keys.Backspace || e3.key === r.keys.BACKSPACE_SAFARI ? n3.begin++ : e3.key === r.keys.Delete && n3.begin - 1 === p2 && (f2 = s.extend({}, n3), n3.begin--, n3.end--)), (a2 = t3.slice().reverse()).splice(a2.length - n3.begin, n3.begin - n3.end + 1), a2 = u(a2, i3.digits, i3).join(""), f2 && (n3 = f2), o2.trigger("setvalue", [a2, n3.begin >= a2.length ? p2 + 1 : n3.begin]), false;
                      }
                    }
                  }
                },
                currency: {
                  prefix: "",
                  groupSeparator: ",",
                  alias: "numeric",
                  digits: 2,
                  digitsOptional: false
                },
                decimal: {
                  alias: "numeric"
                },
                integer: {
                  alias: "numeric",
                  inputmode: "numeric",
                  digits: 0
                },
                percentage: {
                  alias: "numeric",
                  min: 0,
                  max: 100,
                  suffix: " %",
                  digits: 0,
                  allowMinus: false
                },
                indianns: {
                  alias: "numeric",
                  _mask: function(e3) {
                    return "(" + e3.groupSeparator + "99){*|1}(" + e3.groupSeparator + "999){1|1}";
                  },
                  groupSeparator: ",",
                  radixPoint: ".",
                  placeholder: "0",
                  digits: 2,
                  digitsOptional: false
                }
              });
            },
            9380: function(e2, t2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = void 0;
              var n2 = !("undefined" == typeof window || !window.document || !window.document.createElement);
              t2.default = n2 ? window : {};
            },
            7760: function(e2, t2, n2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.HandleNativePlaceholder = function(e3, t3) {
                var n3 = e3 ? e3.inputmask : this;
                if (i2.ie) {
                  if (e3.inputmask._valueGet() !== t3 && (e3.placeholder !== t3 || "" === e3.placeholder)) {
                    var a2 = o.getBuffer.call(n3).slice(), r2 = e3.inputmask._valueGet();
                    if (r2 !== t3) {
                      var l2 = o.getLastValidPosition.call(n3);
                      -1 === l2 && r2 === o.getBufferTemplate.call(n3).join("") ? a2 = [] : -1 !== l2 && u.call(n3, a2), p(e3, a2);
                    }
                  }
                } else e3.placeholder !== t3 && (e3.placeholder = t3, "" === e3.placeholder && e3.removeAttribute("placeholder"));
              }, t2.applyInputValue = c, t2.checkVal = f, t2.clearOptionalTail = u, t2.unmaskedvalue = function(e3) {
                var t3 = e3 ? e3.inputmask : this, n3 = t3.opts, i3 = t3.maskset;
                if (e3) {
                  if (void 0 === e3.inputmask) return e3.value;
                  e3.inputmask && e3.inputmask.refreshValue && c(e3, e3.inputmask._valueGet(true));
                }
                for (var a2 = [], r2 = i3.validPositions, l2 = 0, s2 = r2.length; l2 < s2; l2++) r2[l2] && r2[l2].match && (1 != r2[l2].match.static || Array.isArray(i3.metadata) && true !== r2[l2].generatedInput) && a2.push(r2[l2].input);
                var u2 = 0 === a2.length ? "" : (t3.isRTL ? a2.reverse() : a2).join("");
                if ("function" == typeof n3.onUnMask) {
                  var f2 = (t3.isRTL ? o.getBuffer.call(t3).slice().reverse() : o.getBuffer.call(t3)).join("");
                  u2 = n3.onUnMask.call(t3, f2, u2, n3);
                }
                return u2;
              }, t2.writeBuffer = p;
              var i2 = n2(9845), a = n2(6030), r = n2(2839), o = n2(8711), l = n2(7215), s = n2(4713);
              function c(e3, t3, n3) {
                var i3 = e3 ? e3.inputmask : this, a2 = i3.opts;
                e3.inputmask.refreshValue = false, "function" == typeof a2.onBeforeMask && (t3 = a2.onBeforeMask.call(i3, t3, a2) || t3), f(e3, true, false, t3 = (t3 || "").toString().split(""), n3), i3.undoValue = i3._valueGet(true), (a2.clearMaskOnLostFocus || a2.clearIncomplete) && e3.inputmask._valueGet() === o.getBufferTemplate.call(i3).join("") && -1 === o.getLastValidPosition.call(i3) && e3.inputmask._valueSet("");
              }
              function u(e3) {
                e3.length = 0;
                for (var t3, n3 = s.getMaskTemplate.call(this, true, 0, true, void 0, true); void 0 !== (t3 = n3.shift()); ) e3.push(t3);
                return e3;
              }
              function f(e3, t3, n3, i3, r2) {
                var c2, u2 = e3 ? e3.inputmask : this, f2 = u2.maskset, d = u2.opts, h = u2.dependencyLib, v = i3.slice(), m = "", g = -1, y = d.skipOptionalPartCharacter;
                d.skipOptionalPartCharacter = "", o.resetMaskSet.call(u2, false), u2.clicked = 0, g = d.radixPoint ? o.determineNewCaretPosition.call(u2, {
                  begin: 0,
                  end: 0
                }, false, false === d.__financeInput ? "radixFocus" : void 0).begin : 0, f2.p = g, u2.caretPos = {
                  begin: g
                };
                var k = [], b = u2.caretPos;
                if (v.forEach(function(e4, t4) {
                  if (void 0 !== e4) {
                    var i4 = new h.Event("_checkval");
                    i4.key = e4, m += e4;
                    var r3 = o.getLastValidPosition.call(u2, void 0, true);
                    !function(e5, t5) {
                      for (var n4 = s.getMaskTemplate.call(u2, true, 0).slice(e5, o.seekNext.call(u2, e5, false, false)).join("").replace(/'/g, ""), i5 = n4.indexOf(t5); i5 > 0 && " " === n4[i5 - 1]; ) i5--;
                      var a2 = 0 === i5 && !o.isMask.call(u2, e5) && (s.getTest.call(u2, e5).match.nativeDef === t5.charAt(0) || true === s.getTest.call(u2, e5).match.static && s.getTest.call(u2, e5).match.nativeDef === "'" + t5.charAt(0) || " " === s.getTest.call(u2, e5).match.nativeDef && (s.getTest.call(u2, e5 + 1).match.nativeDef === t5.charAt(0) || true === s.getTest.call(u2, e5 + 1).match.static && s.getTest.call(u2, e5 + 1).match.nativeDef === "'" + t5.charAt(0)));
                      if (!a2 && i5 > 0 && !o.isMask.call(u2, e5, false, true)) {
                        var r4 = o.seekNext.call(u2, e5);
                        u2.caretPos.begin < r4 && (u2.caretPos = {
                          begin: r4
                        });
                      }
                      return a2;
                    }(g, m) ? (c2 = a.EventHandlers.keypressEvent.call(u2, i4, true, false, n3, u2.caretPos.begin)) && (g = u2.caretPos.begin + 1, m = "") : c2 = a.EventHandlers.keypressEvent.call(u2, i4, true, false, n3, r3 + 1), c2 ? (void 0 !== c2.pos && f2.validPositions[c2.pos] && true === f2.validPositions[c2.pos].match.static && void 0 === f2.validPositions[c2.pos].alternation && (k.push(c2.pos), u2.isRTL || (c2.forwardPosition = c2.pos + 1)), p.call(u2, void 0, o.getBuffer.call(u2), c2.forwardPosition, i4, false), u2.caretPos = {
                      begin: c2.forwardPosition,
                      end: c2.forwardPosition
                    }, b = u2.caretPos) : void 0 === f2.validPositions[t4] && v[t4] === s.getPlaceholder.call(u2, t4) && o.isMask.call(u2, t4, true) ? u2.caretPos.begin++ : u2.caretPos = b;
                  }
                }), k.length > 0) {
                  var x, w, P = o.seekNext.call(u2, -1, void 0, false);
                  if (!l.isComplete.call(u2, o.getBuffer.call(u2)) && k.length <= P || l.isComplete.call(u2, o.getBuffer.call(u2)) && k.length > 0 && k.length !== P && 0 === k[0]) {
                    for (var S = P; void 0 !== (x = k.shift()); ) if (x < S) {
                      var O = new h.Event("_checkval");
                      if ((w = f2.validPositions[x]).generatedInput = true, O.key = w.input, (c2 = a.EventHandlers.keypressEvent.call(u2, O, true, false, n3, S)) && void 0 !== c2.pos && c2.pos !== x && f2.validPositions[c2.pos] && true === f2.validPositions[c2.pos].match.static) k.push(c2.pos);
                      else if (!c2) break;
                      S++;
                    }
                  }
                }
                t3 && p.call(u2, e3, o.getBuffer.call(u2), c2 ? c2.forwardPosition : u2.caretPos.begin, r2 || new h.Event("checkval"), r2 && ("input" === r2.type && u2.undoValue !== o.getBuffer.call(u2).join("") || "paste" === r2.type)), d.skipOptionalPartCharacter = y;
              }
              function p(e3, t3, n3, i3, a2) {
                var s2 = e3 ? e3.inputmask : this, c2 = s2.opts, u2 = s2.dependencyLib;
                if (i3 && "function" == typeof c2.onBeforeWrite) {
                  var f2 = c2.onBeforeWrite.call(s2, i3, t3, n3, c2);
                  if (f2) {
                    if (f2.refreshFromBuffer) {
                      var p2 = f2.refreshFromBuffer;
                      l.refreshFromBuffer.call(s2, true === p2 ? p2 : p2.start, p2.end, f2.buffer || t3), t3 = o.getBuffer.call(s2, true);
                    }
                    void 0 !== n3 && (n3 = void 0 !== f2.caret ? f2.caret : n3);
                  }
                }
                if (void 0 !== e3 && (e3.inputmask._valueSet(t3.join("")), void 0 === n3 || void 0 !== i3 && "blur" === i3.type || o.caret.call(s2, e3, n3, void 0, void 0, void 0 !== i3 && "keydown" === i3.type && (i3.key === r.keys.Delete || i3.key === r.keys.Backspace)), void 0 === e3.inputmask.writeBufferHook || e3.inputmask.writeBufferHook(n3), true === a2)) {
                  var d = u2(e3), h = e3.inputmask._valueGet();
                  e3.inputmask.skipInputEvent = true, d.trigger("input"), setTimeout(function() {
                    h === o.getBufferTemplate.call(s2).join("") ? d.trigger("cleared") : true === l.isComplete.call(s2, t3) && d.trigger("complete");
                  }, 0);
                }
              }
            },
            2394: function(e2, t2, n2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = void 0;
              var i2 = v(n2(3976)), a = v(n2(7392)), r = v(n2(4963)), o = n2(9716), l = v(n2(9380)), s = n2(7760), c = n2(157), u = n2(2391), f = n2(8711), p = n2(7215), d = n2(4713);
              function h(e3) {
                return h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
                  return typeof e4;
                } : function(e4) {
                  return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
                }, h(e3);
              }
              function v(e3) {
                return e3 && e3.__esModule ? e3 : {
                  default: e3
                };
              }
              var m = l.default.document, g = "_inputmask_opts";
              function y(e3, t3, n3) {
                if (!(this instanceof y)) return new y(e3, t3, n3);
                this.dependencyLib = r.default, this.el = void 0, this.events = {}, this.maskset = void 0, true !== n3 && ("[object Object]" === Object.prototype.toString.call(e3) ? t3 = e3 : (t3 = t3 || {}, e3 && (t3.alias = e3)), this.opts = r.default.extend(true, {}, this.defaults, t3), this.noMasksCache = t3 && void 0 !== t3.definitions, this.userOptions = t3 || {}, k(this.opts.alias, t3, this.opts)), this.refreshValue = false, this.undoValue = void 0, this.$el = void 0, this.skipInputEvent = false, this.validationEvent = false, this.ignorable = false, this.maxLength, this.mouseEnter = false, this.clicked = 0, this.originalPlaceholder = void 0, this.isComposing = false, this.hasAlternator = false;
              }
              function k(e3, t3, n3) {
                var i3 = y.prototype.aliases[e3];
                return i3 ? (i3.alias && k(i3.alias, void 0, n3), r.default.extend(true, n3, i3), r.default.extend(true, n3, t3), true) : (null === n3.mask && (n3.mask = e3), false);
              }
              y.prototype = {
                dataAttribute: "data-inputmask",
                defaults: i2.default,
                definitions: a.default,
                aliases: {},
                masksCache: {},
                i18n: {},
                get isRTL() {
                  return this.opts.isRTL || this.opts.numericInput;
                },
                mask: function(e3) {
                  var t3 = this;
                  return "string" == typeof e3 && (e3 = m.getElementById(e3) || m.querySelectorAll(e3)), (e3 = e3.nodeName ? [e3] : Array.isArray(e3) ? e3 : [].slice.call(e3)).forEach(function(e4, n3) {
                    var i3 = r.default.extend(true, {}, t3.opts);
                    if (function(e5, t4, n4, i4) {
                      function a3(t5, a4) {
                        var r2 = "" === i4 ? t5 : i4 + "-" + t5;
                        null !== (a4 = void 0 !== a4 ? a4 : e5.getAttribute(r2)) && ("string" == typeof a4 && (0 === t5.indexOf("on") ? a4 = l.default[a4] : "false" === a4 ? a4 = false : "true" === a4 && (a4 = true)), n4[t5] = a4);
                      }
                      if (true === t4.importDataAttributes) {
                        var o2, s2, c2, u2, f2 = e5.getAttribute(i4);
                        if (f2 && "" !== f2 && (f2 = f2.replace(/'/g, '"'), s2 = JSON.parse("{" + f2 + "}")), s2) {
                          for (u2 in c2 = void 0, s2) if ("alias" === u2.toLowerCase()) {
                            c2 = s2[u2];
                            break;
                          }
                        }
                        for (o2 in a3("alias", c2), n4.alias && k(n4.alias, n4, t4), t4) {
                          if (s2) {
                            for (u2 in c2 = void 0, s2) if (u2.toLowerCase() === o2.toLowerCase()) {
                              c2 = s2[u2];
                              break;
                            }
                          }
                          a3(o2, c2);
                        }
                      }
                      r.default.extend(true, t4, n4), ("rtl" === e5.dir || t4.rightAlign) && (e5.style.textAlign = "right");
                      ("rtl" === e5.dir || t4.numericInput) && (e5.dir = "ltr", e5.removeAttribute("dir"), t4.isRTL = true);
                      return Object.keys(n4).length;
                    }(e4, i3, r.default.extend(true, {}, t3.userOptions), t3.dataAttribute)) {
                      var a2 = (0, u.generateMaskSet)(i3, t3.noMasksCache);
                      void 0 !== a2 && (void 0 !== e4.inputmask && (e4.inputmask.opts.autoUnmask = true, e4.inputmask.remove()), e4.inputmask = new y(void 0, void 0, true), e4.inputmask.opts = i3, e4.inputmask.noMasksCache = t3.noMasksCache, e4.inputmask.userOptions = r.default.extend(true, {}, t3.userOptions), e4.inputmask.el = e4, e4.inputmask.$el = (0, r.default)(e4), e4.inputmask.maskset = a2, r.default.data(e4, g, t3.userOptions), c.mask.call(e4.inputmask));
                    }
                  }), e3 && e3[0] && e3[0].inputmask || this;
                },
                option: function(e3, t3) {
                  return "string" == typeof e3 ? this.opts[e3] : "object" === h(e3) ? (r.default.extend(this.userOptions, e3), this.el && true !== t3 && this.mask(this.el), this) : void 0;
                },
                unmaskedvalue: function(e3) {
                  if (this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache), void 0 === this.el || void 0 !== e3) {
                    var t3 = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e3, this.opts) || e3).split("");
                    s.checkVal.call(this, void 0, false, false, t3), "function" == typeof this.opts.onBeforeWrite && this.opts.onBeforeWrite.call(this, void 0, f.getBuffer.call(this), 0, this.opts);
                  }
                  return s.unmaskedvalue.call(this, this.el);
                },
                remove: function() {
                  if (this.el) {
                    r.default.data(this.el, g, null);
                    var e3 = this.opts.autoUnmask ? (0, s.unmaskedvalue)(this.el) : this._valueGet(this.opts.autoUnmask);
                    e3 !== f.getBufferTemplate.call(this).join("") ? this._valueSet(e3, this.opts.autoUnmask) : this._valueSet(""), o.EventRuler.off(this.el), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.el), "value") && this.__valueGet && Object.defineProperty(this.el, "value", {
                      get: this.__valueGet,
                      set: this.__valueSet,
                      configurable: true
                    }) : m.__lookupGetter__ && this.el.__lookupGetter__("value") && this.__valueGet && (this.el.__defineGetter__("value", this.__valueGet), this.el.__defineSetter__("value", this.__valueSet)), this.el.inputmask = void 0;
                  }
                  return this.el;
                },
                getemptymask: function() {
                  return this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache), (this.isRTL ? f.getBufferTemplate.call(this).reverse() : f.getBufferTemplate.call(this)).join("");
                },
                hasMaskedValue: function() {
                  return !this.opts.autoUnmask;
                },
                isComplete: function() {
                  return this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache), p.isComplete.call(this, f.getBuffer.call(this));
                },
                getmetadata: function() {
                  if (this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache), Array.isArray(this.maskset.metadata)) {
                    var e3 = d.getMaskTemplate.call(this, true, 0, false).join("");
                    return this.maskset.metadata.forEach(function(t3) {
                      return t3.mask !== e3 || (e3 = t3, false);
                    }), e3;
                  }
                  return this.maskset.metadata;
                },
                isValid: function(e3) {
                  if (this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache), e3) {
                    var t3 = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e3, this.opts) || e3).split("");
                    s.checkVal.call(this, void 0, true, false, t3);
                  } else e3 = this.isRTL ? f.getBuffer.call(this).slice().reverse().join("") : f.getBuffer.call(this).join("");
                  for (var n3 = f.getBuffer.call(this), i3 = f.determineLastRequiredPosition.call(this), a2 = n3.length - 1; a2 > i3 && !f.isMask.call(this, a2); a2--) ;
                  return n3.splice(i3, a2 + 1 - i3), p.isComplete.call(this, n3) && e3 === (this.isRTL ? f.getBuffer.call(this).slice().reverse().join("") : f.getBuffer.call(this).join(""));
                },
                format: function(e3, t3) {
                  this.maskset = this.maskset || (0, u.generateMaskSet)(this.opts, this.noMasksCache);
                  var n3 = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e3, this.opts) || e3).split("");
                  s.checkVal.call(this, void 0, true, false, n3);
                  var i3 = this.isRTL ? f.getBuffer.call(this).slice().reverse().join("") : f.getBuffer.call(this).join("");
                  return t3 ? {
                    value: i3,
                    metadata: this.getmetadata()
                  } : i3;
                },
                setValue: function(e3) {
                  this.el && (0, r.default)(this.el).trigger("setvalue", [e3]);
                },
                analyseMask: u.analyseMask
              }, y.extendDefaults = function(e3) {
                r.default.extend(true, y.prototype.defaults, e3);
              }, y.extendDefinitions = function(e3) {
                r.default.extend(true, y.prototype.definitions, e3);
              }, y.extendAliases = function(e3) {
                r.default.extend(true, y.prototype.aliases, e3);
              }, y.format = function(e3, t3, n3) {
                return y(t3).format(e3, n3);
              }, y.unmask = function(e3, t3) {
                return y(t3).unmaskedvalue(e3);
              }, y.isValid = function(e3, t3) {
                return y(t3).isValid(e3);
              }, y.remove = function(e3) {
                "string" == typeof e3 && (e3 = m.getElementById(e3) || m.querySelectorAll(e3)), (e3 = e3.nodeName ? [e3] : e3).forEach(function(e4) {
                  e4.inputmask && e4.inputmask.remove();
                });
              }, y.setValue = function(e3, t3) {
                "string" == typeof e3 && (e3 = m.getElementById(e3) || m.querySelectorAll(e3)), (e3 = e3.nodeName ? [e3] : e3).forEach(function(e4) {
                  e4.inputmask ? e4.inputmask.setValue(t3) : (0, r.default)(e4).trigger("setvalue", [t3]);
                });
              }, y.dependencyLib = r.default, l.default.Inputmask = y;
              t2.default = y;
            },
            5296: function(e2, t2, n2) {
              function i2(e3) {
                return i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
                  return typeof e4;
                } : function(e4) {
                  return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
                }, i2(e3);
              }
              var a = d(n2(9380)), r = d(n2(2394));
              function o(e3, t3) {
                for (var n3 = 0; n3 < t3.length; n3++) {
                  var a2 = t3[n3];
                  a2.enumerable = a2.enumerable || false, a2.configurable = true, "value" in a2 && (a2.writable = true), Object.defineProperty(e3, (r2 = a2.key, o2 = void 0, o2 = function(e4, t4) {
                    if ("object" !== i2(e4) || null === e4) return e4;
                    var n4 = e4[Symbol.toPrimitive];
                    if (void 0 !== n4) {
                      var a3 = n4.call(e4, t4 || "default");
                      if ("object" !== i2(a3)) return a3;
                      throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === t4 ? String : Number)(e4);
                  }(r2, "string"), "symbol" === i2(o2) ? o2 : String(o2)), a2);
                }
                var r2, o2;
              }
              function l(e3) {
                var t3 = u();
                return function() {
                  var n3, a2 = p(e3);
                  if (t3) {
                    var r2 = p(this).constructor;
                    n3 = Reflect.construct(a2, arguments, r2);
                  } else n3 = a2.apply(this, arguments);
                  return function(e4, t4) {
                    if (t4 && ("object" === i2(t4) || "function" == typeof t4)) return t4;
                    if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
                    return function(e5) {
                      if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      return e5;
                    }(e4);
                  }(this, n3);
                };
              }
              function s(e3) {
                var t3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
                return s = function(e4) {
                  if (null === e4 || !function(e5) {
                    try {
                      return -1 !== Function.toString.call(e5).indexOf("[native code]");
                    } catch (t4) {
                      return "function" == typeof e5;
                    }
                  }(e4)) return e4;
                  if ("function" != typeof e4) throw new TypeError("Super expression must either be null or a function");
                  if (void 0 !== t3) {
                    if (t3.has(e4)) return t3.get(e4);
                    t3.set(e4, n3);
                  }
                  function n3() {
                    return c(e4, arguments, p(this).constructor);
                  }
                  return n3.prototype = Object.create(e4.prototype, {
                    constructor: {
                      value: n3,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  }), f(n3, e4);
                }, s(e3);
              }
              function c(e3, t3, n3) {
                return c = u() ? Reflect.construct.bind() : function(e4, t4, n4) {
                  var i3 = [null];
                  i3.push.apply(i3, t4);
                  var a2 = new (Function.bind.apply(e4, i3))();
                  return n4 && f(a2, n4.prototype), a2;
                }, c.apply(null, arguments);
              }
              function u() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                if (Reflect.construct.sham) return false;
                if ("function" == typeof Proxy) return true;
                try {
                  return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                  })), true;
                } catch (e3) {
                  return false;
                }
              }
              function f(e3, t3) {
                return f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
                  return e4.__proto__ = t4, e4;
                }, f(e3, t3);
              }
              function p(e3) {
                return p = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
                  return e4.__proto__ || Object.getPrototypeOf(e4);
                }, p(e3);
              }
              function d(e3) {
                return e3 && e3.__esModule ? e3 : {
                  default: e3
                };
              }
              var h = a.default.document;
              if (h && h.head && h.head.attachShadow && a.default.customElements && void 0 === a.default.customElements.get("input-mask")) {
                var v = function(e3) {
                  !function(e4, t4) {
                    if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
                    e4.prototype = Object.create(t4 && t4.prototype, {
                      constructor: {
                        value: e4,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(e4, "prototype", {
                      writable: false
                    }), t4 && f(e4, t4);
                  }(s2, e3);
                  var t3, n3, i3, a2 = l(s2);
                  function s2() {
                    var e4;
                    !function(e5, t5) {
                      if (!(e5 instanceof t5)) throw new TypeError("Cannot call a class as a function");
                    }(this, s2);
                    var t4 = (e4 = a2.call(this)).getAttributeNames(), n4 = e4.attachShadow({
                      mode: "closed"
                    });
                    for (var i4 in e4.input = h.createElement("input"), e4.input.type = "text", n4.appendChild(e4.input), t4) Object.prototype.hasOwnProperty.call(t4, i4) && e4.input.setAttribute(t4[i4], e4.getAttribute(t4[i4]));
                    var o2 = new r.default();
                    return o2.dataAttribute = "", o2.mask(e4.input), e4.input.inputmask.shadowRoot = n4, e4;
                  }
                  return t3 = s2, (n3 = [{
                    key: "attributeChangedCallback",
                    value: function(e4, t4, n4) {
                      this.input.setAttribute(e4, n4);
                    }
                  }, {
                    key: "value",
                    get: function() {
                      return this.input.value;
                    },
                    set: function(e4) {
                      this.input.value = e4;
                    }
                  }]) && o(t3.prototype, n3), i3 && o(t3, i3), Object.defineProperty(t3, "prototype", {
                    writable: false
                  }), s2;
                }(s(HTMLElement));
                a.default.customElements.define("input-mask", v);
              }
            },
            2839: function(e2, t2) {
              function n2(e3) {
                return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
                  return typeof e4;
                } : function(e4) {
                  return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
                }, n2(e3);
              }
              function i2(e3, t3) {
                return function(e4) {
                  if (Array.isArray(e4)) return e4;
                }(e3) || function(e4, t4) {
                  var n3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
                  if (null != n3) {
                    var i3, a2, r2, o2, l2 = [], s2 = true, c = false;
                    try {
                      if (r2 = (n3 = n3.call(e4)).next, 0 === t4) {
                        if (Object(n3) !== n3) return;
                        s2 = false;
                      } else for (; !(s2 = (i3 = r2.call(n3)).done) && (l2.push(i3.value), l2.length !== t4); s2 = true) ;
                    } catch (e5) {
                      c = true, a2 = e5;
                    } finally {
                      try {
                        if (!s2 && null != n3.return && (o2 = n3.return(), Object(o2) !== o2)) return;
                      } finally {
                        if (c) throw a2;
                      }
                    }
                    return l2;
                  }
                }(e3, t3) || function(e4, t4) {
                  if (!e4) return;
                  if ("string" == typeof e4) return a(e4, t4);
                  var n3 = Object.prototype.toString.call(e4).slice(8, -1);
                  "Object" === n3 && e4.constructor && (n3 = e4.constructor.name);
                  if ("Map" === n3 || "Set" === n3) return Array.from(e4);
                  if ("Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return a(e4, t4);
                }(e3, t3) || function() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }();
              }
              function a(e3, t3) {
                (null == t3 || t3 > e3.length) && (t3 = e3.length);
                for (var n3 = 0, i3 = new Array(t3); n3 < t3; n3++) i3[n3] = e3[n3];
                return i3;
              }
              function r(e3, t3) {
                var n3 = Object.keys(e3);
                if (Object.getOwnPropertySymbols) {
                  var i3 = Object.getOwnPropertySymbols(e3);
                  t3 && (i3 = i3.filter(function(t4) {
                    return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
                  })), n3.push.apply(n3, i3);
                }
                return n3;
              }
              function o(e3, t3, i3) {
                return (t3 = function(e4) {
                  var t4 = function(e5, t5) {
                    if ("object" !== n2(e5) || null === e5) return e5;
                    var i4 = e5[Symbol.toPrimitive];
                    if (void 0 !== i4) {
                      var a2 = i4.call(e5, t5 || "default");
                      if ("object" !== n2(a2)) return a2;
                      throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === t5 ? String : Number)(e5);
                  }(e4, "string");
                  return "symbol" === n2(t4) ? t4 : String(t4);
                }(t3)) in e3 ? Object.defineProperty(e3, t3, {
                  value: i3,
                  enumerable: true,
                  configurable: true,
                  writable: true
                }) : e3[t3] = i3, e3;
              }
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.keys = t2.keyCode = void 0, t2.toKey = function(e3, t3) {
                return s[e3] || (t3 ? String.fromCharCode(e3) : String.fromCharCode(e3).toLowerCase());
              }, t2.toKeyCode = function(e3) {
                return l[e3];
              };
              var l = t2.keyCode = function(e3) {
                for (var t3 = 1; t3 < arguments.length; t3++) {
                  var n3 = null != arguments[t3] ? arguments[t3] : {};
                  t3 % 2 ? r(Object(n3), true).forEach(function(t4) {
                    o(e3, t4, n3[t4]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n3)) : r(Object(n3)).forEach(function(t4) {
                    Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n3, t4));
                  });
                }
                return e3;
              }({
                c: 67,
                x: 88,
                z: 90,
                BACKSPACE_SAFARI: 127,
                Enter: 13,
                Meta_LEFT: 91,
                Meta_RIGHT: 92,
                Space: 32
              }, {
                Alt: 18,
                AltGraph: 18,
                ArrowDown: 40,
                ArrowLeft: 37,
                ArrowRight: 39,
                ArrowUp: 38,
                Backspace: 8,
                CapsLock: 20,
                Control: 17,
                ContextMenu: 93,
                Dead: 221,
                Delete: 46,
                End: 35,
                Escape: 27,
                F1: 112,
                F2: 113,
                F3: 114,
                F4: 115,
                F5: 116,
                F6: 117,
                F7: 118,
                F8: 119,
                F9: 120,
                F10: 121,
                F11: 122,
                F12: 123,
                Home: 36,
                Insert: 45,
                NumLock: 144,
                PageDown: 34,
                PageUp: 33,
                Pause: 19,
                PrintScreen: 44,
                Process: 229,
                Shift: 16,
                ScrollLock: 145,
                Tab: 9,
                Unidentified: 229
              }), s = Object.entries(l).reduce(function(e3, t3) {
                var n3 = i2(t3, 2), a2 = n3[0], r2 = n3[1];
                return e3[r2] = void 0 === e3[r2] ? a2 : e3[r2], e3;
              }, {});
              t2.keys = Object.entries(l).reduce(function(e3, t3) {
                var n3 = i2(t3, 2), a2 = n3[0];
                n3[1];
                return e3[a2] = "Space" === a2 ? " " : a2, e3;
              }, {});
            },
            2391: function(e2, t2, n2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.analyseMask = function(e3, t3, n3) {
                var i3, a2, s2, c2, u, f, p = /(?:[?*+]|\{[0-9+*]+(?:,[0-9+*]*)?(?:\|[0-9+*]*)?\})|[^.?*+^${[]()|\\]+|./g, d = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g, h = false, v = new o.default(), m = [], g = [], y = false;
                function k(e4, i4, a3) {
                  a3 = void 0 !== a3 ? a3 : e4.matches.length;
                  var o2 = e4.matches[a3 - 1];
                  if (t3) {
                    if (0 === i4.indexOf("[") || h && /\\d|\\s|\\w|\\p/i.test(i4) || "." === i4) {
                      var s3 = n3.casing ? "i" : "";
                      /\\p\{.*}/i.test(i4) && (s3 += "u"), e4.matches.splice(a3++, 0, {
                        fn: new RegExp(i4, s3),
                        static: false,
                        optionality: false,
                        newBlockMarker: void 0 === o2 ? "master" : o2.def !== i4,
                        casing: null,
                        def: i4,
                        placeholder: "object" === l(n3.placeholder) ? n3.placeholder[v.matches.length] : void 0,
                        nativeDef: i4
                      });
                    } else h && (i4 = i4[i4.length - 1]), i4.split("").forEach(function(t4, i5) {
                      o2 = e4.matches[a3 - 1], e4.matches.splice(a3++, 0, {
                        fn: /[a-z]/i.test(n3.staticDefinitionSymbol || t4) ? new RegExp("[" + (n3.staticDefinitionSymbol || t4) + "]", n3.casing ? "i" : "") : null,
                        static: true,
                        optionality: false,
                        newBlockMarker: void 0 === o2 ? "master" : o2.def !== t4 && true !== o2.static,
                        casing: null,
                        def: n3.staticDefinitionSymbol || t4,
                        placeholder: void 0 !== n3.staticDefinitionSymbol ? t4 : "object" === l(n3.placeholder) ? n3.placeholder[v.matches.length] : void 0,
                        nativeDef: (h ? "'" : "") + t4
                      });
                    });
                    h = false;
                  } else {
                    var c3 = n3.definitions && n3.definitions[i4] || n3.usePrototypeDefinitions && r.default.prototype.definitions[i4];
                    c3 && !h ? e4.matches.splice(a3++, 0, {
                      fn: c3.validator ? "string" == typeof c3.validator ? new RegExp(c3.validator, n3.casing ? "i" : "") : new function() {
                        this.test = c3.validator;
                      }() : /./,
                      static: c3.static || false,
                      optionality: c3.optional || false,
                      defOptionality: c3.optional || false,
                      newBlockMarker: void 0 === o2 || c3.optional ? "master" : o2.def !== (c3.definitionSymbol || i4),
                      casing: c3.casing,
                      def: c3.definitionSymbol || i4,
                      placeholder: c3.placeholder,
                      nativeDef: i4,
                      generated: c3.generated
                    }) : (e4.matches.splice(a3++, 0, {
                      fn: /[a-z]/i.test(n3.staticDefinitionSymbol || i4) ? new RegExp("[" + (n3.staticDefinitionSymbol || i4) + "]", n3.casing ? "i" : "") : null,
                      static: true,
                      optionality: false,
                      newBlockMarker: void 0 === o2 ? "master" : o2.def !== i4 && true !== o2.static,
                      casing: null,
                      def: n3.staticDefinitionSymbol || i4,
                      placeholder: void 0 !== n3.staticDefinitionSymbol ? i4 : void 0,
                      nativeDef: (h ? "'" : "") + i4
                    }), h = false);
                  }
                }
                function b() {
                  if (m.length > 0) {
                    if (k(c2 = m[m.length - 1], a2), c2.isAlternator) {
                      u = m.pop();
                      for (var e4 = 0; e4 < u.matches.length; e4++) u.matches[e4].isGroup && (u.matches[e4].isGroup = false);
                      m.length > 0 ? (c2 = m[m.length - 1]).matches.push(u) : v.matches.push(u);
                    }
                  } else k(v, a2);
                }
                function x(e4) {
                  var t4 = new o.default(true);
                  return t4.openGroup = false, t4.matches = e4, t4;
                }
                function w() {
                  if ((s2 = m.pop()).openGroup = false, void 0 !== s2) if (m.length > 0) {
                    if ((c2 = m[m.length - 1]).matches.push(s2), c2.isAlternator) {
                      u = m.pop();
                      for (var e4 = 0; e4 < u.matches.length; e4++) u.matches[e4].isGroup = false, u.matches[e4].alternatorGroup = false;
                      m.length > 0 ? (c2 = m[m.length - 1]).matches.push(u) : v.matches.push(u);
                    }
                  } else v.matches.push(s2);
                  else b();
                }
                function P(e4) {
                  var t4 = e4.pop();
                  return t4.isQuantifier && (t4 = x([e4.pop(), t4])), t4;
                }
                t3 && (n3.optionalmarker[0] = void 0, n3.optionalmarker[1] = void 0);
                for (; i3 = t3 ? d.exec(e3) : p.exec(e3); ) {
                  if (a2 = i3[0], t3) {
                    switch (a2.charAt(0)) {
                      case "?":
                        a2 = "{0,1}";
                        break;
                      case "+":
                      case "*":
                        a2 = "{" + a2 + "}";
                        break;
                      case "|":
                        if (0 === m.length) {
                          var S = x(v.matches);
                          S.openGroup = true, m.push(S), v.matches = [], y = true;
                        }
                    }
                    switch (a2) {
                      case "\\d":
                        a2 = "[0-9]";
                        break;
                      case "\\p":
                        a2 += d.exec(e3)[0], a2 += d.exec(e3)[0];
                    }
                  }
                  if (h) b();
                  else switch (a2.charAt(0)) {
                    case "$":
                    case "^":
                      t3 || b();
                      break;
                    case n3.escapeChar:
                      h = true, t3 && b();
                      break;
                    case n3.optionalmarker[1]:
                    case n3.groupmarker[1]:
                      w();
                      break;
                    case n3.optionalmarker[0]:
                      m.push(new o.default(false, true));
                      break;
                    case n3.groupmarker[0]:
                      m.push(new o.default(true));
                      break;
                    case n3.quantifiermarker[0]:
                      var O = new o.default(false, false, true), _2 = (a2 = a2.replace(/[{}?]/g, "")).split("|"), M = _2[0].split(","), E = isNaN(M[0]) ? M[0] : parseInt(M[0]), j = 1 === M.length ? E : isNaN(M[1]) ? M[1] : parseInt(M[1]), T = isNaN(_2[1]) ? _2[1] : parseInt(_2[1]);
                      "*" !== E && "+" !== E || (E = "*" === j ? 0 : 1), O.quantifier = {
                        min: E,
                        max: j,
                        jit: T
                      };
                      var A = m.length > 0 ? m[m.length - 1].matches : v.matches;
                      (i3 = A.pop()).isGroup || (i3 = x([i3])), A.push(i3), A.push(O);
                      break;
                    case n3.alternatormarker:
                      if (m.length > 0) {
                        var D = (c2 = m[m.length - 1]).matches[c2.matches.length - 1];
                        f = c2.openGroup && (void 0 === D.matches || false === D.isGroup && false === D.isAlternator) ? m.pop() : P(c2.matches);
                      } else f = P(v.matches);
                      if (f.isAlternator) m.push(f);
                      else if (f.alternatorGroup ? (u = m.pop(), f.alternatorGroup = false) : u = new o.default(false, false, false, true), u.matches.push(f), m.push(u), f.openGroup) {
                        f.openGroup = false;
                        var L = new o.default(true);
                        L.alternatorGroup = true, m.push(L);
                      }
                      break;
                    default:
                      b();
                  }
                }
                y && w();
                for (; m.length > 0; ) s2 = m.pop(), v.matches.push(s2);
                v.matches.length > 0 && (!function e4(i4) {
                  i4 && i4.matches && i4.matches.forEach(function(a3, r2) {
                    var o2 = i4.matches[r2 + 1];
                    (void 0 === o2 || void 0 === o2.matches || false === o2.isQuantifier) && a3 && a3.isGroup && (a3.isGroup = false, t3 || (k(a3, n3.groupmarker[0], 0), true !== a3.openGroup && k(a3, n3.groupmarker[1]))), e4(a3);
                  });
                }(v), g.push(v));
                (n3.numericInput || n3.isRTL) && function e4(t4) {
                  for (var i4 in t4.matches = t4.matches.reverse(), t4.matches) if (Object.prototype.hasOwnProperty.call(t4.matches, i4)) {
                    var a3 = parseInt(i4);
                    if (t4.matches[i4].isQuantifier && t4.matches[a3 + 1] && t4.matches[a3 + 1].isGroup) {
                      var r2 = t4.matches[i4];
                      t4.matches.splice(i4, 1), t4.matches.splice(a3 + 1, 0, r2);
                    }
                    void 0 !== t4.matches[i4].matches ? t4.matches[i4] = e4(t4.matches[i4]) : t4.matches[i4] = ((o2 = t4.matches[i4]) === n3.optionalmarker[0] ? o2 = n3.optionalmarker[1] : o2 === n3.optionalmarker[1] ? o2 = n3.optionalmarker[0] : o2 === n3.groupmarker[0] ? o2 = n3.groupmarker[1] : o2 === n3.groupmarker[1] && (o2 = n3.groupmarker[0]), o2);
                  }
                  var o2;
                  return t4;
                }(g[0]);
                return g;
              }, t2.generateMaskSet = function(e3, t3) {
                var n3;
                function o2(e4, t4) {
                  var n4 = t4.repeat, i3 = t4.groupmarker, r2 = t4.quantifiermarker, o3 = t4.keepStatic;
                  if (n4 > 0 || "*" === n4 || "+" === n4) {
                    var l2 = "*" === n4 ? 0 : "+" === n4 ? 1 : n4;
                    if (l2 != n4) e4 = i3[0] + e4 + i3[1] + r2[0] + l2 + "," + n4 + r2[1];
                    else for (var c3 = e4, u2 = 1; u2 < l2; u2++) e4 += c3;
                  }
                  if (true === o3) {
                    var f = e4.match(new RegExp("(.)\\[([^\\]]*)\\]", "g"));
                    f && f.forEach(function(t5, n5) {
                      var i4 = function(e5, t6) {
                        return function(e6) {
                          if (Array.isArray(e6)) return e6;
                        }(e5) || function(e6, t7) {
                          var n6 = null == e6 ? null : "undefined" != typeof Symbol && e6[Symbol.iterator] || e6["@@iterator"];
                          if (null != n6) {
                            var i5, a2, r4, o5, l3 = [], s2 = true, c4 = false;
                            try {
                              if (r4 = (n6 = n6.call(e6)).next, 0 === t7) {
                                if (Object(n6) !== n6) return;
                                s2 = false;
                              } else for (; !(s2 = (i5 = r4.call(n6)).done) && (l3.push(i5.value), l3.length !== t7); s2 = true) ;
                            } catch (e7) {
                              c4 = true, a2 = e7;
                            } finally {
                              try {
                                if (!s2 && null != n6.return && (o5 = n6.return(), Object(o5) !== o5)) return;
                              } finally {
                                if (c4) throw a2;
                              }
                            }
                            return l3;
                          }
                        }(e5, t6) || function(e6, t7) {
                          if (!e6) return;
                          if ("string" == typeof e6) return s(e6, t7);
                          var n6 = Object.prototype.toString.call(e6).slice(8, -1);
                          "Object" === n6 && e6.constructor && (n6 = e6.constructor.name);
                          if ("Map" === n6 || "Set" === n6) return Array.from(e6);
                          if ("Arguments" === n6 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n6)) return s(e6, t7);
                        }(e5, t6) || function() {
                          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }();
                      }(t5.split("["), 2), r3 = i4[0], o4 = i4[1];
                      o4 = o4.replace("]", ""), e4 = e4.replace(new RegExp("".concat((0, a.default)(r3), "\\[").concat((0, a.default)(o4), "\\]")), r3.charAt(0) === o4.charAt(0) ? "(".concat(r3, "|").concat(r3).concat(o4, ")") : "".concat(r3, "[").concat(o4, "]"));
                    });
                  }
                  return e4;
                }
                function c2(e4, n4, a2) {
                  var s2, c3, u2 = false;
                  return null !== e4 && "" !== e4 || ((u2 = null !== a2.regex) ? e4 = (e4 = a2.regex).replace(/^(\^)(.*)(\$)$/, "$2") : (u2 = true, e4 = ".*")), 1 === e4.length && false === a2.greedy && 0 !== a2.repeat && (a2.placeholder = ""), e4 = o2(e4, a2), c3 = u2 ? "regex_" + a2.regex : a2.numericInput ? e4.split("").reverse().join("") : e4, null !== a2.keepStatic && (c3 = "ks_" + a2.keepStatic + c3), "object" === l(a2.placeholder) && (c3 = "ph_" + JSON.stringify(a2.placeholder) + c3), void 0 === r.default.prototype.masksCache[c3] || true === t3 ? (s2 = {
                    mask: e4,
                    maskToken: r.default.prototype.analyseMask(e4, u2, a2),
                    validPositions: [],
                    _buffer: void 0,
                    buffer: void 0,
                    tests: {},
                    excludes: {},
                    metadata: n4,
                    maskLength: void 0,
                    jitOffset: {}
                  }, true !== t3 && (r.default.prototype.masksCache[c3] = s2, s2 = i2.default.extend(true, {}, r.default.prototype.masksCache[c3]))) : s2 = i2.default.extend(true, {}, r.default.prototype.masksCache[c3]), s2;
                }
                "function" == typeof e3.mask && (e3.mask = e3.mask(e3));
                if (Array.isArray(e3.mask)) {
                  if (e3.mask.length > 1) {
                    null === e3.keepStatic && (e3.keepStatic = true);
                    var u = e3.groupmarker[0];
                    return (e3.isRTL ? e3.mask.reverse() : e3.mask).forEach(function(t4) {
                      u.length > 1 && (u += e3.alternatormarker), void 0 !== t4.mask && "function" != typeof t4.mask ? u += t4.mask : u += t4;
                    }), c2(u += e3.groupmarker[1], e3.mask, e3);
                  }
                  e3.mask = e3.mask.pop();
                }
                n3 = e3.mask && void 0 !== e3.mask.mask && "function" != typeof e3.mask.mask ? c2(e3.mask.mask, e3.mask, e3) : c2(e3.mask, e3.mask, e3);
                null === e3.keepStatic && (e3.keepStatic = false);
                return n3;
              };
              var i2 = c(n2(4963)), a = c(n2(7184)), r = c(n2(2394)), o = c(n2(9695));
              function l(e3) {
                return l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
                  return typeof e4;
                } : function(e4) {
                  return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
                }, l(e3);
              }
              function s(e3, t3) {
                (null == t3 || t3 > e3.length) && (t3 = e3.length);
                for (var n3 = 0, i3 = new Array(t3); n3 < t3; n3++) i3[n3] = e3[n3];
                return i3;
              }
              function c(e3) {
                return e3 && e3.__esModule ? e3 : {
                  default: e3
                };
              }
            },
            157: function(e2, t2, n2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.mask = function() {
                var e3 = this, t3 = this.opts, n3 = this.el, c = this.dependencyLib;
                r.EventRuler.off(n3);
                var u = function(t4, n4) {
                  var i3 = t4.getAttribute("type"), a2 = "input" === t4.tagName.toLowerCase() && n4.supportsInputType.includes(i3) || t4.isContentEditable || "textarea" === t4.tagName.toLowerCase();
                  if (!a2) if ("input" === t4.tagName.toLowerCase()) {
                    var s2 = document.createElement("input");
                    s2.setAttribute("type", i3), a2 = "text" === s2.type, s2 = null;
                  } else a2 = "partial";
                  return false !== a2 ? function(t5) {
                    var i4, a3;
                    function s3() {
                      return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== l.getLastValidPosition.call(e3) || true !== n4.nullable ? (this.inputmask.shadowRoot || this.ownerDocument).activeElement === this && n4.clearMaskOnLostFocus ? (e3.isRTL ? o.clearOptionalTail.call(e3, l.getBuffer.call(e3).slice()).reverse() : o.clearOptionalTail.call(e3, l.getBuffer.call(e3).slice())).join("") : i4.call(this) : "" : i4.call(this);
                    }
                    function u2(e4) {
                      a3.call(this, e4), this.inputmask && (0, o.applyInputValue)(this, e4);
                    }
                    if (!t5.inputmask.__valueGet) {
                      if (true !== n4.noValuePatching) {
                        if (Object.getOwnPropertyDescriptor) {
                          var f2 = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t5), "value") : void 0;
                          f2 && f2.get && f2.set ? (i4 = f2.get, a3 = f2.set, Object.defineProperty(t5, "value", {
                            get: s3,
                            set: u2,
                            configurable: true
                          })) : "input" !== t5.tagName.toLowerCase() && (i4 = function() {
                            return this.textContent;
                          }, a3 = function(e4) {
                            this.textContent = e4;
                          }, Object.defineProperty(t5, "value", {
                            get: s3,
                            set: u2,
                            configurable: true
                          }));
                        } else document.__lookupGetter__ && t5.__lookupGetter__("value") && (i4 = t5.__lookupGetter__("value"), a3 = t5.__lookupSetter__("value"), t5.__defineGetter__("value", s3), t5.__defineSetter__("value", u2));
                        t5.inputmask.__valueGet = i4, t5.inputmask.__valueSet = a3;
                      }
                      t5.inputmask._valueGet = function(t6) {
                        return e3.isRTL && true !== t6 ? i4.call(this.el).split("").reverse().join("") : i4.call(this.el);
                      }, t5.inputmask._valueSet = function(t6, n5) {
                        a3.call(this.el, null == t6 ? "" : true !== n5 && e3.isRTL ? t6.split("").reverse().join("") : t6);
                      }, void 0 === i4 && (i4 = function() {
                        return this.value;
                      }, a3 = function(e4) {
                        this.value = e4;
                      }, function(t6) {
                        if (c.valHooks && (void 0 === c.valHooks[t6] || true !== c.valHooks[t6].inputmaskpatch)) {
                          var i5 = c.valHooks[t6] && c.valHooks[t6].get ? c.valHooks[t6].get : function(e4) {
                            return e4.value;
                          }, a4 = c.valHooks[t6] && c.valHooks[t6].set ? c.valHooks[t6].set : function(e4, t7) {
                            return e4.value = t7, e4;
                          };
                          c.valHooks[t6] = {
                            get: function(t7) {
                              if (t7.inputmask) {
                                if (t7.inputmask.opts.autoUnmask) return t7.inputmask.unmaskedvalue();
                                var a5 = i5(t7);
                                return -1 !== l.getLastValidPosition.call(e3, void 0, void 0, t7.inputmask.maskset.validPositions) || true !== n4.nullable ? a5 : "";
                              }
                              return i5(t7);
                            },
                            set: function(e4, t7) {
                              var n5 = a4(e4, t7);
                              return e4.inputmask && (0, o.applyInputValue)(e4, t7), n5;
                            },
                            inputmaskpatch: true
                          };
                        }
                      }(t5.type), function(e4) {
                        r.EventRuler.on(e4, "mouseenter", function() {
                          var e5 = this, t6 = e5.inputmask._valueGet(true);
                          t6 != (e5.inputmask.isRTL ? l.getBuffer.call(e5.inputmask).slice().reverse() : l.getBuffer.call(e5.inputmask)).join("") && (0, o.applyInputValue)(e5, t6);
                        });
                      }(t5));
                    }
                  }(t4) : t4.inputmask = void 0, a2;
                }(n3, t3);
                if (false !== u) {
                  e3.originalPlaceholder = n3.placeholder, e3.maxLength = void 0 !== n3 ? n3.maxLength : void 0, -1 === e3.maxLength && (e3.maxLength = void 0), "inputMode" in n3 && null === n3.getAttribute("inputmode") && (n3.inputMode = t3.inputmode, n3.setAttribute("inputmode", t3.inputmode)), true === u && (t3.showMaskOnFocus = t3.showMaskOnFocus && -1 === ["cc-number", "cc-exp"].indexOf(n3.autocomplete), i2.iphone && (t3.insertModeVisual = false, n3.setAttribute("autocorrect", "off")), r.EventRuler.on(n3, "submit", a.EventHandlers.submitEvent), r.EventRuler.on(n3, "reset", a.EventHandlers.resetEvent), r.EventRuler.on(n3, "blur", a.EventHandlers.blurEvent), r.EventRuler.on(n3, "focus", a.EventHandlers.focusEvent), r.EventRuler.on(n3, "invalid", a.EventHandlers.invalidEvent), r.EventRuler.on(n3, "click", a.EventHandlers.clickEvent), r.EventRuler.on(n3, "mouseleave", a.EventHandlers.mouseleaveEvent), r.EventRuler.on(n3, "mouseenter", a.EventHandlers.mouseenterEvent), r.EventRuler.on(n3, "paste", a.EventHandlers.pasteEvent), r.EventRuler.on(n3, "cut", a.EventHandlers.cutEvent), r.EventRuler.on(n3, "complete", t3.oncomplete), r.EventRuler.on(n3, "incomplete", t3.onincomplete), r.EventRuler.on(n3, "cleared", t3.oncleared), true !== t3.inputEventOnly && r.EventRuler.on(n3, "keydown", a.EventHandlers.keyEvent), (i2.mobile || t3.inputEventOnly) && n3.removeAttribute("maxLength"), r.EventRuler.on(n3, "input", a.EventHandlers.inputFallBackEvent)), r.EventRuler.on(n3, "setvalue", a.EventHandlers.setValueEvent), void 0 === e3.applyMaskHook || e3.applyMaskHook(), l.getBufferTemplate.call(e3).join(""), e3.undoValue = e3._valueGet(true);
                  var f = (n3.inputmask.shadowRoot || n3.ownerDocument).activeElement;
                  if ("" !== n3.inputmask._valueGet(true) || false === t3.clearMaskOnLostFocus || f === n3) {
                    (0, o.applyInputValue)(n3, n3.inputmask._valueGet(true), t3);
                    var p = l.getBuffer.call(e3).slice();
                    false === s.isComplete.call(e3, p) && t3.clearIncomplete && l.resetMaskSet.call(e3, false), t3.clearMaskOnLostFocus && f !== n3 && (-1 === l.getLastValidPosition.call(e3) ? p = [] : o.clearOptionalTail.call(e3, p)), (false === t3.clearMaskOnLostFocus || t3.showMaskOnFocus && f === n3 || "" !== n3.inputmask._valueGet(true)) && (0, o.writeBuffer)(n3, p), f === n3 && l.caret.call(e3, n3, l.seekNext.call(e3, l.getLastValidPosition.call(e3)));
                  }
                }
              };
              var i2 = n2(9845), a = n2(6030), r = n2(9716), o = n2(7760), l = n2(8711), s = n2(7215);
            },
            9695: function(e2, t2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = function(e3, t3, n2, i2) {
                this.matches = [], this.openGroup = e3 || false, this.alternatorGroup = false, this.isGroup = e3 || false, this.isOptional = t3 || false, this.isQuantifier = n2 || false, this.isAlternator = i2 || false, this.quantifier = {
                  min: 1,
                  max: 1
                };
              };
            },
            3194: function() {
              Array.prototype.includes || Object.defineProperty(Array.prototype, "includes", {
                value: function(e2, t2) {
                  if (null == this) throw new TypeError('"this" is null or not defined');
                  var n2 = Object(this), i2 = n2.length >>> 0;
                  if (0 === i2) return false;
                  for (var a = 0 | t2, r = Math.max(a >= 0 ? a : i2 - Math.abs(a), 0); r < i2; ) {
                    if (n2[r] === e2) return true;
                    r++;
                  }
                  return false;
                }
              });
            },
            9302: function() {
              var e2 = Function.bind.call(Function.call, Array.prototype.reduce), t2 = Function.bind.call(Function.call, Object.prototype.propertyIsEnumerable), n2 = Function.bind.call(Function.call, Array.prototype.concat), i2 = Object.keys;
              Object.entries || (Object.entries = function(a) {
                return e2(i2(a), function(e3, i3) {
                  return n2(e3, "string" == typeof i3 && t2(a, i3) ? [[i3, a[i3]]] : []);
                }, []);
              });
            },
            7149: function() {
              function e2(t2) {
                return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
                  return typeof e3;
                } : function(e3) {
                  return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
                }, e2(t2);
              }
              "function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" === e2("test".__proto__) ? function(e3) {
                return e3.__proto__;
              } : function(e3) {
                return e3.constructor.prototype;
              });
            },
            4013: function() {
              String.prototype.includes || (String.prototype.includes = function(e2, t2) {
                return "number" != typeof t2 && (t2 = 0), !(t2 + e2.length > this.length) && -1 !== this.indexOf(e2, t2);
              });
            },
            8711: function(e2, t2, n2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.caret = function(e3, t3, n3, i3, r2) {
                var o2, l2 = this, s2 = this.opts;
                if (void 0 === t3) return "selectionStart" in e3 && "selectionEnd" in e3 ? (t3 = e3.selectionStart, n3 = e3.selectionEnd) : a.default.getSelection ? (o2 = a.default.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== e3 && o2.commonAncestorContainer !== e3 || (t3 = o2.startOffset, n3 = o2.endOffset) : document.selection && document.selection.createRange && (n3 = (t3 = 0 - (o2 = document.selection.createRange()).duplicate().moveStart("character", -e3.inputmask._valueGet().length)) + o2.text.length), {
                  begin: i3 ? t3 : f.call(l2, t3),
                  end: i3 ? n3 : f.call(l2, n3)
                };
                if (Array.isArray(t3) && (n3 = l2.isRTL ? t3[0] : t3[1], t3 = l2.isRTL ? t3[1] : t3[0]), void 0 !== t3.begin && (n3 = l2.isRTL ? t3.begin : t3.end, t3 = l2.isRTL ? t3.end : t3.begin), "number" == typeof t3) {
                  t3 = i3 ? t3 : f.call(l2, t3), n3 = "number" == typeof (n3 = i3 ? n3 : f.call(l2, n3)) ? n3 : t3;
                  var c2 = parseInt(((e3.ownerDocument.defaultView || a.default).getComputedStyle ? (e3.ownerDocument.defaultView || a.default).getComputedStyle(e3, null) : e3.currentStyle).fontSize) * n3;
                  if (e3.scrollLeft = c2 > e3.scrollWidth ? c2 : 0, e3.inputmask.caretPos = {
                    begin: t3,
                    end: n3
                  }, s2.insertModeVisual && false === s2.insertMode && t3 === n3 && (r2 || n3++), e3 === (e3.inputmask.shadowRoot || e3.ownerDocument).activeElement) {
                    if ("setSelectionRange" in e3) e3.setSelectionRange(t3, n3);
                    else if (a.default.getSelection) {
                      if (o2 = document.createRange(), void 0 === e3.firstChild || null === e3.firstChild) {
                        var u2 = document.createTextNode("");
                        e3.appendChild(u2);
                      }
                      o2.setStart(e3.firstChild, t3 < e3.inputmask._valueGet().length ? t3 : e3.inputmask._valueGet().length), o2.setEnd(e3.firstChild, n3 < e3.inputmask._valueGet().length ? n3 : e3.inputmask._valueGet().length), o2.collapse(true);
                      var p = a.default.getSelection();
                      p.removeAllRanges(), p.addRange(o2);
                    } else e3.createTextRange && ((o2 = e3.createTextRange()).collapse(true), o2.moveEnd("character", n3), o2.moveStart("character", t3), o2.select());
                    void 0 === e3.inputmask.caretHook || e3.inputmask.caretHook.call(l2, {
                      begin: t3,
                      end: n3
                    });
                  }
                }
              }, t2.determineLastRequiredPosition = function(e3) {
                var t3, n3, i3 = this, a2 = i3.maskset, l2 = i3.dependencyLib, c2 = s.call(i3), u2 = {}, f2 = a2.validPositions[c2], p = o.getMaskTemplate.call(i3, true, s.call(i3), true, true), d = p.length, h = void 0 !== f2 ? f2.locator.slice() : void 0;
                for (t3 = c2 + 1; t3 < p.length; t3++) h = (n3 = o.getTestTemplate.call(i3, t3, h, t3 - 1)).locator.slice(), u2[t3] = l2.extend(true, {}, n3);
                var v = f2 && void 0 !== f2.alternation ? f2.locator[f2.alternation] : void 0;
                for (t3 = d - 1; t3 > c2 && (((n3 = u2[t3]).match.optionality || n3.match.optionalQuantifier && n3.match.newBlockMarker || v && (v !== u2[t3].locator[f2.alternation] && true !== n3.match.static || true === n3.match.static && n3.locator[f2.alternation] && r.checkAlternationMatch.call(i3, n3.locator[f2.alternation].toString().split(","), v.toString().split(",")) && "" !== o.getTests.call(i3, t3)[0].def)) && p[t3] === o.getPlaceholder.call(i3, t3, n3.match)); t3--) d--;
                return e3 ? {
                  l: d,
                  def: u2[d] ? u2[d].match : void 0
                } : d;
              }, t2.determineNewCaretPosition = function(e3, t3, n3) {
                var i3, a2, r2, f2 = this, p = f2.maskset, d = f2.opts;
                t3 && (f2.isRTL ? e3.end = e3.begin : e3.begin = e3.end);
                if (e3.begin === e3.end) {
                  switch (n3 = n3 || d.positionCaretOnClick) {
                    case "none":
                      break;
                    case "select":
                      e3 = {
                        begin: 0,
                        end: l.call(f2).length
                      };
                      break;
                    case "ignore":
                      e3.end = e3.begin = u.call(f2, s.call(f2));
                      break;
                    case "radixFocus":
                      if (f2.clicked > 1 && 0 === p.validPositions.length) break;
                      if (function(e4) {
                        if ("" !== d.radixPoint && 0 !== d.digits) {
                          var t4 = p.validPositions;
                          if (void 0 === t4[e4] || void 0 === t4[e4].input) {
                            if (e4 < u.call(f2, -1)) return true;
                            var n4 = l.call(f2).indexOf(d.radixPoint);
                            if (-1 !== n4) {
                              for (var i4 = 0, a3 = t4.length; i4 < a3; i4++) if (t4[i4] && n4 < i4 && t4[i4].input !== o.getPlaceholder.call(f2, i4)) return false;
                              return true;
                            }
                          }
                        }
                        return false;
                      }(e3.begin)) {
                        var h = l.call(f2).join("").indexOf(d.radixPoint);
                        e3.end = e3.begin = d.numericInput ? u.call(f2, h) : h;
                        break;
                      }
                    default:
                      if (i3 = e3.begin, a2 = s.call(f2, i3, true), i3 <= (r2 = u.call(f2, -1 !== a2 || c.call(f2, 0) ? a2 : -1))) e3.end = e3.begin = c.call(f2, i3, false, true) ? i3 : u.call(f2, i3);
                      else {
                        var v = p.validPositions[a2], m = o.getTestTemplate.call(f2, r2, v ? v.match.locator : void 0, v), g = o.getPlaceholder.call(f2, r2, m.match);
                        if ("" !== g && l.call(f2)[r2] !== g && true !== m.match.optionalQuantifier && true !== m.match.newBlockMarker || !c.call(f2, r2, d.keepStatic, true) && m.match.def === g) {
                          var y = u.call(f2, r2);
                          (i3 >= y || i3 === r2) && (r2 = y);
                        }
                        e3.end = e3.begin = r2;
                      }
                  }
                  return e3;
                }
              }, t2.getBuffer = l, t2.getBufferTemplate = function() {
                var e3 = this.maskset;
                void 0 === e3._buffer && (e3._buffer = o.getMaskTemplate.call(this, false, 1), void 0 === e3.buffer && (e3.buffer = e3._buffer.slice()));
                return e3._buffer;
              }, t2.getLastValidPosition = s, t2.isMask = c, t2.resetMaskSet = function(e3) {
                var t3 = this.maskset;
                t3.buffer = void 0, true !== e3 && (t3.validPositions = [], t3.p = 0);
                false === e3 && (t3.tests = {}, t3.jitOffset = {});
              }, t2.seekNext = u, t2.seekPrevious = function(e3, t3) {
                var n3 = this, i3 = e3 - 1;
                if (e3 <= 0) return 0;
                for (; i3 > 0 && (true === t3 && (true !== o.getTest.call(n3, i3).match.newBlockMarker || !c.call(n3, i3, void 0, true)) || true !== t3 && !c.call(n3, i3, void 0, true)); ) i3--;
                return i3;
              }, t2.translatePosition = f;
              var i2, a = (i2 = n2(9380)) && i2.__esModule ? i2 : {
                default: i2
              }, r = n2(7215), o = n2(4713);
              function l(e3) {
                var t3 = this, n3 = t3.maskset;
                return void 0 !== n3.buffer && true !== e3 || (n3.buffer = o.getMaskTemplate.call(t3, true, s.call(t3), true), void 0 === n3._buffer && (n3._buffer = n3.buffer.slice())), n3.buffer;
              }
              function s(e3, t3, n3) {
                var i3 = this.maskset, a2 = -1, r2 = -1, o2 = n3 || i3.validPositions;
                void 0 === e3 && (e3 = -1);
                for (var l2 = 0, s2 = o2.length; l2 < s2; l2++) o2[l2] && (t3 || true !== o2[l2].generatedInput) && (l2 <= e3 && (a2 = l2), l2 >= e3 && (r2 = l2));
                return -1 === a2 || a2 === e3 ? r2 : -1 === r2 || e3 - a2 < r2 - e3 ? a2 : r2;
              }
              function c(e3, t3, n3) {
                var i3 = this, a2 = this.maskset, r2 = o.getTestTemplate.call(i3, e3).match;
                if ("" === r2.def && (r2 = o.getTest.call(i3, e3).match), true !== r2.static) return r2.fn;
                if (true === n3 && void 0 !== a2.validPositions[e3] && true !== a2.validPositions[e3].generatedInput) return true;
                if (true !== t3 && e3 > -1) {
                  if (n3) {
                    var l2 = o.getTests.call(i3, e3);
                    return l2.length > 1 + ("" === l2[l2.length - 1].match.def ? 1 : 0);
                  }
                  var s2 = o.determineTestTemplate.call(i3, e3, o.getTests.call(i3, e3)), c2 = o.getPlaceholder.call(i3, e3, s2.match);
                  return s2.match.def !== c2;
                }
                return false;
              }
              function u(e3, t3, n3) {
                var i3 = this;
                void 0 === n3 && (n3 = true);
                for (var a2 = e3 + 1; "" !== o.getTest.call(i3, a2).match.def && (true === t3 && (true !== o.getTest.call(i3, a2).match.newBlockMarker || !c.call(i3, a2, void 0, true)) || true !== t3 && !c.call(i3, a2, void 0, n3)); ) a2++;
                return a2;
              }
              function f(e3) {
                var t3 = this.opts, n3 = this.el;
                return !this.isRTL || "number" != typeof e3 || t3.greedy && "" === t3.placeholder || !n3 || (e3 = this._valueGet().length - e3) < 0 && (e3 = 0), e3;
              }
            },
            4713: function(e2, t2, n2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.determineTestTemplate = f, t2.getDecisionTaker = s, t2.getMaskTemplate = function(e3, t3, n3, i3, a2) {
                var r2 = this, o2 = this.opts, l2 = this.maskset, s2 = o2.greedy;
                a2 && o2.greedy && (o2.greedy = false, r2.maskset.tests = {});
                t3 = t3 || 0;
                var p2, d2, v, m, g = [], y = 0;
                do {
                  if (true === e3 && l2.validPositions[y]) d2 = (v = a2 && l2.validPositions[y].match.optionality && void 0 === l2.validPositions[y + 1] && (true === l2.validPositions[y].generatedInput || l2.validPositions[y].input == o2.skipOptionalPartCharacter && y > 0) ? f.call(r2, y, h.call(r2, y, p2, y - 1)) : l2.validPositions[y]).match, p2 = v.locator.slice(), g.push(true === n3 ? v.input : false === n3 ? d2.nativeDef : c.call(r2, y, d2));
                  else {
                    d2 = (v = u.call(r2, y, p2, y - 1)).match, p2 = v.locator.slice();
                    var k = true !== i3 && (false !== o2.jitMasking ? o2.jitMasking : d2.jit);
                    (m = (m || l2.validPositions[y - 1]) && d2.static && d2.def !== o2.groupSeparator && null === d2.fn) || false === k || void 0 === k || "number" == typeof k && isFinite(k) && k > y ? g.push(false === n3 ? d2.nativeDef : c.call(r2, g.length, d2)) : m = false;
                  }
                  y++;
                } while (true !== d2.static || "" !== d2.def || t3 > y);
                "" === g[g.length - 1] && g.pop();
                false === n3 && void 0 !== l2.maskLength || (l2.maskLength = y - 1);
                return o2.greedy = s2, g;
              }, t2.getPlaceholder = c, t2.getTest = p, t2.getTestTemplate = u, t2.getTests = h, t2.isSubsetOf = d;
              var i2, a = (i2 = n2(2394)) && i2.__esModule ? i2 : {
                default: i2
              }, r = n2(8711);
              function o(e3) {
                return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
                  return typeof e4;
                } : function(e4) {
                  return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
                }, o(e3);
              }
              function l(e3, t3) {
                var n3 = (null != e3.alternation ? e3.mloc[s(e3)] : e3.locator).join("");
                if ("" !== n3) for (n3 = n3.split(":")[0]; n3.length < t3; ) n3 += "0";
                return n3;
              }
              function s(e3) {
                var t3 = e3.locator[e3.alternation];
                return "string" == typeof t3 && t3.length > 0 && (t3 = t3.split(",")[0]), void 0 !== t3 ? t3.toString() : "";
              }
              function c(e3, t3, n3) {
                var i3 = this, a2 = this.opts, l2 = this.maskset;
                if (void 0 !== (t3 = t3 || p.call(i3, e3).match).placeholder || true === n3) {
                  if ("" !== t3.placeholder && true === t3.static && true !== t3.generated) {
                    var s2 = r.getLastValidPosition.call(i3, e3), c2 = r.seekNext.call(i3, s2);
                    return (n3 ? e3 <= c2 : e3 < c2) ? a2.staticDefinitionSymbol && t3.static ? t3.nativeDef : t3.def : "function" == typeof t3.placeholder ? t3.placeholder(a2) : t3.placeholder;
                  }
                  return "function" == typeof t3.placeholder ? t3.placeholder(a2) : t3.placeholder;
                }
                if (true === t3.static) {
                  if (e3 > -1 && void 0 === l2.validPositions[e3]) {
                    var u2, f2 = h.call(i3, e3), d2 = [];
                    if ("string" == typeof a2.placeholder && f2.length > 1 + ("" === f2[f2.length - 1].match.def ? 1 : 0)) {
                      for (var v = 0; v < f2.length; v++) if ("" !== f2[v].match.def && true !== f2[v].match.optionality && true !== f2[v].match.optionalQuantifier && (true === f2[v].match.static || void 0 === u2 || false !== f2[v].match.fn.test(u2.match.def, l2, e3, true, a2)) && (d2.push(f2[v]), true === f2[v].match.static && (u2 = f2[v]), d2.length > 1 && /[0-9a-bA-Z]/.test(d2[0].match.def))) return a2.placeholder.charAt(e3 % a2.placeholder.length);
                    }
                  }
                  return t3.def;
                }
                return "object" === o(a2.placeholder) ? t3.def : a2.placeholder.charAt(e3 % a2.placeholder.length);
              }
              function u(e3, t3, n3) {
                return this.maskset.validPositions[e3] || f.call(this, e3, h.call(this, e3, t3 ? t3.slice() : t3, n3));
              }
              function f(e3, t3) {
                var n3 = this.opts, i3 = 0, a2 = function(e4, t4) {
                  var n4 = 0, i4 = false;
                  t4.forEach(function(e5) {
                    e5.match.optionality && (0 !== n4 && n4 !== e5.match.optionality && (i4 = true), (0 === n4 || n4 > e5.match.optionality) && (n4 = e5.match.optionality));
                  }), n4 && (0 == e4 || 1 == t4.length ? n4 = 0 : i4 || (n4 = 0));
                  return n4;
                }(e3, t3);
                e3 = e3 > 0 ? e3 - 1 : 0;
                var r2, o2, s2, c2 = l(p.call(this, e3));
                n3.greedy && t3.length > 1 && "" === t3[t3.length - 1].match.def && (i3 = 1);
                for (var u2 = 0; u2 < t3.length - i3; u2++) {
                  var f2 = t3[u2];
                  r2 = l(f2, c2.length);
                  var d2 = Math.abs(r2 - c2);
                  (true !== f2.unMatchedAlternationStopped || t3.filter(function(e4) {
                    return true !== e4.unMatchedAlternationStopped;
                  }).length <= 1) && (void 0 === o2 || "" !== r2 && d2 < o2 || s2 && !n3.greedy && s2.match.optionality && s2.match.optionality - a2 > 0 && "master" === s2.match.newBlockMarker && (!f2.match.optionality || f2.match.optionality - a2 < 1 || !f2.match.newBlockMarker) || s2 && !n3.greedy && s2.match.optionalQuantifier && !f2.match.optionalQuantifier) && (o2 = d2, s2 = f2);
                }
                return s2;
              }
              function p(e3, t3) {
                var n3 = this.maskset;
                return n3.validPositions[e3] ? n3.validPositions[e3] : (t3 || h.call(this, e3))[0];
              }
              function d(e3, t3, n3) {
                function i3(e4) {
                  for (var t4, n4 = [], i4 = -1, a2 = 0, r2 = e4.length; a2 < r2; a2++) if ("-" === e4.charAt(a2)) for (t4 = e4.charCodeAt(a2 + 1); ++i4 < t4; ) n4.push(String.fromCharCode(i4));
                  else i4 = e4.charCodeAt(a2), n4.push(e4.charAt(a2));
                  return n4.join("");
                }
                return e3.match.def === t3.match.nativeDef || !(!(n3.regex || e3.match.fn instanceof RegExp && t3.match.fn instanceof RegExp) || true === e3.match.static || true === t3.match.static) && ("." === t3.match.fn.source || -1 !== i3(t3.match.fn.source.replace(/[[\]/]/g, "")).indexOf(i3(e3.match.fn.source.replace(/[[\]/]/g, ""))));
              }
              function h(e3, t3, n3) {
                var i3, r2, o2 = this, l2 = this.dependencyLib, s2 = this.maskset, c2 = this.opts, u2 = this.el, p2 = s2.maskToken, h2 = t3 ? n3 : 0, v = t3 ? t3.slice() : [0], m = [], g = false, y = t3 ? t3.join("") : "", k = false;
                function b(t4, n4, r3, l3) {
                  function f2(r4, l4, p4) {
                    function v3(e4, t5) {
                      var n5 = 0 === t5.matches.indexOf(e4);
                      return n5 || t5.matches.every(function(i4, a2) {
                        return true === i4.isQuantifier ? n5 = v3(e4, t5.matches[a2 - 1]) : Object.prototype.hasOwnProperty.call(i4, "matches") && (n5 = v3(e4, i4)), !n5;
                      }), n5;
                    }
                    function w2(e4, t5, n5) {
                      var i4, a2;
                      if ((s2.tests[e4] || s2.validPositions[e4]) && (s2.validPositions[e4] ? [s2.validPositions[e4]] : s2.tests[e4]).every(function(e5, r6) {
                        if (e5.mloc[t5]) return i4 = e5, false;
                        var o4 = void 0 !== n5 ? n5 : e5.alternation, l5 = void 0 !== e5.locator[o4] ? e5.locator[o4].toString().indexOf(t5) : -1;
                        return (void 0 === a2 || l5 < a2) && -1 !== l5 && (i4 = e5, a2 = l5), true;
                      }), i4) {
                        var r5 = i4.locator[i4.alternation], o3 = i4.mloc[t5] || i4.mloc[r5] || i4.locator;
                        if (-1 !== o3[o3.length - 1].toString().indexOf(":")) o3.pop();
                        return o3.slice((void 0 !== n5 ? n5 : i4.alternation) + 1);
                      }
                      return void 0 !== n5 ? w2(e4, t5) : void 0;
                    }
                    function P2(t5, n5) {
                      return true === t5.match.static && true !== n5.match.static && n5.match.fn.test(t5.match.def, s2, e3, false, c2, false);
                    }
                    function S2(e4, t5) {
                      var n5 = e4.alternation, i4 = void 0 === t5 || n5 <= t5.alternation && -1 === e4.locator[n5].toString().indexOf(t5.locator[n5]);
                      if (!i4 && n5 > t5.alternation) {
                        for (var a2 = 0; a2 < n5; a2++) if (e4.locator[a2] !== t5.locator[a2]) {
                          n5 = a2, i4 = true;
                          break;
                        }
                      }
                      return !!i4 && function(n6) {
                        e4.mloc = e4.mloc || {};
                        var i5 = e4.locator[n6];
                        if (void 0 !== i5) {
                          if ("string" == typeof i5 && (i5 = i5.split(",")[0]), void 0 === e4.mloc[i5] && (e4.mloc[i5] = e4.locator.slice(), e4.mloc[i5].push(":".concat(e4.alternation))), void 0 !== t5) {
                            for (var a3 in t5.mloc) "string" == typeof a3 && (a3 = parseInt(a3.split(",")[0])), e4.mloc[a3 + 0] = t5.mloc[a3];
                            e4.locator[n6] = Object.keys(e4.mloc).join(",");
                          }
                          return e4.alternation > n6 && (e4.alternation = n6), true;
                        }
                        return e4.alternation = void 0, false;
                      }(n5);
                    }
                    function O(e4, t5) {
                      if (e4.locator.length !== t5.locator.length) return false;
                      for (var n5 = e4.alternation + 1; n5 < e4.locator.length; n5++) if (e4.locator[n5] !== t5.locator[n5]) return false;
                      return true;
                    }
                    if (h2 > e3 + c2._maxTestPos) throw new Error("Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. ".concat(s2.mask));
                    if (h2 === e3 && void 0 === r4.matches) {
                      if (m.push({
                        match: r4,
                        locator: l4.reverse(),
                        cd: y,
                        mloc: {}
                      }), !r4.optionality || void 0 !== p4 || !(c2.definitions && c2.definitions[r4.nativeDef] && c2.definitions[r4.nativeDef].optional || a.default.prototype.definitions[r4.nativeDef] && a.default.prototype.definitions[r4.nativeDef].optional)) return true;
                      g = true, h2 = e3;
                    } else if (void 0 !== r4.matches) {
                      if (r4.isGroup && p4 !== r4) return function() {
                        if (r4 = f2(t4.matches[t4.matches.indexOf(r4) + 1], l4, p4)) return true;
                      }();
                      if (r4.isOptional) return function() {
                        var t5 = r4, a2 = m.length;
                        if (r4 = b(r4, n4, l4, p4), m.length > 0) {
                          if (m.forEach(function(e4, t6) {
                            t6 >= a2 && (e4.match.optionality = e4.match.optionality ? e4.match.optionality + 1 : 1);
                          }), i3 = m[m.length - 1].match, void 0 !== p4 || !v3(i3, t5)) return r4;
                          g = true, h2 = e3;
                        }
                      }();
                      if (r4.isAlternator) return function() {
                        function i4(e4) {
                          for (var t5, n5 = e4.matches[0].matches ? e4.matches[0].matches.length : 1, i5 = 0; i5 < e4.matches.length && n5 === (t5 = e4.matches[i5].matches ? e4.matches[i5].matches.length : 1); i5++) ;
                          return n5 !== t5;
                        }
                        o2.hasAlternator = true;
                        var a2, v4 = r4, y2 = [], b2 = m.slice(), x2 = l4.length, _2 = n4.length > 0 ? n4.shift() : -1;
                        if (-1 === _2 || "string" == typeof _2) {
                          var M, E = h2, j = n4.slice(), T = [];
                          if ("string" == typeof _2) T = _2.split(",");
                          else for (M = 0; M < v4.matches.length; M++) T.push(M.toString());
                          if (void 0 !== s2.excludes[e3]) {
                            for (var A = T.slice(), D = 0, L = s2.excludes[e3].length; D < L; D++) {
                              var C = s2.excludes[e3][D].toString().split(":");
                              l4.length == C[1] && T.splice(T.indexOf(C[0]), 1);
                            }
                            0 === T.length && (delete s2.excludes[e3], T = A);
                          }
                          (true === c2.keepStatic || isFinite(parseInt(c2.keepStatic)) && E >= c2.keepStatic) && (T = T.slice(0, 1));
                          for (var B = 0; B < T.length; B++) {
                            M = parseInt(T[B]), m = [], n4 = "string" == typeof _2 && w2(h2, M, x2) || j.slice();
                            var I = v4.matches[M];
                            if (I && f2(I, [M].concat(l4), p4)) r4 = true;
                            else if (0 === B && (k = i4(v4)), I && I.matches && I.matches.length > v4.matches[0].matches.length) break;
                            a2 = m.slice(), h2 = E, m = [];
                            for (var R = 0; R < a2.length; R++) {
                              var F = a2[R], N = false;
                              F.alternation = F.alternation || x2, S2(F);
                              for (var V = 0; V < y2.length; V++) {
                                var G = y2[V];
                                if ("string" != typeof _2 || void 0 !== F.alternation && T.includes(F.locator[F.alternation].toString())) {
                                  if (F.match.nativeDef === G.match.nativeDef) {
                                    N = true, S2(G, F);
                                    break;
                                  }
                                  if (d(F, G, c2)) {
                                    S2(F, G) && (N = true, y2.splice(y2.indexOf(G), 0, F));
                                    break;
                                  }
                                  if (d(G, F, c2)) {
                                    S2(G, F);
                                    break;
                                  }
                                  if (P2(F, G)) {
                                    O(F, G) || void 0 !== u2.inputmask.userOptions.keepStatic ? S2(F, G) && (N = true, y2.splice(y2.indexOf(G), 0, F)) : c2.keepStatic = true;
                                    break;
                                  }
                                  if (P2(G, F)) {
                                    S2(G, F);
                                    break;
                                  }
                                }
                              }
                              N || y2.push(F);
                            }
                          }
                          m = b2.concat(y2), h2 = e3, g = m.length > 0 && k, r4 = y2.length > 0 && !k, k && g && !r4 && m.forEach(function(e4, t5) {
                            e4.unMatchedAlternationStopped = true;
                          }), n4 = j.slice();
                        } else r4 = f2(v4.matches[_2] || t4.matches[_2], [_2].concat(l4), p4);
                        if (r4) return true;
                      }();
                      if (r4.isQuantifier && p4 !== t4.matches[t4.matches.indexOf(r4) - 1]) return function() {
                        for (var a2 = r4, o3 = false, u3 = n4.length > 0 ? n4.shift() : 0; u3 < (isNaN(a2.quantifier.max) ? u3 + 1 : a2.quantifier.max) && h2 <= e3; u3++) {
                          var p5 = t4.matches[t4.matches.indexOf(a2) - 1];
                          if (r4 = f2(p5, [u3].concat(l4), p5)) {
                            if (m.forEach(function(t5, n5) {
                              (i3 = x(p5, t5.match) ? t5.match : m[m.length - 1].match).optionalQuantifier = u3 >= a2.quantifier.min, i3.jit = (u3 + 1) * (p5.matches.indexOf(i3) + 1) > a2.quantifier.jit, i3.optionalQuantifier && v3(i3, p5) && (g = true, h2 = e3, c2.greedy && null == s2.validPositions[e3 - 1] && u3 > a2.quantifier.min && -1 != ["*", "+"].indexOf(a2.quantifier.max) && (m.pop(), y = void 0), o3 = true, r4 = false), !o3 && i3.jit && (s2.jitOffset[e3] = p5.matches.length - p5.matches.indexOf(i3));
                            }), o3) break;
                            return true;
                          }
                        }
                      }();
                      if (r4 = b(r4, n4, l4, p4)) return true;
                    } else h2++;
                  }
                  for (var p3 = n4.length > 0 ? n4.shift() : 0; p3 < t4.matches.length; p3++) if (true !== t4.matches[p3].isQuantifier) {
                    var v2 = f2(t4.matches[p3], [p3].concat(r3), l3);
                    if (v2 && h2 === e3) return v2;
                    if (h2 > e3) break;
                  }
                }
                function x(e4, t4) {
                  var n4 = -1 != e4.matches.indexOf(t4);
                  return n4 || e4.matches.forEach(function(e5, i4) {
                    void 0 === e5.matches || n4 || (n4 = x(e5, t4));
                  }), n4;
                }
                if (e3 > -1) {
                  if (void 0 === t3) {
                    for (var w, P = e3 - 1; void 0 === (w = s2.validPositions[P] || s2.tests[P]) && P > -1; ) P--;
                    void 0 !== w && P > -1 && (v = function(e4, t4) {
                      var n4, i4 = [];
                      return Array.isArray(t4) || (t4 = [t4]), t4.length > 0 && (void 0 === t4[0].alternation || true === c2.keepStatic ? 0 === (i4 = f.call(o2, e4, t4.slice()).locator.slice()).length && (i4 = t4[0].locator.slice()) : t4.forEach(function(e5) {
                        "" !== e5.def && (0 === i4.length ? (n4 = e5.alternation, i4 = e5.locator.slice()) : e5.locator[n4] && -1 === i4[n4].toString().indexOf(e5.locator[n4]) && (i4[n4] += "," + e5.locator[n4]));
                      })), i4;
                    }(P, w), y = v.join(""), h2 = P);
                  }
                  if (s2.tests[e3] && s2.tests[e3][0].cd === y) return s2.tests[e3];
                  for (var S = v.shift(); S < p2.length; S++) {
                    if (b(p2[S], v, [S]) && h2 === e3 || h2 > e3) break;
                  }
                }
                return (0 === m.length || g) && m.push({
                  match: {
                    fn: null,
                    static: true,
                    optionality: false,
                    casing: null,
                    def: "",
                    placeholder: ""
                  },
                  locator: k && 0 === m.filter(function(e4) {
                    return true !== e4.unMatchedAlternationStopped;
                  }).length ? [0] : [],
                  mloc: {},
                  cd: y
                }), void 0 !== t3 && s2.tests[e3] ? r2 = l2.extend(true, [], m) : (s2.tests[e3] = l2.extend(true, [], m), r2 = s2.tests[e3]), m.forEach(function(e4) {
                  e4.match.optionality = e4.match.defOptionality || false;
                }), r2;
              }
            },
            7215: function(e2, t2, n2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.alternate = l, t2.checkAlternationMatch = function(e3, t3, n3) {
                for (var i3, a2 = this.opts.greedy ? t3 : t3.slice(0, 1), r2 = false, o2 = void 0 !== n3 ? n3.split(",") : [], l2 = 0; l2 < o2.length; l2++) -1 !== (i3 = e3.indexOf(o2[l2])) && e3.splice(i3, 1);
                for (var s2 = 0; s2 < e3.length; s2++) if (a2.includes(e3[s2])) {
                  r2 = true;
                  break;
                }
                return r2;
              }, t2.handleRemove = function(e3, t3, n3, i3, s2) {
                var c2 = this, u2 = this.maskset, f2 = this.opts;
                if ((f2.numericInput || c2.isRTL) && (t3 === a.keys.Backspace ? t3 = a.keys.Delete : t3 === a.keys.Delete && (t3 = a.keys.Backspace), c2.isRTL)) {
                  var p2 = n3.end;
                  n3.end = n3.begin, n3.begin = p2;
                }
                var d2, h2 = r.getLastValidPosition.call(c2, void 0, true);
                n3.end >= r.getBuffer.call(c2).length && h2 >= n3.end && (n3.end = h2 + 1);
                t3 === a.keys.Backspace ? n3.end - n3.begin < 1 && (n3.begin = r.seekPrevious.call(c2, n3.begin)) : t3 === a.keys.Delete && n3.begin === n3.end && (n3.end = r.isMask.call(c2, n3.end, true, true) ? n3.end + 1 : r.seekNext.call(c2, n3.end) + 1);
                false !== (d2 = v.call(c2, n3)) && ((true !== i3 && false !== f2.keepStatic || null !== f2.regex && -1 !== o.getTest.call(c2, n3.begin).match.def.indexOf("|")) && l.call(c2, true), true !== i3 && (u2.p = t3 === a.keys.Delete ? n3.begin + d2 : n3.begin, u2.p = r.determineNewCaretPosition.call(c2, {
                  begin: u2.p,
                  end: u2.p
                }, false, false === f2.insertMode && t3 === a.keys.Backspace ? "none" : void 0).begin));
              }, t2.isComplete = c, t2.isSelection = u, t2.isValid = f, t2.refreshFromBuffer = d, t2.revalidateMask = v;
              var i2 = n2(6030), a = n2(2839), r = n2(8711), o = n2(4713);
              function l(e3, t3, n3, i3, a2, s2) {
                var c2 = this, u2 = this.dependencyLib, p2 = this.opts, d2 = c2.maskset;
                if (!c2.hasAlternator) return false;
                var h2, v2, m, g, y, k, b, x, w, P, S, O = u2.extend(true, [], d2.validPositions), _2 = u2.extend(true, {}, d2.tests), M = false, E = false, j = void 0 !== a2 ? a2 : r.getLastValidPosition.call(c2);
                if (s2 && (P = s2.begin, S = s2.end, s2.begin > s2.end && (P = s2.end, S = s2.begin)), -1 === j && void 0 === a2) h2 = 0, v2 = (g = o.getTest.call(c2, h2)).alternation;
                else for (; j >= 0; j--) if ((m = d2.validPositions[j]) && void 0 !== m.alternation) {
                  if (j <= (e3 || 0) && g && g.locator[m.alternation] !== m.locator[m.alternation]) break;
                  h2 = j, v2 = d2.validPositions[h2].alternation, g = m;
                }
                if (void 0 !== v2) {
                  b = parseInt(h2), d2.excludes[b] = d2.excludes[b] || [], true !== e3 && d2.excludes[b].push((0, o.getDecisionTaker)(g) + ":" + g.alternation);
                  var T = [], A = -1;
                  for (y = b; b < r.getLastValidPosition.call(c2, void 0, true) + 1; y++) -1 === A && e3 <= y && void 0 !== t3 && (T.push(t3), A = T.length - 1), (k = d2.validPositions[b]) && true !== k.generatedInput && (void 0 === s2 || y < P || y >= S) && T.push(k.input), d2.validPositions.splice(b, 1);
                  for (-1 === A && void 0 !== t3 && (T.push(t3), A = T.length - 1); void 0 !== d2.excludes[b] && d2.excludes[b].length < 10; ) {
                    for (d2.tests = {}, r.resetMaskSet.call(c2, true), M = true, y = 0; y < T.length && (x = M.caret || 0 == p2.insertMode && null != x ? r.seekNext.call(c2, x) : r.getLastValidPosition.call(c2, void 0, true) + 1, w = T[y], M = f.call(c2, x, w, false, i3, true)); y++) y === A && (E = M), 1 == e3 && M && (E = {
                      caretPos: y
                    });
                    if (M) break;
                    if (r.resetMaskSet.call(c2), g = o.getTest.call(c2, b), d2.validPositions = u2.extend(true, [], O), d2.tests = u2.extend(true, {}, _2), !d2.excludes[b]) {
                      E = l.call(c2, e3, t3, n3, i3, b - 1, s2);
                      break;
                    }
                    if (null != g.alternation) {
                      var D = (0, o.getDecisionTaker)(g);
                      if (-1 !== d2.excludes[b].indexOf(D + ":" + g.alternation)) {
                        E = l.call(c2, e3, t3, n3, i3, b - 1, s2);
                        break;
                      }
                      for (d2.excludes[b].push(D + ":" + g.alternation), y = b; y < r.getLastValidPosition.call(c2, void 0, true) + 1; y++) d2.validPositions.splice(b);
                    } else delete d2.excludes[b];
                  }
                }
                return E && false === p2.keepStatic || delete d2.excludes[b], E;
              }
              function s(e3, t3, n3) {
                var i3 = this.opts, r2 = this.maskset;
                switch (i3.casing || t3.casing) {
                  case "upper":
                    e3 = e3.toUpperCase();
                    break;
                  case "lower":
                    e3 = e3.toLowerCase();
                    break;
                  case "title":
                    var o2 = r2.validPositions[n3 - 1];
                    e3 = 0 === n3 || o2 && o2.input === String.fromCharCode(a.keyCode.Space) ? e3.toUpperCase() : e3.toLowerCase();
                    break;
                  default:
                    if ("function" == typeof i3.casing) {
                      var l2 = Array.prototype.slice.call(arguments);
                      l2.push(r2.validPositions), e3 = i3.casing.apply(this, l2);
                    }
                }
                return e3;
              }
              function c(e3) {
                var t3 = this, n3 = this.opts, i3 = this.maskset;
                if ("function" == typeof n3.isComplete) return n3.isComplete(e3, n3);
                if ("*" !== n3.repeat) {
                  var a2 = false, l2 = r.determineLastRequiredPosition.call(t3, true), s2 = l2.l;
                  if (void 0 === l2.def || l2.def.newBlockMarker || l2.def.optionality || l2.def.optionalQuantifier) {
                    a2 = true;
                    for (var c2 = 0; c2 <= s2; c2++) {
                      var u2 = o.getTestTemplate.call(t3, c2).match;
                      if (true !== u2.static && void 0 === i3.validPositions[c2] && (false === u2.optionality || void 0 === u2.optionality || u2.optionality && 0 == u2.newBlockMarker) && (false === u2.optionalQuantifier || void 0 === u2.optionalQuantifier) || true === u2.static && "" != u2.def && e3[c2] !== o.getPlaceholder.call(t3, c2, u2)) {
                        a2 = false;
                        break;
                      }
                    }
                  }
                  return a2;
                }
              }
              function u(e3) {
                var t3 = this.opts.insertMode ? 0 : 1;
                return this.isRTL ? e3.begin - e3.end > t3 : e3.end - e3.begin > t3;
              }
              function f(e3, t3, n3, i3, a2, p2, m) {
                var g = this, y = this.dependencyLib, k = this.opts, b = g.maskset;
                n3 = true === n3;
                var x = e3;
                function w(e4) {
                  if (void 0 !== e4) {
                    if (void 0 !== e4.remove && (Array.isArray(e4.remove) || (e4.remove = [e4.remove]), e4.remove.sort(function(e5, t5) {
                      return g.isRTL ? e5.pos - t5.pos : t5.pos - e5.pos;
                    }).forEach(function(e5) {
                      v.call(g, {
                        begin: e5,
                        end: e5 + 1
                      });
                    }), e4.remove = void 0), void 0 !== e4.insert && (Array.isArray(e4.insert) || (e4.insert = [e4.insert]), e4.insert.sort(function(e5, t5) {
                      return g.isRTL ? t5.pos - e5.pos : e5.pos - t5.pos;
                    }).forEach(function(e5) {
                      "" !== e5.c && f.call(g, e5.pos, e5.c, void 0 === e5.strict || e5.strict, void 0 !== e5.fromIsValid ? e5.fromIsValid : i3);
                    }), e4.insert = void 0), e4.refreshFromBuffer && e4.buffer) {
                      var t4 = e4.refreshFromBuffer;
                      d.call(g, true === t4 ? t4 : t4.start, t4.end, e4.buffer), e4.refreshFromBuffer = void 0;
                    }
                    void 0 !== e4.rewritePosition && (x = e4.rewritePosition, e4 = true);
                  }
                  return e4;
                }
                function P(t4, n4, a3) {
                  var l2 = false;
                  return o.getTests.call(g, t4).every(function(c2, f2) {
                    var p3 = c2.match;
                    if (r.getBuffer.call(g, true), false !== (l2 = (!p3.jit || void 0 !== b.validPositions[r.seekPrevious.call(g, t4)]) && (null != p3.fn ? p3.fn.test(n4, b, t4, a3, k, u.call(g, e3)) : (n4 === p3.def || n4 === k.skipOptionalPartCharacter) && "" !== p3.def && {
                      c: o.getPlaceholder.call(g, t4, p3, true) || p3.def,
                      pos: t4
                    }))) {
                      var d2 = void 0 !== l2.c ? l2.c : n4, h2 = t4;
                      return d2 = d2 === k.skipOptionalPartCharacter && true === p3.static ? o.getPlaceholder.call(g, t4, p3, true) || p3.def : d2, true !== (l2 = w(l2)) && void 0 !== l2.pos && l2.pos !== t4 && (h2 = l2.pos), true !== l2 && void 0 === l2.pos && void 0 === l2.c ? false : (false === v.call(g, e3, y.extend({}, c2, {
                        input: s.call(g, d2, p3, h2)
                      }), i3, h2) && (l2 = false), false);
                    }
                    return true;
                  }), l2;
                }
                void 0 !== e3.begin && (x = g.isRTL ? e3.end : e3.begin);
                var S = true, O = y.extend(true, [], b.validPositions);
                if (false === k.keepStatic && void 0 !== b.excludes[x] && true !== a2 && true !== i3) for (var _2 = x; _2 < (g.isRTL ? e3.begin : e3.end); _2++) void 0 !== b.excludes[_2] && (b.excludes[_2] = void 0, delete b.tests[_2]);
                if ("function" == typeof k.preValidation && true !== i3 && true !== p2 && (S = w(S = k.preValidation.call(g, r.getBuffer.call(g), x, t3, u.call(g, e3), k, b, e3, n3 || a2))), true === S) {
                  if (S = P(x, t3, n3), (!n3 || true === i3) && false === S && true !== p2) {
                    var M = b.validPositions[x];
                    if (!M || true !== M.match.static || M.match.def !== t3 && t3 !== k.skipOptionalPartCharacter) {
                      if (k.insertMode || void 0 === b.validPositions[r.seekNext.call(g, x)] || e3.end > x) {
                        var E = false;
                        if (b.jitOffset[x] && void 0 === b.validPositions[r.seekNext.call(g, x)] && false !== (S = f.call(g, x + b.jitOffset[x], t3, true, true)) && (true !== a2 && (S.caret = x), E = true), e3.end > x && (b.validPositions[x] = void 0), !E && !r.isMask.call(g, x, k.keepStatic && 0 === x)) {
                          for (var j = x + 1, T = r.seekNext.call(g, x, false, 0 !== x); j <= T; j++) if (false !== (S = P(j, t3, n3))) {
                            S = h.call(g, x, void 0 !== S.pos ? S.pos : j) || S, x = j;
                            break;
                          }
                        }
                      }
                    } else S = {
                      caret: r.seekNext.call(g, x)
                    };
                  }
                  g.hasAlternator && true !== a2 && !n3 && (a2 = true, false === S && k.keepStatic && (c.call(g, r.getBuffer.call(g)) || 0 === x) ? S = l.call(g, x, t3, n3, i3, void 0, e3) : (u.call(g, e3) && b.tests[x] && b.tests[x].length > 1 && k.keepStatic || 1 == S && true !== k.numericInput && b.tests[x] && b.tests[x].length > 1 && r.getLastValidPosition.call(g, void 0, true) > x) && (S = l.call(g, true))), true === S && (S = {
                    pos: x
                  });
                }
                if ("function" == typeof k.postValidation && true !== i3 && true !== p2) {
                  var A = k.postValidation.call(g, r.getBuffer.call(g, true), void 0 !== e3.begin ? g.isRTL ? e3.end : e3.begin : e3, t3, S, k, b, n3, m);
                  void 0 !== A && (S = true === A ? S : A);
                }
                S && void 0 === S.pos && (S.pos = x), false === S || true === p2 ? (r.resetMaskSet.call(g, true), b.validPositions = y.extend(true, [], O)) : h.call(g, void 0, x, true);
                var D = w(S);
                void 0 !== g.maxLength && (r.getBuffer.call(g).length > g.maxLength && !i3 && (r.resetMaskSet.call(g, true), b.validPositions = y.extend(true, [], O), D = false));
                return D;
              }
              function p(e3, t3, n3) {
                for (var i3 = this.maskset, a2 = false, r2 = o.getTests.call(this, e3), l2 = 0; l2 < r2.length; l2++) {
                  if (r2[l2].match && (r2[l2].match.nativeDef === t3.match[n3.shiftPositions ? "def" : "nativeDef"] && (!n3.shiftPositions || !t3.match.static) || r2[l2].match.nativeDef === t3.match.nativeDef || n3.regex && !r2[l2].match.static && r2[l2].match.fn.test(t3.input, i3, e3, false, n3))) {
                    a2 = true;
                    break;
                  }
                  if (r2[l2].match && r2[l2].match.def === t3.match.nativeDef) {
                    a2 = void 0;
                    break;
                  }
                }
                return false === a2 && void 0 !== i3.jitOffset[e3] && (a2 = p.call(this, e3 + i3.jitOffset[e3], t3, n3)), a2;
              }
              function d(e3, t3, n3) {
                var a2, o2, l2 = this, s2 = this.maskset, c2 = this.opts, u2 = this.dependencyLib, f2 = c2.skipOptionalPartCharacter, p2 = l2.isRTL ? n3.slice().reverse() : n3;
                if (c2.skipOptionalPartCharacter = "", true === e3) r.resetMaskSet.call(l2, false), e3 = 0, t3 = n3.length, o2 = r.determineNewCaretPosition.call(l2, {
                  begin: 0,
                  end: 0
                }, false).begin;
                else {
                  for (a2 = e3; a2 < t3; a2++) s2.validPositions.splice(e3, 0);
                  o2 = e3;
                }
                var d2 = new u2.Event("keypress");
                for (a2 = e3; a2 < t3; a2++) {
                  d2.key = p2[a2].toString(), l2.ignorable = false;
                  var h2 = i2.EventHandlers.keypressEvent.call(l2, d2, true, false, false, o2);
                  false !== h2 && void 0 !== h2 && (o2 = h2.forwardPosition);
                }
                c2.skipOptionalPartCharacter = f2;
              }
              function h(e3, t3, n3) {
                var i3 = this, a2 = this.maskset, l2 = this.dependencyLib;
                if (void 0 === e3) for (e3 = t3 - 1; e3 > 0 && !a2.validPositions[e3]; e3--) ;
                for (var s2 = e3; s2 < t3; s2++) {
                  if (void 0 === a2.validPositions[s2] && !r.isMask.call(i3, s2, false)) {
                    if (0 == s2 ? o.getTest.call(i3, s2) : a2.validPositions[s2 - 1]) {
                      var c2 = o.getTests.call(i3, s2).slice();
                      "" === c2[c2.length - 1].match.def && c2.pop();
                      var u2, p2 = o.determineTestTemplate.call(i3, s2, c2);
                      if (p2 && (true !== p2.match.jit || "master" === p2.match.newBlockMarker && (u2 = a2.validPositions[s2 + 1]) && true === u2.match.optionalQuantifier) && ((p2 = l2.extend({}, p2, {
                        input: o.getPlaceholder.call(i3, s2, p2.match, true) || p2.match.def
                      })).generatedInput = true, v.call(i3, s2, p2, true), true !== n3)) {
                        var d2 = a2.validPositions[t3].input;
                        return a2.validPositions[t3] = void 0, f.call(i3, t3, d2, true, true);
                      }
                    }
                  }
                }
              }
              function v(e3, t3, n3, i3) {
                var a2 = this, l2 = this.maskset, s2 = this.opts, c2 = this.dependencyLib;
                function d2(e4, t4, n4) {
                  var i4 = t4[e4];
                  if (void 0 !== i4 && true === i4.match.static && true !== i4.match.optionality && (void 0 === t4[0] || void 0 === t4[0].alternation)) {
                    var a3 = n4.begin <= e4 - 1 ? t4[e4 - 1] && true === t4[e4 - 1].match.static && t4[e4 - 1] : t4[e4 - 1], r2 = n4.end > e4 + 1 ? t4[e4 + 1] && true === t4[e4 + 1].match.static && t4[e4 + 1] : t4[e4 + 1];
                    return a3 && r2;
                  }
                  return false;
                }
                var h2 = 0, v2 = void 0 !== e3.begin ? e3.begin : e3, m = void 0 !== e3.end ? e3.end : e3, g = true;
                if (e3.begin > e3.end && (v2 = e3.end, m = e3.begin), i3 = void 0 !== i3 ? i3 : v2, void 0 === n3 && (v2 !== m || s2.insertMode && void 0 !== l2.validPositions[i3] || void 0 === t3 || t3.match.optionalQuantifier || t3.match.optionality)) {
                  var y, k = c2.extend(true, [], l2.validPositions), b = r.getLastValidPosition.call(a2, void 0, true);
                  l2.p = v2;
                  var x = u.call(a2, e3) ? v2 : i3;
                  for (y = b; y >= x; y--) l2.validPositions.splice(y, 1), void 0 === t3 && delete l2.tests[y + 1];
                  var w, P, S = i3, O = S;
                  for (t3 && (l2.validPositions[i3] = c2.extend(true, {}, t3), O++, S++), null == k[m] && l2.jitOffset[m] && (m += l2.jitOffset[m] + 1), y = t3 ? m : m - 1; y <= b; y++) {
                    if (void 0 !== (w = k[y]) && true !== w.generatedInput && (y >= m || y >= v2 && d2(y, k, {
                      begin: v2,
                      end: m
                    }))) {
                      for (; "" !== o.getTest.call(a2, O).match.def; ) {
                        if (false !== (P = p.call(a2, O, w, s2)) || "+" === w.match.def) {
                          "+" === w.match.def && r.getBuffer.call(a2, true);
                          var _2 = f.call(a2, O, w.input, "+" !== w.match.def, true);
                          if (g = false !== _2, S = (_2.pos || O) + 1, !g && P) break;
                        } else g = false;
                        if (g) {
                          void 0 === t3 && w.match.static && y === e3.begin && h2++;
                          break;
                        }
                        if (!g && r.getBuffer.call(a2), O > l2.maskLength) break;
                        O++;
                      }
                      "" == o.getTest.call(a2, O).match.def && (g = false), O = S;
                    }
                    if (!g) break;
                  }
                  if (!g) return l2.validPositions = c2.extend(true, [], k), r.resetMaskSet.call(a2, true), false;
                } else t3 && o.getTest.call(a2, i3).match.cd === t3.match.cd && (l2.validPositions[i3] = c2.extend(true, {}, t3));
                return r.resetMaskSet.call(a2, true), h2;
              }
            }
          }, t = {};
          function n(i2) {
            var a = t[i2];
            if (void 0 !== a) return a.exports;
            var r = t[i2] = {
              exports: {}
            };
            return e[i2](r, r.exports, n), r.exports;
          }
          var i = {};
          return function() {
            var e2 = i;
            Object.defineProperty(e2, "__esModule", {
              value: true
            }), e2.default = void 0, n(7149), n(3194), n(9302), n(4013), n(3851), n(219), n(207), n(5296);
            var t2, a = (t2 = n(2394)) && t2.__esModule ? t2 : {
              default: t2
            };
            e2.default = a.default;
          }(), i;
        }();
      });
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/number.js
  var require_number = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/number.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toggleNegative = toggleNegative;
      exports.fixDecimal = fixDecimal;
      exports.between = between;
      exports.padDecimals = padDecimals2;
      exports.prettify = prettify;
      exports.getFormats = getFormats2;
      exports.getFormatsFromInput = getFormatsFromInput2;
      function toggleNegative(value, absolute) {
        const isNegative = (value.match(/\-/g) || []).length % 2;
        const negative = !absolute && isNegative ? "-" : "";
        value = value.replaceAll("-", "");
        value = value.replace(new RegExp("^0+", "g"), "");
        return negative + value;
      }
      function fixDecimal(value, decimal, decimals, cursor) {
        if (decimals < 0) {
          return value;
        }
        if (!decimals) {
          return value.replaceAll(decimal, "");
        }
        cursor = cursor || value.lastIndexOf(decimal);
        const allDecimals = new RegExp(`\\${decimal}`, "g");
        if ((value.match(allDecimals) || []).length > 1) {
          value = [
            value.substring(0, cursor).replaceAll(decimal, ""),
            value.substring(cursor + 1).replaceAll(decimal, "")
          ].join(decimal);
        }
        if ((value.split(decimal)[1] || "").length > decimals) {
          value = value.substring(0, value.length - 1);
        }
        return value;
      }
      function between(value, min, max) {
        if (min && !isNaN(min) && parseFloat(value) < min) {
          value = String(min);
        }
        if (max && !isNaN(max) && parseFloat(value) > max) {
          value = String(max);
        }
        return value;
      }
      function padDecimals2(value, decimal, decimals) {
        if (!decimals || !value.length) {
          return value;
        }
        if (value[value.length - 1] === decimal) {
          value = value.substring(0, value.length - 1);
        }
        const allDecimals = new RegExp(`\\${decimal}`, "g");
        if (!(value.match(allDecimals) || []).length && decimals > 0) {
          value += decimal + "0".repeat(decimals);
        }
        if (value[0] === decimal) {
          value = "0" + value;
        }
        if (value.indexOf(`-${decimal}`) === 0) {
          value = "-0." + value.substr(decimal.length + 1);
        }
        if (decimals > 0) {
          value += "0".repeat(decimals - value.split(decimal)[1].length);
        }
        return value;
      }
      function prettify(value, separator, decimal) {
        const placeCommas = new RegExp(`\\B(?<!\\${separator}\\d*)(?=(\\d{3})+(?!\\d))`, "g");
        if (separator) {
          if (value.indexOf(decimal) !== -1) {
            let [numerator, denominator] = value.split(decimal);
            numerator = numerator.replace(placeCommas, separator);
            value = [numerator, denominator].join(decimal);
          } else {
            value = value.replace(placeCommas, separator);
          }
        }
        return value;
      }
      function getFormats2(value, options2, cursor = 0) {
        const { min, max, separator = ",", decimal = ".", decimals = 0, absolute = false } = options2;
        const dec = decimal || ".";
        const notNumberRelated = new RegExp(`[^0-9-\\${dec}]`, "g");
        let formatted = value.replace(notNumberRelated, "");
        formatted = toggleNegative(formatted, absolute);
        formatted = fixDecimal(formatted, dec, decimals, cursor);
        formatted = between(formatted, min, max);
        return {
          value: padDecimals2(formatted, dec, decimals),
          display: prettify(formatted, separator, decimal)
        };
      }
      function getFormatsFromInput2(input, options2) {
        const cursor = input.selectionStart ? input.selectionStart - 1 : 0;
        return getFormats2(input.value, options2, cursor);
      }
    }
  });

  // ../../node_modules/@stackpress/ink-ui/utilities/slug.js
  var require_slug = __commonJS({
    "../../node_modules/@stackpress/ink-ui/utilities/slug.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.slugify = slugify2;
      exports.camelfy = camelfy2;
      function slugify2(str, noDash = false, noLine = false) {
        return str.trim().replace(/[^a-zA-Z0-9\-_]/g, noLine ? "-" : "_").replace(/-/g, noLine ? "-" : "_").replace(/_/g, noDash ? "_" : "-").replace(/-{2,}/g, "-").replace(/_{2,}/g, "_").replace(/^-+|-+$/g, "").replace(/^_+|_+$/g, "").toLowerCase();
      }
      function camelfy2(str) {
        return str.trim().replace(/[^a-zA-Z0-9]/g, "_").replace(/_{2,}/g, "_").replace(/^_+|_+$/g, "").replace(/([-_][a-z0-9])/ig, ($1) => {
          return $1.toUpperCase().replace("-", "").replace("_", "");
        });
      }
    }
  });

  // ../../node_modules/suneditor/src/lang/en.js
  var require_en = __commonJS({
    "../../node_modules/suneditor/src/lang/en.js"(exports, module) {
      "use strict";
      (function(global, factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
              throw new Error("SUNEDITOR_LANG a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        const lang = {
          code: "en",
          toolbar: {
            default: "Default",
            save: "Save",
            font: "Font",
            formats: "Formats",
            fontSize: "Size",
            bold: "Bold",
            underline: "Underline",
            italic: "Italic",
            strike: "Strike",
            subscript: "Subscript",
            superscript: "Superscript",
            removeFormat: "Remove Format",
            fontColor: "Font Color",
            hiliteColor: "Highlight Color",
            indent: "Indent",
            outdent: "Outdent",
            align: "Align",
            alignLeft: "Align left",
            alignRight: "Align right",
            alignCenter: "Align center",
            alignJustify: "Align justify",
            list: "List",
            orderList: "Ordered list",
            unorderList: "Unordered list",
            horizontalRule: "Horizontal line",
            hr_solid: "Solid",
            hr_dotted: "Dotted",
            hr_dashed: "Dashed",
            table: "Table",
            link: "Link",
            math: "Math",
            image: "Image",
            video: "Video",
            audio: "Audio",
            fullScreen: "Full screen",
            showBlocks: "Show blocks",
            codeView: "Code view",
            undo: "Undo",
            redo: "Redo",
            preview: "Preview",
            print: "print",
            tag_p: "Paragraph",
            tag_div: "Normal (DIV)",
            tag_h: "Header",
            tag_blockquote: "Quote",
            tag_pre: "Code",
            template: "Template",
            lineHeight: "Line height",
            paragraphStyle: "Paragraph style",
            textStyle: "Text style",
            imageGallery: "Image gallery",
            dir_ltr: "Left to right",
            dir_rtl: "Right to left",
            mention: "Mention"
          },
          dialogBox: {
            linkBox: {
              title: "Insert Link",
              url: "URL to link",
              text: "Text to display",
              newWindowCheck: "Open in new window",
              downloadLinkCheck: "Download link",
              bookmark: "Bookmark"
            },
            mathBox: {
              title: "Math",
              inputLabel: "Mathematical Notation",
              fontSizeLabel: "Font Size",
              previewLabel: "Preview"
            },
            imageBox: {
              title: "Insert image",
              file: "Select from files",
              url: "Image URL",
              altText: "Alternative text"
            },
            videoBox: {
              title: "Insert Video",
              file: "Select from files",
              url: "Media embed URL, YouTube/Vimeo"
            },
            audioBox: {
              title: "Insert Audio",
              file: "Select from files",
              url: "Audio URL"
            },
            browser: {
              tags: "Tags",
              search: "Search"
            },
            caption: "Insert description",
            close: "Close",
            submitButton: "Submit",
            revertButton: "Revert",
            proportion: "Constrain proportions",
            basic: "Basic",
            left: "Left",
            right: "Right",
            center: "Center",
            width: "Width",
            height: "Height",
            size: "Size",
            ratio: "Ratio"
          },
          controller: {
            edit: "Edit",
            unlink: "Unlink",
            remove: "Remove",
            insertRowAbove: "Insert row above",
            insertRowBelow: "Insert row below",
            deleteRow: "Delete row",
            insertColumnBefore: "Insert column before",
            insertColumnAfter: "Insert column after",
            deleteColumn: "Delete column",
            fixedColumnWidth: "Fixed column width",
            resize100: "Resize 100%",
            resize75: "Resize 75%",
            resize50: "Resize 50%",
            resize25: "Resize 25%",
            autoSize: "Auto size",
            mirrorHorizontal: "Mirror, Horizontal",
            mirrorVertical: "Mirror, Vertical",
            rotateLeft: "Rotate left",
            rotateRight: "Rotate right",
            maxSize: "Max size",
            minSize: "Min size",
            tableHeader: "Table header",
            mergeCells: "Merge cells",
            splitCells: "Split Cells",
            HorizontalSplit: "Horizontal split",
            VerticalSplit: "Vertical split"
          },
          menu: {
            spaced: "Spaced",
            bordered: "Bordered",
            neon: "Neon",
            translucent: "Translucent",
            shadow: "Shadow",
            code: "Code"
          }
        };
        if (typeof noGlobal === "undefined") {
          if (!window2.SUNEDITOR_LANG) {
            Object.defineProperty(window2, "SUNEDITOR_LANG", {
              enumerable: true,
              writable: false,
              configurable: false,
              value: {}
            });
          }
          Object.defineProperty(window2.SUNEDITOR_LANG, "en", {
            enumerable: true,
            writable: true,
            configurable: true,
            value: lang
          });
        }
        return lang;
      });
    }
  });

  // ../../node_modules/suneditor/src/plugins/modules/dialog.js
  var require_dialog = __commonJS({
    "../../node_modules/suneditor/src/plugins/modules/dialog.js"(exports, module) {
      "use strict";
      (function(global, factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
              throw new Error("SUNEDITOR_MODULES a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        const dialog6 = {
          name: "dialog",
          /**
           * @description Constructor
           * @param {Object} core Core object 
           */
          add: function(core) {
            const context = core.context;
            context.dialog = {
              kind: "",
              updateModal: false,
              _closeSignal: false
            };
            let dialog_div = core.util.createElement("DIV");
            dialog_div.className = "se-dialog sun-editor-common";
            let dialog_back = core.util.createElement("DIV");
            dialog_back.className = "se-dialog-back";
            dialog_back.style.display = "none";
            let dialog_area = core.util.createElement("DIV");
            dialog_area.className = "se-dialog-inner";
            dialog_area.style.display = "none";
            dialog_div.appendChild(dialog_back);
            dialog_div.appendChild(dialog_area);
            context.dialog.modalArea = dialog_div;
            context.dialog.back = dialog_back;
            context.dialog.modal = dialog_area;
            context.dialog.modal.addEventListener("mousedown", this._onMouseDown_dialog.bind(core));
            context.dialog.modal.addEventListener("click", this._onClick_dialog.bind(core));
            context.element.relative.appendChild(dialog_div);
            dialog_div = null, dialog_back = null, dialog_area = null;
          },
          /**
           * @description Event to control the behavior of closing the dialog
           * @param {MouseEvent} e Event object
           * @private
           */
          _onMouseDown_dialog: function(e) {
            if (/se-dialog-inner/.test(e.target.className)) {
              this.context.dialog._closeSignal = true;
            } else {
              this.context.dialog._closeSignal = false;
            }
          },
          /**
           * @description Event to close the window when the outside area of the dialog or close button is click
           * @param {MouseEvent} e Event object
           * @private
           */
          _onClick_dialog: function(e) {
            if (/close/.test(e.target.getAttribute("data-command")) || this.context.dialog._closeSignal) {
              this.plugins.dialog.close.call(this);
            }
          },
          /**
           * @description Open a Dialog plugin
           * @param {String} kind Dialog plugin name
           * @param {Boolean} update Whether it will open for update ('image' === this.currentControllerName)
           */
          open: function(kind, update) {
            if (this.modalForm) return false;
            if (this.plugins.dialog._bindClose) {
              this._d.removeEventListener("keydown", this.plugins.dialog._bindClose);
              this.plugins.dialog._bindClose = null;
            }
            this.plugins.dialog._bindClose = function(e) {
              if (!/27/.test(e.keyCode)) return;
              this.plugins.dialog.close.call(this);
            }.bind(this);
            this._d.addEventListener("keydown", this.plugins.dialog._bindClose);
            this.context.dialog.updateModal = update;
            if (this.options.popupDisplay === "full") {
              this.context.dialog.modalArea.style.position = "fixed";
            } else {
              this.context.dialog.modalArea.style.position = "absolute";
            }
            this.context.dialog.kind = kind;
            this.modalForm = this.context[kind].modal;
            const focusElement = this.context[kind].focusElement;
            if (typeof this.plugins[kind].on === "function") this.plugins[kind].on.call(this, update);
            this.context.dialog.modalArea.style.display = "block";
            this.context.dialog.back.style.display = "block";
            this.context.dialog.modal.style.display = "block";
            this.modalForm.style.display = "block";
            if (focusElement) focusElement.focus();
          },
          _bindClose: null,
          /**
           * @description Close a Dialog plugin
           * The plugin's "init" method is called.
           */
          close: function() {
            if (this.plugins.dialog._bindClose) {
              this._d.removeEventListener("keydown", this.plugins.dialog._bindClose);
              this.plugins.dialog._bindClose = null;
            }
            const kind = this.context.dialog.kind;
            this.modalForm.style.display = "none";
            this.context.dialog.back.style.display = "none";
            this.context.dialog.modalArea.style.display = "none";
            this.context.dialog.updateModal = false;
            if (typeof this.plugins[kind].init === "function") this.plugins[kind].init.call(this);
            this.context.dialog.kind = "";
            this.modalForm = null;
            this.focus();
          }
        };
        if (typeof noGlobal === "undefined") {
          if (!window2.SUNEDITOR_MODULES) {
            Object.defineProperty(window2, "SUNEDITOR_MODULES", {
              enumerable: true,
              writable: false,
              configurable: false,
              value: {}
            });
          }
          Object.defineProperty(window2.SUNEDITOR_MODULES, "dialog", {
            enumerable: true,
            writable: false,
            configurable: false,
            value: dialog6
          });
        }
        return dialog6;
      });
    }
  });

  // ../../node_modules/suneditor/src/plugins/modules/component.js
  var require_component2 = __commonJS({
    "../../node_modules/suneditor/src/plugins/modules/component.js"(exports, module) {
      "use strict";
      (function(global, factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
              throw new Error("SUNEDITOR_MODULES a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        const component4 = {
          name: "component",
          /**
           * @description Create a container for the resizing component and insert the element.
           * @param {Element} cover Cover element (FIGURE)
           * @param {String} className Class name of container (fixed: se-component)
           * @returns {Element} Created container element
           */
          set_container: function(cover, className) {
            const container = this.util.createElement("DIV");
            container.className = "se-component " + className;
            container.appendChild(cover);
            return container;
          },
          /**
           * @description Cover the target element with a FIGURE element.
           * @param {Element} element Target element
           */
          set_cover: function(element) {
            const cover = this.util.createElement("FIGURE");
            cover.appendChild(element);
            return cover;
          },
          /**
           * @description Return HTML string of caption(FIGCAPTION) element
           * @returns {String}
           */
          create_caption: function() {
            const caption = this.util.createElement("FIGCAPTION");
            caption.innerHTML = "<div>" + this.lang.dialogBox.caption + "</div>";
            return caption;
          }
        };
        if (typeof noGlobal === "undefined") {
          if (!window2.SUNEDITOR_MODULES) {
            Object.defineProperty(window2, "SUNEDITOR_MODULES", {
              enumerable: true,
              writable: false,
              configurable: false,
              value: {}
            });
          }
          Object.defineProperty(window2.SUNEDITOR_MODULES, "component", {
            enumerable: true,
            writable: false,
            configurable: false,
            value: component4
          });
        }
        return component4;
      });
    }
  });

  // ../../node_modules/suneditor/src/plugins/modules/resizing.js
  var require_resizing = __commonJS({
    "../../node_modules/suneditor/src/plugins/modules/resizing.js"(exports, module) {
      "use strict";
      (function(global, factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
              throw new Error("SUNEDITOR_MODULES a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        const resizing3 = {
          name: "resizing",
          /**
           * @description Constructor
           * Require context properties when resizing module
              inputX: Element,
              inputY: Element,
              _container: null,
              _cover: null,
              _element: null,
              _element_w: 1,
              _element_h: 1,
              _element_l: 0,
              _element_t: 0,
              _defaultSizeX: 'auto',
              _defaultSizeY: 'auto',
              _origin_w: core.options.imageWidth === 'auto' ? '' : core.options.imageWidth,
              _origin_h: core.options.imageHeight === 'auto' ? '' : core.options.imageHeight,
              _proportionChecked: true,
              // -- select function --
              _resizing: core.options.imageResizing,
              _resizeDotHide: !core.options.imageHeightShow,
              _rotation: core.options.imageRotation,
              _onlyPercentage: core.options.imageSizeOnlyPercentage,
              _ratio: false,
              _ratioX: 1,
              _ratioY: 1
              _captionShow: true,
              // -- when used caption (_captionShow: true) --
              _caption: null,
              _captionChecked: false,
              captionCheckEl: null,
           * @param {Object} core Core object 
           */
          add: function(core) {
            const icons = core.icons;
            const context = core.context;
            context.resizing = {
              _resizeClientX: 0,
              _resizeClientY: 0,
              _resize_plugin: "",
              _resize_w: 0,
              _resize_h: 0,
              _origin_w: 0,
              _origin_h: 0,
              _rotateVertical: false,
              _resize_direction: "",
              _move_path: null,
              _isChange: false,
              alignIcons: {
                basic: icons.align_justify,
                left: icons.align_left,
                right: icons.align_right,
                center: icons.align_center
              }
            };
            let resize_div_container = this.setController_resize(core);
            context.resizing.resizeContainer = resize_div_container;
            context.resizing.resizeDiv = resize_div_container.querySelector(".se-modal-resize");
            context.resizing.resizeDot = resize_div_container.querySelector(".se-resize-dot");
            context.resizing.resizeDisplay = resize_div_container.querySelector(".se-resize-display");
            let resize_button = this.setController_button(core);
            context.resizing.resizeButton = resize_button;
            let resize_handles = context.resizing.resizeHandles = context.resizing.resizeDot.querySelectorAll("span");
            context.resizing.resizeButtonGroup = resize_button.querySelector("._se_resizing_btn_group");
            context.resizing.rotationButtons = resize_button.querySelectorAll("._se_resizing_btn_group ._se_rotation");
            context.resizing.percentageButtons = resize_button.querySelectorAll("._se_resizing_btn_group ._se_percentage");
            context.resizing.alignMenu = resize_button.querySelector(".se-resizing-align-list");
            context.resizing.alignMenuList = context.resizing.alignMenu.querySelectorAll("button");
            context.resizing.alignButton = resize_button.querySelector("._se_resizing_align_button");
            context.resizing.autoSizeButton = resize_button.querySelector("._se_resizing_btn_group ._se_auto_size");
            context.resizing.captionButton = resize_button.querySelector("._se_resizing_caption_button");
            resize_div_container.addEventListener("mousedown", function(e) {
              e.preventDefault();
            });
            resize_handles[0].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_handles[1].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_handles[2].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_handles[3].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_handles[4].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_handles[5].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_handles[6].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_handles[7].addEventListener("mousedown", this.onMouseDown_resize_handle.bind(core));
            resize_button.addEventListener("click", this.onClick_resizeButton.bind(core));
            context.element.relative.appendChild(resize_div_container);
            context.element.relative.appendChild(resize_button);
            resize_div_container = null, resize_button = null, resize_handles = null;
          },
          /** resize controller, button (image, iframe, video) */
          setController_resize: function(core) {
            const resize_container = core.util.createElement("DIV");
            resize_container.className = "se-controller se-resizing-container";
            resize_container.style.display = "none";
            resize_container.innerHTML = '<div class="se-modal-resize"></div><div class="se-resize-dot"><span class="tl"></span><span class="tr"></span><span class="bl"></span><span class="br"></span><span class="lw"></span><span class="th"></span><span class="rw"></span><span class="bh"></span><div class="se-resize-display"></div></div>';
            return resize_container;
          },
          setController_button: function(core) {
            const lang = core.lang;
            const icons = core.icons;
            const resize_button = core.util.createElement("DIV");
            resize_button.className = "se-controller se-controller-resizing";
            resize_button.innerHTML = '<div class="se-arrow se-arrow-up"></div><div class="se-btn-group _se_resizing_btn_group"><button type="button" data-command="percent" data-value="1" class="se-tooltip _se_percentage"><span>100%</span><span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.resize100 + '</span></span></button><button type="button" data-command="percent" data-value="0.75" class="se-tooltip _se_percentage"><span>75%</span><span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.resize75 + '</span></span></button><button type="button" data-command="percent" data-value="0.5" class="se-tooltip _se_percentage"><span>50%</span><span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.resize50 + '</span></span></button><button type="button" data-command="auto" class="se-btn se-tooltip _se_auto_size">' + icons.auto_size + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.autoSize + '</span></span></button><button type="button" data-command="rotate" data-value="-90" class="se-btn se-tooltip _se_rotation">' + icons.rotate_left + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.rotateLeft + '</span></span></button><button type="button" data-command="rotate" data-value="90" class="se-btn se-tooltip _se_rotation">' + icons.rotate_right + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.rotateRight + '</span></span></button></div><div class="se-btn-group" style="padding-top: 0;"><button type="button" data-command="mirror" data-value="h" class="se-btn se-tooltip">' + icons.mirror_horizontal + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.mirrorHorizontal + '</span></span></button><button type="button" data-command="mirror" data-value="v" class="se-btn se-tooltip">' + icons.mirror_vertical + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.mirrorVertical + '</span></span></button><button type="button" data-command="onalign" class="se-btn se-tooltip _se_resizing_align_button">' + icons.align_justify + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.toolbar.align + '</span></span></button><div class="se-btn-group-sub sun-editor-common se-list-layer se-resizing-align-list"><div class="se-list-inner"><ul class="se-list-basic"><li><button type="button" class="se-btn-list se-tooltip" data-command="align" data-value="basic">' + icons.align_justify + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.basic + '</span></span></button></li><li><button type="button" class="se-btn-list se-tooltip" data-command="align" data-value="left">' + icons.align_left + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.left + '</span></span></button></li><li><button type="button" class="se-btn-list se-tooltip" data-command="align" data-value="center">' + icons.align_center + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.center + '</span></span></button></li><li><button type="button" class="se-btn-list se-tooltip" data-command="align" data-value="right">' + icons.align_right + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.right + '</span></span></button></li></ul></div></div><button type="button" data-command="caption" class="se-btn se-tooltip _se_resizing_caption_button">' + icons.caption + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.caption + '</span></span></button><button type="button" data-command="revert" class="se-btn se-tooltip">' + icons.revert + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.revertButton + '</span></span></button><button type="button" data-command="update" class="se-btn se-tooltip">' + icons.modify + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.edit + '</span></span></button><button type="button" data-command="delete" class="se-btn se-tooltip">' + icons.delete + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.remove + "</span></span></button></div>";
            return resize_button;
          },
          /**
           * @description Gets the width size
           * @param {Object} contextPlugin context object of plugin (core.context[plugin])
           * @param {Element} element Target element
           * @param {Element} cover Cover element (FIGURE)
           * @param {Element} container Container element (DIV.se-component)
           * @returns {String}
           */
          _module_getSizeX: function(contextPlugin, element, cover, container) {
            if (!element) element = contextPlugin._element;
            if (!cover) cover = contextPlugin._cover;
            if (!container) container = contextPlugin._container;
            if (!element) return "";
            return !/%$/.test(element.style.width) ? element.style.width : (container && this.util.getNumber(container.style.width, 2) || 100) + "%";
          },
          /**
           * @description Gets the height size
           * @param {Object} contextPlugin context object of plugin (core.context[plugin])
           * @param {Element} element Target element
           * @param {Element} cover Cover element (FIGURE)
           * @param {Element} container Container element (DIV.se-component)
           * @returns {String}
           */
          _module_getSizeY: function(contextPlugin, element, cover, container) {
            if (!element) element = contextPlugin._element;
            if (!cover) cover = contextPlugin._cover;
            if (!container) container = contextPlugin._container;
            if (!container || !cover) return element && element.style.height || "";
            return this.util.getNumber(cover.style.paddingBottom, 0) > 0 && !this.context.resizing._rotateVertical ? cover.style.height : !/%$/.test(element.style.height) || !/%$/.test(element.style.width) ? element.style.height : (container && this.util.getNumber(container.style.height, 2) || 100) + "%";
          },
          /**
           * @description Called at the "openModify" to put the size of the current target into the size input element.
           * @param {Object} contextPlugin context object of plugin (core.context[plugin])
           * @param {Object} pluginObj Plugin object
           */
          _module_setModifyInputSize: function(contextPlugin, pluginObj) {
            const percentageRotation = contextPlugin._onlyPercentage && this.context.resizing._rotateVertical;
            contextPlugin.proportion.checked = contextPlugin._proportionChecked = contextPlugin._element.getAttribute("data-proportion") !== "false";
            let x = percentageRotation ? "" : this.plugins.resizing._module_getSizeX.call(this, contextPlugin);
            if (x === contextPlugin._defaultSizeX) x = "";
            if (contextPlugin._onlyPercentage) x = this.util.getNumber(x, 2);
            contextPlugin.inputX.value = x;
            pluginObj.setInputSize.call(this, "x");
            if (!contextPlugin._onlyPercentage) {
              let y = percentageRotation ? "" : this.plugins.resizing._module_getSizeY.call(this, contextPlugin);
              if (y === contextPlugin._defaultSizeY) y = "";
              if (contextPlugin._onlyPercentage) y = this.util.getNumber(y, 2);
              contextPlugin.inputY.value = y;
            }
            contextPlugin.inputX.disabled = percentageRotation ? true : false;
            contextPlugin.inputY.disabled = percentageRotation ? true : false;
            contextPlugin.proportion.disabled = percentageRotation ? true : false;
            pluginObj.setRatio.call(this);
          },
          /**
           * @description It is called in "setInputSize" (input tag keyupEvent), 
           * checks the value entered in the input tag, 
           * calculates the ratio, and sets the calculated value in the input tag of the opposite size.
           * @param {Object} contextPlugin context object of plugin (core.context[plugin])
           * @param {String} xy 'x': width, 'y': height
           */
          _module_setInputSize: function(contextPlugin, xy) {
            if (contextPlugin._onlyPercentage) {
              if (xy === "x" && contextPlugin.inputX.value > 100) contextPlugin.inputX.value = 100;
              return;
            }
            if (contextPlugin.proportion.checked && contextPlugin._ratio && /\d/.test(contextPlugin.inputX.value) && /\d/.test(contextPlugin.inputY.value)) {
              const xUnit = contextPlugin.inputX.value.replace(/\d+|\./g, "") || contextPlugin.sizeUnit;
              const yUnit = contextPlugin.inputY.value.replace(/\d+|\./g, "") || contextPlugin.sizeUnit;
              if (xUnit !== yUnit) return;
              const dec = xUnit === "%" ? 2 : 0;
              if (xy === "x") {
                contextPlugin.inputY.value = this.util.getNumber(contextPlugin._ratioY * this.util.getNumber(contextPlugin.inputX.value, dec), dec) + yUnit;
              } else {
                contextPlugin.inputX.value = this.util.getNumber(contextPlugin._ratioX * this.util.getNumber(contextPlugin.inputY.value, dec), dec) + xUnit;
              }
            }
          },
          /**
           * @description It is called in "setRatio" (input and proportionCheck tags changeEvent), 
           * checks the value of the input tag, calculates the ratio, and resets it in the input tag.
           * @param {Object} contextPlugin context object of plugin (core.context[plugin])
           */
          _module_setRatio: function(contextPlugin) {
            const xValue = contextPlugin.inputX.value;
            const yValue = contextPlugin.inputY.value;
            if (contextPlugin.proportion.checked && /\d+/.test(xValue) && /\d+/.test(yValue)) {
              const xUnit = xValue.replace(/\d+|\./g, "") || contextPlugin.sizeUnit;
              const yUnit = yValue.replace(/\d+|\./g, "") || contextPlugin.sizeUnit;
              if (xUnit !== yUnit) {
                contextPlugin._ratio = false;
              } else if (!contextPlugin._ratio) {
                const x = this.util.getNumber(xValue, 0);
                const y = this.util.getNumber(yValue, 0);
                contextPlugin._ratio = true;
                contextPlugin._ratioX = x / y;
                contextPlugin._ratioY = y / x;
              }
            } else {
              contextPlugin._ratio = false;
            }
          },
          /**
           * @description Revert size of element to origin size (plugin._origin_w, plugin._origin_h)
           * @param {Object} contextPlugin context object of plugin (core.context[plugin])
           */
          _module_sizeRevert: function(contextPlugin) {
            if (contextPlugin._onlyPercentage) {
              contextPlugin.inputX.value = contextPlugin._origin_w > 100 ? 100 : contextPlugin._origin_w;
            } else {
              contextPlugin.inputX.value = contextPlugin._origin_w;
              contextPlugin.inputY.value = contextPlugin._origin_h;
            }
          },
          /**
           * @description Save the size data (element.setAttribute("data-size"))
           * Used at the "setSize" method
           * @param {Object} contextPlugin context object of plugin (core.context[plugin])
           */
          _module_saveCurrentSize: function(contextPlugin) {
            const x = this.plugins.resizing._module_getSizeX.call(this, contextPlugin);
            const y = this.plugins.resizing._module_getSizeY.call(this, contextPlugin);
            contextPlugin._element.setAttribute("width", x.replace("px", ""));
            contextPlugin._element.setAttribute("height", y.replace("px", ""));
            contextPlugin._element.setAttribute("data-size", x + "," + y);
            if (!!contextPlugin._videoRatio) contextPlugin._videoRatio = y;
          },
          /**
           * @description Call the resizing module
           * @param {Element} targetElement Resizing target element
           * @param {string} plugin Plugin name
           * @returns {Object} Size of resizing div {w, h, t, l}
           */
          call_controller_resize: function(targetElement, plugin) {
            const contextResizing = this.context.resizing;
            const contextPlugin = this.context[plugin];
            contextResizing._resize_plugin = plugin;
            const resizeContainer = contextResizing.resizeContainer;
            const resizeDiv = contextResizing.resizeDiv;
            const offset = this.util.getOffset(targetElement, this.context.element.wysiwygFrame);
            const isVertical = contextResizing._rotateVertical = /^(90|270)$/.test(Math.abs(targetElement.getAttribute("data-rotate")).toString());
            const w = isVertical ? targetElement.offsetHeight : targetElement.offsetWidth;
            const h = isVertical ? targetElement.offsetWidth : targetElement.offsetHeight;
            const t = offset.top;
            const l = offset.left - this.context.element.wysiwygFrame.scrollLeft;
            resizeContainer.style.top = t + "px";
            resizeContainer.style.left = l + "px";
            resizeContainer.style.width = w + "px";
            resizeContainer.style.height = h + "px";
            resizeDiv.style.top = "0px";
            resizeDiv.style.left = "0px";
            resizeDiv.style.width = w + "px";
            resizeDiv.style.height = h + "px";
            let align = targetElement.getAttribute("data-align") || "basic";
            align = align === "none" ? "basic" : align;
            const container = this.util.getParentElement(targetElement, this.util.isComponent);
            const cover = this.util.getParentElement(targetElement, "FIGURE");
            const displayX = this.plugins.resizing._module_getSizeX.call(this, contextPlugin, targetElement, cover, container) || "auto";
            const displayY = contextPlugin._onlyPercentage && plugin === "image" ? "" : ", " + (this.plugins.resizing._module_getSizeY.call(this, contextPlugin, targetElement, cover, container) || "auto");
            this.util.changeTxt(contextResizing.resizeDisplay, this.lang.dialogBox[align] + " (" + displayX + displayY + ")");
            contextResizing.resizeButtonGroup.style.display = contextPlugin._resizing ? "" : "none";
            const resizeDotShow = contextPlugin._resizing && !contextPlugin._resizeDotHide && !contextPlugin._onlyPercentage ? "flex" : "none";
            const resizeHandles = contextResizing.resizeHandles;
            for (let i = 0, len = resizeHandles.length; i < len; i++) {
              resizeHandles[i].style.display = resizeDotShow;
            }
            if (contextPlugin._resizing) {
              const rotations = contextResizing.rotationButtons;
              rotations[0].style.display = rotations[1].style.display = contextPlugin._rotation ? "" : "none";
            }
            if (contextPlugin._alignHide) {
              contextResizing.alignButton.style.display = "none";
            } else {
              contextResizing.alignButton.style.display = "";
              const alignList = contextResizing.alignMenuList;
              this.util.changeElement(contextResizing.alignButton.firstElementChild, contextResizing.alignIcons[align]);
              for (let i = 0, len = alignList.length; i < len; i++) {
                if (alignList[i].getAttribute("data-value") === align) this.util.addClass(alignList[i], "on");
                else this.util.removeClass(alignList[i], "on");
              }
            }
            const pButtons = contextResizing.percentageButtons;
            const value = /%$/.test(targetElement.style.width) && /%$/.test(container.style.width) ? this.util.getNumber(container.style.width, 0) / 100 + "" : "";
            for (let i = 0, len = pButtons.length; i < len; i++) {
              if (pButtons[i].getAttribute("data-value") === value) {
                this.util.addClass(pButtons[i], "active");
              } else {
                this.util.removeClass(pButtons[i], "active");
              }
            }
            if (!contextPlugin._captionShow) {
              contextResizing.captionButton.style.display = "none";
            } else {
              contextResizing.captionButton.style.display = "";
              if (this.util.getChildElement(targetElement.parentNode, "figcaption")) {
                this.util.addClass(contextResizing.captionButton, "active");
                contextPlugin._captionChecked = true;
              } else {
                this.util.removeClass(contextResizing.captionButton, "active");
                contextPlugin._captionChecked = false;
              }
            }
            resizeContainer.style.display = "block";
            const addOffset = { left: 0, top: 50 };
            if (this.options.iframe) {
              addOffset.left -= this.context.element.wysiwygFrame.parentElement.offsetLeft;
              addOffset.top -= this.context.element.wysiwygFrame.parentElement.offsetTop;
            }
            this.setControllerPosition(contextResizing.resizeButton, resizeContainer, "bottom", addOffset);
            const onControlsOff = function() {
              this.util.setDisabledButtons.call(this.util, false, this.resizingDisabledButtons);
              this.history._resetCachingButton();
            };
            this.controllersOn(resizeContainer, contextResizing.resizeButton, onControlsOff.bind(this), targetElement, plugin);
            this.util.setDisabledButtons(true, this.resizingDisabledButtons);
            contextResizing._resize_w = w;
            contextResizing._resize_h = h;
            const originSize = (targetElement.getAttribute("origin-size") || "").split(",");
            contextResizing._origin_w = originSize[0] || targetElement.naturalWidth;
            contextResizing._origin_h = originSize[1] || targetElement.naturalHeight;
            return {
              w,
              h,
              t,
              l
            };
          },
          _closeAlignMenu: null,
          /**
           * @description Open align submenu of module
           */
          openAlignMenu: function() {
            const alignButton = this.context.resizing.alignButton;
            this.util.addClass(alignButton, "on");
            this.context.resizing.alignMenu.style.top = alignButton.offsetTop + alignButton.offsetHeight + "px";
            this.context.resizing.alignMenu.style.left = alignButton.offsetLeft - alignButton.offsetWidth / 2 + "px";
            this.context.resizing.alignMenu.style.display = "block";
            this.plugins.resizing._closeAlignMenu = function() {
              this.util.removeClass(this.context.resizing.alignButton, "on");
              this.context.resizing.alignMenu.style.display = "none";
              this.removeDocEvent("click", this.plugins.resizing._closeAlignMenu);
              this.plugins.resizing._closeAlignMenu = null;
            }.bind(this);
            this.addDocEvent("click", this.plugins.resizing._closeAlignMenu);
          },
          /**
           * @description Click event of resizing toolbar
           * Performs the action of the clicked toolbar button.
           * @param {MouseEvent} e Event object
           */
          onClick_resizeButton: function(e) {
            e.stopPropagation();
            const target = e.target;
            const command = target.getAttribute("data-command") || target.parentNode.getAttribute("data-command");
            if (!command) return;
            const value = target.getAttribute("data-value") || target.parentNode.getAttribute("data-value");
            const pluginName = this.context.resizing._resize_plugin;
            const currentContext = this.context[pluginName];
            const contextEl = currentContext._element;
            const currentModule = this.plugins[pluginName];
            e.preventDefault();
            if (typeof this.plugins.resizing._closeAlignMenu === "function") {
              this.plugins.resizing._closeAlignMenu();
              if (command === "onalign") return;
            }
            switch (command) {
              case "auto":
                this.plugins.resizing.resetTransform.call(this, contextEl);
                currentModule.setAutoSize.call(this);
                this.selectComponent(contextEl, pluginName);
                break;
              case "percent":
                let percentY = this.plugins.resizing._module_getSizeY.call(this, currentContext);
                if (this.context.resizing._rotateVertical) {
                  const percentage = contextEl.getAttribute("data-percentage");
                  if (percentage) percentY = percentage.split(",")[1];
                }
                this.plugins.resizing.resetTransform.call(this, contextEl);
                currentModule.setPercentSize.call(this, value * 100, this.util.getNumber(percentY, 0) === null || !/%$/.test(percentY) ? "" : percentY);
                this.selectComponent(contextEl, pluginName);
                break;
              case "mirror":
                const r = contextEl.getAttribute("data-rotate") || "0";
                let x = contextEl.getAttribute("data-rotateX") || "";
                let y = contextEl.getAttribute("data-rotateY") || "";
                if (value === "h" && !this.context.resizing._rotateVertical || value === "v" && this.context.resizing._rotateVertical) {
                  y = y ? "" : "180";
                } else {
                  x = x ? "" : "180";
                }
                contextEl.setAttribute("data-rotateX", x);
                contextEl.setAttribute("data-rotateY", y);
                this.plugins.resizing._setTransForm(contextEl, r, x, y);
                break;
              case "rotate":
                const contextResizing = this.context.resizing;
                const slope = contextEl.getAttribute("data-rotate") * 1 + value * 1;
                const deg = this._w.Math.abs(slope) >= 360 ? 0 : slope;
                contextEl.setAttribute("data-rotate", deg);
                contextResizing._rotateVertical = /^(90|270)$/.test(this._w.Math.abs(deg).toString());
                this.plugins.resizing.setTransformSize.call(this, contextEl, null, null);
                this.selectComponent(contextEl, pluginName);
                break;
              case "onalign":
                this.plugins.resizing.openAlignMenu.call(this);
                return;
              case "align":
                const alignValue = value === "basic" ? "none" : value;
                currentModule.setAlign.call(this, alignValue, null, null, null);
                this.selectComponent(contextEl, pluginName);
                break;
              case "caption":
                const caption = !currentContext._captionChecked;
                currentModule.openModify.call(this, true);
                currentContext._captionChecked = currentContext.captionCheckEl.checked = caption;
                currentModule.update_image.call(this, false, false, false);
                if (caption) {
                  const captionText = this.util.getChildElement(currentContext._caption, function(current) {
                    return current.nodeType === 3;
                  });
                  if (!captionText) {
                    currentContext._caption.focus();
                  } else {
                    this.setRange(captionText, 0, captionText, captionText.textContent.length);
                  }
                  this.controllersOff();
                } else {
                  this.selectComponent(contextEl, pluginName);
                  currentModule.openModify.call(this, true);
                }
                break;
              case "revert":
                currentModule.setOriginSize.call(this);
                this.selectComponent(contextEl, pluginName);
                break;
              case "update":
                currentModule.openModify.call(this);
                this.controllersOff();
                break;
              case "delete":
                currentModule.destroy.call(this);
                break;
            }
            this.history.push(false);
          },
          /**
           * @description Initialize the transform style (rotation) of the element.
           * @param {Element} element Target element
           */
          resetTransform: function(element) {
            const size = (element.getAttribute("data-size") || element.getAttribute("data-origin") || "").split(",");
            this.context.resizing._rotateVertical = false;
            element.style.maxWidth = "";
            element.style.transform = "";
            element.style.transformOrigin = "";
            element.setAttribute("data-rotate", "");
            element.setAttribute("data-rotateX", "");
            element.setAttribute("data-rotateY", "");
            this.plugins[this.context.resizing._resize_plugin].setSize.call(this, size[0] ? size[0] : "auto", size[1] ? size[1] : "", true);
          },
          /**
           * @description Set the transform style (rotation) of the element.
           * @param {Element} element Target element
           * @param {Number|null} width Element's width size
           * @param {Number|null} height Element's height size
           */
          setTransformSize: function(element, width, height) {
            let percentage = element.getAttribute("data-percentage");
            const isVertical = this.context.resizing._rotateVertical;
            const deg = element.getAttribute("data-rotate") * 1;
            let transOrigin = "";
            if (percentage && !isVertical) {
              percentage = percentage.split(",");
              if (percentage[0] === "auto" && percentage[1] === "auto") {
                this.plugins[this.context.resizing._resize_plugin].setAutoSize.call(this);
              } else {
                this.plugins[this.context.resizing._resize_plugin].setPercentSize.call(this, percentage[0], percentage[1]);
              }
            } else {
              const cover = this.util.getParentElement(element, "FIGURE");
              const offsetW = width || element.offsetWidth;
              const offsetH = height || element.offsetHeight;
              const w = (isVertical ? offsetH : offsetW) + "px";
              const h = (isVertical ? offsetW : offsetH) + "px";
              this.plugins[this.context.resizing._resize_plugin].cancelPercentAttr.call(this);
              this.plugins[this.context.resizing._resize_plugin].setSize.call(this, offsetW + "px", offsetH + "px", true);
              cover.style.width = w;
              cover.style.height = !!this.context[this.context.resizing._resize_plugin]._caption ? "" : h;
              if (isVertical) {
                let transW = offsetW / 2 + "px " + offsetW / 2 + "px 0";
                let transH = offsetH / 2 + "px " + offsetH / 2 + "px 0";
                transOrigin = deg === 90 || deg === -270 ? transH : transW;
              }
            }
            element.style.transformOrigin = transOrigin;
            this.plugins.resizing._setTransForm(element, deg.toString(), element.getAttribute("data-rotateX") || "", element.getAttribute("data-rotateY") || "");
            if (isVertical) element.style.maxWidth = "none";
            else element.style.maxWidth = "";
            this.plugins.resizing.setCaptionPosition.call(this, element);
          },
          _setTransForm: function(element, r, x, y) {
            let width = (element.offsetWidth - element.offsetHeight) * (/-/.test(r) ? 1 : -1);
            let translate2 = "";
            if (/[1-9]/.test(r) && (x || y)) {
              translate2 = x ? "Y" : "X";
              switch (r) {
                case "90":
                  translate2 = x && y ? "X" : y ? translate2 : "";
                  break;
                case "270":
                  width *= -1;
                  translate2 = x && y ? "Y" : x ? translate2 : "";
                  break;
                case "-90":
                  translate2 = x && y ? "Y" : x ? translate2 : "";
                  break;
                case "-270":
                  width *= -1;
                  translate2 = x && y ? "X" : y ? translate2 : "";
                  break;
                default:
                  translate2 = "";
              }
            }
            if (r % 180 === 0) {
              element.style.maxWidth = "";
            }
            element.style.transform = "rotate(" + r + "deg)" + (x ? " rotateX(" + x + "deg)" : "") + (y ? " rotateY(" + y + "deg)" : "") + (translate2 ? " translate" + translate2 + "(" + width + "px)" : "");
          },
          /**
           * @description The position of the caption is set automatically.
           * @param {Element} element Target element (not caption element)
           */
          setCaptionPosition: function(element) {
            const figcaption = this.util.getChildElement(this.util.getParentElement(element, "FIGURE"), "FIGCAPTION");
            if (figcaption) {
              figcaption.style.marginTop = (this.context.resizing._rotateVertical ? element.offsetWidth - element.offsetHeight : 0) + "px";
            }
          },
          /**
           * @description Mouse down event of resize handles
           * @param {MouseEvent} e Event object 
           */
          onMouseDown_resize_handle: function(e) {
            e.stopPropagation();
            e.preventDefault();
            const contextResizing = this.context.resizing;
            const direction = contextResizing._resize_direction = e.target.classList[0];
            contextResizing._resizeClientX = e.clientX;
            contextResizing._resizeClientY = e.clientY;
            this.context.element.resizeBackground.style.display = "block";
            contextResizing.resizeButton.style.display = "none";
            contextResizing.resizeDiv.style.float = /l/.test(direction) ? "right" : /r/.test(direction) ? "left" : "none";
            const closureFunc_bind = function closureFunc(e2) {
              if (e2.type === "keydown" && e2.keyCode !== 27) return;
              const change = contextResizing._isChange;
              contextResizing._isChange = false;
              this.removeDocEvent("mousemove", resizing_element_bind);
              this.removeDocEvent("mouseup", closureFunc_bind);
              this.removeDocEvent("keydown", closureFunc_bind);
              if (e2.type === "keydown") {
                this.controllersOff();
                this.context.element.resizeBackground.style.display = "none";
                this.plugins[this.context.resizing._resize_plugin].init.call(this);
              } else {
                this.plugins.resizing.cancel_controller_resize.call(this, direction);
                if (change) this.history.push(false);
              }
            }.bind(this);
            const resizing_element_bind = this.plugins.resizing.resizing_element.bind(this, contextResizing, direction, this.context[contextResizing._resize_plugin]);
            this.addDocEvent("mousemove", resizing_element_bind);
            this.addDocEvent("mouseup", closureFunc_bind);
            this.addDocEvent("keydown", closureFunc_bind);
          },
          /**
           * @description Mouse move event after call "onMouseDown_resize_handle" of resize handles
           * The size of the module's "div" is adjusted according to the mouse move event.
           * @param {Object} contextResizing "core.context.resizing" object (binding argument)
           * @param {String} direction Direction ("tl", "tr", "bl", "br", "lw", "th", "rw", "bh") (binding argument)
           * @param {Object} plugin "core.context[currentPlugin]" object (binding argument)
           * @param {MouseEvent} e Event object
           */
          resizing_element: function(contextResizing, direction, plugin, e) {
            const clientX = e.clientX;
            const clientY = e.clientY;
            let resultW = plugin._element_w;
            let resultH = plugin._element_h;
            const w = plugin._element_w + (/r/.test(direction) ? clientX - contextResizing._resizeClientX : contextResizing._resizeClientX - clientX);
            const h = plugin._element_h + (/b/.test(direction) ? clientY - contextResizing._resizeClientY : contextResizing._resizeClientY - clientY);
            const wh = plugin._element_h / plugin._element_w * w;
            if (/t/.test(direction)) contextResizing.resizeDiv.style.top = plugin._element_h - (/h/.test(direction) ? h : wh) + "px";
            if (/l/.test(direction)) contextResizing.resizeDiv.style.left = plugin._element_w - w + "px";
            if (/r|l/.test(direction)) {
              contextResizing.resizeDiv.style.width = w + "px";
              resultW = w;
            }
            if (/^(t|b)[^h]$/.test(direction)) {
              contextResizing.resizeDiv.style.height = wh + "px";
              resultH = wh;
            } else if (/^(t|b)h$/.test(direction)) {
              contextResizing.resizeDiv.style.height = h + "px";
              resultH = h;
            }
            contextResizing._resize_w = resultW;
            contextResizing._resize_h = resultH;
            this.util.changeTxt(contextResizing.resizeDisplay, this._w.Math.round(resultW) + " x " + this._w.Math.round(resultH));
            contextResizing._isChange = true;
          },
          /**
           * @description Resize the element to the size of the "div" adjusted in the "resizing_element" method.
           * Called at the mouse-up event registered in "onMouseDown_resize_handle".
           * @param {String} direction Direction ("tl", "tr", "bl", "br", "lw", "th", "rw", "bh")
           */
          cancel_controller_resize: function(direction) {
            const isVertical = this.context.resizing._rotateVertical;
            this.controllersOff();
            this.context.element.resizeBackground.style.display = "none";
            let w = this._w.Math.round(isVertical ? this.context.resizing._resize_h : this.context.resizing._resize_w);
            let h = this._w.Math.round(isVertical ? this.context.resizing._resize_w : this.context.resizing._resize_h);
            if (!isVertical && !/%$/.test(w)) {
              const padding = 16;
              const limit = this.context.element.wysiwygFrame.clientWidth - padding * 2 - 2;
              if (this.util.getNumber(w, 0) > limit) {
                h = this._w.Math.round(h / w * limit);
                w = limit;
              }
            }
            const pluginName = this.context.resizing._resize_plugin;
            this.plugins[pluginName].setSize.call(this, w, h, false, direction);
            if (isVertical) this.plugins.resizing.setTransformSize.call(this, this.context[this.context.resizing._resize_plugin]._element, w, h);
            this.selectComponent(this.context[pluginName]._element, pluginName);
          }
        };
        if (typeof noGlobal === "undefined") {
          if (!window2.SUNEDITOR_MODULES) {
            Object.defineProperty(window2, "SUNEDITOR_MODULES", {
              enumerable: true,
              writable: false,
              configurable: false,
              value: {}
            });
          }
          Object.defineProperty(window2.SUNEDITOR_MODULES, "resizing", {
            enumerable: true,
            writable: false,
            configurable: false,
            value: resizing3
          });
        }
        return resizing3;
      });
    }
  });

  // ../../node_modules/suneditor/src/plugins/modules/fileManager.js
  var require_fileManager = __commonJS({
    "../../node_modules/suneditor/src/plugins/modules/fileManager.js"(exports, module) {
      "use strict";
      (function(global, factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
              throw new Error("SUNEDITOR_MODULES a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        const fileManager4 = {
          name: "fileManager",
          _xmlHttp: null,
          _checkMediaComponent: function(tag2) {
            if (/IMG/i.test(tag2)) {
              return !/FIGURE/i.test(tag2.parentElement.nodeName) || !/FIGURE/i.test(tag2.parentElement.parentElement.nodeName);
            }
            return true;
          },
          /**
           * @description Upload the file to the server.
           * @param {String} uploadUrl Upload server url
           * @param {Object|null} uploadHeader Request header
           * @param {FormData} formData FormData in body
           * @param {Function|null} callBack Success call back function
           * @param {Function|null} errorCallBack Error call back function
           * @example this.plugins.fileManager.upload.call(this, imageUploadUrl, this.options.imageUploadHeader, formData, this.plugins.image.callBack_imgUpload.bind(this, info), this.functions.onImageUploadError);
           */
          upload: function(uploadUrl, uploadHeader, formData, callBack, errorCallBack) {
            this.showLoading();
            const filePlugin = this.plugins.fileManager;
            const xmlHttp = filePlugin._xmlHttp = this.util.getXMLHttpRequest();
            xmlHttp.onreadystatechange = filePlugin._callBackUpload.bind(this, xmlHttp, callBack, errorCallBack);
            xmlHttp.open("post", uploadUrl, true);
            if (uploadHeader !== null && typeof uploadHeader === "object" && this._w.Object.keys(uploadHeader).length > 0) {
              for (let key in uploadHeader) {
                xmlHttp.setRequestHeader(key, uploadHeader[key]);
              }
            }
            xmlHttp.send(formData);
          },
          _callBackUpload: function(xmlHttp, callBack, errorCallBack) {
            if (xmlHttp.readyState === 4) {
              if (xmlHttp.status === 200) {
                try {
                  callBack(xmlHttp);
                } catch (e) {
                  throw Error('[SUNEDITOR.fileManager.upload.callBack.fail] cause : "' + e.message + '"');
                } finally {
                  this.closeLoading();
                }
              } else {
                this.closeLoading();
                const res = !xmlHttp.responseText ? xmlHttp : JSON.parse(xmlHttp.responseText);
                if (typeof errorCallBack !== "function" || errorCallBack("", res, this)) {
                  const err = "[SUNEDITOR.fileManager.upload.serverException] status: " + xmlHttp.status + ", response: " + (res.errorMessage || xmlHttp.responseText);
                  this.functions.noticeOpen(err);
                  throw Error(err);
                }
              }
            }
          },
          /**
           * @description Checke the file's information and modify the tag that does not fit the format.
           * @param {String} pluginName Plugin name
           * @param {Array} tagNames Tag array to check
           * @param {Function|null} uploadEventHandler Event handler to process updated file info after checking (used in "setInfo")
           * @param {Function} modifyHandler A function to modify a tag that does not fit the format (Argument value: Tag element)
           * @param {Boolean} resizing True if the plugin is using a resizing module
           * @example 
           * const modifyHandler = function (tag) {
           *      imagePlugin.onModifyMode.call(this, tag, null);
           *      imagePlugin.openModify.call(this, true);
           *      imagePlugin.update_image.call(this, true, false, true);
           *  }.bind(this);
           *  this.plugins.fileManager.checkInfo.call(this, 'image', ['img'], this.functions.onImageUpload, modifyHandler, true);
           */
          checkInfo: function(pluginName, tagNames, uploadEventHandler, modifyHandler, resizing3) {
            let tags = [];
            for (let i = 0, len = tagNames.length; i < len; i++) {
              tags = tags.concat([].slice.call(this.context.element.wysiwyg.querySelectorAll(tagNames[i] + ':not([data-se-embed="true"])')));
            }
            const fileManagerPlugin = this.plugins.fileManager;
            const context = this.context[pluginName];
            const infoList = context._infoList;
            const setFileInfo = fileManagerPlugin.setInfo.bind(this);
            if (tags.length === infoList.length) {
              if (this._componentsInfoReset) {
                for (let i = 0, len = tags.length; i < len; i++) {
                  setFileInfo(pluginName, tags[i], uploadEventHandler, null, resizing3);
                }
                return;
              } else {
                let infoUpdate = false;
                for (let i = 0, len = infoList.length, info; i < len; i++) {
                  info = infoList[i];
                  if (tags.filter(function(t) {
                    return info.src === t.src && info.index.toString() === t.getAttribute("data-index");
                  }).length === 0) {
                    infoUpdate = true;
                    break;
                  }
                }
                if (!infoUpdate) return;
              }
            }
            const _resize_plugin = resizing3 ? this.context.resizing._resize_plugin : "";
            if (resizing3) this.context.resizing._resize_plugin = pluginName;
            const currentTags = [];
            const infoIndex = [];
            for (let i = 0, len = infoList.length; i < len; i++) {
              infoIndex[i] = infoList[i].index;
            }
            context.__updateTags = tags;
            while (tags.length > 0) {
              const tag2 = tags.shift();
              if (!this.util.getParentElement(tag2, this.util.isMediaComponent) || !fileManagerPlugin._checkMediaComponent(tag2)) {
                currentTags.push(context._infoIndex);
                modifyHandler(tag2);
              } else if (!tag2.getAttribute("data-index") || infoIndex.indexOf(tag2.getAttribute("data-index") * 1) < 0) {
                currentTags.push(context._infoIndex);
                tag2.removeAttribute("data-index");
                setFileInfo(pluginName, tag2, uploadEventHandler, null, resizing3);
              } else {
                currentTags.push(tag2.getAttribute("data-index") * 1);
              }
            }
            for (let i = 0, dataIndex; i < infoList.length; i++) {
              dataIndex = infoList[i].index;
              if (currentTags.indexOf(dataIndex) > -1) continue;
              infoList.splice(i, 1);
              if (typeof uploadEventHandler === "function") uploadEventHandler(null, dataIndex, "delete", null, 0, this);
              i--;
            }
            if (resizing3) this.context.resizing._resize_plugin = _resize_plugin;
          },
          /**
           * @description Create info object of file and add it to "_infoList" (this.context[pluginName]._infoList[])
           * @param {String} pluginName Plugin name 
           * @param {Element} element 
           * @param {Function|null} uploadEventHandler Event handler to process updated file info (created in setInfo)
           * @param {Object|null} file 
           * @param {Boolean} resizing True if the plugin is using a resizing module
           * @example 
           * uploadCallBack {.. file = { name: fileList[i].name, size: fileList[i].size };
           * this.plugins.fileManager.setInfo.call(this, 'image', oImg, this.functions.onImageUpload, file, true);
           */
          setInfo: function(pluginName, element, uploadEventHandler, file, resizing3) {
            const _resize_plugin = resizing3 ? this.context.resizing._resize_plugin : "";
            if (resizing3) this.context.resizing._resize_plugin = pluginName;
            const plguin = this.plugins[pluginName];
            const context = this.context[pluginName];
            const infoList = context._infoList;
            let dataIndex = element.getAttribute("data-index");
            let info = null;
            let state = "";
            if (!file) {
              file = {
                "name": element.getAttribute("data-file-name") || (typeof element.src === "string" ? element.src.split("/").pop() : ""),
                "size": element.getAttribute("data-file-size") || 0
              };
            }
            if (!dataIndex || this._componentsInfoInit) {
              state = "create";
              dataIndex = context._infoIndex++;
              element.setAttribute("data-index", dataIndex);
              element.setAttribute("data-file-name", file.name);
              element.setAttribute("data-file-size", file.size);
              info = {
                src: element.src,
                index: dataIndex * 1,
                name: file.name,
                size: file.size
              };
              infoList.push(info);
            } else {
              state = "update";
              dataIndex *= 1;
              for (let i = 0, len = infoList.length; i < len; i++) {
                if (dataIndex === infoList[i].index) {
                  info = infoList[i];
                  break;
                }
              }
              if (!info) {
                dataIndex = context._infoIndex++;
                info = { index: dataIndex };
                infoList.push(info);
              }
              info.src = element.src;
              info.name = element.getAttribute("data-file-name");
              info.size = element.getAttribute("data-file-size") * 1;
            }
            info.element = element;
            info.delete = plguin.destroy.bind(this, element);
            info.select = function(element2) {
              element2.scrollIntoView(true);
              this._w.setTimeout(plguin.select.bind(this, element2));
            }.bind(this, element);
            if (resizing3) {
              if (!element.getAttribute("origin-size") && element.naturalWidth) {
                element.setAttribute("origin-size", element.naturalWidth + "," + element.naturalHeight);
              }
              if (!element.getAttribute("data-origin")) {
                const container = this.util.getParentElement(element, this.util.isMediaComponent);
                const cover = this.util.getParentElement(element, "FIGURE");
                const w = this.plugins.resizing._module_getSizeX.call(this, context, element, cover, container);
                const h = this.plugins.resizing._module_getSizeY.call(this, context, element, cover, container);
                element.setAttribute("data-origin", w + "," + h);
                element.setAttribute("data-size", w + "," + h);
              }
              if (!element.style.width) {
                const size = (element.getAttribute("data-size") || element.getAttribute("data-origin") || "").split(",");
                plguin.onModifyMode.call(this, element, null);
                plguin.applySize.call(this, size[0], size[1]);
              }
              this.context.resizing._resize_plugin = _resize_plugin;
            }
            if (typeof uploadEventHandler === "function") uploadEventHandler(element, dataIndex, state, info, --context._uploadFileLength < 0 ? 0 : context._uploadFileLength, this);
          },
          /**
           * @description Delete info object at "_infoList"
           * @param {String} pluginName Plugin name 
           * @param {Number} index index of info object (this.context[pluginName]._infoList[].index)
           * @param {Function|null} uploadEventHandler Event handler to process updated file info (created in setInfo)
           */
          deleteInfo: function(pluginName, index, uploadEventHandler) {
            if (index >= 0) {
              const infoList = this.context[pluginName]._infoList;
              for (let i = 0, len = infoList.length; i < len; i++) {
                if (index === infoList[i].index) {
                  infoList.splice(i, 1);
                  if (typeof uploadEventHandler === "function") uploadEventHandler(null, index, "delete", null, 0, this);
                  return;
                }
              }
            }
          },
          /**
           * @description Reset info object and "_infoList = []", "_infoIndex = 0"
           * @param {String} pluginName Plugin name 
           * @param {Function|null} uploadEventHandler Event handler to process updated file info (created in setInfo)
           */
          resetInfo: function(pluginName, uploadEventHandler) {
            const context = this.context[pluginName];
            if (typeof uploadEventHandler === "function") {
              const infoList = context._infoList;
              for (let i = 0, len = infoList.length; i < len; i++) {
                uploadEventHandler(null, infoList[i].index, "delete", null, 0, this);
              }
            }
            context._infoList = [];
            context._infoIndex = 0;
          }
        };
        if (typeof noGlobal === "undefined") {
          if (!window2.SUNEDITOR_MODULES) {
            Object.defineProperty(window2, "SUNEDITOR_MODULES", {
              enumerable: true,
              writable: false,
              configurable: false,
              value: {}
            });
          }
          Object.defineProperty(window2.SUNEDITOR_MODULES, "fileManager", {
            enumerable: true,
            writable: false,
            configurable: false,
            value: fileManager4
          });
        }
        return fileManager4;
      });
    }
  });

  // ../../node_modules/suneditor/src/plugins/modules/fileBrowser.js
  var require_fileBrowser = __commonJS({
    "../../node_modules/suneditor/src/plugins/modules/fileBrowser.js"(exports, module) {
      "use strict";
      (function(global, factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
              throw new Error("SUNEDITOR_MODULES a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        const fileBrowser2 = {
          name: "fileBrowser",
          _xmlHttp: null,
          _loading: null,
          /**
           * @description Constructor
           * @param {Object} core Core object 
           */
          add: function(core) {
            const context = core.context;
            context.fileBrowser = {
              _closeSignal: false,
              area: null,
              header: null,
              tagArea: null,
              body: null,
              list: null,
              tagElements: null,
              items: [],
              selectedTags: [],
              selectorHandler: null,
              contextPlugin: "",
              columnSize: 4
            };
            let browser_div = core.util.createElement("DIV");
            browser_div.className = "se-file-browser sun-editor-common";
            let back = core.util.createElement("DIV");
            back.className = "se-file-browser-back";
            let content = core.util.createElement("DIV");
            content.className = "se-file-browser-inner";
            content.innerHTML = this.set_browser(core);
            browser_div.appendChild(back);
            browser_div.appendChild(content);
            this._loading = browser_div.querySelector(".se-loading-box");
            context.fileBrowser.area = browser_div;
            context.fileBrowser.header = content.querySelector(".se-file-browser-header");
            context.fileBrowser.titleArea = content.querySelector(".se-file-browser-title");
            context.fileBrowser.tagArea = content.querySelector(".se-file-browser-tags");
            context.fileBrowser.body = content.querySelector(".se-file-browser-body");
            context.fileBrowser.list = content.querySelector(".se-file-browser-list");
            context.fileBrowser.tagArea.addEventListener("click", this.onClickTag.bind(core));
            context.fileBrowser.list.addEventListener("click", this.onClickFile.bind(core));
            content.addEventListener("mousedown", this._onMouseDown_browser.bind(core));
            content.addEventListener("click", this._onClick_browser.bind(core));
            context.element.relative.appendChild(browser_div);
            browser_div = null, back = null, content = null;
          },
          set_browser: function(core) {
            const lang = core.lang;
            return '<div class="se-file-browser-content"><div class="se-file-browser-header"><button type="button" data-command="close" class="se-btn se-file-browser-close" class="close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + core.icons.cancel + '</button><span class="se-file-browser-title"></span><div class="se-file-browser-tags"></div></div><div class="se-file-browser-body"><div class="se-loading-box sun-editor-common"><div class="se-loading-effect"></div></div><div class="se-file-browser-list"></div></div></div>';
          },
          /**
           * @description Event to control the behavior of closing the browser
           * @param {MouseEvent} e Event object
           * @private
           */
          _onMouseDown_browser: function(e) {
            if (/se-file-browser-inner/.test(e.target.className)) {
              this.context.fileBrowser._closeSignal = true;
            } else {
              this.context.fileBrowser._closeSignal = false;
            }
          },
          /**
           * @description Event to close the window when the outside area of the browser or close button is click
           * @param {MouseEvent} e Event object
           * @private
           */
          _onClick_browser: function(e) {
            e.stopPropagation();
            if (/close/.test(e.target.getAttribute("data-command")) || this.context.fileBrowser._closeSignal) {
              this.plugins.fileBrowser.close.call(this);
            }
          },
          /**
           * @description Open a file browser plugin
           * @param {String} pluginName Plugin name using the file browser
           * @param {Function|null} selectorHandler When the function comes as an argument value, it substitutes "context.selectorHandler".
           */
          open: function(pluginName, selectorHandler) {
            if (this.plugins.fileBrowser._bindClose) {
              this._d.removeEventListener("keydown", this.plugins.fileBrowser._bindClose);
              this.plugins.fileBrowser._bindClose = null;
            }
            this.plugins.fileBrowser._bindClose = function(e) {
              if (!/27/.test(e.keyCode)) return;
              this.plugins.fileBrowser.close.call(this);
            }.bind(this);
            this._d.addEventListener("keydown", this.plugins.fileBrowser._bindClose);
            const fileBrowserContext = this.context.fileBrowser;
            fileBrowserContext.contextPlugin = pluginName;
            fileBrowserContext.selectorHandler = selectorHandler;
            const pluginContext = this.context[pluginName];
            const listClassName = pluginContext.listClass;
            if (!this.util.hasClass(fileBrowserContext.list, listClassName)) {
              fileBrowserContext.list.className = "se-file-browser-list " + listClassName;
            }
            if (this.options.popupDisplay === "full") {
              fileBrowserContext.area.style.position = "fixed";
            } else {
              fileBrowserContext.area.style.position = "absolute";
            }
            fileBrowserContext.titleArea.textContent = pluginContext.title;
            fileBrowserContext.area.style.display = "block";
            this.plugins.fileBrowser._drawFileList.call(this, this.context[pluginName].url, this.context[pluginName].header);
          },
          _bindClose: null,
          /**
           * @description Close a fileBrowser plugin
           * The plugin's "init" method is called.
           */
          close: function() {
            const fileBrowserPlugin = this.plugins.fileBrowser;
            if (fileBrowserPlugin._xmlHttp) {
              fileBrowserPlugin._xmlHttp.abort();
            }
            if (fileBrowserPlugin._bindClose) {
              this._d.removeEventListener("keydown", fileBrowserPlugin._bindClose);
              fileBrowserPlugin._bindClose = null;
            }
            const fileBrowserContext = this.context.fileBrowser;
            fileBrowserContext.area.style.display = "none";
            fileBrowserContext.selectorHandler = null;
            fileBrowserContext.selectedTags = [];
            fileBrowserContext.items = [];
            fileBrowserContext.list.innerHTML = fileBrowserContext.tagArea.innerHTML = fileBrowserContext.titleArea.textContent = "";
            if (typeof this.plugins[fileBrowserContext.contextPlugin].init === "function") this.plugins[fileBrowserContext.contextPlugin].init.call(this);
            fileBrowserContext.contextPlugin = "";
          },
          /**
           * @description Show file browser loading box
           */
          showBrowserLoading: function() {
            this._loading.style.display = "block";
          },
          /**
           * @description Close file browser loading box
           */
          closeBrowserLoading: function() {
            this._loading.style.display = "none";
          },
          _drawFileList: function(url, browserHeader) {
            const fileBrowserPlugin = this.plugins.fileBrowser;
            const xmlHttp = fileBrowserPlugin._xmlHttp = this.util.getXMLHttpRequest();
            xmlHttp.onreadystatechange = fileBrowserPlugin._callBackGet.bind(this, xmlHttp);
            xmlHttp.open("get", url, true);
            if (browserHeader !== null && typeof browserHeader === "object" && this._w.Object.keys(browserHeader).length > 0) {
              for (let key in browserHeader) {
                xmlHttp.setRequestHeader(key, browserHeader[key]);
              }
            }
            xmlHttp.send(null);
            this.plugins.fileBrowser.showBrowserLoading();
          },
          _callBackGet: function(xmlHttp) {
            if (xmlHttp.readyState === 4) {
              this.plugins.fileBrowser._xmlHttp = null;
              if (xmlHttp.status === 200) {
                try {
                  const res = JSON.parse(xmlHttp.responseText);
                  if (res.result.length > 0) {
                    this.plugins.fileBrowser._drawListItem.call(this, res.result, true);
                  } else if (res.nullMessage) {
                    this.context.fileBrowser.list.innerHTML = res.nullMessage;
                  }
                } catch (e) {
                  throw Error('[SUNEDITOR.fileBrowser.drawList.fail] cause : "' + e.message + '"');
                } finally {
                  this.plugins.fileBrowser.closeBrowserLoading();
                  this.context.fileBrowser.body.style.maxHeight = this._w.innerHeight - this.context.fileBrowser.header.offsetHeight - 50 + "px";
                }
              } else {
                this.plugins.fileBrowser.closeBrowserLoading();
                if (xmlHttp.status !== 0) {
                  const res = !xmlHttp.responseText ? xmlHttp : JSON.parse(xmlHttp.responseText);
                  const err = "[SUNEDITOR.fileBrowser.get.serverException] status: " + xmlHttp.status + ", response: " + (res.errorMessage || xmlHttp.responseText);
                  throw Error(err);
                }
              }
            }
          },
          _drawListItem: function(items, update) {
            const fileBrowserContext = this.context.fileBrowser;
            const pluginContext = this.context[fileBrowserContext.contextPlugin];
            const _tags = [];
            const len = items.length;
            const columnSize = pluginContext.columnSize || fileBrowserContext.columnSize;
            const splitSize = columnSize <= 1 ? 1 : Math.round(len / columnSize) || 1;
            const drawItemHandler = pluginContext.itemTemplateHandler;
            let tagsHTML = "";
            let listHTML = '<div class="se-file-item-column">';
            let columns = 1;
            for (let i = 0, item, tags; i < len; i++) {
              item = items[i];
              tags = !item.tag ? [] : typeof item.tag === "string" ? item.tag.split(",") : item.tag;
              tags = item.tag = tags.map(function(v) {
                return v.trim();
              });
              listHTML += drawItemHandler(item);
              if ((i + 1) % splitSize === 0 && columns < columnSize && i + 1 < len) {
                columns++;
                listHTML += '</div><div class="se-file-item-column">';
              }
              if (update && tags.length > 0) {
                for (let t = 0, tLen = tags.length, tag2; t < tLen; t++) {
                  tag2 = tags[t];
                  if (tag2 && _tags.indexOf(tag2) === -1) {
                    _tags.push(tag2);
                    tagsHTML += '<a title="' + tag2 + '" aria-label="' + tag2 + '">' + tag2 + "</a>";
                  }
                }
              }
            }
            listHTML += "</div>";
            fileBrowserContext.list.innerHTML = listHTML;
            if (update) {
              fileBrowserContext.items = items;
              fileBrowserContext.tagArea.innerHTML = tagsHTML;
              fileBrowserContext.tagElements = fileBrowserContext.tagArea.querySelectorAll("A");
            }
          },
          onClickTag: function(e) {
            const target = e.target;
            if (!this.util.isAnchor(target)) return;
            const tagName = target.textContent;
            const fileBrowserPlugin = this.plugins.fileBrowser;
            const fileBrowserContext = this.context.fileBrowser;
            const selectTag = fileBrowserContext.tagArea.querySelector('a[title="' + tagName + '"]');
            const selectedTags = fileBrowserContext.selectedTags;
            const sTagIndex = selectedTags.indexOf(tagName);
            if (sTagIndex > -1) {
              selectedTags.splice(sTagIndex, 1);
              this.util.removeClass(selectTag, "on");
            } else {
              selectedTags.push(tagName);
              this.util.addClass(selectTag, "on");
            }
            fileBrowserPlugin._drawListItem.call(
              this,
              selectedTags.length === 0 ? fileBrowserContext.items : fileBrowserContext.items.filter(function(item) {
                return item.tag.some(function(tag2) {
                  return selectedTags.indexOf(tag2) > -1;
                });
              }),
              false
            );
          },
          onClickFile: function(e) {
            e.preventDefault();
            e.stopPropagation();
            const fileBrowserContext = this.context.fileBrowser;
            const listEl = fileBrowserContext.list;
            let target = e.target;
            let command = null;
            if (target === listEl) return;
            while (listEl !== target.parentNode) {
              command = target.getAttribute("data-command");
              if (command) break;
              target = target.parentNode;
            }
            if (!command) return;
            const handler = fileBrowserContext.selectorHandler || this.context[fileBrowserContext.contextPlugin].selectorHandler;
            handler(target, target.parentNode.querySelector(".__se__img_name").textContent);
            this.plugins.fileBrowser.close.call(this);
          }
        };
        if (typeof noGlobal === "undefined") {
          if (!window2.SUNEDITOR_MODULES) {
            Object.defineProperty(window2, "SUNEDITOR_MODULES", {
              enumerable: true,
              writable: false,
              configurable: false,
              value: {}
            });
          }
          Object.defineProperty(window2.SUNEDITOR_MODULES, "fileBrowser", {
            enumerable: true,
            writable: false,
            configurable: false,
            value: fileBrowser2
          });
        }
        return fileBrowser2;
      });
    }
  });

  // ink-document-client-resolver:C:\Users\Win 10\dev\ink\packages\ink-web\src\pages\ui\form\index.ink
  var form_exports = {};
  __export(form_exports, {
    BUILD_ID: () => BUILD_ID,
    ClientRegistry: () => import_Registry34.default,
    TemplateDocument: () => TemplateDocument,
    components: () => components,
    data: () => import_data.default,
    elements: () => elements,
    emitter: () => import_Emitter.default
  });
  var import_Document = __toESM(require_Document());
  var import_Document2 = __toESM(require_Document2());
  var import_Registry34 = __toESM(require_Registry());
  var import_Emitter = __toESM(require_Emitter());
  var import_data = __toESM(require_data());

  // ink-component-resolver:C:\Users\Win 10\dev\ink\packages\ink-web\src\components\api\docs.ink
  var import_Registry = __toESM(require_Registry());
  var import_Component = __toESM(require_Component());
  var import_ink = __toESM(require_ink());
  var Docs_0ab1bce486b32e7cdafc = class extends import_Component.default {
    static id = "0ab1bce486b32e7cdafc";
    static tagname = "docs";
    static classname = "Docs_0ab1bce486b32e7cdafc";
    styles() {
      return ``;
    }
    template() {
      (0, import_ink.classlist)().add(
        "block",
        "w-full",
        "h-full",
        "scroll-y-auto",
        "scroll-x-hidden"
      );
      return () => [
        import_Registry.default.createText(`
`, false),
        import_Registry.default.createElement("article", { "class": `block p-10 tx-t-1` }, [
          ...this._toNodeList((0, import_ink.children)())
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\packages\ink-web\src\components\i18n\translate.ink
  var import_Registry2 = __toESM(require_Registry());
  var import_Component2 = __toESM(require_Component());

  // src/components/i18n/index.ts
  var _ = function(phrase, ...variables) {
    let translation = translate(phrase);
    for (let i = 0; i < variables.length; i++) {
      translation = translation.replace("%s", String(variables[i]));
    }
    return translation;
  };
  var translate = function(phrase) {
    return phrase;
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\packages\ink-web\src\components\i18n\translate.ink
  var Translate_794a00a5e900fca28310 = class extends import_Component2.default {
    static id = "794a00a5e900fca28310";
    static tagname = "translate";
    static classname = "Translate_794a00a5e900fca28310";
    styles() {
      return ``;
    }
    template() {
      const { trim = false, p = false, li = false, div = false } = this.props;
      const childlist = this.originalChildren;
      const phrase = [];
      const variables = [];
      for (const child of childlist) {
        if (typeof child === "string") {
          phrase.push(child);
        } else if (child instanceof Node && child.textContent) {
          phrase.push(child.textContent);
        } else {
          phrase.push("%s");
          variables.push(child);
        }
      }
      let words = phrase.join("");
      if (trim) {
        words = words.replace(/\s+/, " ").trim();
      }
      const chunks = translate(words).split("%s");
      const translations = [];
      for (let i = 0; i < chunks.length; i++) {
        translations.push(document.createTextNode(chunks[i]));
        if (variables[i]) {
          translations.push(variables[i]);
        }
      }
      return () => [
        import_Registry2.default.createText(`
    `, false),
        ...!!p ? [
          import_Registry2.default.createText(`
      `, false),
          import_Registry2.default.createElement("p", {}, [
            ...this._toNodeList(translations)
          ]).element,
          import_Registry2.default.createText(`
    `, false)
        ] : !!li ? [
          ,
          import_Registry2.default.createText(`
      `, false),
          import_Registry2.default.createElement("li", {}, [
            ...this._toNodeList(translations)
          ]).element,
          import_Registry2.default.createText(`
    `, false)
        ] : !!div ? [
          ,
          import_Registry2.default.createText(`
      `, false),
          import_Registry2.default.createElement("div", {}, [
            ...this._toNodeList(translations)
          ]).element,
          import_Registry2.default.createText(`
    `, false)
        ] : true ? [
          ,
          import_Registry2.default.createText(`
      `, false),
          ...this._toNodeList(translations),
          import_Registry2.default.createText(`
    `, false)
        ] : []
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\layout\panel.ink
  var import_Registry3 = __toESM(require_Registry());
  var import_Component3 = __toESM(require_Component());
  var Panel_c4c96a14064fc0c4d224 = class extends import_Component3.default {
    static id = "c4c96a14064fc0c4d224";
    static tagname = "panel";
    static classname = "Panel_c4c96a14064fc0c4d224";
    styles() {
      return ``;
    }
    template() {
      const panels = this.originalChildren;
      const section = {
        main: panels.find((panel) => panel.nodeName === "MAIN"),
        head: panels.find((panel) => panel.nodeName === "HEADER"),
        foot: panels.find((panel) => panel.nodeName === "FOOTER"),
        left: panels.find((panel) => panel.nodeName === "ASIDE" && panel.hasAttribute("left")),
        right: panels.find((panel) => panel.nodeName === "ASIDE" && panel.hasAttribute("right"))
      };
      const show = { left: false, right: false };
      this.toggle = (panel) => {
        show[panel] = !show[panel];
        setClassNames.all();
      };
      const setClassNames = {
        all() {
          section.main && this.main();
          section.head && this.head();
          section.foot && this.foot();
          section.left && this.left();
          section.right && this.right();
        },
        head() {
          const { classList } = section.head;
          classList.add("absolute", "top-0", "right-0", "h-60", "transition-500");
          if (section.left) {
            classList.remove("left-0");
            classList.add("left-226");
          } else {
            classList.remove("left-226");
            classList.add("left-0");
          }
          if (show.left) {
            classList.remove("md-left-0");
            classList.add("md-left-226");
          } else {
            classList.remove("md-left-226");
            classList.add("md-left-0");
          }
        },
        foot() {
          const { classList } = section.foot;
          classList.add("absolute", "bottom-0", "right-0", "h-60", "transition-500");
          if (section.left) {
            classList.remove("left-0");
            classList.add("left-226");
          } else {
            classList.remove("left-226");
            classList.add("left-0");
          }
          if (show.left) {
            classList.remove("md-left-0");
            classList.add("md-left-226");
          } else {
            classList.remove("md-left-226");
            classList.add("md-left-0");
          }
        },
        left() {
          const { classList } = section.left;
          classList.add("w-226", "absolute", "bottom-0", "left-0", "top-0", "transition-500");
          if (show.left) {
            classList.remove("md-left--226");
            classList.add("md-left-0");
          } else {
            classList.remove("md-left-0");
            classList.add("md-left--226");
          }
        },
        right() {
          const { classList } = section.right;
          classList.add("w-200", "absolute", "right-0", "transition-500");
          if (section.foot) {
            classList.remove("bottom-0");
            classList.add("bottom-60");
          } else {
            classList.remove("bottom-60");
            classList.add("bottom-0");
          }
          if (section.head) {
            classList.remove("top-0");
            classList.add("top-60");
          } else {
            classList.remove("top-60");
            classList.add("top-0");
          }
          if (show.right) {
            classList.remove("lg-right--200");
            classList.add("lg-right-0");
          } else {
            classList.remove("lg-right-0");
            classList.add("lg-right--200");
          }
        },
        main() {
          const { classList } = section.main;
          classList.add("absolute", "transition-500");
          if (section.head) {
            classList.remove("top-0");
            classList.add("top-60");
          } else {
            classList.remove("top-60");
            classList.add("top-0");
          }
          if (section.foot) {
            classList.remove("bottom-0");
            classList.add("bottom-60");
          } else {
            classList.remove("bottom-60");
            classList.add("bottom-0");
          }
          if (section.left) {
            classList.remove("left-0");
            classList.add("left-226");
          } else {
            classList.remove("left-226");
            classList.add("left-0");
          }
          if (section.right) {
            classList.remove("right-0");
            classList.add("right-200");
          } else {
            classList.remove("right-200");
            classList.add("right-0");
          }
          if (show.left) {
            classList.remove("md-left-0");
            classList.add("md-left-226");
          } else {
            classList.remove("md-left-226");
            classList.add("md-left-0");
          }
          if (show.right) {
            classList.remove("lg-right-0");
            classList.add("lg-right-200");
          } else {
            classList.remove("lg-right-200");
            classList.add("lg-right-0");
          }
        }
      };
      setClassNames.all();
      this.classList.add("block", "relative", "w-full", "vh", "scroll-hidden");
      return () => [
        import_Registry3.default.createText(`
`, false),
        ...this._toNodeList(panels)
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\form\button.ink
  var import_Registry4 = __toESM(require_Registry());
  var import_Component4 = __toESM(require_Component());
  var import_StyleSet = __toESM(require_StyleSet());
  var import_color = __toESM(require_color());
  var import_curve = __toESM(require_curve());
  var import_display = __toESM(require_display());
  var import_padding = __toESM(require_padding());
  var import_events = __toESM(require_events());
  var Button_8b2d9633875784010957 = class extends import_Component4.default {
    static id = "8b2d9633875784010957";
    static tagname = "button";
    static classname = "Button_8b2d9633875784010957";
    styles() {
      return `::slotted(button), ::slotted(a) {
    cursor: pointer;
    background: transparent;
    border: 0;
    box-sizing: border-box;
    color: inherit;
    cursor: pointer;
    display: block;
    font-family: inherit;
    font-size: inherit;
    height: 100%;
    text-align: inherit;
    text-decoration: none;
    width: 100%;
  }`;
    }
    template() {
      const {
        //display
        flex,
        none,
        inline: inline2,
        block: block2,
        "inline-block": iblock,
        "inline-flex": iflex,
        //spacing
        padding,
        "padding-x": paddingX,
        "padding-y": paddingY,
        //font color
        color,
        white,
        black,
        info,
        warning,
        success,
        error,
        muted,
        primary,
        secondary,
        theme,
        //font size
        size,
        xs,
        sm,
        md,
        lg,
        xl,
        xl2,
        xl3,
        xl4,
        xl5,
        //curve
        curve,
        curved,
        rounded,
        pill,
        //layouts
        outline,
        solid,
        transparent,
        //others
        full,
        href,
        //dont need these
        style,
        "class": _2,
        //for the button
        ...attributes
      } = this.props;
      const styles = new import_StyleSet.default();
      const css = this.styles();
      this.styles = () => css + styles.toString();
      const slotted = "::slotted(button), ::slotted(a)";
      (0, import_display.default)(this.props, styles, "inline-block", ":host");
      const pad = (0, import_padding.default)(this.props, styles, slotted);
      if (!pad) {
        xs ? styles.add(slotted, "padding", "2px 4px") : sm ? styles.add(slotted, "padding", "5px 10px") : md ? styles.add(slotted, "padding", "8px 16px") : lg ? styles.add(slotted, "padding", "12px 24px") : xl ? styles.add(slotted, "padding", "15px 30px") : xl2 ? styles.add(slotted, "padding", "18px 36px") : xl3 ? styles.add(slotted, "padding", "22px 44px") : xl4 ? styles.add(slotted, "padding", "26px 52px") : xl5 ? styles.add(slotted, "padding", "30px 60px") : null;
      }
      (0, import_curve.default)(this.props, styles, false, ":host");
      styles.add(":host", "text-align", "center");
      if (full) {
        styles.add(":host", "width", "100%");
      }
      if (outline || transparent) {
        (0, import_color.default)(this.props, styles, "var(--muted)", ":host", "color");
        (0, import_color.default)(this.props, styles, "var(--muted)", ":host", "border-color");
        styles.add(":host", "border-style", "solid");
        styles.add(":host", "border-width", "1px");
        if (outline) {
          styles.add(":host", "background-color", "var(--white)");
        }
      } else {
        styles.add(":host", "color", "var(--white)");
        (0, import_color.default)(this.props, styles, "var(--muted)", ":host", "background-color");
      }
      const children2 = this.getChildren(false);
      const attr = (0, import_events.removeEvents)(attributes);
      return () => [
        import_Registry4.default.createText(`
`, false),
        import_Registry4.default.createElement("template", { "type": `light` }, [
          import_Registry4.default.createText(`
  `, false),
          ...!!href ? [
            import_Registry4.default.createText(`
    `, false),
            import_Registry4.default.createElement("a", { ...attr, "href": href }, [
              ...this._toNodeList(children2)
            ]).element,
            import_Registry4.default.createText(`
  `, false)
          ] : true ? [
            ,
            import_Registry4.default.createText(`
    `, false),
            import_Registry4.default.createElement("button", { ...attr }, [
              ...this._toNodeList(children2)
            ]).element,
            import_Registry4.default.createText(`
  `, false)
          ] : [],
          import_Registry4.default.createText(`
`, false)
        ]).element,
        import_Registry4.default.createText(`
`, false),
        import_Registry4.default.createElement("template", { "type": `shadow` }, [
          import_Registry4.default.createText(`
  `, false),
          import_Registry4.default.createElement("slot", {}, []).element,
          import_Registry4.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\form\control.ink
  var import_Registry5 = __toESM(require_Registry());
  var import_Component5 = __toESM(require_Component());
  var import_StyleSet2 = __toESM(require_StyleSet());
  var Control_7df3c1a799ae50f9a174 = class extends import_Component5.default {
    static id = "7df3c1a799ae50f9a174";
    static tagname = "control";
    static classname = "Control_7df3c1a799ae50f9a174";
    styles() {
      return ``;
    }
    template() {
      const { label, error } = this.props;
      const styles = new import_StyleSet2.default();
      this.styles = () => styles.toString();
      styles.add(":host", "display", "block");
      styles.add("label", "display", "block");
      styles.add("label", "padding-bottom", "3px");
      styles.add("div", "padding-top", "3px");
      styles.add("div", "font-size", "0.90rem");
      if (error) {
        styles.add(":host", "color", "var(--error)");
      }
      return () => [
        import_Registry5.default.createText(`
`, false),
        ...!!!!label ? [
          import_Registry5.default.createText(`
  `, false),
          import_Registry5.default.createElement("label", {}, [
            ...this._toNodeList(label)
          ]).element,
          import_Registry5.default.createText(`
`, false)
        ] : [],
        import_Registry5.default.createText(`
`, false),
        import_Registry5.default.createElement("slot", {}, []).element,
        import_Registry5.default.createText(`
`, false),
        ...!!(!!error && error?.length > 0) ? [
          import_Registry5.default.createText(`
  `, false),
          import_Registry5.default.createElement("div", {}, [
            ...this._toNodeList(error)
          ]).element,
          import_Registry5.default.createText(`
`, false)
        ] : []
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\form\fieldset.ink
  var import_Registry6 = __toESM(require_Registry());
  var import_Component6 = __toESM(require_Component());
  var import_StyleSet3 = __toESM(require_StyleSet());
  var import_display2 = __toESM(require_display());
  var import_fieldset = __toESM(require_fieldset());
  var Fieldset_ef9b2ae0fcce531cd739 = class extends import_Component6.default {
    static id = "ef9b2ae0fcce531cd739";
    static tagname = "fieldset";
    static classname = "Fieldset_ef9b2ae0fcce531cd739";
    styles() {
      return `a {
    color: var(--error);
    display: inline-block;
    cursor: pointer;
    text-decoration: none;
    padding: 0 7px;
  }
  legend {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  button {
    box-sizing: border-box;
    cursor: pointer;
    display: inline-block;
    font-family: inherit;
    font-size: inherit;
    margin-top: 7px;
    text-align: center;
  }`;
    }
    template() {
      const { multiple, inputs, errors, add = "Add" } = this.props;
      const styles = new import_StyleSet3.default();
      const css = this.styles();
      this.styles = () => css + styles.toString();
      (0, import_display2.default)(this.props, styles, "block", ":host");
      (0, import_fieldset.borderStyles)(this.propsTree, styles);
      if (multiple) {
        (0, import_fieldset.buttonStyles)(this.props, styles);
      }
      const template = this.originalChildren;
      const handlers = (0, import_fieldset.getHandlers)(this, template);
      const initial = {
        inputs: (Array.isArray(inputs) ? inputs : [inputs]).map(
          (input) => input?.constructor.name === "Object" ? input : {}
        ),
        errors: (Array.isArray(errors) ? errors : [errors]).map(
          (errors2) => errors2?.constructor.name === "Object" ? errors2 : {}
        )
      };
      if (multiple && typeof inputs === "undefined") {
        initial.inputs = [];
      }
      const rows = multiple ? initial.inputs.map(
        (input, index) => handlers.create(
          index,
          input || {},
          initial.errors[index] || {}
        )
      ) : [handlers.set(
        initial.inputs[0] || {},
        initial.errors[0] || {}
      )];
      return () => [
        import_Registry6.default.createText(`
`, false),
        import_Registry6.default.createElement("template", { "type": `light` }, [
          import_Registry6.default.createText(`
  `, false),
          ...this._toNodeList(rows.map((row) => row.slot)),
          import_Registry6.default.createText(`
`, false)
        ]).element,
        import_Registry6.default.createText(`
`, false),
        import_Registry6.default.createElement("template", { "type": `shadow` }, [
          import_Registry6.default.createText(`
  `, false),
          ...this._toNodeList(rows.map((row) => row.fieldset)),
          import_Registry6.default.createText(`
  `, false),
          ...!!multiple ? [
            import_Registry6.default.createText(`
    `, false),
            import_Registry6.default.createElement("button", { "type": `button`, "click": handlers.add }, [
              ...this._toNodeList(add)
            ]).element,
            import_Registry6.default.createText(`
  `, false)
          ] : [],
          import_Registry6.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\color.ink
  var import_Registry7 = __toESM(require_Registry());
  var import_Component7 = __toESM(require_Component());
  var import_StyleSet4 = __toESM(require_StyleSet());
  var import_display3 = __toESM(require_display());
  var Color_a278209728128a71ca7a = class extends import_Component7.default {
    static id = "a278209728128a71ca7a";
    static tagname = "color";
    static classname = "Color_a278209728128a71ca7a";
    static observedAttributes = ["autocomplete", "disabled", "name", "readonly", "required", "value"];
    styles() {
      return `:host {
    background-color: var(--white);
    border: 1px solid var(--border);
  }
  div {
    align-items: stretch;
    display: flex;
  }
  div span:last-child {
    flex: 1;
    padding: 7px 7px 8px 0;
  }
  input {
    background-color: transparent;
    border: 0;
    box-sizing: border-box;
    font-size: inherit;
    font-family: inherit;
    height: 100%;
  }
  ::slotted(input) {
    background-color: transparent;
    border: 0;
    box-sizing: border-box;
    font-size: inherit;
    font-family: inherit;
    width: 100%;
  }
  ::slotted(input:focus) {
    outline: none;
  }`;
    }
    template() {
      const {
        //dont need these...
        style,
        "class": _2,
        //input attributes
        ...attributes
      } = this.props;
      const styles = new import_StyleSet4.default();
      const css = this.styles();
      this.styles = () => css + styles.toString();
      (0, import_display3.default)(this.props, styles, "inline-block", ":host");
      const handlers = {
        change: (e) => {
          const box = e.target;
          const input1 = this.querySelector("input");
          const input2 = this.shadowRoot?.querySelector("input");
          console.log("change", box.value, input1, input2);
          if (!input1 || !input2) return;
          input1.value = box.value;
          input1.setAttribute("value", box.value);
          input2.value = box.value;
          input2.setAttribute("value", box.value);
        },
        attribute: (e) => {
          const { action, name: name2, prev, value, target } = e.detail;
          const input1 = this.querySelector("input");
          const input2 = this.shadowRoot?.querySelector("input");
          if (!input1 || !input2) return;
          switch (action) {
            case "add":
            case "update":
              input1.setAttribute(name2, value);
              input2.setAttribute(name2, value);
              break;
            case "remove":
              input1.removeAttribute(name2);
              input2.removeAttribute(name2);
              break;
          }
        }
      };
      this.on("attributechange", handlers.attribute);
      return () => [
        import_Registry7.default.createText(`
`, false),
        import_Registry7.default.createElement("template", { "type": `light` }, [
          import_Registry7.default.createText(`
  `, false),
          import_Registry7.default.createElement("input", { ...attributes, "change": handlers.change }).element,
          import_Registry7.default.createText(`
`, false)
        ]).element,
        import_Registry7.default.createText(`
`, false),
        import_Registry7.default.createElement("template", { "type": `shadow` }, [
          import_Registry7.default.createText(`
  `, false),
          import_Registry7.default.createElement("div", {}, [
            import_Registry7.default.createText(`
    `, false),
            import_Registry7.default.createElement("span", {}, [
              import_Registry7.default.createElement("input", { "type": `color`, "change": handlers.change }).element
            ]).element,
            import_Registry7.default.createText(`
    `, false),
            import_Registry7.default.createElement("span", {}, [
              import_Registry7.default.createElement("slot", {}, []).element
            ]).element,
            import_Registry7.default.createText(`
  `, false)
          ]).element,
          import_Registry7.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\checkbox.ink
  var import_Registry8 = __toESM(require_Registry());
  var import_Field = __toESM(require_Field());
  var import_StyleSet5 = __toESM(require_StyleSet());
  var import_display4 = __toESM(require_display());
  var import_option = __toESM(require_option());
  var Checkbox_22993f1e10483a264a1f = class extends import_Field.default {
    static id = "22993f1e10483a264a1f";
    static tagname = "checkbox";
    static classname = "Checkbox_22993f1e10483a264a1f";
    static observedAttributes = ["checked", "disabled", "name", "readonly", "required", "value"];
    styles() {
      return ``;
    }
    template() {
      const { label = "", click, attributes } = (0, import_option.getProps)(this);
      const styles = new import_StyleSet5.default();
      this.styles = () => styles.toString();
      (0, import_display4.default)(this.props, styles, "inline-block", ":host");
      (0, import_option.setStyles)(this.props, styles, "check");
      const handlers = (0, import_option.getHandlers)(this);
      return () => [
        import_Registry8.default.createText(`
`, false),
        import_Registry8.default.createElement("label", { "mount": handlers.mount }, [
          import_Registry8.default.createText(`
  `, false),
          import_Registry8.default.createElement("input", { ...attributes, "type": `checkbox`, "change": handlers.change, "click": click }).element,
          import_Registry8.default.createText(`
  `, false),
          import_Registry8.default.createElement("span", {}, [
            ...this._toNodeList(label)
          ]).element,
          import_Registry8.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\country.ink
  var import_Registry9 = __toESM(require_Registry());
  var import_Component8 = __toESM(require_Component());

  // ../../node_modules/@stackpress/ink-ui/utilities/intl.json
  var intl_default = [
    {
      countryCode: "AD",
      countryName: "Andorra",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "AE",
      countryName: "United Arab Emirates",
      currencyType: "fiat",
      currencyCode: "AED",
      currencyName: "United Arab Emirates Dirham",
      currencyPlural: "UAE dirhams",
      currencySymbol: "AED",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "AF",
      countryName: "Afghanistan",
      currencyType: "fiat",
      currencyCode: "AFN",
      currencyName: "Afghan Afghani",
      currencyPlural: "Afghan Afghanis",
      currencySymbol: "Af",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "AL",
      countryName: "Albania",
      currencyType: "fiat",
      currencyCode: "ALL",
      currencyName: "Albanian Lek",
      currencyPlural: "Albanian lek\xEB",
      currencySymbol: "ALL",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "AM",
      countryName: "Armenia",
      currencyType: "fiat",
      currencyCode: "AMD",
      currencyName: "Armenian Dram",
      currencyPlural: "Armenian drams",
      currencySymbol: "AMD",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "AR",
      countryName: "Argentina",
      currencyType: "fiat",
      currencyCode: "ARS",
      currencyName: "Argentine Peso",
      currencyPlural: "Argentine pesos",
      currencySymbol: "AR$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "AS",
      countryName: "American Samoa",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "AT",
      countryName: "Austria",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "AU",
      countryName: "Australia",
      currencyType: "fiat",
      currencyCode: "AUD",
      currencyName: "Australian Dollar",
      currencyPlural: "Australian dollars",
      currencySymbol: "AU$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "AX",
      countryName: "\xC5land",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "AZ",
      countryName: "Azerbaijan",
      currencyType: "fiat",
      currencyCode: "AZN",
      currencyName: "Azerbaijani Manat",
      currencyPlural: "Azerbaijani manats",
      currencySymbol: "man.",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "BA",
      countryName: "Bosnia and Herzegovina",
      currencyType: "fiat",
      currencyCode: "BAM",
      currencyName: "Bosnia-Herzegovina Convertible Mark",
      currencyPlural: "Bosnia-Herzegovina convertible marks",
      currencySymbol: "KM",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "b",
      countryName: "Bangladesh",
      currencyType: "fiat",
      currencyCode: "bT",
      currencyName: "Bangladeshi Taka",
      currencyPlural: "Bangladeshi takas",
      currencySymbol: "Tk",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "BE",
      countryName: "Belgium",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "BF",
      countryName: "Burkina Faso",
      currencyType: "fiat",
      currencyCode: "XOF",
      currencyName: "CFA Franc BCEAO",
      currencyPlural: "CFA francs BCEAO",
      currencySymbol: "CFA",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "BG",
      countryName: "Bulgaria",
      currencyType: "fiat",
      currencyCode: "BGN",
      currencyName: "Bulgarian Lev",
      currencyPlural: "Bulgarian leva",
      currencySymbol: "BGN",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "BH",
      countryName: "Bahrain",
      currencyType: "fiat",
      currencyCode: "BHD",
      currencyName: "Bahraini Dinar",
      currencyPlural: "Bahraini dinars",
      currencySymbol: "b",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "BI",
      countryName: "Burundi",
      currencyType: "fiat",
      currencyCode: "BIF",
      currencyName: "Burundian Franc",
      currencyPlural: "Burundian francs",
      currencySymbol: "FBu",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "BJ",
      countryName: "Benin",
      currencyType: "fiat",
      currencyCode: "XOF",
      currencyName: "CFA Franc BCEAO",
      currencyPlural: "CFA francs BCEAO",
      currencySymbol: "CFA",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "BL",
      countryName: "Saint Barth\xE9lemy",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "BN",
      countryName: "Brunei",
      currencyType: "fiat",
      currencyCode: "BND",
      currencyName: "Brunei Dollar",
      currencyPlural: "Brunei dollars",
      currencySymbol: "BN$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "BO",
      countryName: "Bolivia",
      currencyType: "fiat",
      currencyCode: "BOB",
      currencyName: "Bolivian Boliviano",
      currencyPlural: "Bolivian bolivianos",
      currencySymbol: "Bs",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "BQ",
      countryName: "Bonaire",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "BR",
      countryName: "Brazil",
      currencyType: "fiat",
      currencyCode: "BRL",
      currencyName: "Brazilian Real",
      currencyPlural: "Brazilian reals",
      currencySymbol: "R$",
      currencyOrigin: true,
      language: "pt_BR"
    },
    {
      countryCode: "BV",
      countryName: "Bouvet Island",
      currencyType: "fiat",
      currencyCode: "NOK",
      currencyName: "Norwegian Krone",
      currencyPlural: "Norwegian kroner",
      currencySymbol: "Nkr",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "BW",
      countryName: "Botswana",
      currencyType: "fiat",
      currencyCode: "BWP",
      currencyName: "Botswanan Pula",
      currencyPlural: "Botswanan pulas",
      currencySymbol: "BWP",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "BZ",
      countryName: "Belize",
      currencyType: "fiat",
      currencyCode: "BZD",
      currencyName: "Belize Dollar",
      currencyPlural: "Belize dollars",
      currencySymbol: "BZ$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "CA",
      countryName: "Canada",
      currencyType: "fiat",
      currencyCode: "CAD",
      currencyName: "Canadian Dollar",
      currencyPlural: "Canadian dollars",
      currencySymbol: "CA$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "CC",
      countryName: "Cocos [Keeling] Islands",
      currencyType: "fiat",
      currencyCode: "AUD",
      currencyName: "Australian Dollar",
      currencyPlural: "Australian dollars",
      currencySymbol: "AU$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "CD",
      countryName: "Democratic Republic of the Congo",
      currencyType: "fiat",
      currencyCode: "CDF",
      currencyName: "Congolese Franc",
      currencyPlural: "Congolese francs",
      currencySymbol: "CDF",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "CF",
      countryName: "Central African Republic",
      currencyType: "fiat",
      currencyCode: "XAF",
      currencyName: "CFA Franc BEAC",
      currencyPlural: "CFA francs BEAC",
      currencySymbol: "FCFA",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "CG",
      countryName: "Republic of the Congo",
      currencyType: "fiat",
      currencyCode: "XAF",
      currencyName: "CFA Franc BEAC",
      currencyPlural: "CFA francs BEAC",
      currencySymbol: "FCFA",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "CH",
      countryName: "Switzerland",
      currencyType: "fiat",
      currencyCode: "CHF",
      currencyName: "Swiss Franc",
      currencyPlural: "Swiss francs",
      currencySymbol: "CHF",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "CI",
      countryName: "Ivory Coast",
      currencyType: "fiat",
      currencyCode: "XOF",
      currencyName: "CFA Franc BCEAO",
      currencyPlural: "CFA francs BCEAO",
      currencySymbol: "CFA",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "CK",
      countryName: "Cook Islands",
      currencyType: "fiat",
      currencyCode: "NZD",
      currencyName: "New Zealand Dollar",
      currencyPlural: "New Zealand dollars",
      currencySymbol: "NZ$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "CL",
      countryName: "Chile",
      currencyType: "fiat",
      currencyCode: "CLP",
      currencyName: "Chilean Peso",
      currencyPlural: "Chilean pesos",
      currencySymbol: "CL$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "CM",
      countryName: "Cameroon",
      currencyType: "fiat",
      currencyCode: "XAF",
      currencyName: "CFA Franc BEAC",
      currencyPlural: "CFA francs BEAC",
      currencySymbol: "FCFA",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "CN",
      countryName: "China",
      currencyType: "fiat",
      currencyCode: "CNY",
      currencyName: "Chinese Yuan",
      currencyPlural: "Chinese yuan",
      currencySymbol: "CN\xA5",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "CO",
      countryName: "Colombia",
      currencyType: "fiat",
      currencyCode: "COP",
      currencyName: "Colombian Peso",
      currencyPlural: "Colombian pesos",
      currencySymbol: "CO$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "CR",
      countryName: "Costa Rica",
      currencyType: "fiat",
      currencyCode: "CRC",
      currencyName: "Costa Rican Col\xF3n",
      currencyPlural: "Costa Rican col\xF3ns",
      currencySymbol: "\u20A1",
      currencyOrigin: true,
      language: "es"
    },
    {
      countryCode: "CV",
      countryName: "Cape Verde",
      currencyType: "fiat",
      currencyCode: "CVE",
      currencyName: "Cape Verdean Escudo",
      currencyPlural: "Cape Verdean escudos",
      currencySymbol: "CV$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "CX",
      countryName: "Christmas Island",
      currencyType: "fiat",
      currencyCode: "AUD",
      currencyName: "Australian Dollar",
      currencyPlural: "Australian dollars",
      currencySymbol: "AU$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "CY",
      countryName: "Cyprus",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "CZ",
      countryName: "Czechia",
      currencyType: "fiat",
      currencyCode: "CZK",
      currencyName: "Czech Republic Koruna",
      currencyPlural: "Czech Republic korunas",
      currencySymbol: "K\u010D",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "DE",
      countryName: "Germany",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "DJ",
      countryName: "Djibouti",
      currencyType: "fiat",
      currencyCode: "DJF",
      currencyName: "Djiboutian Franc",
      currencyPlural: "Djiboutian francs",
      currencySymbol: "Fdj",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "DK",
      countryName: "Denmark",
      currencyType: "fiat",
      currencyCode: "DKK",
      currencyName: "Danish Krone",
      currencyPlural: "Danish kroner",
      currencySymbol: "Dkr",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "DO",
      countryName: "Dominican Republic",
      currencyType: "fiat",
      currencyCode: "DOP",
      currencyName: "Dominican Peso",
      currencyPlural: "Dominican pesos",
      currencySymbol: "RD$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "DZ",
      countryName: "Algeria",
      currencyType: "fiat",
      currencyCode: "DZD",
      currencyName: "Algerian Dinar",
      currencyPlural: "Algerian dinars",
      currencySymbol: "DA",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "EC",
      countryName: "Ecuador",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "EE",
      countryName: "Estonia",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "EG",
      countryName: "Egypt",
      currencyType: "fiat",
      currencyCode: "EGP",
      currencyName: "Egyptian Pound",
      currencyPlural: "Egyptian pounds",
      currencySymbol: "EGP",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "EH",
      countryName: "Western Sahara",
      currencyType: "fiat",
      currencyCode: "MAD",
      currencyName: "Moroccan Dirham",
      currencyPlural: "Moroccan dirhams",
      currencySymbol: "MAD",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "ER",
      countryName: "Eritrea",
      currencyType: "fiat",
      currencyCode: "ERN",
      currencyName: "Eritrean Nakfa",
      currencyPlural: "Eritrean nakfas",
      currencySymbol: "Nfk",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "ES",
      countryName: "Spain",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "ET",
      countryName: "Ethiopia",
      currencyType: "fiat",
      currencyCode: "ETB",
      currencyName: "Ethiopian Birr",
      currencyPlural: "Ethiopian birrs",
      currencySymbol: "Br",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "FI",
      countryName: "Finland",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "FM",
      countryName: "Micronesia",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "FO",
      countryName: "Faroe Islands",
      currencyType: "fiat",
      currencyCode: "DKK",
      currencyName: "Danish Krone",
      currencyPlural: "Danish kroner",
      currencySymbol: "Dkr",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "FR",
      countryName: "France",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "GA",
      countryName: "Gabon",
      currencyType: "fiat",
      currencyCode: "XAF",
      currencyName: "CFA Franc BEAC",
      currencyPlural: "CFA francs BEAC",
      currencySymbol: "FCFA",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "GB",
      countryName: "United Kingdom",
      currencyType: "fiat",
      currencyCode: "GBP",
      currencyName: "British Pound Sterling",
      currencyPlural: "British pounds sterling",
      currencySymbol: "\xA3",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "GE",
      countryName: "Georgia",
      currencyType: "fiat",
      currencyCode: "GEL",
      currencyName: "Georgian Lari",
      currencyPlural: "Georgian laris",
      currencySymbol: "GEL",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "GF",
      countryName: "French Guiana",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "GG",
      countryName: "Guernsey",
      currencyType: "fiat",
      currencyCode: "GBP",
      currencyName: "British Pound Sterling",
      currencyPlural: "British pounds sterling",
      currencySymbol: "\xA3",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "GH",
      countryName: "Ghana",
      currencyType: "fiat",
      currencyCode: "GHS",
      currencyName: "Ghanaian Cedi",
      currencyPlural: "Ghanaian cedis",
      currencySymbol: "GH\u20B5",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "GL",
      countryName: "Greenland",
      currencyType: "fiat",
      currencyCode: "DKK",
      currencyName: "Danish Krone",
      currencyPlural: "Danish kroner",
      currencySymbol: "Dkr",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "GN",
      countryName: "Guinea",
      currencyType: "fiat",
      currencyCode: "GNF",
      currencyName: "Guinean Franc",
      currencyPlural: "Guinean francs",
      currencySymbol: "FG",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "GP",
      countryName: "Guadeloupe",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "GQ",
      countryName: "Equatorial Guinea",
      currencyType: "fiat",
      currencyCode: "XAF",
      currencyName: "CFA Franc BEAC",
      currencyPlural: "CFA francs BEAC",
      currencySymbol: "FCFA",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "GR",
      countryName: "Greece",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "GS",
      countryName: "South Georgia and the South Sandwich Islands",
      currencyType: "fiat",
      currencyCode: "GBP",
      currencyName: "British Pound Sterling",
      currencyPlural: "British pounds sterling",
      currencySymbol: "\xA3",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "GT",
      countryName: "Guatemala",
      currencyType: "fiat",
      currencyCode: "GTQ",
      currencyName: "Guatemalan Quetzal",
      currencyPlural: "Guatemalan quetzals",
      currencySymbol: "GTQ",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "GU",
      countryName: "Guam",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "GW",
      countryName: "Guinea-Bissau",
      currencyType: "fiat",
      currencyCode: "XOF",
      currencyName: "CFA Franc BCEAO",
      currencyPlural: "CFA francs BCEAO",
      currencySymbol: "CFA",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "HK",
      countryName: "Hong Kong",
      currencyType: "fiat",
      currencyCode: "HKD",
      currencyName: "Hong Kong Dollar",
      currencyPlural: "Hong Kong dollars",
      currencySymbol: "HK$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "HM",
      countryName: "Heard Island and McDonald Islands",
      currencyType: "fiat",
      currencyCode: "AUD",
      currencyName: "Australian Dollar",
      currencyPlural: "Australian dollars",
      currencySymbol: "AU$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "HN",
      countryName: "Honduras",
      currencyType: "fiat",
      currencyCode: "HNL",
      currencyName: "Honduran Lempira",
      currencyPlural: "Honduran lempiras",
      currencySymbol: "HNL",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "HR",
      countryName: "Croatia",
      currencyType: "fiat",
      currencyCode: "HRK",
      currencyName: "Croatian Kuna",
      currencyPlural: "Croatian kunas",
      currencySymbol: "kn",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "HU",
      countryName: "Hungary",
      currencyType: "fiat",
      currencyCode: "HUF",
      currencyName: "Hungarian Forint",
      currencyPlural: "Hungarian forints",
      currencySymbol: "Ft",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "ID",
      countryName: "Indonesia",
      currencyType: "fiat",
      currencyCode: "IDR",
      currencyName: "Indonesian Rupiah",
      currencyPlural: "Indonesian rupiahs",
      currencySymbol: "Rp",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "IE",
      countryName: "Ireland",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "IL",
      countryName: "Israel",
      currencyType: "fiat",
      currencyCode: "ILS",
      currencyName: "Israeli New Sheqel",
      currencyPlural: "Israeli new sheqels",
      currencySymbol: "\u20AA",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "IM",
      countryName: "Isle of Man",
      currencyType: "fiat",
      currencyCode: "GBP",
      currencyName: "British Pound Sterling",
      currencyPlural: "British pounds sterling",
      currencySymbol: "\xA3",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "IN",
      countryName: "India",
      currencyType: "fiat",
      currencyCode: "INR",
      currencyName: "Indian Rupee",
      currencyPlural: "Indian rupees",
      currencySymbol: "Rs",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "IO",
      countryName: "British Indian Ocean Territory",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "IQ",
      countryName: "Iraq",
      currencyType: "fiat",
      currencyCode: "IQD",
      currencyName: "Iraqi Dinar",
      currencyPlural: "Iraqi dinars",
      currencySymbol: "IQD",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "IR",
      countryName: "Iran",
      currencyType: "fiat",
      currencyCode: "IRR",
      currencyName: "Iranian Rial",
      currencyPlural: "Iranian rials",
      currencySymbol: "IRR",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "IS",
      countryName: "Iceland",
      currencyType: "fiat",
      currencyCode: "ISK",
      currencyName: "Icelandic Kr\xF3na",
      currencyPlural: "Icelandic kr\xF3nur",
      currencySymbol: "Ikr",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "IT",
      countryName: "Italy",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "JE",
      countryName: "Jersey",
      currencyType: "fiat",
      currencyCode: "GBP",
      currencyName: "British Pound Sterling",
      currencyPlural: "British pounds sterling",
      currencySymbol: "\xA3",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "JM",
      countryName: "Jamaica",
      currencyType: "fiat",
      currencyCode: "JMD",
      currencyName: "Jamaican Dollar",
      currencyPlural: "Jamaican dollars",
      currencySymbol: "J$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "JO",
      countryName: "Jordan",
      currencyType: "fiat",
      currencyCode: "JOD",
      currencyName: "Jordanian Dinar",
      currencyPlural: "Jordanian dinars",
      currencySymbol: "JD",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "JP",
      countryName: "Japan",
      currencyType: "fiat",
      currencyCode: "JPY",
      currencyName: "Japanese Yen",
      currencyPlural: "Japanese yen",
      currencySymbol: "\xA5",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "KE",
      countryName: "Kenya",
      currencyType: "fiat",
      currencyCode: "KES",
      currencyName: "Kenyan Shilling",
      currencyPlural: "Kenyan shillings",
      currencySymbol: "Ksh",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "KH",
      countryName: "Cambodia",
      currencyType: "fiat",
      currencyCode: "KHR",
      currencyName: "Cambodian Riel",
      currencyPlural: "Cambodian riels",
      currencySymbol: "KHR",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "KI",
      countryName: "Kiribati",
      currencyType: "fiat",
      currencyCode: "AUD",
      currencyName: "Australian Dollar",
      currencyPlural: "Australian dollars",
      currencySymbol: "AU$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "KM",
      countryName: "Comoros",
      currencyType: "fiat",
      currencyCode: "KMF",
      currencyName: "Comorian Franc",
      currencyPlural: "Comorian francs",
      currencySymbol: "CF",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "KR",
      countryName: "South Korea",
      currencyType: "fiat",
      currencyCode: "KRW",
      currencyName: "South Korean Won",
      currencyPlural: "South Korean won",
      currencySymbol: "\u20A9",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "KW",
      countryName: "Kuwait",
      currencyType: "fiat",
      currencyCode: "KWD",
      currencyName: "Kuwaiti Dinar",
      currencyPlural: "Kuwaiti dinars",
      currencySymbol: "KD",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "KZ",
      countryName: "Kazakhstan",
      currencyType: "fiat",
      currencyCode: "KZT",
      currencyName: "Kazakhstani Tenge",
      currencyPlural: "Kazakhstani tenges",
      currencySymbol: "KZT",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "LB",
      countryName: "Lebanon",
      currencyType: "fiat",
      currencyCode: "LBP",
      currencyName: "Lebanese Pound",
      currencyPlural: "Lebanese pounds",
      currencySymbol: "LB\xA3",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "LI",
      countryName: "Liechtenstein",
      currencyType: "fiat",
      currencyCode: "CHF",
      currencyName: "Swiss Franc",
      currencyPlural: "Swiss francs",
      currencySymbol: "CHF",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "LK",
      countryName: "Sri Lanka",
      currencyType: "fiat",
      currencyCode: "LKR",
      currencyName: "Sri Lankan Rupee",
      currencyPlural: "Sri Lankan rupees",
      currencySymbol: "SLRs",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "LT",
      countryName: "Lithuania",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "LU",
      countryName: "Luxembourg",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "LV",
      countryName: "Latvia",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "LY",
      countryName: "Libya",
      currencyType: "fiat",
      currencyCode: "LYD",
      currencyName: "Libyan Dinar",
      currencyPlural: "Libyan dinars",
      currencySymbol: "LD",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "MA",
      countryName: "Morocco",
      currencyType: "fiat",
      currencyCode: "MAD",
      currencyName: "Moroccan Dirham",
      currencyPlural: "Moroccan dirhams",
      currencySymbol: "MAD",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "MC",
      countryName: "Monaco",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "MD",
      countryName: "Moldova",
      currencyType: "fiat",
      currencyCode: "MDL",
      currencyName: "Moldovan Leu",
      currencyPlural: "Moldovan lei",
      currencySymbol: "MDL",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "ME",
      countryName: "Montenegro",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "MF",
      countryName: "Saint Martin",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "MG",
      countryName: "Madagascar",
      currencyType: "fiat",
      currencyCode: "MGA",
      currencyName: "Malagasy Ariary",
      currencyPlural: "Malagasy Ariaries",
      currencySymbol: "MGA",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "MH",
      countryName: "Marshall Islands",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "MK",
      countryName: "Macedonia",
      currencyType: "fiat",
      currencyCode: "MKD",
      currencyName: "Macedonian Denar",
      currencyPlural: "Macedonian denari",
      currencySymbol: "MKD",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "ML",
      countryName: "Mali",
      currencyType: "fiat",
      currencyCode: "XOF",
      currencyName: "CFA Franc BCEAO",
      currencyPlural: "CFA francs BCEAO",
      currencySymbol: "CFA",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "MM",
      countryName: "Myanmar [Burma]",
      currencyType: "fiat",
      currencyCode: "MMK",
      currencyName: "Myanma Kyat",
      currencyPlural: "Myanma kyats",
      currencySymbol: "MMK",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "MO",
      countryName: "Macao",
      currencyType: "fiat",
      currencyCode: "MOP",
      currencyName: "Macanese Pataca",
      currencyPlural: "Macanese patacas",
      currencySymbol: "MOP$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "MP",
      countryName: "Northern Mariana Islands",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "MQ",
      countryName: "Martinique",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "MT",
      countryName: "Malta",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "MU",
      countryName: "Mauritius",
      currencyType: "fiat",
      currencyCode: "MUR",
      currencyName: "Mauritian Rupee",
      currencyPlural: "Mauritian rupees",
      currencySymbol: "MURs",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "MX",
      countryName: "Mexico",
      currencyType: "fiat",
      currencyCode: "MXN",
      currencyName: "Mexican Peso",
      currencyPlural: "Mexican pesos",
      currencySymbol: "MX$",
      currencyOrigin: true,
      language: "es"
    },
    {
      countryCode: "MY",
      countryName: "Malaysia",
      currencyType: "fiat",
      currencyCode: "MYR",
      currencyName: "Malaysian Ringgit",
      currencyPlural: "Malaysian ringgits",
      currencySymbol: "RM",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "MZ",
      countryName: "Mozambique",
      currencyType: "fiat",
      currencyCode: "MZN",
      currencyName: "Mozambican Metical",
      currencyPlural: "Mozambican meticals",
      currencySymbol: "MTn",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "NA",
      countryName: "Namibia",
      currencyType: "fiat",
      currencyCode: "NAD",
      currencyName: "Namibian Dollar",
      currencyPlural: "Namibian dollars",
      currencySymbol: "N$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "NE",
      countryName: "Niger",
      currencyType: "fiat",
      currencyCode: "XOF",
      currencyName: "CFA Franc BCEAO",
      currencyPlural: "CFA francs BCEAO",
      currencySymbol: "CFA",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "NF",
      countryName: "Norfolk Island",
      currencyType: "fiat",
      currencyCode: "AUD",
      currencyName: "Australian Dollar",
      currencyPlural: "Australian dollars",
      currencySymbol: "AU$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "NG",
      countryName: "Nigeria",
      currencyType: "fiat",
      currencyCode: "NGN",
      currencyName: "Nigerian Naira",
      currencyPlural: "Nigerian nairas",
      currencySymbol: "\u20A6",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "NI",
      countryName: "Nicaragua",
      currencyType: "fiat",
      currencyCode: "NIO",
      currencyName: "Nicaraguan C\xF3rdoba",
      currencyPlural: "Nicaraguan c\xF3rdobas",
      currencySymbol: "C$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "NL",
      countryName: "Netherlands",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "NO",
      countryName: "Norway",
      currencyType: "fiat",
      currencyCode: "NOK",
      currencyName: "Norwegian Krone",
      currencyPlural: "Norwegian kroner",
      currencySymbol: "Nkr",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "NP",
      countryName: "Nepal",
      currencyType: "fiat",
      currencyCode: "NPR",
      currencyName: "Nepalese Rupee",
      currencyPlural: "Nepalese rupees",
      currencySymbol: "NPRs",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "NR",
      countryName: "Nauru",
      currencyType: "fiat",
      currencyCode: "AUD",
      currencyName: "Australian Dollar",
      currencyPlural: "Australian dollars",
      currencySymbol: "AU$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "NU",
      countryName: "Niue",
      currencyType: "fiat",
      currencyCode: "NZD",
      currencyName: "New Zealand Dollar",
      currencyPlural: "New Zealand dollars",
      currencySymbol: "NZ$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "NZ",
      countryName: "New Zealand",
      currencyType: "fiat",
      currencyCode: "NZD",
      currencyName: "New Zealand Dollar",
      currencyPlural: "New Zealand dollars",
      currencySymbol: "NZ$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "OM",
      countryName: "Oman",
      currencyType: "fiat",
      currencyCode: "OMR",
      currencyName: "Omani Rial",
      currencyPlural: "Omani rials",
      currencySymbol: "OMR",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "PA",
      countryName: "Panama",
      currencyType: "fiat",
      currencyCode: "PAB",
      currencyName: "Panamanian Balboa",
      currencyPlural: "Panamanian balboas",
      currencySymbol: "B/.",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "PE",
      countryName: "Peru",
      currencyType: "fiat",
      currencyCode: "PEN",
      currencyName: "Peruvian Nuevo Sol",
      currencyPlural: "Peruvian nuevos soles",
      currencySymbol: "S/.",
      currencyOrigin: true,
      language: "es"
    },
    {
      countryCode: "PH",
      countryName: "Philippines",
      currencyType: "fiat",
      currencyCode: "PHP",
      currencyName: "Philippine Peso",
      currencyPlural: "Philippine pesos",
      currencySymbol: "\u20B1",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "PK",
      countryName: "Pakistan",
      currencyType: "fiat",
      currencyCode: "PKR",
      currencyName: "Pakistani Rupee",
      currencyPlural: "Pakistani rupees",
      currencySymbol: "PKRs",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "PL",
      countryName: "Poland",
      currencyType: "fiat",
      currencyCode: "PLN",
      currencyName: "Polish Zloty",
      currencyPlural: "Polish zlotys",
      currencySymbol: "z\u0142",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "PM",
      countryName: "Saint Pierre and Miquelon",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "PN",
      countryName: "Pitcairn Islands",
      currencyType: "fiat",
      currencyCode: "NZD",
      currencyName: "New Zealand Dollar",
      currencyPlural: "New Zealand dollars",
      currencySymbol: "NZ$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "PR",
      countryName: "Puerto Rico",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "PS",
      countryName: "Palestine",
      currencyType: "fiat",
      currencyCode: "ILS",
      currencyName: "Israeli New Sheqel",
      currencyPlural: "Israeli new sheqels",
      currencySymbol: "\u20AA",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "PT",
      countryName: "Portugal",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "PW",
      countryName: "Palau",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "PY",
      countryName: "Paraguay",
      currencyType: "fiat",
      currencyCode: "PYG",
      currencyName: "Paraguayan Guarani",
      currencyPlural: "Paraguayan guaranis",
      currencySymbol: "\u20B2",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "QA",
      countryName: "Qatar",
      currencyType: "fiat",
      currencyCode: "QAR",
      currencyName: "Qatari Rial",
      currencyPlural: "Qatari rials",
      currencySymbol: "QR",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "RE",
      countryName: "R\xE9union",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "RO",
      countryName: "Romania",
      currencyType: "fiat",
      currencyCode: "RON",
      currencyName: "Romanian Leu",
      currencyPlural: "Romanian lei",
      currencySymbol: "RON",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "RS",
      countryName: "Serbia",
      currencyType: "fiat",
      currencyCode: "RSD",
      currencyName: "Serbian Dinar",
      currencyPlural: "Serbian dinars",
      currencySymbol: "din.",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "RU",
      countryName: "Russia",
      currencyType: "fiat",
      currencyCode: "RUB",
      currencyName: "Russian Ruble",
      currencyPlural: "Russian rubles",
      currencySymbol: "RUB",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "RW",
      countryName: "Rwanda",
      currencyType: "fiat",
      currencyCode: "RWF",
      currencyName: "Rwandan Franc",
      currencyPlural: "Rwandan francs",
      currencySymbol: "RWF",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "SA",
      countryName: "Saudi Arabia",
      currencyType: "fiat",
      currencyCode: "SAR",
      currencyName: "Saudi Riyal",
      currencyPlural: "Saudi riyals",
      currencySymbol: "SR",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "SD",
      countryName: "Sudan",
      currencyType: "fiat",
      currencyCode: "SDG",
      currencyName: "Sudanese Pound",
      currencyPlural: "Sudanese pounds",
      currencySymbol: "SDG",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "SE",
      countryName: "Sweden",
      currencyType: "fiat",
      currencyCode: "SEK",
      currencyName: "Swedish Krona",
      currencyPlural: "Swedish kronor",
      currencySymbol: "Skr",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "SG",
      countryName: "Singapore",
      currencyType: "fiat",
      currencyCode: "SGD",
      currencyName: "Singapore Dollar",
      currencyPlural: "Singapore dollars",
      currencySymbol: "S$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "SI",
      countryName: "Slovenia",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "SJ",
      countryName: "Svalbard and Jan Mayen",
      currencyType: "fiat",
      currencyCode: "NOK",
      currencyName: "Norwegian Krone",
      currencyPlural: "Norwegian kroner",
      currencySymbol: "Nkr",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "SK",
      countryName: "Slovakia",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "SM",
      countryName: "San Marino",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "SN",
      countryName: "Senegal",
      currencyType: "fiat",
      currencyCode: "XOF",
      currencyName: "CFA Franc BCEAO",
      currencyPlural: "CFA francs BCEAO",
      currencySymbol: "CFA",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "SO",
      countryName: "Somalia",
      currencyType: "fiat",
      currencyCode: "SOS",
      currencyName: "Somali Shilling",
      currencyPlural: "Somali shillings",
      currencySymbol: "Ssh",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "SV",
      countryName: "El Salvador",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "SY",
      countryName: "Syria",
      currencyType: "fiat",
      currencyCode: "SYP",
      currencyName: "Syrian Pound",
      currencyPlural: "Syrian pounds",
      currencySymbol: "SY\xA3",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "TC",
      countryName: "Turks and Caicos Islands",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "TD",
      countryName: "Chad",
      currencyType: "fiat",
      currencyCode: "XAF",
      currencyName: "CFA Franc BEAC",
      currencyPlural: "CFA francs BEAC",
      currencySymbol: "FCFA",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "TF",
      countryName: "French Southern Territories",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "TG",
      countryName: "Togo",
      currencyType: "fiat",
      currencyCode: "XOF",
      currencyName: "CFA Franc BCEAO",
      currencyPlural: "CFA francs BCEAO",
      currencySymbol: "CFA",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "TH",
      countryName: "Thailand",
      currencyType: "fiat",
      currencyCode: "THB",
      currencyName: "Thai Baht",
      currencyPlural: "Thai baht",
      currencySymbol: "\u0E3F",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "TK",
      countryName: "Tokelau",
      currencyType: "fiat",
      currencyCode: "NZD",
      currencyName: "New Zealand Dollar",
      currencyPlural: "New Zealand dollars",
      currencySymbol: "NZ$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "TL",
      countryName: "East Timor",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "TN",
      countryName: "Tunisia",
      currencyType: "fiat",
      currencyCode: "TND",
      currencyName: "Tunisian Dinar",
      currencyPlural: "Tunisian dinars",
      currencySymbol: "DT",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "TO",
      countryName: "Tonga",
      currencyType: "fiat",
      currencyCode: "TOP",
      currencyName: "Tongan Pa\u02BBanga",
      currencyPlural: "Tongan pa\u02BBanga",
      currencySymbol: "T$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "TR",
      countryName: "Turkey",
      currencyType: "fiat",
      currencyCode: "TRY",
      currencyName: "Turkish Lira",
      currencyPlural: "Turkish Lira",
      currencySymbol: "TL",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "TT",
      countryName: "Trinidad and Tobago",
      currencyType: "fiat",
      currencyCode: "TTD",
      currencyName: "Trinidad and Tobago Dollar",
      currencyPlural: "Trinidad and Tobago dollars",
      currencySymbol: "TT$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "TV",
      countryName: "Tuvalu",
      currencyType: "fiat",
      currencyCode: "AUD",
      currencyName: "Australian Dollar",
      currencyPlural: "Australian dollars",
      currencySymbol: "AU$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "TW",
      countryName: "Taiwan",
      currencyType: "fiat",
      currencyCode: "TWD",
      currencyName: "New Taiwan Dollar",
      currencyPlural: "New Taiwan dollars",
      currencySymbol: "NT$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "TZ",
      countryName: "Tanzania",
      currencyType: "fiat",
      currencyCode: "TZS",
      currencyName: "Tanzanian Shilling",
      currencyPlural: "Tanzanian shillings",
      currencySymbol: "TSh",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "UA",
      countryName: "Ukraine",
      currencyType: "fiat",
      currencyCode: "UAH",
      currencyName: "Ukrainian Hryvnia",
      currencyPlural: "Ukrainian hryvnias",
      currencySymbol: "\u20B4",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "UG",
      countryName: "Uganda",
      currencyType: "fiat",
      currencyCode: "UGX",
      currencyName: "Ugandan Shilling",
      currencyPlural: "Ugandan shillings",
      currencySymbol: "USh",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "UM",
      countryName: "U.S. Minor Outlying Islands",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "US",
      countryName: "United States",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "UY",
      countryName: "Uruguay",
      currencyType: "fiat",
      currencyCode: "UYU",
      currencyName: "Uruguayan Peso",
      currencyPlural: "Uruguayan pesos",
      currencySymbol: "$U",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "UZ",
      countryName: "Uzbekistan",
      currencyType: "fiat",
      currencyCode: "UZS",
      currencyName: "Uzbekistan Som",
      currencyPlural: "Uzbekistan som",
      currencySymbol: "UZS",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "VA",
      countryName: "Vatican City",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "VE",
      countryName: "Venezuela",
      currencyType: "fiat",
      currencyCode: "VEF",
      currencyName: "Venezuelan Bol\xEDvar",
      currencyPlural: "Venezuelan bol\xEDvars",
      currencySymbol: "Bs.F.",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "VG",
      countryName: "British Virgin Islands",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "VI",
      countryName: "U.S. Virgin Islands",
      currencyType: "fiat",
      currencyCode: "USD",
      currencyName: "US Dollar",
      currencyPlural: "US dollars",
      currencySymbol: "$",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "VN",
      countryName: "Vietnam",
      currencyType: "fiat",
      currencyCode: "VND",
      currencyName: "Vietnamese Dong",
      currencyPlural: "Vietnamese dong",
      currencySymbol: "\u20AB",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "XK",
      countryName: "Kosovo",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "YE",
      countryName: "Yemen",
      currencyType: "fiat",
      currencyCode: "YER",
      currencyName: "Yemeni Rial",
      currencyPlural: "Yemeni rials",
      currencySymbol: "YR",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "YT",
      countryName: "Mayotte",
      currencyType: "fiat",
      currencyCode: "EUR",
      currencyName: "Euro",
      currencyPlural: "euros",
      currencySymbol: "\u20AC",
      currencyOrigin: false,
      language: "en_US"
    },
    {
      countryCode: "ZA",
      countryName: "South Africa",
      currencyType: "fiat",
      currencyCode: "ZAR",
      currencyName: "South African Rand",
      currencyPlural: "South African rand",
      currencySymbol: "R",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "ZW",
      countryName: "Zimbabwe",
      currencyType: "fiat",
      currencyCode: "ZWL",
      currencyName: "Zimbabwean Dollar",
      currencyPlural: "Zimbabwean Dollar",
      currencySymbol: "ZWL$",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "BTC",
      countryName: "Bitcoin",
      currencyType: "crypto",
      currencyCode: "BTC",
      currencyName: "Bitcoin",
      currencyPlural: "bitcions",
      currencySymbol: "BTC",
      currencyOrigin: true,
      language: "en_US"
    },
    {
      countryCode: "ETH",
      countryName: "Ethereum",
      currencyType: "crypto",
      currencyCode: "ETH",
      currencyName: "Ether",
      currencyPlural: "ethers",
      currencySymbol: "ETH",
      currencyOrigin: true,
      language: "en_US"
    }
  ];

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\country.ink
  var import_select = __toESM(require_select());
  var Country_e24d0db854af71ec9fc5 = class extends import_Component8.default {
    static id = "e24d0db854af71ec9fc5";
    static tagname = "country";
    static classname = "Country_e24d0db854af71ec9fc5";
    static observedAttributes = ["name", "value"];
    styles() {
      return `.select {
    color: var(--black);
    position: relative;
  }
  .display {
    display: flex;
    align-items: center;
    padding: 7px;
    border: 1px solid var(--black);
    background-color: var(--white);
  }
  .selected {
    width: 100%;
    overflow: auto;
    display: flex;
    align-items: center;
    flex-grow: 1;
    gap: 5px;
    cursor: pointer;
    white-space: nowrap;
  }
  .placeholder {
    color: var(--muted);
    font-style: italic;
  }
  .count {
    display: inline-block;
    padding-left: 4px;
    color: var(--muted);
    font-size: 12px;
  }
  .clear, .toggle, .add {
    cursor: pointer;
  }
  .dropdown {
    background-color: var(--white);
    border: 1px solid var(--black);
    overflow: auto;
    position: absolute;
    width: 100%;
    max-height: 200px;
  }
  .form {
    display: flex;
    align-items: center;
    margin: 5px;
    padding: 7px;
    border: 1px solid var(--muted);
    height: 18px;
  }
  .input {
    flex-grow: 1;
    padding: 0;
    border: 0;
    background-color: transparent;
  }
  .input:focus {
    outline: none;
  }
  .search {
    color: var(--muted);
  }
  .options {
    overflow: auto;
    cursor: pointer;
  }
  .option {
    align-items: center;
    display: flex;
    padding: 7px;
  }
  .option img {
    height: 16px;
    margin-right: 5px;
  }
  .option:hover {
    background-color: var(--muted);
  }
  .selected .option {
    padding: 0;
  }
  .selected .option:hover {
    background-color: transparent;
  }`;
    }
    template() {
      const { name: name2, placeholder = "Select Country" } = this.props;
      const options2 = intl_default.map((country) => {
        const flag = this.createElement("img", {
          loading: "lazy",
          src: `https://flagcdn.com/w80/${country.countryCode.toLowerCase()}.png`
        });
        const label = this.createElement("span", {}, [
          new Text(country.countryName)
        ]);
        return this.createElement("div", {
          "class": "option",
          keyword: `${country.countryCode} ${country.countryName}`,
          value: country.countryCode
        }, [flag, label]).element;
      });
      const { state, clear, toggle, filter, add } = (0, import_select.getHandlers)(this, options2, false);
      return () => [
        import_Registry9.default.createText(`
`, false),
        import_Registry9.default.createElement("template", { "type": `light` }, [
          import_Registry9.default.createText(`
  `, false),
          ...!!name2 ? [
            import_Registry9.default.createText(`
    `, false),
            ...Object.entries(state.value.values).map(([_2, value]) => [
              import_Registry9.default.createText(`
      `, false),
              import_Registry9.default.createElement("input", { "type": `hidden`, "name": name2, "value": value.toString() }).element,
              import_Registry9.default.createText(`
    `, false)
            ]).flat(),
            import_Registry9.default.createText(`
  `, false)
          ] : [],
          import_Registry9.default.createText(`
`, false)
        ]).element,
        import_Registry9.default.createText(`
`, false),
        import_Registry9.default.createElement("template", { "type": `shadow` }, [
          import_Registry9.default.createText(`
  `, false),
          import_Registry9.default.createElement("link", { "rel": `stylesheet`, "type": `text/css`, "href": `https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css` }).element,
          import_Registry9.default.createText(`
  `, false),
          import_Registry9.default.createElement("div", { "class": `select` }, [
            import_Registry9.default.createText(`
    `, false),
            import_Registry9.default.createElement("div", { "class": `display` }, [
              import_Registry9.default.createText(`
      `, false),
              import_Registry9.default.createElement("div", { "class": `selected`, "click": toggle }, [
                import_Registry9.default.createText(`
        `, false),
                ...!!(state.value.selected.length > 0) ? [
                  import_Registry9.default.createText(`
          `, false),
                  ...this._toNodeList(state.value.selected),
                  import_Registry9.default.createText(`
        `, false)
                ] : !!placeholder ? [
                  ,
                  import_Registry9.default.createText(`
          `, false),
                  import_Registry9.default.createElement("span", { "class": `placeholder` }, [
                    import_Registry9.default.createText(`
            `, false),
                    ...this._toNodeList(placeholder),
                    import_Registry9.default.createText(`
          `, false)
                  ]).element,
                  import_Registry9.default.createText(`
        `, false)
                ] : [],
                import_Registry9.default.createText(`
      `, false)
              ]).element,
              import_Registry9.default.createText(`
      `, false),
              ...!!(state.value.selected.length > 1) ? [
                import_Registry9.default.createText(`
        `, false),
                import_Registry9.default.createElement("em", { "class": `count` }, [
                  import_Registry9.default.createText(`(`, false),
                  ...this._toNodeList(state.value.selected.length),
                  import_Registry9.default.createText(`)`, false)
                ]).element,
                import_Registry9.default.createText(`
      `, false)
              ] : [],
              import_Registry9.default.createText(`
      `, false),
              ...!!(state.value.selected.length > 0) ? [
                import_Registry9.default.createText(`
        `, false),
                import_Registry9.default.createElement("i", { "class": `clear fas fa-fw fa-times`, "click": clear }, []).element,
                import_Registry9.default.createText(`
      `, false)
              ] : [],
              import_Registry9.default.createText(`
      `, false),
              ...!!(state.value.filtered.length > 0 || state.value.query.length > 0) ? [
                import_Registry9.default.createText(`
        `, false),
                ...!!state.value.show ? [
                  import_Registry9.default.createText(`
          `, false),
                  import_Registry9.default.createElement("i", { "class": `toggle fas fa-fw fa-caret-up`, "click": toggle }, []).element,
                  import_Registry9.default.createText(`
        `, false)
                ] : true ? [
                  ,
                  import_Registry9.default.createText(`
          `, false),
                  import_Registry9.default.createElement("i", { "class": `toggle fas fa-fw fa-caret-down`, "click": toggle }, []).element,
                  import_Registry9.default.createText(`
        `, false)
                ] : [],
                import_Registry9.default.createText(`
      `, false)
              ] : [],
              import_Registry9.default.createText(`
    `, false)
            ]).element,
            import_Registry9.default.createText(`
    `, false),
            ...!!(state.value.show && (state.value.filtered.length > 0 || state.value.query.length > 0)) ? [
              import_Registry9.default.createText(`
      `, false),
              import_Registry9.default.createElement("div", { "class": `dropdown` }, [
                import_Registry9.default.createText(`
        `, false),
                import_Registry9.default.createElement("div", { "class": `form` }, [
                  import_Registry9.default.createText(`
          `, false),
                  import_Registry9.default.createElement("input", { "class": `input`, "value": state.value.query, "keyup": filter }).element,
                  import_Registry9.default.createText(`
          `, false),
                  import_Registry9.default.createElement("i", { "class": `search fas fa-fe fa-search` }, []).element,
                  import_Registry9.default.createText(`
        `, false)
                ]).element,
                import_Registry9.default.createText(`
        `, false),
                import_Registry9.default.createElement("div", { "class": `options` }, [
                  ...this._toNodeList(state.value.filtered)
                ]).element,
                import_Registry9.default.createText(`
      `, false)
              ]).element,
              import_Registry9.default.createText(`
    `, false)
            ] : [],
            import_Registry9.default.createText(`
  `, false)
          ]).element,
          import_Registry9.default.createText(`
`, false)
        ]).element,
        import_Registry9.default.createText(`
`, false)
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\currency.ink
  var import_Registry10 = __toESM(require_Registry());
  var import_Component9 = __toESM(require_Component());
  var import_select2 = __toESM(require_select());
  var Currency_f19a5f2e28ee751b9497 = class extends import_Component9.default {
    static id = "f19a5f2e28ee751b9497";
    static tagname = "currency";
    static classname = "Currency_f19a5f2e28ee751b9497";
    static observedAttributes = ["name", "value"];
    styles() {
      return `.select {
    color: var(--black);
    position: relative;
  }
  .display {
    display: flex;
    align-items: center;
    padding: 7px;
    border: 1px solid var(--black);
    background-color: var(--white);
  }
  .selected {
    width: 100%;
    overflow: auto;
    display: flex;
    align-items: center;
    flex-grow: 1;
    gap: 5px;
    cursor: pointer;
    white-space: nowrap;
  }
  .placeholder {
    color: var(--muted);
    font-style: italic;
  }
  .count {
    display: inline-block;
    padding-left: 4px;
    color: var(--muted);
    font-size: 12px;
  }
  .clear, .toggle, .add {
    cursor: pointer;
  }
  .dropdown {
    background-color: var(--white);
    border: 1px solid var(--black);
    overflow: auto;
    position: absolute;
    width: 100%;
    max-height: 200px;
  }
  .form {
    display: flex;
    align-items: center;
    margin: 5px;
    padding: 7px;
    border: 1px solid var(--muted);
    height: 18px;
  }
  .input {
    flex-grow: 1;
    padding: 0;
    border: 0;
    background-color: transparent;
  }
  .input:focus {
    outline: none;
  }
  .search {
    color: var(--muted);
  }
  .options {
    overflow: auto;
    cursor: pointer;
  }
  .option {
    align-items: center;
    display: flex;
    padding: 7px;
  }
  .option img {
    height: 16px;
    margin-right: 5px;
  }
  .option:hover {
    background-color: var(--muted);
  }
  .selected .option {
    padding: 0;
  }
  .selected .option:hover {
    background-color: transparent;
  }`;
    }
    template() {
      const { name: name2, placeholder = "Select Country" } = this.props;
      const options2 = intl_default.filter((country) => country.currencyOrigin).map((country) => {
        const flag = this.createElement("img", {
          loading: "lazy",
          src: `https://flagcdn.com/w80/${country.countryCode.toLowerCase()}.png`
        });
        const label = this.createElement("span", {}, [
          new Text(country.currencyName)
        ]);
        return this.createElement("div", {
          "class": "option",
          keyword: `${country.currencyCode} ${country.currencyName}`,
          value: country.currencyCode
        }, [flag, label]).element;
      });
      const { state, clear, toggle, filter, add } = (0, import_select2.getHandlers)(this, options2, false);
      return () => [
        import_Registry10.default.createText(`
`, false),
        import_Registry10.default.createElement("template", { "type": `light` }, [
          import_Registry10.default.createText(`
  `, false),
          ...!!name2 ? [
            import_Registry10.default.createText(`
    `, false),
            ...Object.entries(state.value.values).map(([_2, value]) => [
              import_Registry10.default.createText(`
      `, false),
              import_Registry10.default.createElement("input", { "type": `hidden`, "name": name2, "value": value.toString() }).element,
              import_Registry10.default.createText(`
    `, false)
            ]).flat(),
            import_Registry10.default.createText(`
  `, false)
          ] : [],
          import_Registry10.default.createText(`
`, false)
        ]).element,
        import_Registry10.default.createText(`
`, false),
        import_Registry10.default.createElement("template", { "type": `shadow` }, [
          import_Registry10.default.createText(`
  `, false),
          import_Registry10.default.createElement("link", { "rel": `stylesheet`, "type": `text/css`, "href": `https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css` }).element,
          import_Registry10.default.createText(`
  `, false),
          import_Registry10.default.createElement("div", { "class": `select` }, [
            import_Registry10.default.createText(`
    `, false),
            import_Registry10.default.createElement("div", { "class": `display` }, [
              import_Registry10.default.createText(`
      `, false),
              import_Registry10.default.createElement("div", { "class": `selected`, "click": toggle }, [
                import_Registry10.default.createText(`
        `, false),
                ...!!(state.value.selected.length > 0) ? [
                  import_Registry10.default.createText(`
          `, false),
                  ...this._toNodeList(state.value.selected),
                  import_Registry10.default.createText(`
        `, false)
                ] : !!placeholder ? [
                  ,
                  import_Registry10.default.createText(`
          `, false),
                  import_Registry10.default.createElement("span", { "class": `placeholder` }, [
                    import_Registry10.default.createText(`
            `, false),
                    ...this._toNodeList(placeholder),
                    import_Registry10.default.createText(`
          `, false)
                  ]).element,
                  import_Registry10.default.createText(`
        `, false)
                ] : [],
                import_Registry10.default.createText(`
      `, false)
              ]).element,
              import_Registry10.default.createText(`
      `, false),
              ...!!(state.value.selected.length > 1) ? [
                import_Registry10.default.createText(`
        `, false),
                import_Registry10.default.createElement("em", { "class": `count` }, [
                  import_Registry10.default.createText(`(`, false),
                  ...this._toNodeList(state.value.selected.length),
                  import_Registry10.default.createText(`)`, false)
                ]).element,
                import_Registry10.default.createText(`
      `, false)
              ] : [],
              import_Registry10.default.createText(`
      `, false),
              ...!!(state.value.selected.length > 0) ? [
                import_Registry10.default.createText(`
        `, false),
                import_Registry10.default.createElement("i", { "class": `clear fas fa-fw fa-times`, "click": clear }, []).element,
                import_Registry10.default.createText(`
      `, false)
              ] : [],
              import_Registry10.default.createText(`
      `, false),
              ...!!(state.value.filtered.length > 0 || state.value.query.length > 0) ? [
                import_Registry10.default.createText(`
        `, false),
                ...!!state.value.show ? [
                  import_Registry10.default.createText(`
          `, false),
                  import_Registry10.default.createElement("i", { "class": `toggle fas fa-fw fa-caret-up`, "click": toggle }, []).element,
                  import_Registry10.default.createText(`
        `, false)
                ] : true ? [
                  ,
                  import_Registry10.default.createText(`
          `, false),
                  import_Registry10.default.createElement("i", { "class": `toggle fas fa-fw fa-caret-down`, "click": toggle }, []).element,
                  import_Registry10.default.createText(`
        `, false)
                ] : [],
                import_Registry10.default.createText(`
      `, false)
              ] : [],
              import_Registry10.default.createText(`
    `, false)
            ]).element,
            import_Registry10.default.createText(`
    `, false),
            ...!!(state.value.show && (state.value.filtered.length > 0 || state.value.query.length > 0)) ? [
              import_Registry10.default.createText(`
      `, false),
              import_Registry10.default.createElement("div", { "class": `dropdown` }, [
                import_Registry10.default.createText(`
        `, false),
                import_Registry10.default.createElement("div", { "class": `form` }, [
                  import_Registry10.default.createText(`
          `, false),
                  import_Registry10.default.createElement("input", { "class": `input`, "value": state.value.query, "keyup": filter }).element,
                  import_Registry10.default.createText(`
          `, false),
                  import_Registry10.default.createElement("i", { "class": `search fas fa-fe fa-search` }, []).element,
                  import_Registry10.default.createText(`
        `, false)
                ]).element,
                import_Registry10.default.createText(`
        `, false),
                import_Registry10.default.createElement("div", { "class": `options` }, [
                  ...this._toNodeList(state.value.filtered)
                ]).element,
                import_Registry10.default.createText(`
      `, false)
              ]).element,
              import_Registry10.default.createText(`
    `, false)
            ] : [],
            import_Registry10.default.createText(`
  `, false)
          ]).element,
          import_Registry10.default.createText(`
`, false)
        ]).element,
        import_Registry10.default.createText(`
`, false)
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\date.ink
  var import_Registry11 = __toESM(require_Registry());
  var import_Component10 = __toESM(require_Component());
  var import_StyleSet6 = __toESM(require_StyleSet());
  var import_input = __toESM(require_input());
  var Date_af6eaa22db40ba187f7b = class extends import_Component10.default {
    static id = "af6eaa22db40ba187f7b";
    static tagname = "date";
    static classname = "Date_af6eaa22db40ba187f7b";
    static observedAttributes = ["autocomplete", "disabled", "name", "pattern", "readonly", "required", "value"];
    styles() {
      return ``;
    }
    template() {
      const {
        //handlers
        change,
        update,
        //input attributes
        attributes,
        //the rest of the props
        ...props
      } = (0, import_input.getProps)(this);
      const styles = new import_StyleSet6.default();
      this.styles = () => styles.toString();
      (0, import_input.setDefaultStyles)(props, styles);
      if (attributes.value) {
        try {
          attributes.value = attributes.value instanceof Date ? attributes.value.toISOString() : new Date(attributes.value).toISOString();
          attributes.value = attributes.value.split("T")[0];
        } catch (e) {
          delete attributes.value;
        }
      }
      const handlers = {
        change(e) {
          const utc = new Date(e.target.value).toUTCString();
          const datetime = new Date(utc).toISOString();
          const date = datetime.split("T")[0];
          change && change(e);
          update && update(date);
        },
        attribute(e) {
          let { action, name: name2, value, target } = e.detail;
          const input = target.querySelector("input");
          switch (action) {
            case "add":
            case "update":
              if (name2 === "value") {
                const utc = new Date(value).toUTCString();
                const datetime = new Date(utc).toISOString();
                value = datetime.split("T")[0];
              }
              input?.setAttribute(name2, value);
              break;
            case "remove":
              input?.removeAttribute(name2);
              break;
          }
        }
      };
      this.on("attributechange", handlers.attribute);
      return () => [
        import_Registry11.default.createText(`
`, false),
        import_Registry11.default.createElement("template", { "type": `light` }, [
          import_Registry11.default.createText(`
  `, false),
          import_Registry11.default.createElement("input", { ...attributes, "type": `date`, "change": handlers.change }).element,
          import_Registry11.default.createText(`
`, false)
        ]).element,
        import_Registry11.default.createText(`
`, false),
        import_Registry11.default.createElement("template", { "type": `shadow` }, [
          import_Registry11.default.createText(`
  `, false),
          import_Registry11.default.createElement("slot", {}, []).element,
          import_Registry11.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\datetime.ink
  var import_Registry12 = __toESM(require_Registry());
  var import_Component11 = __toESM(require_Component());
  var import_StyleSet7 = __toESM(require_StyleSet());
  var import_input2 = __toESM(require_input());
  var Datetime_b6d79d7c9e1a2f6724a8 = class extends import_Component11.default {
    static id = "b6d79d7c9e1a2f6724a8";
    static tagname = "datetime";
    static classname = "Datetime_b6d79d7c9e1a2f6724a8";
    static observedAttributes = ["autocomplete", "disabled", "name", "pattern", "readonly", "required", "value"];
    styles() {
      return ``;
    }
    template() {
      const {
        //handlers
        change,
        update,
        //input attributes
        attributes,
        //the rest of the props
        ...props
      } = (0, import_input2.getProps)(this);
      const styles = new import_StyleSet7.default();
      this.styles = () => styles.toString();
      (0, import_input2.setDefaultStyles)(props, styles);
      if (attributes.value) {
        try {
          attributes.value = attributes.value instanceof Date ? attributes.value.toISOString() : new Date(attributes.value).toISOString();
          attributes.value = attributes.value.replace("Z", "");
        } catch (e) {
          delete attributes.value;
        }
      }
      const handlers = {
        change(e) {
          const utc = new Date(e.target.value).toUTCString();
          const datetime = new Date(utc).toISOString().replace("Z", "");
          change && change(e);
          update && update(datetime);
        },
        attribute(e) {
          let { action, name: name2, value, target } = e.detail;
          const input = target.querySelector("input");
          switch (action) {
            case "add":
            case "update":
              if (name2 === "value") {
                const utc = new Date(value).toUTCString();
                value = new Date(utc).toISOString().replace("Z", "");
              }
              input?.setAttribute(name2, value);
              break;
            case "remove":
              input?.removeAttribute(name2);
              break;
          }
        }
      };
      this.on("attributechange", handlers.attribute);
      return () => [
        import_Registry12.default.createText(`
`, false),
        import_Registry12.default.createElement("template", { "type": `light` }, [
          import_Registry12.default.createText(`
  `, false),
          import_Registry12.default.createElement("input", { ...attributes, "type": `datetime-local`, "change": handlers.change }).element,
          import_Registry12.default.createText(`
`, false)
        ]).element,
        import_Registry12.default.createText(`
`, false),
        import_Registry12.default.createElement("template", { "type": `shadow` }, [
          import_Registry12.default.createText(`
  `, false),
          import_Registry12.default.createElement("slot", {}, []).element,
          import_Registry12.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\editor.ink
  var import_Registry13 = __toESM(require_Registry());
  var import_Component12 = __toESM(require_Component());
  var import_StyleSet8 = __toESM(require_StyleSet());
  var import_display5 = __toESM(require_display());
  var import_codemirror = __toESM(require_codemirror());
  var Editor_015bbef1a0403600489f = class extends import_Component12.default {
    static id = "015bbef1a0403600489f";
    static tagname = "editor";
    static classname = "Editor_015bbef1a0403600489f";
    styles() {
      return `.CodeMirror {
    font-family: monospace;
    height: 100%;
    color: black;
  }

  .CodeMirror-lines {
    padding: 4px 0;
  }
  .CodeMirror pre {
    padding: 0 4px;
  }

  .CodeMirror-scrollbar-filler, 
  .CodeMirror-gutter-filler {
    background-color: white; 
  }

  .CodeMirror-gutters {
    border-right: 1px solid #DDDDDD;
    background-color: #F7F7F7;
    white-space: nowrap;
  }
  .CodeMirror-linenumbers {}
  .CodeMirror-linenumber {
    padding: 0 3px 0 5px;
    min-width: 20px;
    text-align: right;
    color: #999999;
    white-space: nowrap;
  }

  .CodeMirror-guttermarker { 
    color: black; 
  }
  .CodeMirror-guttermarker-subtle { 
    color: #999999; 
  }

  .CodeMirror-cursor {
    border-left: 1px solid black;
    border-right: none;
    width: 0;
  }
  .CodeMirror div.CodeMirror-secondarycursor {
    border-left: 1px solid silver;
  }
  .cm-fat-cursor .CodeMirror-cursor {
    width: auto;
    border: 0;
    background: #77EE77;
  }
  .cm-fat-cursor div.CodeMirror-cursors {
    z-index: 1;
  }

  .cm-animate-fat-cursor {
    -moz-animation: blink 1.06s steps(1) infinite;
    -webkit-animation: blink 1.06s steps(1) infinite;
    animation: blink 1.06s steps(1) infinite;
    border: 0;
    background-color: #77EE77;
    width: auto;
  }
  @-moz-keyframes blink {
    0% {}
    50% { 
      background-color: transparent; 
    }
    100% {}
  }
  @-webkit-keyframes blink {
    0% {}
    50% { 
      background-color: transparent; 
    }
    100% {}
  }
  @keyframes blink {
    0% {}
    50% { 
      background-color: transparent; 
    }
    100% {}
  }

  .CodeMirror-overwrite .CodeMirror-cursor {}

  .cm-tab { 
    display: inline-block; 
    text-decoration: inherit; 
  }

  .CodeMirror-ruler {
    border-left: 1px solid #CCCCCC;
    position: absolute;
  }

  .cm-s-default .cm-header {
    color: blue;
  }
  .cm-s-default .cm-quote {
    color: #009900;
  }
  .cm-negative {
    color: #DD4444;
  }
  .cm-positive {
    color: #229922;
  }
  .cm-header, .cm-strong {
    font-weight: bold;
  }
  .cm-em {
    font-style: italic;
  }
  .cm-link {
    text-decoration: underline;
  }
  .cm-strikethrough {
    text-decoration: line-through;
  }

  .cm-s-default .cm-keyword {
    color: #770088;
  }
  .cm-s-default .cm-atom {
    color: #221199;
  }
  .cm-s-default .cm-number {
    color: #116644;
  }
  .cm-s-default .cm-def {
    color: #0000FF;
  }
  .cm-s-default .cm-variable,
  .cm-s-default .cm-punctuation,
  .cm-s-default .cm-property,
  .cm-s-default .cm-operator {}
  .cm-s-default .cm-variable-2 {
    color: #0055AA;
  }
  .cm-s-default .cm-variable-3 {
    color: #008855;
  }
  .cm-s-default .cm-comment {
    color: #AA5500;
  }
  .cm-s-default .cm-string {
    color: #AA1111;
  }
  .cm-s-default .cm-string-2 {
    color: #FF5500;
  }
  .cm-s-default .cm-meta {
    color: #555555;
  }
  .cm-s-default .cm-qualifier {
    color: #555555;
  }
  .cm-s-default .cm-builtin {
    color: #3300AA;
  }
  .cm-s-default .cm-bracket {
    color: #999977;
  }
  .cm-s-default .cm-tag {
    color: #117700;
  }
  .cm-s-default .cm-attribute {
    color: #0000CC;
  }
  .cm-s-default .cm-hr {
    color: #999999;
  }
  .cm-s-default .cm-link {
    color: #0000CC;
  }

  .cm-s-default .cm-error {
    color: #FF0000;
  }
  .cm-invalidchar {
    color: #FF0000;
  }

  .CodeMirror-composing { 
    border-bottom: 2px solid; 
  }

  div.CodeMirror span.CodeMirror-matchingbracket {
    color: #00FF00;
  }
  div.CodeMirror span.CodeMirror-nonmatchingbracket {
    color: #FF2222;
  }
  .CodeMirror-matchingtag { 
    background: rgba(255, 150, 0, .3); 
  }
  .CodeMirror-activeline-background {
    background: #E8F2FF;
  }

  .CodeMirror {
    position: relative;
    overflow: hidden;
    background: white;
  }

  .CodeMirror-scroll {
    overflow: scroll !important; 
    margin-bottom: -30px; margin-right: -30px;
    padding-bottom: 30px;
    height: 100%;
    outline: none; 
    position: relative;
  }
  .CodeMirror-sizer {
    position: relative;
    border-right: 30px solid transparent;
  }

  .CodeMirror-vscrollbar, 
  .CodeMirror-hscrollbar, 
  .CodeMirror-scrollbar-filler, 
  .CodeMirror-gutter-filler {
    position: absolute;
    z-index: 6;
    display: none;
  }
  .CodeMirror-vscrollbar {
    right: 0; top: 0;
    overflow-x: hidden;
    overflow-y: scroll;
  }
  .CodeMirror-hscrollbar {
    bottom: 0; left: 0;
    overflow-y: hidden;
    overflow-x: scroll;
  }
  .CodeMirror-scrollbar-filler {
    right: 0; bottom: 0;
  }
  .CodeMirror-gutter-filler {
    left: 0; bottom: 0;
  }

  .CodeMirror-gutters {
    position: absolute; left: 0; top: 0;
    min-height: 100%;
    z-index: 3;
  }
  .CodeMirror-gutter {
    white-space: normal;
    height: 100%;
    display: inline-block;
    vertical-align: top;
    margin-bottom: -30px;
  }
  .CodeMirror-gutter-wrapper {
    position: absolute;
    z-index: 4;
    background: none !important;
    border: none !important;
  }
  .CodeMirror-gutter-background {
    position: absolute;
    top: 0; bottom: 0;
    z-index: 4;
  }
  .CodeMirror-gutter-elt {
    position: absolute;
    cursor: default;
    z-index: 4;
  }
  .CodeMirror-gutter-wrapper {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
  }

  .CodeMirror-lines {
    cursor: text;
    min-height: 1px;
  }
  .CodeMirror pre {
    -moz-border-radius: 0; 
    -webkit-border-radius: 0; 
    border-radius: 0;
    border-width: 0;
    background: transparent;
    font-family: inherit;
    font-size: inherit;
    margin: 0;
    white-space: pre;
    word-wrap: normal;
    line-height: inherit;
    color: inherit;
    z-index: 2;
    position: relative;
    overflow: visible;
    -webkit-tap-highlight-color: transparent;
    -webkit-font-variant-ligatures: none;
    font-variant-ligatures: none;
  }
  .CodeMirror-wrap pre {
    word-wrap: break-word;
    white-space: pre-wrap;
    word-break: normal;
  }

  .CodeMirror-linebackground {
    position: absolute;
    left: 0; right: 0; top: 0; bottom: 0;
    z-index: 0;
  }

  .CodeMirror-linewidget {
    position: relative;
    z-index: 2;
    overflow: auto;
  }

  .CodeMirror-widget {}

  .CodeMirror-code {
    outline: none;
  }

  .CodeMirror-scroll,
  .CodeMirror-sizer,
  .CodeMirror-gutter,
  .CodeMirror-gutters,
  .CodeMirror-linenumber {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
  }

  .CodeMirror-measure {
    position: absolute;
    width: 100%;
    height: 0;
    overflow: hidden;
    visibility: hidden;
  }

  .CodeMirror-cursor { 
    position: absolute; 
  }
  .CodeMirror-measure pre { 
    position: static; 
  }

  div.CodeMirror-cursors {
    visibility: hidden;
    position: relative;
    z-index: 3;
  }
  div.CodeMirror-dragcursors {
    visibility: visible;
  }

  .CodeMirror-focused div.CodeMirror-cursors {
    visibility: visible;
  }

  .CodeMirror-selected { 
    background: #D9D9D9; 
  }
  .CodeMirror-focused .CodeMirror-selected { 
    background: #D7D4F0; 
  }
  .CodeMirror-crosshair { 
    cursor: crosshair; 
  }
  .CodeMirror-line::selection, 
  .CodeMirror-line > span::selection, 
  .CodeMirror-line > span > span::selection { 
    background: #D7D4F0; 
  }
  .CodeMirror-line::-moz-selection, 
  .CodeMirror-line > span::-moz-selection, 
  .CodeMirror-line > span > span::-moz-selection { 
    background: #D7D4F0; 
  }

  .cm-searching {
    background: #FFFFAA;
    background: rgba(255, 255, 0, .4);
  }

  .cm-force-border { 
    padding-right: .1px; 
  }

  @media print {
    .CodeMirror div.CodeMirror-cursors {
      visibility: hidden;
    }
  }

  .cm-tab-wrap-hack:after { 
    content: ''; 
  }

  span.CodeMirror-selectedtext { 
    background: none; 
  }`;
    }
    template() {
      const {
        lang = "htmlmixed",
        numbers,
        change,
        update,
        value,
        //dont need these...
        style,
        "class": _2,
        //input attributes
        ...attributes
      } = this.props;
      const styles = new import_StyleSet8.default();
      const css = this.styles();
      this.styles = () => css + styles.toString();
      (0, import_display5.default)(this.props, styles, "block", ":host");
      const children2 = this.originalChildren;
      const handlers = {
        update: (textarea, value2) => {
          textarea.value = value2;
          textarea.dispatchEvent(new Event("change", { bubbles: true }));
        },
        change: (e) => {
          const textarea = this.querySelector("textarea");
          if (textarea) {
            textarea.value = e.target.value;
          }
          change && change(e);
          update && update(e.target.value);
        },
        init: (mode, textarea) => {
          const defaultValue = textarea.value || value;
          this._editor = import_codemirror.default.fromTextArea(textarea, {
            mode,
            lineNumbers: numbers,
            tabSize: 2
          });
          defaultValue && this._editor.setValue(defaultValue);
          this._editor.on("change", () => handlers.update(
            textarea,
            this._editor.getValue()
          ));
        },
        mount: () => {
          const textarea = this.shadowRoot?.querySelector("textarea");
          if (!textarea) return;
          switch (lang) {
            case "md":
            case "markdown":
              Promise.resolve().then(() => __toESM(require_markdown())).then(() => handlers.init("markdown", textarea));
              break;
            case "css":
              Promise.resolve().then(() => __toESM(require_css())).then(() => handlers.init("css", textarea));
              break;
            case "js":
            case "javascript":
              Promise.resolve().then(() => __toESM(require_javascript())).then(() => handlers.init("javascript", textarea));
              break;
            case "json":
              Promise.resolve().then(() => __toESM(require_javascript())).then(() => handlers.init("application/json", textarea));
              break;
            case "ts":
            case "typescript":
              Promise.resolve().then(() => __toESM(require_javascript())).then(() => handlers.init("application/typescript", textarea));
              break;
            case "html":
            case "htmlmixed":
            default:
              Promise.resolve().then(() => __toESM(require_htmlmixed())).then(() => handlers.init("htmlmixed", textarea));
              break;
          }
        }
      };
      return () => [
        import_Registry13.default.createText(`
`, false),
        import_Registry13.default.createElement("template", { "type": `light` }, [
          import_Registry13.default.createText(`
  `, false),
          import_Registry13.default.createElement("textarea", { ...attributes, "value": value }, [
            ...this._toNodeList(children2)
          ]).element,
          import_Registry13.default.createText(`
`, false)
        ]).element,
        import_Registry13.default.createText(`
`, false),
        import_Registry13.default.createElement("template", { "type": `shadow` }, [
          import_Registry13.default.createText(`
  `, false),
          import_Registry13.default.createElement("textarea", { ...attributes, "mount": handlers.mount, "change": handlers.change, "value": value }, [
            ...this._toNodeList(children2)
          ]).element,
          import_Registry13.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\file.ink
  var import_Registry15 = __toESM(require_Registry());
  var import_Component14 = __toESM(require_Component());

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\input.ink
  var import_Registry14 = __toESM(require_Registry());
  var import_Component13 = __toESM(require_Component());
  var import_StyleSet9 = __toESM(require_StyleSet());
  var import_input3 = __toESM(require_input());
  var Input_cb7a6224432a087beaf2 = class extends import_Component13.default {
    static id = "cb7a6224432a087beaf2";
    static tagname = "input";
    static classname = "Input_cb7a6224432a087beaf2";
    static observedAttributes = ["accept", "autocomplete", "checked", "disabled", "max", "min", "multiple", "name", "pattern", "placeholder", "readonly", "required", "step", "type", "value"];
    styles() {
      return ``;
    }
    template() {
      const {
        //handlers
        change,
        update,
        //input attributes
        attributes,
        //the rest of the props
        ...props
      } = (0, import_input3.getProps)(this);
      const styles = new import_StyleSet9.default();
      this.styles = () => styles.toString();
      (0, import_input3.setDefaultStyles)(props, styles);
      const handlers = (0, import_input3.getHandlers)(this, change, update);
      return () => [
        import_Registry14.default.createText(`
`, false),
        import_Registry14.default.createElement("template", { "type": `light` }, [
          import_Registry14.default.createText(`
  `, false),
          import_Registry14.default.createElement("input", { ...attributes, "change": handlers.change }).element,
          import_Registry14.default.createText(`
`, false)
        ]).element,
        import_Registry14.default.createText(`
`, false),
        import_Registry14.default.createElement("template", { "type": `shadow` }, [
          import_Registry14.default.createText(`
  `, false),
          import_Registry14.default.createElement("slot", {}, []).element,
          import_Registry14.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\file.ink
  var import_StyleSet10 = __toESM(require_StyleSet());
  var import_display6 = __toESM(require_display());
  var import_signal = __toESM(require_signal());
  var File_e1ccc97731cc5c06477e = class extends import_Component14.default {
    static id = "e1ccc97731cc5c06477e";
    static tagname = "file";
    static classname = "File_e1ccc97731cc5c06477e";
    styles() {
      return `div {
    background-color: var(--white);
    border: 1px solid var(--black);
    box-sizing: border-box;
    color: var(--black);
    display: flex;
    align-items: center;
    padding-right: 7px;
  }
  span {
    display: inline-block;
    flex-grow: 1;
    overflow: hidden;
    padding: 7px;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  a {
    display: inline-block;
    flex-grow: 1;
    overflow: hidden;
    padding: 7px;
    text-overflow: ellipsis;
    white-space: nowrap;
    color: var(--black);
    text-decoration: underline;
  }
  em {
    cursor: pointer;
    font-size: 20px;
    margin-top: -2px;
    color: var(--error);
  }
  img {
    height: 32px;
  }
  img + a {
    padding: 7px 4px;
  }`;
    }
    template() {
      const {
        image,
        uploading = "Uploading...",
        name: name2,
        value,
        change,
        update,
        upload,
        //dont need these...
        style,
        "class": _2,
        ...attributes
      } = this.props;
      const styles = new import_StyleSet10.default();
      const css = this.styles();
      this.styles = () => css + styles.toString();
      (0, import_display6.default)(this.props, styles, "inline-block");
      const state = (0, import_signal.default)({ uploading: false, url: value });
      const handlers = {
        change: (e) => {
          if (upload && e.target.files?.length) {
            state.value = { ...state.value, uploading: true };
            upload(e.target.files[0], (url) => {
              state.value = { url, uploading: false };
              update && update(url);
            });
          }
          change && change(e);
        },
        reset: () => {
          state.value = { uploading: false, url: void 0 };
        }
      };
      return () => [
        import_Registry15.default.createText(`
`, false),
        import_Registry15.default.createElement("template", { "type": `light` }, [
          import_Registry15.default.createText(`
  `, false),
          ...!!(name2 && state.value.url) ? [
            import_Registry15.default.createText(`
    `, false),
            import_Registry15.default.createElement("input", { "name": name2, "type": `hidden`, "value": state.value.url }).element,
            import_Registry15.default.createText(`
  `, false)
          ] : [],
          import_Registry15.default.createText(`
`, false)
        ]).element,
        import_Registry15.default.createText(`
`, false),
        import_Registry15.default.createElement("template", { "type": `shadow` }, [
          import_Registry15.default.createText(`
  `, false),
          ...!!(!state.value.url && !state.value.uploading) ? [
            import_Registry15.default.createText(`
    `, false),
            ...!!image ? [
              import_Registry15.default.createText(`
      `, false),
              import_Registry15.default.createComponent("field-input", Input_cb7a6224432a087beaf2, { ...attributes, "type": `file`, "accept": `image/*`, "change": handlers.change }).element,
              import_Registry15.default.createText(`
    `, false)
            ] : true ? [
              ,
              import_Registry15.default.createText(`
      `, false),
              import_Registry15.default.createComponent("field-input", Input_cb7a6224432a087beaf2, { ...attributes, "type": `file`, "change": handlers.change }).element,
              import_Registry15.default.createText(`
    `, false)
            ] : [],
            import_Registry15.default.createText(`
  `, false)
          ] : !!(!state.value.url && state.value.uploading) ? [
            ,
            import_Registry15.default.createText(`
    `, false),
            import_Registry15.default.createElement("div", {}, [
              import_Registry15.default.createElement("span", {}, [
                ...this._toNodeList(uploading)
              ]).element
            ]).element,
            import_Registry15.default.createText(`
  `, false)
          ] : !!state.value.url ? [
            ,
            import_Registry15.default.createText(`
    `, false),
            import_Registry15.default.createElement("div", {}, [
              import_Registry15.default.createText(`
      `, false),
              ...!!image ? [
                import_Registry15.default.createText(`
        `, false),
                import_Registry15.default.createElement("img", { "src": state.value.url, "alt": `preview` }).element,
                import_Registry15.default.createText(`
      `, false)
              ] : [],
              import_Registry15.default.createText(`
      `, false),
              import_Registry15.default.createElement("a", { "href": state.value.url, "target": `_blank`, "rel": `noreferrer` }, [
                import_Registry15.default.createText(`
        `, false),
                ...this._toNodeList(state.value.url),
                import_Registry15.default.createText(`
      `, false)
              ]).element,
              import_Registry15.default.createText(`
      `, false),
              import_Registry15.default.createElement("em", { "click": handlers.reset }, [
                import_Registry15.default.createText(`&times;`, false)
              ]).element,
              import_Registry15.default.createText(`
    `, false)
            ]).element,
            import_Registry15.default.createText(`
  `, false)
          ] : [],
          import_Registry15.default.createText(`
`, false)
        ]).element,
        import_Registry15.default.createText(`
`, false)
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\filelist.ink
  var import_Registry16 = __toESM(require_Registry());
  var import_Component15 = __toESM(require_Component());
  var import_StyleSet11 = __toESM(require_StyleSet());
  var import_display7 = __toESM(require_display());
  var import_signal2 = __toESM(require_signal());
  var Filelist_1bad9ce547117f592df7 = class extends import_Component15.default {
    static id = "1bad9ce547117f592df7";
    static tagname = "filelist";
    static classname = "Filelist_1bad9ce547117f592df7";
    styles() {
      return `div {
    background-color: var(--white);
    border: 1px solid var(--black);
    border-top: 0;
    box-sizing: border-box;
    color: var(--black);
    display: flex;
    align-items: center;
    padding-right: 7px;
  }
  span {
    display: inline-block;
    flex-grow: 1;
    overflow: hidden;
    padding: 7px;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  a {
    display: inline-block;
    flex-grow: 1;
    overflow: hidden;
    padding: 7px;
    text-overflow: ellipsis;
    white-space: nowrap;
    color: var(--black);
    text-decoration: underline;
  }
  em {
    cursor: pointer;
    font-size: 20px;
    margin-top: -2px;
    color: var(--error);
  }
  img {
    height: 32px;
  }
  img + a {
    padding: 7px 4px;
  }`;
    }
    template() {
      const {
        image,
        uploading = "Uploading...",
        name: name2,
        value = [],
        change,
        update,
        upload,
        //dont need these...
        style,
        "class": _2,
        ...attributes
      } = this.props;
      const styles = new import_StyleSet11.default();
      const css = this.styles();
      this.styles = () => css + styles.toString();
      (0, import_display7.default)(this.props, styles, "block");
      const state = (0, import_signal2.default)({ queued: 0, uploaded: value });
      const handlers = {
        change: (e) => {
          if (upload && e.target.files?.length) {
            const pending = Array.from(e.target.files);
            const queued = state.value.queued + pending.length;
            const uploaded = Array.from(state.value.uploaded);
            state.value = { ...state.value, queued };
            upload(pending, (urls) => {
              uploaded.push(...urls);
              state.value = {
                queued: Math.max(queued - urls.length, 0),
                uploaded: [...uploaded]
              };
              console.log(state.value);
            });
          }
          change && change(e);
        },
        remove: (index) => {
          const queued = state.value.queued ? state.value.queued - 1 : 0;
          const uploaded = [...state.value.uploaded];
          uploaded.splice(index, 1);
          state.value = { queued, uploaded };
        }
      };
      return () => [
        import_Registry16.default.createText(`
`, false),
        import_Registry16.default.createElement("template", { "type": `light` }, [
          import_Registry16.default.createText(`
  `, false),
          ...!!name2 ? [
            import_Registry16.default.createText(`
    `, false),
            ...Object.entries(state.value.uploaded).map(([_3, url]) => [
              import_Registry16.default.createText(`
      `, false),
              import_Registry16.default.createElement("input", { "name": name2, "type": `hidden`, "value": url }).element,
              import_Registry16.default.createText(`
    `, false)
            ]).flat(),
            import_Registry16.default.createText(`
  `, false)
          ] : [],
          import_Registry16.default.createText(`
`, false)
        ]).element,
        import_Registry16.default.createText(`
`, false),
        import_Registry16.default.createElement("template", { "type": `shadow` }, [
          import_Registry16.default.createText(`
  `, false),
          ...!!image ? [
            import_Registry16.default.createText(`
    `, false),
            import_Registry16.default.createComponent("field-input", Input_cb7a6224432a087beaf2, { ...attributes, "type": `file`, "accept": `image/*`, "change": handlers.change, "multiple": true }).element,
            import_Registry16.default.createText(`
  `, false)
          ] : true ? [
            ,
            import_Registry16.default.createText(`
    `, false),
            import_Registry16.default.createComponent("field-input", Input_cb7a6224432a087beaf2, { ...attributes, "type": `file`, "change": handlers.change, "multiple": true }).element,
            import_Registry16.default.createText(`
  `, false)
          ] : [],
          import_Registry16.default.createText(`
  `, false),
          ...!!(state.value.uploaded.length > 0) ? [
            import_Registry16.default.createText(`
    `, false),
            ...Object.entries(state.value.uploaded).map(([i, url]) => [
              import_Registry16.default.createText(`
      `, false),
              import_Registry16.default.createElement("div", {}, [
                import_Registry16.default.createText(`
        `, false),
                ...!!image ? [
                  import_Registry16.default.createText(`
          `, false),
                  import_Registry16.default.createElement("img", { "src": url, "alt": `preview` }).element,
                  import_Registry16.default.createText(`
        `, false)
                ] : [],
                import_Registry16.default.createText(`
        `, false),
                import_Registry16.default.createElement("a", { "href": url, "target": `_blank`, "rel": `noreferrer` }, [
                  import_Registry16.default.createText(`
          `, false),
                  ...this._toNodeList(url),
                  import_Registry16.default.createText(`
        `, false)
                ]).element,
                import_Registry16.default.createText(`
        `, false),
                import_Registry16.default.createElement("em", { "click": () => handlers.remove(i) }, [
                  import_Registry16.default.createText(`
          &times;
        `, false)
                ]).element,
                import_Registry16.default.createText(`
      `, false)
              ]).element,
              import_Registry16.default.createText(`
    `, false)
            ]).flat(),
            import_Registry16.default.createText(`
  `, false)
          ] : [],
          import_Registry16.default.createText(`
  `, false),
          ...!!(state.value.queued > 0) ? [
            import_Registry16.default.createText(`
    `, false),
            import_Registry16.default.createElement("div", {}, [
              import_Registry16.default.createElement("span", {}, [
                ...this._toNodeList(uploading)
              ]).element
            ]).element,
            import_Registry16.default.createText(`
  `, false)
          ] : [],
          import_Registry16.default.createText(`
`, false)
        ]).element,
        import_Registry16.default.createText(`
`, false)
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\markdown.ink
  var import_Registry18 = __toESM(require_Registry());
  var import_Component17 = __toESM(require_Component());

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\element\icon.ink
  var import_Registry17 = __toESM(require_Registry());
  var import_Component16 = __toESM(require_Component());
  var import_StyleSet12 = __toESM(require_StyleSet());
  var import_color2 = __toESM(require_color());
  var import_display8 = __toESM(require_display());
  var import_size = __toESM(require_size());
  var Icon_33cb84912ffcb000a388 = class extends import_Component16.default {
    static id = "33cb84912ffcb000a388";
    static tagname = "icon";
    static classname = "Icon_33cb84912ffcb000a388";
    styles() {
      return ``;
    }
    template() {
      const { name: name2, solid, brand } = this.props;
      const styles = new import_StyleSet12.default();
      this.styles = () => styles.toString();
      (0, import_display8.default)(this.props, styles, "inline-block", ":host");
      (0, import_color2.default)(this.props, styles, false, ":host", "color");
      (0, import_size.default)(this.props, styles, false, ":host", "font-size");
      const iconClass = ["fa-fw", `fa-${name2}`];
      iconClass.push(brand ? "fa-brands" : "fa-solid");
      return () => [
        import_Registry17.default.createElement("link", { "rel": `stylesheet`, "type": `text/css`, "href": `https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css` }).element,
        import_Registry17.default.createText(`
`, false),
        import_Registry17.default.createElement("i", { "class": iconClass.join(" ") }, []).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\markdown.ink
  var import_StyleSet13 = __toESM(require_StyleSet());
  var import_display9 = __toESM(require_display());

  // ../../node_modules/marked/lib/marked.esm.js
  function _getDefaults() {
    return {
      async: false,
      breaks: false,
      extensions: null,
      gfm: true,
      hooks: null,
      pedantic: false,
      renderer: null,
      silent: false,
      tokenizer: null,
      walkTokens: null
    };
  }
  var _defaults = _getDefaults();
  function changeDefaults(newDefaults) {
    _defaults = newDefaults;
  }
  var escapeTest = /[&<>"']/;
  var escapeReplace = new RegExp(escapeTest.source, "g");
  var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
  var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
  var escapeReplacements = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  var getEscapeReplacement = (ch) => escapeReplacements[ch];
  function escape$1(html2, encode) {
    if (encode) {
      if (escapeTest.test(html2)) {
        return html2.replace(escapeReplace, getEscapeReplacement);
      }
    } else {
      if (escapeTestNoEncode.test(html2)) {
        return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
      }
    }
    return html2;
  }
  var caret = /(^|[^\[])\^/g;
  function edit(regex, opt) {
    let source = typeof regex === "string" ? regex : regex.source;
    opt = opt || "";
    const obj = {
      replace: (name2, val) => {
        let valSource = typeof val === "string" ? val : val.source;
        valSource = valSource.replace(caret, "$1");
        source = source.replace(name2, valSource);
        return obj;
      },
      getRegex: () => {
        return new RegExp(source, opt);
      }
    };
    return obj;
  }
  function cleanUrl(href) {
    try {
      href = encodeURI(href).replace(/%25/g, "%");
    } catch {
      return null;
    }
    return href;
  }
  var noopTest = { exec: () => null };
  function splitCells(tableRow, count) {
    const row = tableRow.replace(/\|/g, (match, offset, str) => {
      let escaped = false;
      let curr = offset;
      while (--curr >= 0 && str[curr] === "\\")
        escaped = !escaped;
      if (escaped) {
        return "|";
      } else {
        return " |";
      }
    }), cells = row.split(/ \|/);
    let i = 0;
    if (!cells[0].trim()) {
      cells.shift();
    }
    if (cells.length > 0 && !cells[cells.length - 1].trim()) {
      cells.pop();
    }
    if (count) {
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count)
          cells.push("");
      }
    }
    for (; i < cells.length; i++) {
      cells[i] = cells[i].trim().replace(/\\\|/g, "|");
    }
    return cells;
  }
  function rtrim(str, c, invert) {
    const l = str.length;
    if (l === 0) {
      return "";
    }
    let suffLen = 0;
    while (suffLen < l) {
      const currChar = str.charAt(l - suffLen - 1);
      if (currChar === c && !invert) {
        suffLen++;
      } else if (currChar !== c && invert) {
        suffLen++;
      } else {
        break;
      }
    }
    return str.slice(0, l - suffLen);
  }
  function findClosingBracket(str, b) {
    if (str.indexOf(b[1]) === -1) {
      return -1;
    }
    let level = 0;
    for (let i = 0; i < str.length; i++) {
      if (str[i] === "\\") {
        i++;
      } else if (str[i] === b[0]) {
        level++;
      } else if (str[i] === b[1]) {
        level--;
        if (level < 0) {
          return i;
        }
      }
    }
    return -1;
  }
  function outputLink(cap, link2, raw, lexer2) {
    const href = link2.href;
    const title = link2.title ? escape$1(link2.title) : null;
    const text = cap[1].replace(/\\([\[\]])/g, "$1");
    if (cap[0].charAt(0) !== "!") {
      lexer2.state.inLink = true;
      const token = {
        type: "link",
        raw,
        href,
        title,
        text,
        tokens: lexer2.inlineTokens(text)
      };
      lexer2.state.inLink = false;
      return token;
    }
    return {
      type: "image",
      raw,
      href,
      title,
      text: escape$1(text)
    };
  }
  function indentCodeCompensation(raw, text) {
    const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
    if (matchIndentToCode === null) {
      return text;
    }
    const indentToCode = matchIndentToCode[1];
    return text.split("\n").map((node) => {
      const matchIndentInNode = node.match(/^\s+/);
      if (matchIndentInNode === null) {
        return node;
      }
      const [indentInNode] = matchIndentInNode;
      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }
      return node;
    }).join("\n");
  }
  var _Tokenizer = class {
    options;
    rules;
    // set by the lexer
    lexer;
    // set by the lexer
    constructor(options2) {
      this.options = options2 || _defaults;
    }
    space(src) {
      const cap = this.rules.block.newline.exec(src);
      if (cap && cap[0].length > 0) {
        return {
          type: "space",
          raw: cap[0]
        };
      }
    }
    code(src) {
      const cap = this.rules.block.code.exec(src);
      if (cap) {
        const text = cap[0].replace(/^(?: {1,4}| {0,3}\t)/gm, "");
        return {
          type: "code",
          raw: cap[0],
          codeBlockStyle: "indented",
          text: !this.options.pedantic ? rtrim(text, "\n") : text
        };
      }
    }
    fences(src) {
      const cap = this.rules.block.fences.exec(src);
      if (cap) {
        const raw = cap[0];
        const text = indentCodeCompensation(raw, cap[3] || "");
        return {
          type: "code",
          raw,
          lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
          text
        };
      }
    }
    heading(src) {
      const cap = this.rules.block.heading.exec(src);
      if (cap) {
        let text = cap[2].trim();
        if (/#$/.test(text)) {
          const trimmed = rtrim(text, "#");
          if (this.options.pedantic) {
            text = trimmed.trim();
          } else if (!trimmed || / $/.test(trimmed)) {
            text = trimmed.trim();
          }
        }
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[1].length,
          text,
          tokens: this.lexer.inline(text)
        };
      }
    }
    hr(src) {
      const cap = this.rules.block.hr.exec(src);
      if (cap) {
        return {
          type: "hr",
          raw: rtrim(cap[0], "\n")
        };
      }
    }
    blockquote(src) {
      const cap = this.rules.block.blockquote.exec(src);
      if (cap) {
        let lines = rtrim(cap[0], "\n").split("\n");
        let raw = "";
        let text = "";
        const tokens = [];
        while (lines.length > 0) {
          let inBlockquote = false;
          const currentLines = [];
          let i;
          for (i = 0; i < lines.length; i++) {
            if (/^ {0,3}>/.test(lines[i])) {
              currentLines.push(lines[i]);
              inBlockquote = true;
            } else if (!inBlockquote) {
              currentLines.push(lines[i]);
            } else {
              break;
            }
          }
          lines = lines.slice(i);
          const currentRaw = currentLines.join("\n");
          const currentText = currentRaw.replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, "\n    $1").replace(/^ {0,3}>[ \t]?/gm, "");
          raw = raw ? `${raw}
${currentRaw}` : currentRaw;
          text = text ? `${text}
${currentText}` : currentText;
          const top = this.lexer.state.top;
          this.lexer.state.top = true;
          this.lexer.blockTokens(currentText, tokens, true);
          this.lexer.state.top = top;
          if (lines.length === 0) {
            break;
          }
          const lastToken = tokens[tokens.length - 1];
          if (lastToken?.type === "code") {
            break;
          } else if (lastToken?.type === "blockquote") {
            const oldToken = lastToken;
            const newText = oldToken.raw + "\n" + lines.join("\n");
            const newToken = this.blockquote(newText);
            tokens[tokens.length - 1] = newToken;
            raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
            text = text.substring(0, text.length - oldToken.text.length) + newToken.text;
            break;
          } else if (lastToken?.type === "list") {
            const oldToken = lastToken;
            const newText = oldToken.raw + "\n" + lines.join("\n");
            const newToken = this.list(newText);
            tokens[tokens.length - 1] = newToken;
            raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
            text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;
            lines = newText.substring(tokens[tokens.length - 1].raw.length).split("\n");
            continue;
          }
        }
        return {
          type: "blockquote",
          raw,
          tokens,
          text
        };
      }
    }
    list(src) {
      let cap = this.rules.block.list.exec(src);
      if (cap) {
        let bull = cap[1].trim();
        const isordered = bull.length > 1;
        const list2 = {
          type: "list",
          raw: "",
          ordered: isordered,
          start: isordered ? +bull.slice(0, -1) : "",
          loose: false,
          items: []
        };
        bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
        if (this.options.pedantic) {
          bull = isordered ? bull : "[*+-]";
        }
        const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
        let endsWithBlankLine = false;
        while (src) {
          let endEarly = false;
          let raw = "";
          let itemContents = "";
          if (!(cap = itemRegex.exec(src))) {
            break;
          }
          if (this.rules.block.hr.test(src)) {
            break;
          }
          raw = cap[0];
          src = src.substring(raw.length);
          let line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
          let nextLine = src.split("\n", 1)[0];
          let blankLine = !line.trim();
          let indent = 0;
          if (this.options.pedantic) {
            indent = 2;
            itemContents = line.trimStart();
          } else if (blankLine) {
            indent = cap[1].length + 1;
          } else {
            indent = cap[2].search(/[^ ]/);
            indent = indent > 4 ? 1 : indent;
            itemContents = line.slice(indent);
            indent += cap[1].length;
          }
          if (blankLine && /^[ \t]*$/.test(nextLine)) {
            raw += nextLine + "\n";
            src = src.substring(nextLine.length + 1);
            endEarly = true;
          }
          if (!endEarly) {
            const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
            const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
            const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
            const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
            const htmlBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}<[a-z].*>`, "i");
            while (src) {
              const rawLine = src.split("\n", 1)[0];
              let nextLineWithoutTabs;
              nextLine = rawLine;
              if (this.options.pedantic) {
                nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                nextLineWithoutTabs = nextLine;
              } else {
                nextLineWithoutTabs = nextLine.replace(/\t/g, "    ");
              }
              if (fencesBeginRegex.test(nextLine)) {
                break;
              }
              if (headingBeginRegex.test(nextLine)) {
                break;
              }
              if (htmlBeginRegex.test(nextLine)) {
                break;
              }
              if (nextBulletRegex.test(nextLine)) {
                break;
              }
              if (hrRegex.test(nextLine)) {
                break;
              }
              if (nextLineWithoutTabs.search(/[^ ]/) >= indent || !nextLine.trim()) {
                itemContents += "\n" + nextLineWithoutTabs.slice(indent);
              } else {
                if (blankLine) {
                  break;
                }
                if (line.replace(/\t/g, "    ").search(/[^ ]/) >= 4) {
                  break;
                }
                if (fencesBeginRegex.test(line)) {
                  break;
                }
                if (headingBeginRegex.test(line)) {
                  break;
                }
                if (hrRegex.test(line)) {
                  break;
                }
                itemContents += "\n" + nextLine;
              }
              if (!blankLine && !nextLine.trim()) {
                blankLine = true;
              }
              raw += rawLine + "\n";
              src = src.substring(rawLine.length + 1);
              line = nextLineWithoutTabs.slice(indent);
            }
          }
          if (!list2.loose) {
            if (endsWithBlankLine) {
              list2.loose = true;
            } else if (/\n[ \t]*\n[ \t]*$/.test(raw)) {
              endsWithBlankLine = true;
            }
          }
          let istask = null;
          let ischecked;
          if (this.options.gfm) {
            istask = /^\[[ xX]\] /.exec(itemContents);
            if (istask) {
              ischecked = istask[0] !== "[ ] ";
              itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
            }
          }
          list2.items.push({
            type: "list_item",
            raw,
            task: !!istask,
            checked: ischecked,
            loose: false,
            text: itemContents,
            tokens: []
          });
          list2.raw += raw;
        }
        list2.items[list2.items.length - 1].raw = list2.items[list2.items.length - 1].raw.trimEnd();
        list2.items[list2.items.length - 1].text = list2.items[list2.items.length - 1].text.trimEnd();
        list2.raw = list2.raw.trimEnd();
        for (let i = 0; i < list2.items.length; i++) {
          this.lexer.state.top = false;
          list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
          if (!list2.loose) {
            const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
            const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
            list2.loose = hasMultipleLineBreaks;
          }
        }
        if (list2.loose) {
          for (let i = 0; i < list2.items.length; i++) {
            list2.items[i].loose = true;
          }
        }
        return list2;
      }
    }
    html(src) {
      const cap = this.rules.block.html.exec(src);
      if (cap) {
        const token = {
          type: "html",
          block: true,
          raw: cap[0],
          pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
          text: cap[0]
        };
        return token;
      }
    }
    def(src) {
      const cap = this.rules.block.def.exec(src);
      if (cap) {
        const tag2 = cap[1].toLowerCase().replace(/\s+/g, " ");
        const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
        const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
        return {
          type: "def",
          tag: tag2,
          raw: cap[0],
          href,
          title
        };
      }
    }
    table(src) {
      const cap = this.rules.block.table.exec(src);
      if (!cap) {
        return;
      }
      if (!/[:|]/.test(cap[2])) {
        return;
      }
      const headers = splitCells(cap[1]);
      const aligns = cap[2].replace(/^\||\| *$/g, "").split("|");
      const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : [];
      const item = {
        type: "table",
        raw: cap[0],
        header: [],
        align: [],
        rows: []
      };
      if (headers.length !== aligns.length) {
        return;
      }
      for (const align of aligns) {
        if (/^ *-+: *$/.test(align)) {
          item.align.push("right");
        } else if (/^ *:-+: *$/.test(align)) {
          item.align.push("center");
        } else if (/^ *:-+ *$/.test(align)) {
          item.align.push("left");
        } else {
          item.align.push(null);
        }
      }
      for (let i = 0; i < headers.length; i++) {
        item.header.push({
          text: headers[i],
          tokens: this.lexer.inline(headers[i]),
          header: true,
          align: item.align[i]
        });
      }
      for (const row of rows) {
        item.rows.push(splitCells(row, item.header.length).map((cell, i) => {
          return {
            text: cell,
            tokens: this.lexer.inline(cell),
            header: false,
            align: item.align[i]
          };
        }));
      }
      return item;
    }
    lheading(src) {
      const cap = this.rules.block.lheading.exec(src);
      if (cap) {
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[2].charAt(0) === "=" ? 1 : 2,
          text: cap[1],
          tokens: this.lexer.inline(cap[1])
        };
      }
    }
    paragraph(src) {
      const cap = this.rules.block.paragraph.exec(src);
      if (cap) {
        const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
        return {
          type: "paragraph",
          raw: cap[0],
          text,
          tokens: this.lexer.inline(text)
        };
      }
    }
    text(src) {
      const cap = this.rules.block.text.exec(src);
      if (cap) {
        return {
          type: "text",
          raw: cap[0],
          text: cap[0],
          tokens: this.lexer.inline(cap[0])
        };
      }
    }
    escape(src) {
      const cap = this.rules.inline.escape.exec(src);
      if (cap) {
        return {
          type: "escape",
          raw: cap[0],
          text: escape$1(cap[1])
        };
      }
    }
    tag(src) {
      const cap = this.rules.inline.tag.exec(src);
      if (cap) {
        if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
          this.lexer.state.inLink = true;
        } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
          this.lexer.state.inLink = false;
        }
        if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = true;
        } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = false;
        }
        return {
          type: "html",
          raw: cap[0],
          inLink: this.lexer.state.inLink,
          inRawBlock: this.lexer.state.inRawBlock,
          block: false,
          text: cap[0]
        };
      }
    }
    link(src) {
      const cap = this.rules.inline.link.exec(src);
      if (cap) {
        const trimmedUrl = cap[2].trim();
        if (!this.options.pedantic && /^</.test(trimmedUrl)) {
          if (!/>$/.test(trimmedUrl)) {
            return;
          }
          const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
            return;
          }
        } else {
          const lastParenIndex = findClosingBracket(cap[2], "()");
          if (lastParenIndex > -1) {
            const start = cap[0].indexOf("!") === 0 ? 5 : 4;
            const linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = "";
          }
        }
        let href = cap[2];
        let title = "";
        if (this.options.pedantic) {
          const link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
          if (link2) {
            href = link2[1];
            title = link2[3];
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : "";
        }
        href = href.trim();
        if (/^</.test(href)) {
          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
            href = href.slice(1);
          } else {
            href = href.slice(1, -1);
          }
        }
        return outputLink(cap, {
          href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
          title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
        }, cap[0], this.lexer);
      }
    }
    reflink(src, links) {
      let cap;
      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
        const linkString = (cap[2] || cap[1]).replace(/\s+/g, " ");
        const link2 = links[linkString.toLowerCase()];
        if (!link2) {
          const text = cap[0].charAt(0);
          return {
            type: "text",
            raw: text,
            text
          };
        }
        return outputLink(cap, link2, cap[0], this.lexer);
      }
    }
    emStrong(src, maskedSrc, prevChar = "") {
      let match = this.rules.inline.emStrongLDelim.exec(src);
      if (!match)
        return;
      if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
        return;
      const nextChar = match[1] || match[2] || "";
      if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
        const lLength = [...match[0]].length - 1;
        let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
        const endReg = match[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
        endReg.lastIndex = 0;
        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
        while ((match = endReg.exec(maskedSrc)) != null) {
          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
          if (!rDelim)
            continue;
          rLength = [...rDelim].length;
          if (match[3] || match[4]) {
            delimTotal += rLength;
            continue;
          } else if (match[5] || match[6]) {
            if (lLength % 3 && !((lLength + rLength) % 3)) {
              midDelimTotal += rLength;
              continue;
            }
          }
          delimTotal -= rLength;
          if (delimTotal > 0)
            continue;
          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
          const lastCharLength = [...match[0]][0].length;
          const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
          if (Math.min(lLength, rLength) % 2) {
            const text2 = raw.slice(1, -1);
            return {
              type: "em",
              raw,
              text: text2,
              tokens: this.lexer.inlineTokens(text2)
            };
          }
          const text = raw.slice(2, -2);
          return {
            type: "strong",
            raw,
            text,
            tokens: this.lexer.inlineTokens(text)
          };
        }
      }
    }
    codespan(src) {
      const cap = this.rules.inline.code.exec(src);
      if (cap) {
        let text = cap[2].replace(/\n/g, " ");
        const hasNonSpaceChars = /[^ ]/.test(text);
        const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text = text.substring(1, text.length - 1);
        }
        text = escape$1(text, true);
        return {
          type: "codespan",
          raw: cap[0],
          text
        };
      }
    }
    br(src) {
      const cap = this.rules.inline.br.exec(src);
      if (cap) {
        return {
          type: "br",
          raw: cap[0]
        };
      }
    }
    del(src) {
      const cap = this.rules.inline.del.exec(src);
      if (cap) {
        return {
          type: "del",
          raw: cap[0],
          text: cap[2],
          tokens: this.lexer.inlineTokens(cap[2])
        };
      }
    }
    autolink(src) {
      const cap = this.rules.inline.autolink.exec(src);
      if (cap) {
        let text, href;
        if (cap[2] === "@") {
          text = escape$1(cap[1]);
          href = "mailto:" + text;
        } else {
          text = escape$1(cap[1]);
          href = text;
        }
        return {
          type: "link",
          raw: cap[0],
          text,
          href,
          tokens: [
            {
              type: "text",
              raw: text,
              text
            }
          ]
        };
      }
    }
    url(src) {
      let cap;
      if (cap = this.rules.inline.url.exec(src)) {
        let text, href;
        if (cap[2] === "@") {
          text = escape$1(cap[0]);
          href = "mailto:" + text;
        } else {
          let prevCapZero;
          do {
            prevCapZero = cap[0];
            cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? "";
          } while (prevCapZero !== cap[0]);
          text = escape$1(cap[0]);
          if (cap[1] === "www.") {
            href = "http://" + cap[0];
          } else {
            href = cap[0];
          }
        }
        return {
          type: "link",
          raw: cap[0],
          text,
          href,
          tokens: [
            {
              type: "text",
              raw: text,
              text
            }
          ]
        };
      }
    }
    inlineText(src) {
      const cap = this.rules.inline.text.exec(src);
      if (cap) {
        let text;
        if (this.lexer.state.inRawBlock) {
          text = cap[0];
        } else {
          text = escape$1(cap[0]);
        }
        return {
          type: "text",
          raw: cap[0],
          text
        };
      }
    }
  };
  var newline = /^(?:[ \t]*(?:\n|$))+/;
  var blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
  var fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
  var hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
  var heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
  var bullet = /(?:[*+-]|\d{1,9}[.)])/;
  var lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).getRegex();
  var _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
  var blockText = /^[^\n]+/;
  var _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  var def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
  var list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
  var _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
  var _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
  var html = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  var paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
  var blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
  var blockNormal = {
    blockquote,
    code: blockCode,
    def,
    fences,
    heading,
    hr,
    html,
    lheading,
    list,
    newline,
    paragraph,
    table: noopTest,
    text: blockText
  };
  var gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
  var blockGfm = {
    ...blockNormal,
    table: gfmTable,
    paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
  };
  var blockPedantic = {
    ...blockNormal,
    html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    // fences not supported
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
  };
  var escape = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
  var inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
  var br = /^( {2,}|\\)\n(?!\s*$)/;
  var inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
  var _punctuation = "\\p{P}\\p{S}";
  var punctuation = edit(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, _punctuation).getRegex();
  var blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
  var emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, _punctuation).getRegex();
  var emStrongRDelimAst = edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, _punctuation).getRegex();
  var emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, _punctuation).getRegex();
  var anyPunctuation = edit(/\\([punct])/, "gu").replace(/punct/g, _punctuation).getRegex();
  var autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
  var _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
  var tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
  var _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  var link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
  var reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
  var nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
  var reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
  var inlineNormal = {
    _backpedal: noopTest,
    // only used for GFM url
    anyPunctuation,
    autolink,
    blockSkip,
    br,
    code: inlineCode,
    del: noopTest,
    emStrongLDelim,
    emStrongRDelimAst,
    emStrongRDelimUnd,
    escape,
    link,
    nolink,
    punctuation,
    reflink,
    reflinkSearch,
    tag,
    text: inlineText,
    url: noopTest
  };
  var inlinePedantic = {
    ...inlineNormal,
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
  };
  var inlineGfm = {
    ...inlineNormal,
    escape: edit(escape).replace("])", "~|])").getRegex(),
    url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  };
  var inlineBreaks = {
    ...inlineGfm,
    br: edit(br).replace("{2,}", "*").getRegex(),
    text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
  };
  var block = {
    normal: blockNormal,
    gfm: blockGfm,
    pedantic: blockPedantic
  };
  var inline = {
    normal: inlineNormal,
    gfm: inlineGfm,
    breaks: inlineBreaks,
    pedantic: inlinePedantic
  };
  var _Lexer = class __Lexer {
    tokens;
    options;
    state;
    tokenizer;
    inlineQueue;
    constructor(options2) {
      this.tokens = [];
      this.tokens.links = /* @__PURE__ */ Object.create(null);
      this.options = options2 || _defaults;
      this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      this.tokenizer.lexer = this;
      this.inlineQueue = [];
      this.state = {
        inLink: false,
        inRawBlock: false,
        top: true
      };
      const rules = {
        block: block.normal,
        inline: inline.normal
      };
      if (this.options.pedantic) {
        rules.block = block.pedantic;
        rules.inline = inline.pedantic;
      } else if (this.options.gfm) {
        rules.block = block.gfm;
        if (this.options.breaks) {
          rules.inline = inline.breaks;
        } else {
          rules.inline = inline.gfm;
        }
      }
      this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */
    static get rules() {
      return {
        block,
        inline
      };
    }
    /**
     * Static Lex Method
     */
    static lex(src, options2) {
      const lexer2 = new __Lexer(options2);
      return lexer2.lex(src);
    }
    /**
     * Static Lex Inline Method
     */
    static lexInline(src, options2) {
      const lexer2 = new __Lexer(options2);
      return lexer2.inlineTokens(src);
    }
    /**
     * Preprocessing
     */
    lex(src) {
      src = src.replace(/\r\n|\r/g, "\n");
      this.blockTokens(src, this.tokens);
      for (let i = 0; i < this.inlineQueue.length; i++) {
        const next = this.inlineQueue[i];
        this.inlineTokens(next.src, next.tokens);
      }
      this.inlineQueue = [];
      return this.tokens;
    }
    blockTokens(src, tokens = [], lastParagraphClipped = false) {
      if (this.options.pedantic) {
        src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
      }
      let token;
      let lastToken;
      let cutSrc;
      while (src) {
        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.space(src)) {
          src = src.substring(token.raw.length);
          if (token.raw.length === 1 && tokens.length > 0) {
            tokens[tokens.length - 1].raw += "\n";
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.code(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.heading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.def(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.raw;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }
          continue;
        }
        if (token = this.tokenizer.table(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.lheading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startBlock) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startBlock.forEach((getStartIndex) => {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
          lastToken = tokens[tokens.length - 1];
          if (lastParagraphClipped && lastToken?.type === "paragraph") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          lastParagraphClipped = cutSrc.length !== src.length;
          src = src.substring(token.raw.length);
          continue;
        }
        if (token = this.tokenizer.text(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      this.state.top = true;
      return tokens;
    }
    inline(src, tokens = []) {
      this.inlineQueue.push({ src, tokens });
      return tokens;
    }
    /**
     * Lexing/Compiling
     */
    inlineTokens(src, tokens = []) {
      let token, lastToken, cutSrc;
      let maskedSrc = src;
      let match;
      let keepPrevChar, prevChar;
      if (this.tokens.links) {
        const links = Object.keys(this.tokens.links);
        if (links.length > 0) {
          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      }
      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      }
      while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
      }
      while (src) {
        if (!keepPrevChar) {
          prevChar = "";
        }
        keepPrevChar = false;
        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.escape(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.tag(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === "text" && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === "text" && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.codespan(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.autolink(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (!this.state.inLink && (token = this.tokenizer.url(src))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startInline) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startInline.forEach((getStartIndex) => {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (token = this.tokenizer.inlineText(cutSrc)) {
          src = src.substring(token.raw.length);
          if (token.raw.slice(-1) !== "_") {
            prevChar = token.raw.slice(-1);
          }
          keepPrevChar = true;
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      return tokens;
    }
  };
  var _Renderer = class {
    options;
    parser;
    // set by the parser
    constructor(options2) {
      this.options = options2 || _defaults;
    }
    space(token) {
      return "";
    }
    code({ text, lang, escaped }) {
      const langString = (lang || "").match(/^\S*/)?.[0];
      const code = text.replace(/\n$/, "") + "\n";
      if (!langString) {
        return "<pre><code>" + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
      }
      return '<pre><code class="language-' + escape$1(langString) + '">' + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
    }
    blockquote({ tokens }) {
      const body = this.parser.parse(tokens);
      return `<blockquote>
${body}</blockquote>
`;
    }
    html({ text }) {
      return text;
    }
    heading({ tokens, depth }) {
      return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>
`;
    }
    hr(token) {
      return "<hr>\n";
    }
    list(token) {
      const ordered = token.ordered;
      const start = token.start;
      let body = "";
      for (let j = 0; j < token.items.length; j++) {
        const item = token.items[j];
        body += this.listitem(item);
      }
      const type = ordered ? "ol" : "ul";
      const startAttr = ordered && start !== 1 ? ' start="' + start + '"' : "";
      return "<" + type + startAttr + ">\n" + body + "</" + type + ">\n";
    }
    listitem(item) {
      let itemBody = "";
      if (item.task) {
        const checkbox = this.checkbox({ checked: !!item.checked });
        if (item.loose) {
          if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
            item.tokens[0].text = checkbox + " " + item.tokens[0].text;
            if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
              item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
            }
          } else {
            item.tokens.unshift({
              type: "text",
              raw: checkbox + " ",
              text: checkbox + " "
            });
          }
        } else {
          itemBody += checkbox + " ";
        }
      }
      itemBody += this.parser.parse(item.tokens, !!item.loose);
      return `<li>${itemBody}</li>
`;
    }
    checkbox({ checked }) {
      return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
    }
    paragraph({ tokens }) {
      return `<p>${this.parser.parseInline(tokens)}</p>
`;
    }
    table(token) {
      let header = "";
      let cell = "";
      for (let j = 0; j < token.header.length; j++) {
        cell += this.tablecell(token.header[j]);
      }
      header += this.tablerow({ text: cell });
      let body = "";
      for (let j = 0; j < token.rows.length; j++) {
        const row = token.rows[j];
        cell = "";
        for (let k = 0; k < row.length; k++) {
          cell += this.tablecell(row[k]);
        }
        body += this.tablerow({ text: cell });
      }
      if (body)
        body = `<tbody>${body}</tbody>`;
      return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
    }
    tablerow({ text }) {
      return `<tr>
${text}</tr>
`;
    }
    tablecell(token) {
      const content = this.parser.parseInline(token.tokens);
      const type = token.header ? "th" : "td";
      const tag2 = token.align ? `<${type} align="${token.align}">` : `<${type}>`;
      return tag2 + content + `</${type}>
`;
    }
    /**
     * span level renderer
     */
    strong({ tokens }) {
      return `<strong>${this.parser.parseInline(tokens)}</strong>`;
    }
    em({ tokens }) {
      return `<em>${this.parser.parseInline(tokens)}</em>`;
    }
    codespan({ text }) {
      return `<code>${text}</code>`;
    }
    br(token) {
      return "<br>";
    }
    del({ tokens }) {
      return `<del>${this.parser.parseInline(tokens)}</del>`;
    }
    link({ href, title, tokens }) {
      const text = this.parser.parseInline(tokens);
      const cleanHref = cleanUrl(href);
      if (cleanHref === null) {
        return text;
      }
      href = cleanHref;
      let out = '<a href="' + href + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += ">" + text + "</a>";
      return out;
    }
    image({ href, title, text }) {
      const cleanHref = cleanUrl(href);
      if (cleanHref === null) {
        return text;
      }
      href = cleanHref;
      let out = `<img src="${href}" alt="${text}"`;
      if (title) {
        out += ` title="${title}"`;
      }
      out += ">";
      return out;
    }
    text(token) {
      return "tokens" in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;
    }
  };
  var _TextRenderer = class {
    // no need for block level renderers
    strong({ text }) {
      return text;
    }
    em({ text }) {
      return text;
    }
    codespan({ text }) {
      return text;
    }
    del({ text }) {
      return text;
    }
    html({ text }) {
      return text;
    }
    text({ text }) {
      return text;
    }
    link({ text }) {
      return "" + text;
    }
    image({ text }) {
      return "" + text;
    }
    br() {
      return "";
    }
  };
  var _Parser = class __Parser {
    options;
    renderer;
    textRenderer;
    constructor(options2) {
      this.options = options2 || _defaults;
      this.options.renderer = this.options.renderer || new _Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.renderer.parser = this;
      this.textRenderer = new _TextRenderer();
    }
    /**
     * Static Parse Method
     */
    static parse(tokens, options2) {
      const parser2 = new __Parser(options2);
      return parser2.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */
    static parseInline(tokens, options2) {
      const parser2 = new __Parser(options2);
      return parser2.parseInline(tokens);
    }
    /**
     * Parse Loop
     */
    parse(tokens, top = true) {
      let out = "";
      for (let i = 0; i < tokens.length; i++) {
        const anyToken = tokens[i];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {
          const genericToken = anyToken;
          const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
          if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
            out += ret || "";
            continue;
          }
        }
        const token = anyToken;
        switch (token.type) {
          case "space": {
            out += this.renderer.space(token);
            continue;
          }
          case "hr": {
            out += this.renderer.hr(token);
            continue;
          }
          case "heading": {
            out += this.renderer.heading(token);
            continue;
          }
          case "code": {
            out += this.renderer.code(token);
            continue;
          }
          case "table": {
            out += this.renderer.table(token);
            continue;
          }
          case "blockquote": {
            out += this.renderer.blockquote(token);
            continue;
          }
          case "list": {
            out += this.renderer.list(token);
            continue;
          }
          case "html": {
            out += this.renderer.html(token);
            continue;
          }
          case "paragraph": {
            out += this.renderer.paragraph(token);
            continue;
          }
          case "text": {
            let textToken = token;
            let body = this.renderer.text(textToken);
            while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
              textToken = tokens[++i];
              body += "\n" + this.renderer.text(textToken);
            }
            if (top) {
              out += this.renderer.paragraph({
                type: "paragraph",
                raw: body,
                text: body,
                tokens: [{ type: "text", raw: body, text: body }]
              });
            } else {
              out += body;
            }
            continue;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return "";
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
    /**
     * Parse Inline Tokens
     */
    parseInline(tokens, renderer) {
      renderer = renderer || this.renderer;
      let out = "";
      for (let i = 0; i < tokens.length; i++) {
        const anyToken = tokens[i];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {
          const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
          if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(anyToken.type)) {
            out += ret || "";
            continue;
          }
        }
        const token = anyToken;
        switch (token.type) {
          case "escape": {
            out += renderer.text(token);
            break;
          }
          case "html": {
            out += renderer.html(token);
            break;
          }
          case "link": {
            out += renderer.link(token);
            break;
          }
          case "image": {
            out += renderer.image(token);
            break;
          }
          case "strong": {
            out += renderer.strong(token);
            break;
          }
          case "em": {
            out += renderer.em(token);
            break;
          }
          case "codespan": {
            out += renderer.codespan(token);
            break;
          }
          case "br": {
            out += renderer.br(token);
            break;
          }
          case "del": {
            out += renderer.del(token);
            break;
          }
          case "text": {
            out += renderer.text(token);
            break;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return "";
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
  };
  var _Hooks = class {
    options;
    block;
    constructor(options2) {
      this.options = options2 || _defaults;
    }
    static passThroughHooks = /* @__PURE__ */ new Set([
      "preprocess",
      "postprocess",
      "processAllTokens"
    ]);
    /**
     * Process markdown before marked
     */
    preprocess(markdown) {
      return markdown;
    }
    /**
     * Process HTML after marked is finished
     */
    postprocess(html2) {
      return html2;
    }
    /**
     * Process all tokens before walk tokens
     */
    processAllTokens(tokens) {
      return tokens;
    }
    /**
     * Provide function to tokenize markdown
     */
    provideLexer() {
      return this.block ? _Lexer.lex : _Lexer.lexInline;
    }
    /**
     * Provide function to parse tokens
     */
    provideParser() {
      return this.block ? _Parser.parse : _Parser.parseInline;
    }
  };
  var Marked = class {
    defaults = _getDefaults();
    options = this.setOptions;
    parse = this.parseMarkdown(true);
    parseInline = this.parseMarkdown(false);
    Parser = _Parser;
    Renderer = _Renderer;
    TextRenderer = _TextRenderer;
    Lexer = _Lexer;
    Tokenizer = _Tokenizer;
    Hooks = _Hooks;
    constructor(...args) {
      this.use(...args);
    }
    /**
     * Run callback for every token
     */
    walkTokens(tokens, callback) {
      let values = [];
      for (const token of tokens) {
        values = values.concat(callback.call(this, token));
        switch (token.type) {
          case "table": {
            const tableToken = token;
            for (const cell of tableToken.header) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
            for (const row of tableToken.rows) {
              for (const cell of row) {
                values = values.concat(this.walkTokens(cell.tokens, callback));
              }
            }
            break;
          }
          case "list": {
            const listToken = token;
            values = values.concat(this.walkTokens(listToken.items, callback));
            break;
          }
          default: {
            const genericToken = token;
            if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
              this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                const tokens2 = genericToken[childTokens].flat(Infinity);
                values = values.concat(this.walkTokens(tokens2, callback));
              });
            } else if (genericToken.tokens) {
              values = values.concat(this.walkTokens(genericToken.tokens, callback));
            }
          }
        }
      }
      return values;
    }
    use(...args) {
      const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
      args.forEach((pack) => {
        const opts = { ...pack };
        opts.async = this.defaults.async || opts.async || false;
        if (pack.extensions) {
          pack.extensions.forEach((ext) => {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if ("renderer" in ext) {
              const prevRenderer = extensions.renderers[ext.name];
              if (prevRenderer) {
                extensions.renderers[ext.name] = function(...args2) {
                  let ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if ("tokenizer" in ext) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              const extLevel = extensions[ext.level];
              if (extLevel) {
                extLevel.unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if ("childTokens" in ext && ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
          opts.extensions = extensions;
        }
        if (pack.renderer) {
          const renderer = this.defaults.renderer || new _Renderer(this.defaults);
          for (const prop in pack.renderer) {
            if (!(prop in renderer)) {
              throw new Error(`renderer '${prop}' does not exist`);
            }
            if (["options", "parser"].includes(prop)) {
              continue;
            }
            const rendererProp = prop;
            const rendererFunc = pack.renderer[rendererProp];
            const prevRenderer = renderer[rendererProp];
            renderer[rendererProp] = (...args2) => {
              let ret = rendererFunc.apply(renderer, args2);
              if (ret === false) {
                ret = prevRenderer.apply(renderer, args2);
              }
              return ret || "";
            };
          }
          opts.renderer = renderer;
        }
        if (pack.tokenizer) {
          const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
          for (const prop in pack.tokenizer) {
            if (!(prop in tokenizer)) {
              throw new Error(`tokenizer '${prop}' does not exist`);
            }
            if (["options", "rules", "lexer"].includes(prop)) {
              continue;
            }
            const tokenizerProp = prop;
            const tokenizerFunc = pack.tokenizer[tokenizerProp];
            const prevTokenizer = tokenizer[tokenizerProp];
            tokenizer[tokenizerProp] = (...args2) => {
              let ret = tokenizerFunc.apply(tokenizer, args2);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args2);
              }
              return ret;
            };
          }
          opts.tokenizer = tokenizer;
        }
        if (pack.hooks) {
          const hooks = this.defaults.hooks || new _Hooks();
          for (const prop in pack.hooks) {
            if (!(prop in hooks)) {
              throw new Error(`hook '${prop}' does not exist`);
            }
            if (["options", "block"].includes(prop)) {
              continue;
            }
            const hooksProp = prop;
            const hooksFunc = pack.hooks[hooksProp];
            const prevHook = hooks[hooksProp];
            if (_Hooks.passThroughHooks.has(prop)) {
              hooks[hooksProp] = (arg) => {
                if (this.defaults.async) {
                  return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                    return prevHook.call(hooks, ret2);
                  });
                }
                const ret = hooksFunc.call(hooks, arg);
                return prevHook.call(hooks, ret);
              };
            } else {
              hooks[hooksProp] = (...args2) => {
                let ret = hooksFunc.apply(hooks, args2);
                if (ret === false) {
                  ret = prevHook.apply(hooks, args2);
                }
                return ret;
              };
            }
          }
          opts.hooks = hooks;
        }
        if (pack.walkTokens) {
          const walkTokens2 = this.defaults.walkTokens;
          const packWalktokens = pack.walkTokens;
          opts.walkTokens = function(token) {
            let values = [];
            values.push(packWalktokens.call(this, token));
            if (walkTokens2) {
              values = values.concat(walkTokens2.call(this, token));
            }
            return values;
          };
        }
        this.defaults = { ...this.defaults, ...opts };
      });
      return this;
    }
    setOptions(opt) {
      this.defaults = { ...this.defaults, ...opt };
      return this;
    }
    lexer(src, options2) {
      return _Lexer.lex(src, options2 ?? this.defaults);
    }
    parser(tokens, options2) {
      return _Parser.parse(tokens, options2 ?? this.defaults);
    }
    parseMarkdown(blockType) {
      const parse = (src, options2) => {
        const origOpt = { ...options2 };
        const opt = { ...this.defaults, ...origOpt };
        const throwError = this.onError(!!opt.silent, !!opt.async);
        if (this.defaults.async === true && origOpt.async === false) {
          return throwError(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
        }
        if (typeof src === "undefined" || src === null) {
          return throwError(new Error("marked(): input parameter is undefined or null"));
        }
        if (typeof src !== "string") {
          return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
        }
        if (opt.hooks) {
          opt.hooks.options = opt;
          opt.hooks.block = blockType;
        }
        const lexer2 = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;
        const parser2 = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;
        if (opt.async) {
          return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
        }
        try {
          if (opt.hooks) {
            src = opt.hooks.preprocess(src);
          }
          let tokens = lexer2(src, opt);
          if (opt.hooks) {
            tokens = opt.hooks.processAllTokens(tokens);
          }
          if (opt.walkTokens) {
            this.walkTokens(tokens, opt.walkTokens);
          }
          let html2 = parser2(tokens, opt);
          if (opt.hooks) {
            html2 = opt.hooks.postprocess(html2);
          }
          return html2;
        } catch (e) {
          return throwError(e);
        }
      };
      return parse;
    }
    onError(silent, async) {
      return (e) => {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (silent) {
          const msg = "<p>An error occurred:</p><pre>" + escape$1(e.message + "", true) + "</pre>";
          if (async) {
            return Promise.resolve(msg);
          }
          return msg;
        }
        if (async) {
          return Promise.reject(e);
        }
        throw e;
      };
    }
  };
  var markedInstance = new Marked();
  function marked(src, opt) {
    return markedInstance.parse(src, opt);
  }
  marked.options = marked.setOptions = function(options2) {
    markedInstance.setOptions(options2);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.getDefaults = _getDefaults;
  marked.defaults = _defaults;
  marked.use = function(...args) {
    markedInstance.use(...args);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.walkTokens = function(tokens, callback) {
    return markedInstance.walkTokens(tokens, callback);
  };
  marked.parseInline = markedInstance.parseInline;
  marked.Parser = _Parser;
  marked.parser = _Parser.parse;
  marked.Renderer = _Renderer;
  marked.TextRenderer = _TextRenderer;
  marked.Lexer = _Lexer;
  marked.lexer = _Lexer.lex;
  marked.Tokenizer = _Tokenizer;
  marked.Hooks = _Hooks;
  marked.parse = marked;
  var options = marked.options;
  var setOptions = marked.setOptions;
  var use = marked.use;
  var walkTokens = marked.walkTokens;
  var parseInline = marked.parseInline;
  var parser = _Parser.parse;
  var lexer = _Lexer.lex;

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\markdown.ink
  var Markdown_12b2cd27e75a9b30b72c = class extends import_Component17.default {
    static id = "12b2cd27e75a9b30b72c";
    static tagname = "markdown";
    static classname = "Markdown_12b2cd27e75a9b30b72c";
    styles() {
      return `.tui-field-markdown-nav {
    display: none;
    position: relative;
  }
  :host(:hover) .tui-field-markdown-nav {
    display: block;
  }
  .tui-field-markdown-edit {
    bottom: 0;
    position: absolute;
    right: 0;
  }
  .tui-field-markdown-view {
    bottom: 0;
    position: absolute;
    right: 0;
  }
  .tui-field-markdown-editor {
    height: 100%;
    width: 100%;
  }
  .tui-field-markdown-preview {
    background-color: var(--white);
    border: 0;
    height: 100%;
    overflow: auto;
    width: 100%;
  }`;
    }
    template() {
      const { name: name2, value, numbers, change, update } = this.props;
      const styles = new import_StyleSet13.default();
      const css = this.styles();
      this.styles = () => css + styles.toString();
      (0, import_display9.default)(this.props, styles, "block", ":host");
      const children2 = this.originalChildren;
      const handlers = {
        change: (e) => {
          const textarea = this.querySelector("textarea");
          if (textarea) {
            textarea.value = e.target.value;
          }
          change && change(e);
        },
        edit: () => {
          const shadow = this.shadowRoot;
          if (!shadow) return;
          const edit2 = shadow.querySelector(".tui-field-markdown-edit");
          const view = shadow.querySelector(".tui-field-markdown-view");
          const editor = shadow.querySelector(".tui-field-markdown-editor");
          const preview = shadow.querySelector(".tui-field-markdown-preview");
          editor.style.display = "block";
          preview.style.display = "none";
          view.style.display = "inline-block";
          edit2.style.display = "none";
        },
        view: () => {
          const shadow = this.shadowRoot;
          if (!shadow) return;
          const edit2 = shadow.querySelector(".tui-field-markdown-edit");
          const view = shadow.querySelector(".tui-field-markdown-view");
          const editor = shadow.querySelector(".tui-field-markdown-editor");
          const preview = shadow.querySelector(".tui-field-markdown-preview");
          const html2 = marked.parse(editor._editor.getValue() || "");
          preview.src = `data:text/html;charset=utf-8,${encodeURI(html2)}`;
          editor.classList.add("none");
          editor.style.display = "none";
          preview.style.display = "block";
          view.style.display = "none";
          edit2.style.display = "inline-block";
        }
      };
      return () => [
        import_Registry18.default.createText(`
`, false),
        import_Registry18.default.createElement("template", { "type": `light` }, [
          import_Registry18.default.createText(`
  `, false),
          import_Registry18.default.createElement("textarea", { "name": name2, "value": value }, [
            ...this._toNodeList(children2)
          ]).element,
          import_Registry18.default.createText(`
`, false)
        ]).element,
        import_Registry18.default.createText(`
`, false),
        import_Registry18.default.createElement("template", { "type": `shadow` }, [
          import_Registry18.default.createText(`
  `, false),
          import_Registry18.default.createElement("nav", { "class": `tui-field-markdown-nav` }, [
            import_Registry18.default.createText(`
    `, false),
            import_Registry18.default.createComponent("form-button", Button_8b2d9633875784010957, { "sm": true, "muted": true, "class": `tui-field-markdown-edit`, "style": `display:none`, "type": `button`, "click": handlers.edit }, [
              import_Registry18.default.createText(`
      `, false),
              import_Registry18.default.createComponent("element-icon", Icon_33cb84912ffcb000a388, { "name": `edit` }).element,
              import_Registry18.default.createText(`
    `, false)
            ]).element,
            import_Registry18.default.createText(`
    `, false),
            import_Registry18.default.createComponent("form-button", Button_8b2d9633875784010957, { "sm": true, "muted": true, "class": `tui-field-markdown-view`, "type": `button`, "click": handlers.view }, [
              import_Registry18.default.createText(`
      `, false),
              import_Registry18.default.createComponent("element-icon", Icon_33cb84912ffcb000a388, { "name": `eye` }).element,
              import_Registry18.default.createText(`
    `, false)
            ]).element,
            import_Registry18.default.createText(`
  `, false)
          ]).element,
          import_Registry18.default.createText(`
  `, false),
          import_Registry18.default.createComponent("field-editor", Editor_015bbef1a0403600489f, { "class": `tui-field-markdown-editor`, "lang": `md`, "numbers": numbers, "name": name2, "value": value, "update": update, "change": handlers.change }, [
            ...this._toNodeList(
              children2
            )
          ]).element,
          import_Registry18.default.createText(`
  `, false),
          import_Registry18.default.createElement("iframe", { "class": `tui-field-markdown-preview`, "style": `display:none` }, []).element,
          import_Registry18.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\mask.ink
  var import_Registry19 = __toESM(require_Registry());
  var import_Component18 = __toESM(require_Component());
  var import_inputmask = __toESM(require_inputmask());
  var import_StyleSet14 = __toESM(require_StyleSet());
  var import_input6 = __toESM(require_input());
  var Mask_3040fa9be886a5e9b81b = class extends import_Component18.default {
    static id = "3040fa9be886a5e9b81b";
    static tagname = "mask";
    static classname = "Mask_3040fa9be886a5e9b81b";
    static observedAttributes = ["autocomplete", "disabled", "name", "pattern", "readonly", "required", "value"];
    styles() {
      return ``;
    }
    template() {
      const {
        error,
        change,
        update,
        mask,
        regex,
        alias,
        repeat,
        greedy,
        numericInput,
        rightAlign,
        definitions,
        //dont need these...
        style,
        "class": _2,
        //input attributes
        ...attributes
      } = this.props;
      const styles = new import_StyleSet14.default();
      this.styles = () => styles.toString();
      (0, import_input6.setDefaultStyles)(this.props, styles);
      const im = new import_inputmask.default({
        mask,
        regex,
        alias,
        repeat,
        greedy,
        numericInput,
        rightAlign,
        definitions
      });
      const handlers = (0, import_input6.getHandlers)(this, change, update);
      handlers.init = () => {
        im.mask(this.querySelector("input"));
      };
      return () => [
        import_Registry19.default.createText(`
`, false),
        import_Registry19.default.createElement("template", { "type": `light` }, [
          import_Registry19.default.createText(`
  `, false),
          import_Registry19.default.createElement("input", { ...attributes, "change": handlers.change, "mount": handlers.init }).element,
          import_Registry19.default.createText(`
`, false)
        ]).element,
        import_Registry19.default.createText(`
`, false),
        import_Registry19.default.createElement("template", { "type": `shadow` }, [
          import_Registry19.default.createText(`
  `, false),
          import_Registry19.default.createElement("slot", {}, []).element,
          import_Registry19.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\metadata.ink
  var import_Registry20 = __toESM(require_Registry());
  var import_Component19 = __toESM(require_Component());
  var import_StyleSet15 = __toESM(require_StyleSet());
  var import_display10 = __toESM(require_display());
  var import_fieldset2 = __toESM(require_fieldset());
  var Metadata_7a77cccac9ec06877cc1 = class extends import_Component19.default {
    static id = "7a77cccac9ec06877cc1";
    static tagname = "metadata";
    static classname = "Metadata_7a77cccac9ec06877cc1";
    styles() {
      return `a {
    align-items: center;
    color: var(--error);
    display: inline-flex;
    cursor: pointer;
    text-decoration: none;
    padding: 0 10px;
  }
  legend {
    display: inline-block;
    float: right;
    line-height: 20px;
  }
  button {
    box-sizing: border-box;
    cursor: pointer;
    display: inline-block;
    font-family: inherit;
    font-size: inherit;
    margin-top: 7px;
    text-align: center;
  }
  fieldset {
    background-color: var(--white);
    border: 1px solid var(--black);
    display: flex;
    margin: 0 0 -1px 0;
    padding: 0;
  }
  input {
    border: 0;
    border-right: 1px solid var(--black);
    box-sizing: border-box;
    font-family: inherit;
    font-size: inherit;
    padding: 7px;
  }
  input:focus {
    outline: none;
  }
  fieldset input {
    width: calc(65% - 21px);
  }
  fieldset input:first-child {
    width: calc(35% - 1px);
  }`;
    }
    template() {
      const { name: name2, add = "Add", value = {} } = this.props;
      const styles = new import_StyleSet15.default();
      const css = this.styles();
      this.styles = () => css + styles.toString();
      (0, import_display10.default)(this.props, styles, "block", ":host");
      (0, import_fieldset2.buttonStyles)(this.props, styles);
      const handlers = {
        add: (e) => {
          const shadow = this.shadowRoot;
          if (!shadow) return;
          const button = shadow.querySelector("button");
          if (!button) return;
          const { fieldset, field } = handlers.create(this.childElementCount);
          button.before(fieldset);
          this.appendChild(field);
        },
        create: (index, key, value2) => {
          const input = {
            key: this.createElement("input", { value: key }).element,
            value: this.createElement("input", { value: value2 }).element
          };
          const field = this.createElement("input", {
            type: "hidden",
            name: key ? `${name2}[${key}]` : void 0,
            value: value2
          }).element;
          const remove = import_Registry20.default.createElement(
            "a",
            {},
            ["&times;"]
          ).element;
          const fieldset = import_Registry20.default.createElement("fieldset", {}, [
            input.key,
            input.value,
            remove
          ]).element;
          remove.addEventListener(
            "click",
            () => handlers.remove(fieldset, field)
          );
          input.key.addEventListener("change", () => {
            const key2 = input.key.value;
            if (key2.trim().length === 0) return;
            field.name = `${name2}[${key2}]`;
            field.setAttribute("name", `${name2}[${key2}]`);
          });
          input.value.addEventListener("change", () => {
            field.value = input.value.value;
            field.setAttribute("value", input.value.value);
          });
          return { fieldset, field };
        },
        remove: (fieldset, field) => {
          const shadow = this.shadowRoot;
          if (!shadow) return;
          fieldset.remove();
          field.remove();
        }
      };
      const rows = Object.entries(value).map(
        ([key, value2], index) => handlers.create(index, key, value2)
      );
      return () => [
        import_Registry20.default.createText(`
`, false),
        import_Registry20.default.createElement("template", { "type": `light` }, [
          import_Registry20.default.createText(`
  `, false),
          ...this._toNodeList(rows.map((row) => row.field)),
          import_Registry20.default.createText(`
`, false)
        ]).element,
        import_Registry20.default.createText(`
`, false),
        import_Registry20.default.createElement("template", { "type": `shadow` }, [
          import_Registry20.default.createText(`
  `, false),
          ...this._toNodeList(rows.map((row) => row.fieldset)),
          import_Registry20.default.createText(`
  `, false),
          import_Registry20.default.createElement("button", { "type": `button`, "click": handlers.add }, [
            ...this._toNodeList(add)
          ]).element,
          import_Registry20.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\number.ink
  var import_Registry21 = __toESM(require_Registry());
  var import_Component20 = __toESM(require_Component());
  var import_StyleSet16 = __toESM(require_StyleSet());
  var import_align = __toESM(require_align());
  var import_color3 = __toESM(require_color());
  var import_display11 = __toESM(require_display());
  var import_padding2 = __toESM(require_padding());
  var import_size2 = __toESM(require_size());
  var import_input7 = __toESM(require_input());
  var import_signal3 = __toESM(require_signal());
  var import_number = __toESM(require_number());
  var Number_86f400b74c281ff3b8cb = class extends import_Component20.default {
    static id = "86f400b74c281ff3b8cb";
    static tagname = "number";
    static classname = "Number_86f400b74c281ff3b8cb";
    static observedAttributes = ["autocomplete", "disabled", "max", "min", "name", "pattern", "placeholder", "readonly", "required", "step", "type", "value"];
    styles() {
      return ``;
    }
    template() {
      const {
        //listeners
        change,
        update,
        //sub props
        background,
        border,
        //others
        error,
        //for input
        attributes: props
      } = (0, import_input7.getProps)(this);
      const {
        name: name2,
        value,
        min,
        max,
        step,
        separator = ",",
        decimal = ".",
        absolute = false,
        //for input
        ...attributes
      } = props;
      const styles = new import_StyleSet16.default();
      this.styles = () => styles.toString();
      (0, import_display11.default)(this.props, styles, "inline-block", ":host");
      if (background) {
        (0, import_color3.default)(background, styles, "var(--white)", ":host", "background-color");
      } else {
        styles.add(":host", "background-color", "var(--white)");
      }
      styles.add(":host", "border-width", "1px");
      styles.add(":host", "border-style", "solid");
      if (error) {
        styles.add(":host", "border-color", "var(--error)");
      } else if (border) {
        (0, import_color3.default)(border, styles, "var(--black)", ":host", "border-color");
      } else {
        styles.add(":host", "border-color", "var(--black)");
      }
      styles.add("input", "background", "transparent");
      styles.add("input", "border", "0");
      styles.add("input", "box-sizing", "border-box");
      styles.add("input", "display", "block");
      styles.add("input", "height", "100%");
      styles.add("::slotted(input:focus)", "outline", "none");
      styles.add("input", "width", "100%");
      styles.add("::host([error]) input", "color", "var(--error)");
      styles.add("::host([error]) input", "border-color", "var(--error)");
      (0, import_align.default)(props, styles, "left", "input");
      (0, import_size2.default)(props, styles, "inherit", "input", "font-size");
      (0, import_color3.default)(props, styles, "var(--black)", "input", "color");
      const pad = (0, import_padding2.default)(props, styles, "input");
      if (!pad) {
        styles.add("input", "padding", "7px");
      }
      const decimals = step ? String(step).split(".")[1]?.length || -1 : -1;
      const options2 = {
        min: Number(min) || void 0,
        max: Number(max) || void 0,
        separator,
        decimal,
        decimals,
        absolute
      };
      const initial = (0, import_number.getFormats)(String(value || ""), options2);
      const state = (0, import_signal3.default)({
        hiddenValue: initial.value,
        displayValue: initial.display,
        cursor: 0
      });
      const handlers = {
        change: (e) => {
          const { value: value2, display } = (0, import_number.getFormatsFromInput)(e.target, options2);
          let { cursor, displayValue, hiddenValue } = state.value;
          const pointer = e.target.selectionStart || 0;
          let change2 = false;
          if (Number(state.value.hiddenValue) !== Number(value2)) {
            change2 && change2(e);
            update && update(String(Number(value2)));
            hiddenValue = value2;
            change2 = true;
          }
          if (displayValue !== display) {
            if (display.length > displayValue.length) {
              cursor = pointer + (display.length - displayValue.length) - 1;
            } else if (display.length < displayValue.length) {
              cursor = pointer - (displayValue.length - display.length) + 1;
            } else {
              cursor = pointer;
            }
            displayValue = display;
            change2 = true;
          }
          if (change2) {
            state.value = { cursor, displayValue, hiddenValue };
          }
        },
        blur: () => {
          console.log("blur");
          state.value = { ...state.value, displayValue: (0, import_number.padDecimals)(
            state.value.displayValue,
            decimal,
            decimals
          ) };
        }
      };
      return () => [
        import_Registry21.default.createText(`
`, false),
        import_Registry21.default.createElement("template", { "type": `light` }, [
          import_Registry21.default.createText(`
  `, false),
          ...!!name2 ? [
            import_Registry21.default.createText(`
    `, false),
            import_Registry21.default.createElement("input", { "type": `hidden`, "name": name2, "value": state.value.hiddenValue }).element,
            import_Registry21.default.createText(`
  `, false)
          ] : [],
          import_Registry21.default.createText(`
`, false)
        ]).element,
        import_Registry21.default.createText(`
`, false),
        import_Registry21.default.createElement("template", { "type": `shadow` }, [
          import_Registry21.default.createText(`
  `, false),
          import_Registry21.default.createElement("input", { ...attributes, "change": handlers.change, "blur": handlers.blur, "value": state.value.displayValue }).element,
          import_Registry21.default.createText(`
`, false)
        ]).element,
        import_Registry21.default.createText(`

`, false)
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\password.ink
  var import_Registry22 = __toESM(require_Registry());
  var import_Component21 = __toESM(require_Component());
  var import_StyleSet17 = __toESM(require_StyleSet());
  var import_signal4 = __toESM(require_signal());
  var import_input8 = __toESM(require_input());
  var Password_e2bbd1afa75609a2474c = class extends import_Component21.default {
    static id = "e2bbd1afa75609a2474c";
    static tagname = "password";
    static classname = "Password_e2bbd1afa75609a2474c";
    static observedAttributes = ["autocomplete", "disabled", "name", "pattern", "readonly", "required", "value"];
    styles() {
      return ``;
    }
    template() {
      const {
        //handlers
        change,
        update,
        //input attributes
        attributes,
        //the rest of the props
        ...props
      } = (0, import_input8.getProps)(this);
      const styles = new import_StyleSet17.default();
      this.styles = () => styles.toString();
      (0, import_input8.setDefaultStyles)(props, styles);
      styles.add("div", "display", "flex");
      styles.add("div", "align-items", "center");
      styles.add("span", "cursor", "pointer");
      styles.add("span", "padding", "0 7px");
      styles.add("span", "color", "var(--muted)");
      const handlers = (0, import_input8.getHandlers)(this, change, update);
      handlers.toggle = () => {
        const value = this.querySelector("input")?.value;
        exposed.value = !exposed.value;
        const input = this.querySelector("input");
        if (input) {
          input.value = value;
        }
      };
      const exposed = (0, import_signal4.default)(false);
      return () => [
        import_Registry22.default.createText(`
`, false),
        import_Registry22.default.createElement("template", { "type": `light` }, [
          import_Registry22.default.createText(`
  `, false),
          import_Registry22.default.createElement("input", { ...attributes, "type": exposed.value ? "text" : "password", "change": handlers.change }).element,
          import_Registry22.default.createText(`
`, false)
        ]).element,
        import_Registry22.default.createText(`
`, false),
        import_Registry22.default.createElement("template", { "type": `shadow` }, [
          import_Registry22.default.createText(`
  `, false),
          import_Registry22.default.createElement("div", {}, [
            import_Registry22.default.createText(`
    `, false),
            import_Registry22.default.createElement("slot", {}, []).element,
            import_Registry22.default.createText(`
    `, false),
            import_Registry22.default.createElement("span", { "click": handlers.toggle }, [
              import_Registry22.default.createText(`
      `, false),
              ...this._toNodeList(exposed.value ? "\u2737" : "A"),
              import_Registry22.default.createText(`
    `, false)
            ]).element,
            import_Registry22.default.createText(`
  `, false)
          ]).element,
          import_Registry22.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\radio.ink
  var import_Registry23 = __toESM(require_Registry());
  var import_Field2 = __toESM(require_Field());
  var import_StyleSet18 = __toESM(require_StyleSet());
  var import_display12 = __toESM(require_display());
  var import_option2 = __toESM(require_option());
  var Radio_7eb23fa5e323e66c0392 = class extends import_Field2.default {
    static id = "7eb23fa5e323e66c0392";
    static tagname = "radio";
    static classname = "Radio_7eb23fa5e323e66c0392";
    static observedAttributes = ["checked", "disabled", "name", "readonly", "required", "value"];
    styles() {
      return ``;
    }
    template() {
      const { label = "", change, update, attributes } = (0, import_option2.getProps)(this);
      const styles = new import_StyleSet18.default();
      this.styles = () => styles.toString();
      (0, import_display12.default)(this.props, styles, "inline-block", ":host");
      (0, import_option2.setStyles)(this.props, styles, "circle");
      const handlers = (0, import_option2.getHandlers)(this, change, update);
      return () => [
        import_Registry23.default.createText(`
`, false),
        import_Registry23.default.createElement("label", { "mount": handlers.mount }, [
          import_Registry23.default.createText(`
  `, false),
          import_Registry23.default.createElement("input", { ...attributes, "type": `radio`, "change": handlers.change, "click": handlers.click }).element,
          import_Registry23.default.createText(`
  `, false),
          import_Registry23.default.createElement("span", {}, [
            ...this._toNodeList(label)
          ]).element,
          import_Registry23.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\range.ink
  var import_Registry24 = __toESM(require_Registry());
  var import_Component22 = __toESM(require_Component());
  var import_StyleSet19 = __toESM(require_StyleSet());
  var import_display13 = __toESM(require_display());
  var Range_c518adb6b44f1a3d7afe = class extends import_Component22.default {
    static id = "c518adb6b44f1a3d7afe";
    static tagname = "range";
    static classname = "Range_c518adb6b44f1a3d7afe";
    static observedAttributes = ["autocomplete", "disabled", "name", "readonly", "required", "value"];
    styles() {
      return `:host {
    background-color: var(--white);
    border: 1px solid var(--border);
    padding: 6px 6px 6px 0;
  }
  div {
    align-items: center;
    display: flex;
  }
  div span:last-child {
    flex: 1;
  }
  ::slotted(input) {
    background-color: transparent;
    border: 0;
    box-sizing: border-box;
    font-size: inherit;
    font-family: inherit;
    text-align: center;
    width: 100%;
  }
  ::slotted(input:focus) {
    outline: none;
  }`;
    }
    template() {
      const {
        min = 0,
        max = 100,
        step = 1,
        width = 60,
        value,
        //dont need these...
        style,
        "class": _2,
        //input attributes
        ...attributes
      } = this.props;
      const styles = new import_StyleSet19.default();
      const css = this.styles();
      this.styles = () => css + styles.toString();
      (0, import_display13.default)(this.props, styles, "inline-block", ":host");
      if (width) {
        styles.add("span:first-child", "width", `${width}px`);
      }
      const handlers = {
        change: (e) => {
          const box = e.target;
          const input1 = this.querySelector("input");
          const input2 = this.shadowRoot?.querySelector("input");
          if (!input1 || !input2) return;
          input1.value = box.value;
          input1.setAttribute("value", box.value);
          input2.value = box.value;
          input2.setAttribute("value", box.value);
        },
        attribute: (e) => {
          const { action, name: name2, prev, value: value2, target } = e.detail;
          const input1 = this.querySelector("input");
          const input2 = this.shadowRoot?.querySelector("input");
          if (!input1 || !input2) return;
          switch (action) {
            case "add":
            case "update":
              input1.setAttribute(name2, value2);
              input2.setAttribute(name2, value2);
              break;
            case "remove":
              input1.removeAttribute(name2);
              input2.removeAttribute(name2);
              break;
          }
        }
      };
      this.on("attributechange", handlers.attribute);
      return () => [
        import_Registry24.default.createText(`
`, false),
        import_Registry24.default.createElement("template", { "type": `light` }, [
          import_Registry24.default.createText(`
  `, false),
          import_Registry24.default.createElement("input", { ...attributes, "type": `number`, "min": String(min), "max": String(max), "step": String(step), "value": value, "change": handlers.change }).element,
          import_Registry24.default.createText(`
`, false)
        ]).element,
        import_Registry24.default.createText(`
`, false),
        import_Registry24.default.createElement("template", { "type": `shadow` }, [
          import_Registry24.default.createText(`
  `, false),
          import_Registry24.default.createElement("div", {}, [
            import_Registry24.default.createText(`
    `, false),
            import_Registry24.default.createElement("span", {}, [
              import_Registry24.default.createElement("slot", {}, []).element
            ]).element,
            import_Registry24.default.createText(`
    `, false),
            import_Registry24.default.createElement("span", {}, [
              import_Registry24.default.createText(`
      `, false),
              import_Registry24.default.createElement("input", { "type": `range`, "min": String(min), "max": String(max), "step": String(step), "value": value, "change": handlers.change }).element,
              import_Registry24.default.createText(`
    `, false)
            ]).element,
            import_Registry24.default.createText(`
  `, false)
          ]).element,
          import_Registry24.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\rating.ink
  var import_Registry25 = __toESM(require_Registry());
  var import_Component23 = __toESM(require_Component());
  var import_StyleSet20 = __toESM(require_StyleSet());
  var import_color4 = __toESM(require_color());
  var import_display14 = __toESM(require_display());
  var import_size3 = __toESM(require_size());
  var import_signal5 = __toESM(require_signal());
  var Rating_2d6a3c2d29eb25c7053c = class extends import_Component23.default {
    static id = "2d6a3c2d29eb25c7053c";
    static tagname = "rating";
    static classname = "Rating_2d6a3c2d29eb25c7053c";
    styles() {
      return `span {
  color: inherit;
  cursor: pointer;
  display: inline-block;
  font-size: inherit;
}`;
    }
    template() {
      const {
        name: name2,
        value = 0,
        max = 5
      } = this.props;
      const styles = new import_StyleSet20.default();
      const css = this.styles();
      this.styles = () => css + styles.toString();
      (0, import_display14.default)(this.props, styles, "inline-block", ":host");
      (0, import_size3.default)(this.props, styles, false, ":host", "font-size");
      (0, import_color4.default)(this.props, styles, false, ":host", "color");
      const state = (0, import_signal5.default)({
        value,
        stars: Array.from(
          { length: max },
          (_2, i) => i < value ? "\u2605" : "\u2606"
        )
      });
      const rate = (value2) => {
        if (value2 == 1 && state.value.value == 1) {
          value2 = 0;
        } else if (value2 === state.value.value) {
          return;
        }
        const stars = Array.from(
          { length: max },
          (_2, i) => i < value2 ? "\u2605" : "\u2606"
        );
        state.value = { value: value2, stars };
      };
      return () => [
        import_Registry25.default.createText(`
`, false),
        import_Registry25.default.createElement("template", { "type": `light` }, [
          import_Registry25.default.createText(`
  `, false),
          import_Registry25.default.createElement("input", { "type": `hidden`, "name": name2, "value": String(state.value.value) }).element,
          import_Registry25.default.createText(`
`, false)
        ]).element,
        import_Registry25.default.createText(`
`, false),
        import_Registry25.default.createElement("template", { "type": `shadow` }, [
          import_Registry25.default.createText(`
  `, false),
          ...Object.entries(state.value.stars).map(([i, star]) => [
            import_Registry25.default.createText(`
    `, false),
            import_Registry25.default.createElement("span", { "click": () => rate(parseInt(i) + 1) }, [
              ...this._toNodeList(star)
            ]).element,
            import_Registry25.default.createText(`
  `, false)
          ]).flat(),
          import_Registry25.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\select.ink
  var import_Registry26 = __toESM(require_Registry());
  var import_Component24 = __toESM(require_Component());
  var import_select3 = __toESM(require_select());
  var Select_180142206112824ab003 = class extends import_Component24.default {
    static id = "180142206112824ab003";
    static tagname = "select";
    static classname = "Select_180142206112824ab003";
    static observedAttributes = ["name", "value"];
    styles() {
      return `.select {
    color: var(--black);
    position: relative;
  }
  .display {
    display: flex;
    align-items: center;
    padding: 7px;
    border: 1px solid var(--black);
    background-color: var(--white);
  }
  .selected {
    width: 100%;
    overflow: auto;
    display: flex;
    align-items: center;
    flex-grow: 1;
    gap: 5px;
    cursor: pointer;
    white-space: nowrap;
  }
  .placeholder {
    color: var(--muted);
    font-style: italic;
  }
  .count {
    display: inline-block;
    padding-left: 4px;
    color: var(--muted);
    font-size: 12px;
  }
  .clear, .toggle, .add {
    cursor: pointer;
  }
  .dropdown {
    background-color: var(--white);
    border: 1px solid var(--black);
    overflow: auto;
    position: absolute;
    width: 100%;
    max-height: 200px;
  }
  .form {
    display: flex;
    align-items: center;
    margin: 5px;
    padding: 7px;
    border: 1px solid var(--muted);
    height: 18px;
  }
  .input {
    flex-grow: 1;
    padding: 0;
    border: 0;
    background-color: transparent;
  }
  .input:focus {
    outline: none;
  }
  .search {
    color: var(--muted);
  }
  .options {
    overflow: auto;
    cursor: pointer;
  }
  ::slotted(.select-default-option) {
    font-size: 14px;
    padding: 7px;
  }
  ::slotted(.select-default-option:hover) {
    background-color: var(--muted);
  }
  .selected ::slotted(.select-default-option) {
    padding: 0;
  }
  .selected ::slotted(.select-default-option:hover) {
    background-color: transparent;
  }`;
    }
    template() {
      const { placeholder = "Choose Option", custom, search, name: name2 } = this.props;
      const options2 = (0, import_select3.makeOptions)(this.getChildren(false));
      const { state, clear, toggle, filter, add } = (0, import_select3.getHandlers)(this, options2);
      return () => [
        import_Registry26.default.createText(`
`, false),
        import_Registry26.default.createElement("template", { "type": `light` }, [
          import_Registry26.default.createText(`
  `, false),
          ...!!name2 ? [
            import_Registry26.default.createText(`
    `, false),
            ...Object.entries(state.value.values).map(([_2, value]) => [
              import_Registry26.default.createText(`
      `, false),
              import_Registry26.default.createElement("input", { "type": `hidden`, "name": name2, "value": value.toString() }).element,
              import_Registry26.default.createText(`
    `, false)
            ]).flat(),
            import_Registry26.default.createText(`
  `, false)
          ] : [],
          import_Registry26.default.createText(`
  `, false),
          ...this._toNodeList(state.value.selected),
          import_Registry26.default.createText(`
  `, false),
          ...this._toNodeList(state.value.filtered),
          import_Registry26.default.createText(`
`, false)
        ]).element,
        import_Registry26.default.createText(`
`, false),
        import_Registry26.default.createElement("template", { "type": `shadow` }, [
          import_Registry26.default.createText(`
  `, false),
          import_Registry26.default.createElement("link", { "rel": `stylesheet`, "type": `text/css`, "href": `https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css` }).element,
          import_Registry26.default.createText(`
  `, false),
          import_Registry26.default.createElement("div", { "class": `select` }, [
            import_Registry26.default.createText(`
    `, false),
            import_Registry26.default.createElement("div", { "class": `display` }, [
              import_Registry26.default.createText(`
      `, false),
              import_Registry26.default.createElement("div", { "class": `selected`, "click": toggle }, [
                import_Registry26.default.createText(`
        `, false),
                ...!!(state.value.selected.length > 0) ? [
                  import_Registry26.default.createText(`
          `, false),
                  import_Registry26.default.createElement("slot", { "name": `selected` }, []).element,
                  import_Registry26.default.createText(`
        `, false)
                ] : !!placeholder ? [
                  ,
                  import_Registry26.default.createText(`
          `, false),
                  import_Registry26.default.createElement("span", { "class": `placeholder` }, [
                    import_Registry26.default.createText(`
            `, false),
                    ...this._toNodeList(placeholder),
                    import_Registry26.default.createText(`
          `, false)
                  ]).element,
                  import_Registry26.default.createText(`
        `, false)
                ] : [],
                import_Registry26.default.createText(`
      `, false)
              ]).element,
              import_Registry26.default.createText(`
      `, false),
              ...!!(state.value.selected.length > 1) ? [
                import_Registry26.default.createText(`
        `, false),
                import_Registry26.default.createElement("em", { "class": `count` }, [
                  import_Registry26.default.createText(`(`, false),
                  ...this._toNodeList(state.value.selected.length),
                  import_Registry26.default.createText(`)`, false)
                ]).element,
                import_Registry26.default.createText(`
      `, false)
              ] : [],
              import_Registry26.default.createText(`
      `, false),
              ...!!(state.value.selected.length > 0) ? [
                import_Registry26.default.createText(`
        `, false),
                import_Registry26.default.createElement("i", { "class": `clear fas fa-fw fa-times`, "click": clear }, []).element,
                import_Registry26.default.createText(`
      `, false)
              ] : [],
              import_Registry26.default.createText(`
      `, false),
              ...!!(state.value.filtered.length > 0 || state.value.query.length > 0) ? [
                import_Registry26.default.createText(`
        `, false),
                ...!!state.value.show ? [
                  import_Registry26.default.createText(`
          `, false),
                  import_Registry26.default.createElement("i", { "class": `toggle fas fa-fw fa-caret-up`, "click": toggle }, []).element,
                  import_Registry26.default.createText(`
        `, false)
                ] : true ? [
                  ,
                  import_Registry26.default.createText(`
          `, false),
                  import_Registry26.default.createElement("i", { "class": `toggle fas fa-fw fa-caret-down`, "click": toggle }, []).element,
                  import_Registry26.default.createText(`
        `, false)
                ] : [],
                import_Registry26.default.createText(`
      `, false)
              ] : [],
              import_Registry26.default.createText(`
    `, false)
            ]).element,
            import_Registry26.default.createText(`
    `, false),
            ...!!(state.value.show && (state.value.filtered.length > 0 || state.value.query.length > 0)) ? [
              import_Registry26.default.createText(`
      `, false),
              import_Registry26.default.createElement("div", { "class": `dropdown` }, [
                import_Registry26.default.createText(`
        `, false),
                ...!!(search || custom) ? [
                  import_Registry26.default.createText(`
          `, false),
                  import_Registry26.default.createElement("div", { "class": `form` }, [
                    import_Registry26.default.createText(`
            `, false),
                    ...!!search ? [
                      import_Registry26.default.createText(`
              `, false),
                      import_Registry26.default.createElement("input", { "class": `input`, "value": state.value.query, "keyup": filter }).element,
                      import_Registry26.default.createText(`
            `, false)
                    ] : true ? [
                      ,
                      import_Registry26.default.createText(`
              `, false),
                      import_Registry26.default.createElement("input", { "class": `input`, "value": state.value.query }).element,
                      import_Registry26.default.createText(`
            `, false)
                    ] : [],
                    import_Registry26.default.createText(`
            `, false),
                    ...!!custom ? [
                      import_Registry26.default.createText(`
              `, false),
                      import_Registry26.default.createElement("i", { "class": `add fas fa-fw fa-plus`, "click": add }, []).element,
                      import_Registry26.default.createText(`
            `, false)
                    ] : true ? [
                      ,
                      import_Registry26.default.createText(`
              `, false),
                      import_Registry26.default.createElement("i", { "class": `search fas fa-fe fa-search` }, []).element,
                      import_Registry26.default.createText(`
            `, false)
                    ] : [],
                    import_Registry26.default.createText(`
          `, false)
                  ]).element,
                  import_Registry26.default.createText(`
        `, false)
                ] : [],
                import_Registry26.default.createText(`
        `, false),
                import_Registry26.default.createElement("div", { "class": `options` }, [
                  import_Registry26.default.createElement("slot", { "name": `filtered` }, []).element
                ]).element,
                import_Registry26.default.createText(`
      `, false)
              ]).element,
              import_Registry26.default.createText(`
    `, false)
            ] : [],
            import_Registry26.default.createText(`
  `, false)
          ]).element,
          import_Registry26.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\slug.ink
  var import_Registry27 = __toESM(require_Registry());
  var import_Component25 = __toESM(require_Component());
  var import_StyleSet21 = __toESM(require_StyleSet());
  var import_input9 = __toESM(require_input());
  var import_slug = __toESM(require_slug());
  var Slug_fef3f64de8b66d9e4ca9 = class extends import_Component25.default {
    static id = "fef3f64de8b66d9e4ca9";
    static tagname = "slug";
    static classname = "Slug_fef3f64de8b66d9e4ca9";
    static observedAttributes = ["autocomplete", "disabled", "name", "pattern", "readonly", "required", "value"];
    styles() {
      return ``;
    }
    template() {
      const {
        //handlers
        change,
        update,
        //input attributes
        attributes,
        //the rest of the props
        ...props
      } = (0, import_input9.getProps)(this);
      const { dash, line, camel } = attributes;
      const styles = new import_StyleSet21.default();
      this.styles = () => styles.toString();
      (0, import_input9.setDefaultStyles)(props, styles);
      const ify = (value) => {
        return camel ? (0, import_slug.camelfy)(value) : (0, import_slug.slugify)(value, !dash, !line);
      };
      if (attributes.value) {
        attributes.value = ify(String(attributes.value));
      }
      const handlers = {
        change(e) {
          change && change(e);
          update && update(ify(String(e.target.value)));
        },
        transform(e) {
          setTimeout(() => {
            e.target.value = ify(e.target.value);
          }, 1e3);
        },
        attribute(e) {
          let { action, name: name2, value, target } = e.detail;
          const input = target.querySelector("input");
          switch (action) {
            case "add":
            case "update":
              if (name2 === "value") {
                value = ify(String(value));
              }
              input?.setAttribute(name2, value);
              break;
            case "remove":
              input?.removeAttribute(name2);
              break;
          }
        }
      };
      this.on("attributechange", handlers.attribute);
      return () => [
        import_Registry27.default.createText(`
`, false),
        import_Registry27.default.createElement("input", { ...attributes, "type": `text`, "class": `b-0 p-0 block w-full h-full box-border tx-inherit outline-none bg-transparent`, "change": handlers.change, "keyup": handlers.transform }).element,
        import_Registry27.default.createText(`
`, false),
        import_Registry27.default.createElement("template", { "type": `light` }, [
          import_Registry27.default.createText(`
  `, false),
          import_Registry27.default.createElement("input", { ...attributes, "type": `text`, "change": handlers.change, "keyup": handlers.transform }).element,
          import_Registry27.default.createText(`
`, false)
        ]).element,
        import_Registry27.default.createText(`
`, false),
        import_Registry27.default.createElement("template", { "type": `shadow` }, [
          import_Registry27.default.createText(`
  `, false),
          import_Registry27.default.createElement("slot", {}, []).element,
          import_Registry27.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\switch.ink
  var import_Registry28 = __toESM(require_Registry());
  var import_Field3 = __toESM(require_Field());
  var import_StyleSet22 = __toESM(require_StyleSet());
  var import_option3 = __toESM(require_option());
  var Switch_6a5872ff1487f563ea53 = class extends import_Field3.default {
    static id = "6a5872ff1487f563ea53";
    static tagname = "switch";
    static classname = "Switch_6a5872ff1487f563ea53";
    static observedAttributes = ["checked", "disabled", "name", "readonly", "required", "value"];
    styles() {
      return `:host {
  display: inline-block;
}

label {
  position: relative;
  margin: 0;
}

span {
  display: inline-block;
  font-weight: normal;
  line-height: 20px;
  margin: 0 4px;
  min-height: 24px;
  min-width: 18px;
  position: relative;
}

span::before {
  font-family: Arial, Helvetica, sans-serif;
  border-style: solid;
  border-width: 1px;
  box-shadow: inset 0px 2px 2px 0px rgba(0, 0, 0, .2);
  color: #999999;
  display: inline-block;
  font-weight: bold;
  height: 20px;
  margin-right: 8px;
  overflow: hidden;
  padding: 0;
  position: relative;
  text-align: left;
  text-indent: -19px;
  top: 5px;
  transition: text-indent .4s ease;
  width: 52px;
}

span::after {
  -webkit-box-shadow: 0px 1px 1px 1px rgba(0, 0, 0, .3);
  -webkit-transition: left .4s ease;
  box-shadow: 0px 1px 1px 1px rgba(0, 0, 0, .3);
  font-family: Arial, Helvetica, sans-serif;
  font-size: 10px;
  font-weight: lighter;
  left: -3px;
  line-height: 20px;
  height: 22px;
  padding: 0;
  position: absolute;
  text-align: center;
  text-shadow: -1px 0px 0 rgba(0, 0, 0, 0.15);
  top: 4px;
  transition: left .4s ease;
  width: 22px;
}

input {
  cursor: pointer;
  height: 25px;
  opacity: 0;
  position: absolute;
  width: 55px;
}

input:checked + span::before {
  text-indent: 9px;
}

input:checked + span::after {
  left: 34px;
}`;
    }
    template() {
      const {
        error,
        rounded,
        onoff,
        yesno,
        checkex,
        sunmoon,
        ridge,
        smooth,
        blue,
        orange,
        green,
        change,
        update,
        label = "",
        //we dont need these
        "class": _2,
        style,
        ...attributes
      } = this.props;
      const styles = new import_StyleSet22.default();
      const css = this.styles();
      this.styles = () => css + styles.toString();
      const space = "\\a0";
      if (onoff) {
        styles.add("span::before", "content", `"ON${space.repeat(8)}OFF"`);
        styles.add("span::before", "font-size", "11px");
      } else if (yesno) {
        styles.add("span::before", "content", `"YES${space.repeat(9)}NO"`);
        styles.add("span::before", "font-size", "10px");
      } else if (checkex) {
        styles.add("span::before", "content", `"${space}\\2713${space.repeat(9)}\\2716"`);
        styles.add("span::before", "font-size", "13px");
      } else if (sunmoon) {
        styles.add("span::before", "content", `"\\263C${space.repeat(6)}\\263D"`);
        styles.add("span::before", "font-size", "18px");
      } else {
        styles.add("span::before", "content", `"${space}\\2713${space.repeat(9)}\\2716"`);
        styles.add("span::before", "font-size", "13px");
      }
      if (rounded) {
        styles.add("span::before", "border-radius", "12px");
        styles.add("span::after", "border-radius", "100%");
      }
      if (ridge) {
        styles.add("span::after", "content", '"|||"');
      } else if (smooth) {
        styles.add("span::after", "content", '" "');
      } else {
        styles.add("span::after", "content", '" "');
      }
      if (green) {
        styles.add("span::before", "background-color", "#DC3545");
        styles.add("span::before", "border-color", "#DC3545");
        styles.add("span::before", "color", "#FFFFFF");
        styles.add("span::after", "background-color", "#F9F9F9");
        styles.add("span::after", "color", "#DC3545");
        styles.add("input:checked + span::before", "background-color", "#28A745");
        styles.add("input:checked + span::before", "border-color", "#28A745");
        styles.add("input:checked + span::before", "color", "#FFFFFF");
        styles.add("input:checked + span::after", "background-color", "#F9F9F9");
        styles.add("input:checked + span::after", "color", "#28A745");
      } else if (orange) {
        styles.add("span::before", "background-color", "#888888");
        styles.add("span::before", "border-color", "#CCCCCC");
        styles.add("span::before", "color", "#DDDDDD");
        styles.add("span::after", "background-color", "#FFFFFF");
        styles.add("span::after", "color", "#D5D5D5");
        styles.add("input:checked + span::before", "background-color", "#FF893C");
        styles.add("input:checked + span::before", "border-color", "#FF893C");
        styles.add("input:checked + span::before", "color", "#FFFFFF");
        styles.add("input:checked + span::after", "background-color", "#FFFFFF");
        styles.add("input:checked + span::after", "color", "#FF893C");
      } else if (blue) {
        styles.add("span::before", "background-color", "#8B9AA3");
        styles.add("span::before", "border-color", "#8B9AA3");
        styles.add("span::before", "color", "#FFFFFF");
        styles.add("span::after", "background-color", "#FFFFFF");
        styles.add("span::after", "color", "#D5D5D5");
        styles.add("input:checked + span::before", "background-color", "#468FCC");
        styles.add("input:checked + span::before", "border-color", "#468FCC");
        styles.add("input:checked + span::before", "color", "#FFFFFF");
        styles.add("input:checked + span::after", "background-color", "#F9F9F9");
        styles.add("input:checked + span::after", "color", "#468FCC");
      } else {
        styles.add("span::before", "background-color", "#F5F5F5");
        styles.add("span::before", "border-color", "#CCCCCC");
        styles.add("span::before", "color", "#999999");
        styles.add("span::after", "background-color", "#FFFFFF");
        styles.add("span::after", "color", "#D5D5D5");
        styles.add("input:checked + span::before", "background-color", "#8AB2C9");
        styles.add("input:checked + span::before", "border-color", "#468FCC");
        styles.add("input:checked + span::before", "color", "#FFFFFF");
        styles.add("input:checked + span::after", "background-color", "#FFFFFF");
        styles.add("input:checked + span::after", "color", "#8AB2C9");
      }
      const handlers = (0, import_option3.getHandlers)(this, change, update);
      return () => [
        import_Registry28.default.createText(`
`, false),
        import_Registry28.default.createElement("label", { "mount": handlers.mount }, [
          import_Registry28.default.createText(`
  `, false),
          import_Registry28.default.createElement("input", { ...attributes, "type": `checkbox`, "change": handlers.change }).element,
          import_Registry28.default.createText(`
  `, false),
          import_Registry28.default.createElement("span", {}, [
            ...this._toNodeList(label)
          ]).element,
          import_Registry28.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\textarea.ink
  var import_Registry29 = __toESM(require_Registry());
  var import_Component26 = __toESM(require_Component());
  var import_StyleSet23 = __toESM(require_StyleSet());
  var import_input10 = __toESM(require_input());
  var Textarea_8a2ce892dd22c3ebd0b9 = class extends import_Component26.default {
    static id = "8a2ce892dd22c3ebd0b9";
    static tagname = "textarea";
    static classname = "Textarea_8a2ce892dd22c3ebd0b9";
    static observedAttributes = ["disabled", "name", "placeholder", "readonly", "required", "rows"];
    styles() {
      return ``;
    }
    template() {
      const {
        //handlers
        change,
        update,
        //input attributes
        attributes,
        //the rest of the props
        ...props
      } = (0, import_input10.getProps)(this);
      const children2 = this.originalChildren;
      const styles = new import_StyleSet23.default();
      this.styles = () => styles.toString();
      (0, import_input10.setDefaultStyles)(props, styles);
      const handlers = (0, import_input10.getHandlers)(this, change, update);
      return () => [
        import_Registry29.default.createText(`
`, false),
        import_Registry29.default.createElement("template", { "type": `light` }, [
          import_Registry29.default.createText(`
  `, false),
          import_Registry29.default.createElement("textarea", { ...attributes, "change": handlers.change }, [
            ...this._toNodeList(children2)
          ]).element,
          import_Registry29.default.createText(`
`, false)
        ]).element,
        import_Registry29.default.createText(`
`, false),
        import_Registry29.default.createElement("template", { "type": `shadow` }, [
          import_Registry29.default.createText(`
  `, false),
          import_Registry29.default.createElement("slot", {}, []).element,
          import_Registry29.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\taglist.ink
  var import_Registry30 = __toESM(require_Registry());
  var import_Component27 = __toESM(require_Component());
  var import_StyleSet24 = __toESM(require_StyleSet());
  var import_color5 = __toESM(require_color());
  var import_display15 = __toESM(require_display());
  var import_signal6 = __toESM(require_signal());
  var Taglist_77761941800dcd7a085c = class extends import_Component27.default {
    static id = "77761941800dcd7a085c";
    static tagname = "taglist";
    static classname = "Taglist_77761941800dcd7a085c";
    styles() {
      return `div {
    align-items: center;
    background-color: var(--white);
    border: 1px solid var(--black);
    box-sizing: border-box;
    display: flex;
    max-width: 100%;
    overflow: auto;
    padding-bottom: 5px;
    padding-left: 4px;
    padding-top: 5px;
    width: 100%;
  }
  span {
    align-items: center;
    border-radius: 4px;
    color: var(--white);
    display: inline-block;
    margin-right: 2px;
    padding: 2px 4px;
    white-space: nowrap;
  }
  em {
    color: var(--white);
    cursor: pointer;
    display: inline-block;
    font-style: normal;
    padding-left: 5px;
  }
  input {
    background-color: transparent;
    border: 0;
    box-sizing: border-box;
    font-size: inherit;
    font-family: inherit;
    height: 100%;
    min-width: 50%;
    padding: 0;
    width: 100%;
  }
  input:focus {
    outline: none;
  }`;
    }
    template() {
      const {
        info,
        warning,
        success,
        error,
        muted,
        primary,
        color,
        secondary,
        placeholder,
        change,
        update,
        value = [],
        name: name2
      } = this.props;
      const styles = new import_StyleSet24.default();
      const css = this.styles();
      this.styles = () => css + styles.toString();
      (0, import_display15.default)(this.props, styles, "block", ":host");
      (0, import_color5.default)(this.props, styles, "var(--warning)", "span", "background-color");
      const state = (0, import_signal6.default)(
        typeof value === "string" ? value.split(",").filter((value2) => value2.length > 0) : Array.from(value)
      );
      const handlers = {
        change: (e) => {
          change && change(e);
        },
        remove: (index) => {
          state.value = state.value.filter((tag2, i) => i !== index);
          update && update(state.value);
        },
        edit: (e) => {
          const { key } = e;
          const value2 = e.target.value.trim();
          if ((key === "Enter" || key === ",") && value2.length > 0 && !state.value.includes(value2)) {
            e.preventDefault();
            state.value = [...state.value, value2];
            this.shadowRoot?.querySelector("input")?.focus();
            update && update(state.value);
          } else if (key === "Backspace" && e.target.value.length === 0 && state.value.length > 0) {
            e.preventDefault();
            const tags = [...state.value];
            const value3 = tags.pop() || "";
            state.value = tags;
            const input = this.shadowRoot?.querySelector("input");
            if (input) {
              input.value = value3;
              input.focus();
            }
            update && update(tags);
          }
          return false;
        }
      };
      return () => [
        import_Registry30.default.createText(`
`, false),
        import_Registry30.default.createElement("template", { "type": `light` }, [
          import_Registry30.default.createText(`
  `, false),
          ...!!name2 ? [
            import_Registry30.default.createText(`
    `, false),
            ...Object.entries(state.value).map(([i, tag2]) => [
              import_Registry30.default.createText(`
      `, false),
              import_Registry30.default.createElement("input", { "type": `hidden`, "name": name2, "value": tag2 }).element,
              import_Registry30.default.createText(`
    `, false)
            ]).flat(),
            import_Registry30.default.createText(`
  `, false)
          ] : [],
          import_Registry30.default.createText(`
`, false)
        ]).element,
        import_Registry30.default.createText(`
`, false),
        import_Registry30.default.createElement("template", { "type": `shadow` }, [
          import_Registry30.default.createText(`
  `, false),
          import_Registry30.default.createElement("div", {}, [
            import_Registry30.default.createText(`
    `, false),
            ...Object.entries(state.value).map(([i, tag2]) => [
              import_Registry30.default.createText(`
      `, false),
              import_Registry30.default.createElement("span", {}, [
                import_Registry30.default.createText(`
        `, false),
                ...this._toNodeList(tag2),
                import_Registry30.default.createText(`
        `, false),
                import_Registry30.default.createElement("em", { "click": () => handlers.remove(Number(i)) }, [
                  import_Registry30.default.createText(`&times;`, false)
                ]).element,
                import_Registry30.default.createText(`
      `, false)
              ]).element,
              import_Registry30.default.createText(`
    `, false)
            ]).flat(),
            import_Registry30.default.createText(`
    `, false),
            import_Registry30.default.createElement("input", { "placeholder": placeholder, "keydown": handlers.edit, "keyup": handlers.save, "change": handlers.change }).element,
            import_Registry30.default.createText(`
  `, false)
          ]).element,
          import_Registry30.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\textlist.ink
  var import_Registry31 = __toESM(require_Registry());
  var import_Component28 = __toESM(require_Component());
  var import_StyleSet25 = __toESM(require_StyleSet());
  var import_display16 = __toESM(require_display());
  var import_fieldset3 = __toESM(require_fieldset());
  var Textlist_e6367e273a85cfed73bc = class extends import_Component28.default {
    static id = "e6367e273a85cfed73bc";
    static tagname = "textlist";
    static classname = "Textlist_e6367e273a85cfed73bc";
    styles() {
      return `a {
    color: var(--error);
    display: inline-block;
    cursor: pointer;
    text-decoration: none;
    padding: 0 10px;
  }
  legend {
    display: inline-block;
    float: right;
    line-height: 20px;
  }
  button {
    box-sizing: border-box;
    cursor: pointer;
    display: inline-block;
    font-family: inherit;
    font-size: inherit;
    margin-top: 7px;
    text-align: center;
  }
  fieldset {
    background-color: var(--white);
    border: 1px solid var(--black);
    margin: 0 0 -1px 0;
    padding: 0;
  }
  ::slotted(input) {
    border: 0;
    border-right: 1px solid var(--black);
    box-sizing: border-box;
    font-family: inherit;
    font-size: inherit;
    padding: 7px;
    width: calc(100% - 30px);
  }
  ::slotted(input:focus) {
    outline: none;
  }`;
    }
    template() {
      const { name: name2, add = "Add", value = [] } = this.props;
      const styles = new import_StyleSet25.default();
      const css = this.styles();
      this.styles = () => css + styles.toString();
      (0, import_display16.default)(this.props, styles, "block", ":host");
      (0, import_fieldset3.buttonStyles)(this.props, styles);
      const handlers = {
        add: (e) => {
          const shadow = this.shadowRoot;
          if (!shadow) return;
          const button = shadow.querySelector("button");
          if (!button) return;
          const { fieldset, field } = handlers.create(this.childElementCount);
          button.before(fieldset);
          this.appendChild(field);
        },
        create: (index, value2) => {
          const field = this.createElement("input", {
            slot: `row-${index}`,
            name: name2,
            value: value2
          }).element;
          const remove = import_Registry31.default.createElement(
            "a",
            {},
            ["&times;"]
          ).element;
          const slot = import_Registry31.default.createElement(
            "slot",
            { name: `row-${index}` }
          ).element;
          const fieldset = import_Registry31.default.createElement("fieldset", {}, [
            slot,
            remove
          ]).element;
          remove.addEventListener("click", () => handlers.remove(fieldset, field));
          return { fieldset, field };
        },
        remove: (fieldset, slot) => {
          const shadow = this.shadowRoot;
          if (!shadow) return;
          fieldset.remove();
          slot.remove();
          shadow.querySelectorAll("fieldset slot").forEach((slot2, index) => {
            slot2.setAttribute("name", `row-${index}`);
          });
          this.querySelectorAll(":scope > [slot]").forEach((slot2, index) => {
            slot2.setAttribute("slot", `row-${index}`);
          });
        }
      };
      const rows = value.map((value2, index) => handlers.create(index, value2));
      return () => [
        import_Registry31.default.createText(`
`, false),
        import_Registry31.default.createElement("template", { "type": `light` }, [
          import_Registry31.default.createText(`
  `, false),
          ...this._toNodeList(rows.map((row) => row.field)),
          import_Registry31.default.createText(`
`, false)
        ]).element,
        import_Registry31.default.createText(`
`, false),
        import_Registry31.default.createElement("template", { "type": `shadow` }, [
          import_Registry31.default.createText(`
  `, false),
          ...this._toNodeList(rows.map((row) => row.fieldset)),
          import_Registry31.default.createText(`
  `, false),
          import_Registry31.default.createElement("button", { "type": `button`, "click": handlers.add }, [
            ...this._toNodeList(add)
          ]).element,
          import_Registry31.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\time.ink
  var import_Registry32 = __toESM(require_Registry());
  var import_Component29 = __toESM(require_Component());
  var import_StyleSet26 = __toESM(require_StyleSet());
  var import_input11 = __toESM(require_input());
  var Time_33e808b67f575a5b36fc = class extends import_Component29.default {
    static id = "33e808b67f575a5b36fc";
    static tagname = "time";
    static classname = "Time_33e808b67f575a5b36fc";
    static observedAttributes = ["autocomplete", "disabled", "name", "pattern", "readonly", "required", "value"];
    styles() {
      return ``;
    }
    template() {
      const {
        //handlers
        change,
        update,
        //input attributes
        attributes,
        //the rest of the props
        ...props
      } = (0, import_input11.getProps)(this);
      const styles = new import_StyleSet26.default();
      this.styles = () => styles.toString();
      (0, import_input11.setDefaultStyles)(props, styles);
      if (attributes.value) {
        try {
          attributes.value = attributes.value instanceof Date ? attributes.value.toISOString() : new Date(attributes.value).toISOString();
          const [date, min] = attributes.value.split(":");
          attributes.value = [date.split("T")[1], min].join(":");
        } catch (e) {
          delete attributes.value;
        }
      }
      const handlers = (0, import_input11.getHandlers)(this, change, update);
      return () => [
        import_Registry32.default.createText(`
`, false),
        import_Registry32.default.createElement("template", { "type": `light` }, [
          import_Registry32.default.createText(`
  `, false),
          import_Registry32.default.createElement("input", { ...attributes, "type": `time`, "change": handlers.change }).element,
          import_Registry32.default.createText(`
`, false)
        ]).element,
        import_Registry32.default.createText(`
`, false),
        import_Registry32.default.createElement("template", { "type": `shadow` }, [
          import_Registry32.default.createText(`
  `, false),
          import_Registry32.default.createElement("slot", {}, []).element,
          import_Registry32.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\wysiwyg.ink
  var import_Registry33 = __toESM(require_Registry());
  var import_Component30 = __toESM(require_Component());

  // ../../node_modules/suneditor/src/assets/defaultIcons.js
  var defaultIcons_default = {
    // rtl icon
    rtl: {
      italic: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10.5 15.8" xml:space="preserve"><g><path d="M0.3,0.1c0.3,0,0.5,0,0.7,0c1,0.1,1.7,0.1,2.2,0.1H4L7.2,0l0.2,1.1H7c-0.5,0-1,0.1-1.5,0.3v0.4l0.3,1.9L6,4.4L6.3,6 l0.1,0.4l0.1,0.5c0.1,0.2,0.1,0.4,0.2,0.7s0.1,0.6,0.2,0.9L7,9.1l0.6,2.8l0.3,1.4c0.1,0.4,0.2,0.7,0.4,1c0.4,0.2,0.8,0.3,1.2,0.4 l0.8,0.2l0.2,0.9l-1.1,0c-0.9-0.1-1.5-0.1-1.8-0.1h-2c-0.9,0.1-1.4,0.2-1.5,0.2c-0.1,0-0.2,0-0.3,0H3.4c-0.1,0-0.2,0-0.2,0 l-0.1-0.4c0-0.2-0.1-0.4-0.1-0.6l0.7-0.1c0.4,0,0.8-0.1,1.2-0.2c0-0.1,0-0.2,0-0.3l-0.1-0.5l-0.4-2.4L4,9.6L3.4,6.4 C3.2,5.7,3,4.7,2.7,3.3c0-0.3-0.1-0.5-0.1-0.8C2.5,2.1,2.4,1.9,2.3,1.6C2,1.4,1.6,1.3,1.3,1.2C0.9,1.2,0.5,1.1,0.2,0.9L0,0.4L0,0 L0.3,0.1L0.3,0.1z"/></g></svg>',
      indent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 12.4" xml:space="preserve"><g><g><path d="M15.5,10.1L15.5,10.1c0.1,0,0.3,0.1,0.3,0.3v1.7c0,0.1,0,0.1-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1l-15.2,0 c-0.1,0-0.1,0-0.2-0.1C0,12.2,0,12.2,0,12.1l0-1.7c0-0.1,0-0.1,0.1-0.2c0.1-0.1,0.1-0.1,0.2-0.1C0.3,10.1,15.5,10.1,15.5,10.1z M9.8,6.7c0.1,0,0.1,0,0.2,0.1C10.1,6.9,10.1,7,10.1,7v1.7c0,0.1,0,0.2-0.1,0.2C10,9,9.9,9,9.8,9L0.3,9C0.2,9,0.1,9,0.1,8.9 C0,8.9,0,8.8,0,8.7V7C0,7,0,6.9,0.1,6.8c0.1-0.1,0.1-0.1,0.2-0.1C0.3,6.7,9.8,6.7,9.8,6.7z M0.3,3.4h9.6h0c0.1,0,0.3,0.1,0.3,0.3 v1.7v0c0,0.1-0.1,0.3-0.3,0.3H0.3c-0.1,0-0.1,0-0.2-0.1C0,5.5,0,5.4,0,5.3V3.6c0-0.1,0-0.1,0.1-0.2C0.1,3.4,0.2,3.4,0.3,3.4 L0.3,3.4z M0.3,0l15.2,0c0.1,0,0.1,0,0.2,0.1c0.1,0.1,0.1,0.1,0.1,0.2V2c0,0.1,0,0.2-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1H0.3 c-0.1,0-0.1,0-0.2-0.1C0,2.1,0,2,0,2l0-1.7c0-0.1,0-0.1,0.1-0.2C0.1,0,0.2,0,0.3,0z"/></g><path d="M13.1,3.5L15.7,6c0.1,0.1,0.1,0.3,0,0.4l-2.5,2.5C13.1,9,13,9,12.9,9c-0.1,0-0.1,0-0.2-0.1c-0.1-0.1-0.1-0.1-0.1-0.2V3.7 c0-0.1,0-0.2,0.1-0.2c0.1-0.1,0.1-0.1,0.2-0.1C13,3.4,13.1,3.4,13.1,3.5z"/></g></svg>',
      outdent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 12.4" xml:space="preserve"><g><g><path d="M15.5,10.1L15.5,10.1c0.1,0,0.3,0.1,0.3,0.3v1.7c0,0.1,0,0.1-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1l-15.2,0 c-0.1,0-0.1,0-0.2-0.1C0,12.2,0,12.2,0,12.1l0-1.7c0-0.1,0-0.1,0.1-0.2c0.1-0.1,0.1-0.1,0.2-0.1C0.3,10.1,15.5,10.1,15.5,10.1z M9.8,6.7c0.1,0,0.1,0,0.2,0.1C10.1,6.9,10.1,7,10.1,7v1.7c0,0.1,0,0.2-0.1,0.2C10,9,9.9,9,9.8,9L0.3,9C0.2,9,0.1,9,0.1,8.9 C0,8.9,0,8.8,0,8.7V7C0,7,0,6.9,0.1,6.8c0.1-0.1,0.1-0.1,0.2-0.1C0.3,6.7,9.8,6.7,9.8,6.7z M0.3,3.4h9.6h0c0.1,0,0.3,0.1,0.3,0.3 v1.7v0c0,0.1-0.1,0.3-0.3,0.3H0.3c-0.1,0-0.1,0-0.2-0.1C0,5.5,0,5.4,0,5.3V3.6c0-0.1,0-0.1,0.1-0.2C0.1,3.4,0.2,3.4,0.3,3.4 L0.3,3.4z M0.3,0l15.2,0c0.1,0,0.1,0,0.2,0.1c0.1,0.1,0.1,0.1,0.1,0.2V2c0,0.1,0,0.2-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1H0.3 c-0.1,0-0.1,0-0.2-0.1C0,2.1,0,2,0,2l0-1.7c0-0.1,0-0.1,0.1-0.2C0.1,0,0.2,0,0.3,0z"/></g><path d="M15.5,3.4c0.1,0,0.1,0,0.2,0.1c0.1,0.1,0.1,0.1,0.1,0.2v5.1c0,0.1,0,0.1-0.1,0.2C15.6,9,15.5,9,15.5,9 c-0.1,0-0.1,0-0.2-0.1l-2.5-2.5c-0.1-0.1-0.1-0.3,0-0.4l2.5-2.5C15.3,3.4,15.4,3.4,15.5,3.4z"/></g></svg>',
      list_bullets: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 12.4" xml:space="preserve"><g><path d="M12.4,10.7c0,0.9,0.8,1.7,1.7,1.7c0.9,0,1.7-0.8,1.7-1.7C15.7,9.8,15,9,14.1,9c-0.4,0-0.9,0.2-1.2,0.5 C12.5,9.8,12.4,10.2,12.4,10.7C12.4,10.7,12.4,10.7,12.4,10.7z M12.4,6.2c0,0.9,0.8,1.7,1.7,1.7c0.4,0,0.9-0.2,1.2-0.5 c0.3-0.3,0.4-0.7,0.4-1.1c0-0.9-0.7-1.7-1.6-1.7C13.1,4.6,12.4,5.3,12.4,6.2C12.4,6.2,12.4,6.2,12.4,6.2z M0,9.8v1.7 c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1l10.7,0c0,0,0,0,0,0c0.1,0,0.3-0.1,0.3-0.3V9.8c0-0.1,0-0.1-0.1-0.2 C11.1,9.6,11,9.6,11,9.6l-10.7,0c-0.1,0-0.1,0-0.2,0.1C0,9.7,0,9.8,0,9.8L0,9.8z M12.9,2.9c0.3,0.3,0.7,0.5,1.2,0.5 c0.4,0,0.9-0.2,1.2-0.5c0.7-0.7,0.7-1.7,0-2.4C14.9,0.2,14.5,0,14.1,0c-0.4,0-0.9,0.2-1.2,0.5c-0.3,0.3-0.5,0.7-0.5,1.2 C12.4,2.1,12.5,2.6,12.9,2.9z M0,5.3V7c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1H11c0.1,0,0.1,0,0.2-0.1 c0.1-0.1,0.1-0.1,0.1-0.2V5.3c0,0,0,0,0,0c0-0.1-0.1-0.3-0.3-0.3H0.3c-0.1,0-0.1,0-0.2,0.1C0,5.2,0,5.3,0,5.3L0,5.3z M0,0.8v1.7 c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1h10.7c0.1,0,0.1,0,0.2-0.1c0,0,0.1-0.1,0.1-0.2V0.8c0-0.1,0-0.1-0.1-0.2 c0-0.1-0.1-0.1-0.2-0.1H0.3c-0.1,0-0.1,0-0.2,0.1C0,0.7,0,0.8,0,0.8L0,0.8z"/></g></svg>',
      list_number: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.7" xml:space="preserve"><g><path d="M0,11.5l0,1.7c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1H11c0.1,0,0.2,0,0.2-0.1c0.1-0.1,0.1-0.1,0.1-0.2v-1.7 c0-0.1,0-0.1-0.1-0.2c-0.1-0.1-0.1-0.1-0.2-0.1H0.3c-0.1,0-0.2,0-0.2,0.1C0,11.4,0,11.4,0,11.5L0,11.5z M0,8.7c0,0.1,0,0.1,0.1,0.2 C0.1,8.9,0.2,9,0.3,9H11c0.1,0,0.2,0,0.2-0.1c0.1-0.1,0.1-0.1,0.1-0.2V7c0-0.1,0-0.1-0.1-0.2c-0.1-0.1-0.1-0.1-0.2-0.1l-10.7,0 c-0.1,0-0.2,0-0.2,0.1C0,6.8,0,6.9,0,7C0,7,0,8.7,0,8.7z M0,2.5v1.7c0,0.1,0,0.1,0.1,0.2c0,0,0.1,0.1,0.2,0.1l10.7,0 c0.1,0,0.2,0,0.2-0.1c0.1-0.1,0.1-0.1,0.1-0.2V2.4c0-0.1,0-0.1-0.1-0.2c-0.1,0-0.1,0-0.2,0H0.3c-0.1,0-0.1,0-0.2,0 C0,2.3,0,2.4,0,2.5L0,2.5z"/></g><path d="M15.6,14.2c0-0.3-0.1-0.6-0.3-0.8c-0.2-0.2-0.4-0.4-0.7-0.4l0.9-1v-0.8h-2.9v1.3h0.9v-0.5h0.9l0,0c-0.1,0.1-0.2,0.2-0.3,0.3 s-0.2,0.3-0.4,0.5l-0.3,0.3l0.2,0.5c0.6,0,0.9,0.1,0.9,0.5c0,0.1-0.1,0.3-0.2,0.4c-0.1,0.1-0.3,0.1-0.4,0.1c-0.3,0-0.7-0.1-0.9-0.3 l-0.5,0.8c0.4,0.4,0.9,0.6,1.5,0.6c0.4,0,0.9-0.1,1.2-0.4C15.5,15.1,15.6,14.7,15.6,14.2z"/><path d="M15.6,8.7h-0.9v0.5h-1.1c0-0.2,0.2-0.4,0.4-0.5c0.2-0.2,0.4-0.3,0.7-0.4c0.3-0.2,0.5-0.3,0.7-0.6c0.2-0.2,0.3-0.5,0.3-0.8 c0-0.4-0.2-0.8-0.5-1c-0.6-0.4-1.4-0.5-2-0.1c-0.3,0.2-0.5,0.4-0.6,0.7L13.3,7c0.1-0.3,0.4-0.5,0.7-0.5c0.1,0,0.3,0,0.3,0.1 c0.1,0.1,0.1,0.2,0.1,0.3c0,0.2-0.1,0.3-0.2,0.4c-0.2,0.1-0.3,0.3-0.5,0.4c-0.2,0.1-0.4,0.3-0.6,0.4c-0.2,0.2-0.4,0.4-0.5,0.6 c-0.1,0.2-0.2,0.5-0.2,0.8c0,0.2,0,0.3,0,0.5h3.2L15.6,8.7L15.6,8.7z"/><path d="M15.6,3.6h-1V0h-0.9l-1.2,1.1l0.6,0.7c0.2-0.1,0.3-0.3,0.4-0.5l0,0v2.2h-0.9v0.9h3L15.6,3.6L15.6,3.6z"/></svg>',
      link: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.7" xml:space="preserve"><g><path d="M7.4,9.9l3.1,3.1c0.3,0.3,0.8,0.5,1.3,0.5c0.5,0,0.9-0.2,1.3-0.5c0,0,0,0,0,0c0.7-0.7,0.7-1.9,0-2.6L9.9,7.3 c0-0.1,0-0.2,0-0.3C9.9,7,10,7,10.1,7l2.2-0.2c0.1,0,0.1,0,0.2,0.1l2.1,2.1c0.4,0.4,0.7,0.8,0.9,1.3c0.2,0.5,0.3,1,0.3,1.5 c0,0.5-0.1,1-0.3,1.5c-0.8,2-3.2,3-5.2,2.2c-0.5-0.2-0.9-0.5-1.3-0.9l-2.1-2.1c-0.1,0-0.1-0.1-0.1-0.2L7,10.1C7,10,7,9.9,7.1,9.9 C7.2,9.8,7.3,9.9,7.4,9.9z M1.2,1.1C1.6,0.7,2,0.4,2.5,0.3c1-0.4,2.1-0.4,3.1,0C6,0.4,6.5,0.7,6.8,1.1L9,3.2C9,3.3,9.1,3.3,9,3.4 L8.8,5.6c0,0.1-0.1,0.2-0.2,0.2c-0.1,0.1-0.2,0.1-0.3,0L5.3,2.7C5,2.3,4.5,2.1,4,2.1c-0.5,0-0.9,0.2-1.3,0.5c0,0,0,0,0,0 C2,3.4,2,4.5,2.7,5.2l3.1,3.2c0.1,0.1,0.1,0.2,0,0.3c0,0.1-0.1,0.1-0.2,0.1L3.5,9C3.4,9,3.4,9,3.3,8.9L1.2,6.8c0,0,0,0,0,0 C-0.4,5.2-0.4,2.7,1.2,1.1L1.2,1.1z M14.3,6h-2.6c0,0,0,0,0,0c-0.1,0-0.2-0.1-0.2-0.2c0-0.1,0-0.2,0.1-0.3l2.5-0.7 c0.1,0,0.1,0,0.2,0c0.1,0,0.1,0.1,0.1,0.2l0.1,0.8c0,0.1,0,0.1-0.1,0.2C14.5,6,14.4,6,14.3,6L14.3,6z M10.2,4.1 c0,0.1-0.1,0.2-0.2,0.2l0,0c0,0,0,0,0,0C9.8,4.2,9.7,4.1,9.8,4L9.7,1.4c0-0.1,0-0.1,0.1-0.2c0.1,0,0.1,0,0.2,0h0.8 c0.1,0,0.1,0,0.2,0.1c0,0.1,0,0.1,0,0.2L10.2,4.1L10.2,4.1z M1.5,9.7h1.3h1.3c0.1,0,0.2,0.1,0.2,0.2c0,0.1,0,0.2-0.1,0.3l-2.5,0.6 H1.6c0,0-0.1,0-0.1,0c-0.1,0-0.1-0.1-0.1-0.2L1.2,9.9c0-0.1,0-0.1,0.1-0.2c0-0.1,0.1-0.1,0.2-0.1L1.5,9.7z M5.6,11.6 C5.6,11.6,5.6,11.6,5.6,11.6c0-0.1,0.1-0.2,0.3-0.1c0,0,0,0,0,0c0.1,0,0.2,0.1,0.2,0.2v2.6c0,0.1,0,0.1-0.1,0.2 c0,0-0.1,0.1-0.2,0.1L5,14.5c-0.1,0-0.1,0-0.2-0.1c0-0.1,0-0.1,0-0.2L5.6,11.6L5.6,11.6z"/></g></svg>',
      unlink: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.7" xml:space="preserve"><g><path d="M14.6,14.6c1.6-1.6,1.6-4.1,0-5.7l0,0l-3.1-3.1l-1.2,1.6l2.9,2.9c0.4,0.4,0.6,0.9,0.6,1.5c0,1.1-0.9,2.1-2.1,2.1l0,0 c-0.6,0-1.1-0.2-1.5-0.6l-0.4-0.4l-1.7,1l0.8,0.8C10.4,16.2,13,16.2,14.6,14.6L14.6,14.6L14.6,14.6z M3.6,6C3,5.9,2.6,5.5,2.3,5 S1.9,4,2.1,3.4C2.3,2.9,2.6,2.5,3,2.2C3.5,2,4.1,1.9,4.6,2l3.3,1.4l0.5-2L5.1,0.1C4-0.1,2.9,0,2,0.5C1.1,1.1,0.4,1.9,0.2,3 C-0.1,4,0,5.1,0.6,6C1.1,6.9,1.9,7.6,3,7.8l5.4,2l0.5-2L6.2,6.9L3.6,6z"/></g></svg>'
    },
    // common, ltr icon
    redo: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.59 14.18"><g><path d="M11.58,18.48a6.84,6.84,0,1,1,6.85-6.85s0,.26,0,.67a8,8,0,0,1-.22,1.44l.91-.55a.51.51,0,0,1,.36,0,.45.45,0,0,1,.29.22.47.47,0,0,1,.06.36.45.45,0,0,1-.22.29L17.42,15.3l-.12,0h-.25l-.12-.06-.09-.09-.06-.07,0-.06-.87-2.12a.43.43,0,0,1,0-.37.49.49,0,0,1,.27-.26.41.41,0,0,1,.36,0,.53.53,0,0,1,.27.26l.44,1.09a6.51,6.51,0,0,0,.24-1.36,4.58,4.58,0,0,0,0-.64,5.83,5.83,0,0,0-1.73-4.17,5.88,5.88,0,0,0-8.34,0,5.9,5.9,0,0,0,4.17,10.06.51.51,0,0,1,.33.15.48.48,0,0,1,0,.68.53.53,0,0,1-.33.12Z" transform="translate(-4.48 -4.54)"/></g></svg>',
    undo: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.59 14.18"><g><path d="M5,14a.43.43,0,0,1-.22-.29.46.46,0,0,1,.06-.36.43.43,0,0,1,.29-.22.56.56,0,0,1,.36,0l.91.55a8.27,8.27,0,0,1-.22-1.45,5.07,5.07,0,0,1,0-.67A6.85,6.85,0,1,1,13,18.47a.44.44,0,0,1-.33-.13.48.48,0,0,1,0-.68.51.51,0,0,1,.33-.15A5.89,5.89,0,0,0,17.15,7.45a5.88,5.88,0,0,0-8.33,0,5.84,5.84,0,0,0-1.73,4.17s0,.25,0,.65a6.49,6.49,0,0,0,.24,1.37l.44-1.09a.57.57,0,0,1,.27-.26.41.41,0,0,1,.36,0,.53.53,0,0,1,.27.26.43.43,0,0,1,0,.37L7.82,15l0,.09-.09.09-.1.07-.06,0H7.28l-.13,0-1.09-.63c-.65-.36-1-.57-1.1-.63Z" transform="translate(-4.49 -4.53)"/></g></svg>',
    bold: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.76 15.75"><g><path d="M6.4,3.76V19.5h6.76a5.55,5.55,0,0,0,2-.32,4.93,4.93,0,0,0,1.52-1,4.27,4.27,0,0,0,1.48-3.34,3.87,3.87,0,0,0-.69-2.37,5.74,5.74,0,0,0-.71-.83,3.44,3.44,0,0,0-1.1-.65,3.6,3.6,0,0,0,1.58-1.36,3.66,3.66,0,0,0,.53-1.93,3.7,3.7,0,0,0-1.21-2.87,4.65,4.65,0,0,0-3.25-1.1H6.4Zm2.46,6.65V5.57h3.52a4.91,4.91,0,0,1,1.36.15,2.3,2.3,0,0,1,.85.45,2.06,2.06,0,0,1,.74,1.71,2.3,2.3,0,0,1-.78,1.92,2.54,2.54,0,0,1-.86.46,4.7,4.7,0,0,1-1.32.15H8.86Zm0,7.27V12.15H12.7a4.56,4.56,0,0,1,1.38.17,3.43,3.43,0,0,1,.95.49,2.29,2.29,0,0,1,.92,2,2.73,2.73,0,0,1-.83,2.1,2.66,2.66,0,0,1-.83.58,3.25,3.25,0,0,1-1.26.2H8.86Z" transform="translate(-6.4 -3.75)"/></g></svg>',
    underline: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 9.78 15.74"><g><path d="M14.64,3.76h2.52v7.72a4.51,4.51,0,0,1-.59,2.31,3.76,3.76,0,0,1-1.71,1.53,6.12,6.12,0,0,1-2.64.53,5,5,0,0,1-3.57-1.18,4.17,4.17,0,0,1-1.27-3.24V3.76H9.9v7.3a3,3,0,0,0,.55,2,2.3,2.3,0,0,0,1.83.65,2.26,2.26,0,0,0,1.8-.65,3.09,3.09,0,0,0,.55-2V3.76Zm2.52,13.31V19.5H7.39V17.08h9.77Z" transform="translate(-7.38 -3.76)"/></g></svg>',
    italic: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10.49 15.76"><g><path d="M17.16,3.79l.37,0-.06.38-.14.52A10,10,0,0,1,16.21,5a9.37,9.37,0,0,0-1,.32,6.68,6.68,0,0,0-.25.89c-.06.31-.11.59-.14.85-.3,1.36-.52,2.41-.68,3.14l-.61,3.18L13.1,15l-.43,2.4-.12.46a.62.62,0,0,0,0,.28c.44.1.85.17,1.23.22l.68.11a4.51,4.51,0,0,1-.08.6l-.09.42a.92.92,0,0,0-.23,0l-.43,0a1.37,1.37,0,0,1-.29,0c-.13,0-.63-.08-1.49-.16l-2,0c-.28,0-.87,0-1.78.12L7,19.5l.17-.88.8-.2A6.61,6.61,0,0,0,9.19,18,2.62,2.62,0,0,0,9.61,17l.28-1.41.58-2.75.12-.66c.05-.3.11-.58.17-.86s.12-.51.17-.69l.12-.48.12-.43.31-1.6.15-.65.31-1.91V5.14a3.86,3.86,0,0,0-1.48-.29l-.38,0,.2-1.06,3.24.14.75,0c.45,0,1.18,0,2.18-.09.23,0,.46,0,.71,0Z" transform="translate(-7.04 -3.76)"/></g></svg>',
    strike: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.9"><g><path d="M12.94,13a4.27,4.27,0,0,1,1.32.58,1.46,1.46,0,0,1,.55,1.2,1.87,1.87,0,0,1-.88,1.64,4.17,4.17,0,0,1-2.35.59,4.44,4.44,0,0,1-2.74-.71,2.72,2.72,0,0,1-1-2.17H5.57a4.56,4.56,0,0,0,1.55,3.7,7,7,0,0,0,4.47,1.23,6,6,0,0,0,4.07-1.3,4.24,4.24,0,0,0,1.52-3.37,4,4,0,0,0-.26-1.4h-4ZM6.37,10.24A3.27,3.27,0,0,1,6,8.68a4,4,0,0,1,1.48-3.3,5.92,5.92,0,0,1,3.88-1.21,5.58,5.58,0,0,1,3.91,1.24,4.36,4.36,0,0,1,1.45,3.17H14.44a2.12,2.12,0,0,0-.91-1.81,4.45,4.45,0,0,0-2.44-.55,3.69,3.69,0,0,0-2,.51A1.64,1.64,0,0,0,8.3,8.22a1.3,1.3,0,0,0,.48,1.11,7,7,0,0,0,2.1.78l.28.06.28.08H6.37Zm13.09.68a.73.73,0,0,1,.49.21.66.66,0,0,1,.2.48.64.64,0,0,1-.2.48.71.71,0,0,1-.49.19H5.1a.67.67,0,0,1-.49-.19.66.66,0,0,1-.2-.48.64.64,0,0,1,.2-.48.73.73,0,0,1,.49-.21H19.46Z" transform="translate(-4.41 -4.17)"/></g></svg>',
    subscript: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 14.61"><g><path d="M15.38,4.33H12.74L11.19,7c-.28.46-.51.87-.69,1.21L10.07,9h0l-.44-.8c-.22-.4-.45-.81-.71-1.23L7.34,4.33H4.68L8.26,10,4.4,16.08H7.1l1.69-2.83c.38-.63.72-1.22,1-1.78l.25-.46h0l.49.92c.24.45.48.89.74,1.32L13,16.08h2.61L11.84,10l1.77-2.84,1.77-2.85Zm4.77,13.75H17v-.15c0-.4.05-.64.16-.72a4.42,4.42,0,0,1,1.16-.31,3.3,3.3,0,0,0,1.54-.56A1.84,1.84,0,0,0,20.15,15a1.78,1.78,0,0,0-.44-1.41A2.8,2.8,0,0,0,18,13.25a2.71,2.71,0,0,0-1.69.37,1.83,1.83,0,0,0-.44,1.43v.23H17v-.23q0-.63.18-.78a1.62,1.62,0,0,1,.88-.15,1.59,1.59,0,0,1,.88.15q.18.15.18.75t-.18.75a3.58,3.58,0,0,1-1.18.33,3.33,3.33,0,0,0-1.52.51,1.57,1.57,0,0,0-.32,1.18v1.15h4.27v-.86Z" transform="translate(-4.4 -4.33)"/></g></svg>',
    superscript: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.42"><g><path d="M12,13.14l3.61-5.81H12.94L11.33,10c-.28.46-.51.88-.69,1.25l-.45.83h0l-.45-.85c-.22-.41-.45-.82-.71-1.24L7.4,7.33H4.68l3.66,5.81L4.4,19.33H7.14l1.74-2.87q.58-1,1-1.83l.25-.48h0l.51.94.75,1.37,1.72,2.87h2.67l-1.92-3.09c-1.12-1.8-1.76-2.83-1.92-3.1Zm4.84-4.41h0l0,.15h3.27v.86H15.77V8.58a1.66,1.66,0,0,1,.33-1.22,3.51,3.51,0,0,1,1.56-.51,3.68,3.68,0,0,0,1.21-.34c.13-.1.19-.36.19-.77S19,5.07,18.87,5A1.63,1.63,0,0,0,18,4.8a1.58,1.58,0,0,0-.91.17c-.13.11-.19.38-.19.8V6H15.78V5.76a1.87,1.87,0,0,1,.45-1.47A2.84,2.84,0,0,1,18,3.91a2.8,2.8,0,0,1,1.72.38,1.84,1.84,0,0,1,.45,1.44,1.91,1.91,0,0,1-.34,1.35,3.24,3.24,0,0,1-1.58.57A3.69,3.69,0,0,0,17,8c-.12.1-.17.35-.17.76Z" transform="translate(-4.4 -3.91)"/></g></svg>',
    erase: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.76"><g><path d="M13.69,17.2h6.46v1.31H8.56L4.41,14.37,14,4.75l6.06,6.06L16.89,14l-3.2,3.19Zm-4.61,0h2.77L14.09,15,9.88,10.75,6.25,14.38l1.41,1.41c.84.82,1.31,1.29,1.42,1.41Z" transform="translate(-4.41 -4.75)"/></g></svg>',
    indent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 12.36"><g><path d="M4.68,14.45a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V9.1a.27.27,0,0,1,.08-.19.28.28,0,0,1,.2-.08.25.25,0,0,1,.19.07l2.54,2.54a.29.29,0,0,1,0,.4L4.88,14.36a.24.24,0,0,1-.2.09Zm15.19,1.12a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.25.25,0,0,1-.08-.19V15.84a.27.27,0,0,1,.27-.27H19.87Zm0-3.38a.27.27,0,0,1,.19.08.28.28,0,0,1,.08.21v1.68a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V12.48a.32.32,0,0,1,.08-.21.24.24,0,0,1,.19-.08h9.56Zm0-3.37a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.27-.27V9.1a.27.27,0,0,1,.27-.27h9.56Zm.2-3.29a.28.28,0,0,1,.08.2V7.41a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V5.73a.32.32,0,0,1,.08-.21.25.25,0,0,1,.19-.08H19.87a.28.28,0,0,1,.2.09Z" transform="translate(-4.41 -5.44)"/></g></svg>',
    outdent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 12.36"><g><path d="M19.87,15.57a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.25.25,0,0,1-.08-.19V15.84a.27.27,0,0,1,.27-.27H19.87ZM7.5,14.45a.25.25,0,0,1-.2-.09L4.76,11.84a.29.29,0,0,1,0-.4L7.3,8.9a.29.29,0,0,1,.4,0,.31.31,0,0,1,.07.2v5.06a.32.32,0,0,1-.08.21.26.26,0,0,1-.19.08ZM19.87,8.82a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.27-.27V9.1a.27.27,0,0,1,.27-.27h9.56Zm0,3.37a.27.27,0,0,1,.19.08.28.28,0,0,1,.08.21v1.68a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V12.48a.32.32,0,0,1,.08-.21.24.24,0,0,1,.19-.08h9.56Zm.2-6.66a.28.28,0,0,1,.08.2V7.41a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V5.73a.32.32,0,0,1,.08-.21.25.25,0,0,1,.19-.08H19.87a.28.28,0,0,1,.2.09Z" transform="translate(-4.41 -5.44)"/></g></svg>',
    expansion: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M11.8,13.06l-5.1,5.1H9.51V19.5H4.41V14.4H5.75v2.81L8.3,14.66q2.25-2.23,2.55-2.55Zm8.35-9.3v5.1H18.81V6.05l-5.1,5.1-1-1,5.1-5.1H15.05V3.76Z" transform="translate(-4.41 -3.76)"/></g></svg>',
    reduction: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M14.91,10h2.87v1.38H12.55V6.12h1.38V9l5.24-5.24.48.49.49.48ZM6.77,11.92H12v5.23H10.62V14.26L5.37,19.5l-1-1L9.63,13.3H6.77Z" transform="translate(-4.4 -3.76)"/></g></svg>',
    code_view: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 11.8"><g><path d="M8.09,7.94a.76.76,0,0,1,.53.22.72.72,0,0,1,.21.52.76.76,0,0,1-.22.54L6.18,11.63l2.43,2.44a.69.69,0,0,1,.2.51.66.66,0,0,1-.21.51.75.75,0,0,1-.51.22.63.63,0,0,1-.51-.21h0L4.63,12.15a.7.7,0,0,1-.22-.53.67.67,0,0,1,.25-.55L7.57,8.16a.82.82,0,0,1,.52-.22Zm12.05,3.69a.7.7,0,0,1-.23.52L17,15.1h0a.66.66,0,0,1-.51.21.73.73,0,0,1-.51-.22.75.75,0,0,1-.22-.51.63.63,0,0,1,.21-.51l2.43-2.44L15.92,9.22a.73.73,0,0,1-.22-.53A.74.74,0,0,1,17,8.18h0l2.91,2.91a.67.67,0,0,1,.27.54Zm-5.9-5.9a.73.73,0,0,1,.61.32.71.71,0,0,1,.07.68L11,17a1,1,0,0,1-.22.32.6.6,0,0,1-.35.16.75.75,0,0,1-.69-.26.69.69,0,0,1-.12-.72L13.56,6.23a.75.75,0,0,1,.26-.35.74.74,0,0,1,.42-.15Z" transform="translate(-4.41 -5.73)"/></g></svg>',
    preview: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.65 15.66"><g><path d="M16.19,14.43l2.49,2.49a.73.73,0,0,1,.21.52.67.67,0,0,1-.22.51.7.7,0,0,1-.52.22.69.69,0,0,1-.51-.21l-2.49-2.48a5.17,5.17,0,0,1-1.34.69,4.64,4.64,0,0,1-1.48.24,4.78,4.78,0,1,1,0-9.56,4.79,4.79,0,0,1,1.84.36,4.9,4.9,0,0,1,1.56,1,4.77,4.77,0,0,1,.46,6.18ZM10,14a3.3,3.3,0,0,0,2.34.93A3.37,3.37,0,0,0,14.7,14a3.3,3.3,0,0,0-1.08-5.41,3.47,3.47,0,0,0-2.56,0A3,3,0,0,0,10,9.28,3.31,3.31,0,0,0,10,14ZM16,4a3.86,3.86,0,0,1,2.77,1.14A3.9,3.9,0,0,1,20,7.85v4a.77.77,0,0,1-.22.53.7.7,0,0,1-.52.21.72.72,0,0,1-.74-.74v-4a2.46,2.46,0,0,0-.72-1.73A2.37,2.37,0,0,0,16,5.45H8.53A2.42,2.42,0,0,0,6.08,7.89v7.52a2.41,2.41,0,0,0,.71,1.73,2.46,2.46,0,0,0,1.74.72h4.08a.73.73,0,0,1,0,1.46H8.53a3.85,3.85,0,0,1-2.78-1.14A3.93,3.93,0,0,1,4.6,15.4V7.87A3.94,3.94,0,0,1,5.76,5.09,3.88,3.88,0,0,1,8.54,4H16Z" transform="translate(-4.45 -3.8)"/></g></svg>',
    print: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16.05 16.04"><g><path d="M19.76,15.84a1.29,1.29,0,0,0,.39-.92V8.35A2.05,2.05,0,0,0,19.57,7a1.93,1.93,0,0,0-1.38-.57H6.37a1.95,1.95,0,0,0-2,2v6.56a1.23,1.23,0,0,0,.38.92,1.35,1.35,0,0,0,.93.38h2V14.9l-2,0V8.35a.67.67,0,0,1,.18-.47.62.62,0,0,1,.48-.19H18.18a.6.6,0,0,1,.46.19.66.66,0,0,1,.18.47V14.9h-2v1.32h2A1.35,1.35,0,0,0,19.76,15.84ZM17.52,7.69V5.06a1.31,1.31,0,0,0-.38-.92,1.34,1.34,0,0,0-.94-.38H8.34A1.3,1.3,0,0,0,7,5.06V7.69H8.34V5.06h7.87V7.69h1.31ZM8.34,12.93h7.87l0,5.26H8.34V12.93Zm7.87,5.26v0Zm.65,1.31a.6.6,0,0,0,.46-.19.72.72,0,0,0,.2-.47V12.29a.74.74,0,0,0-.2-.47.6.6,0,0,0-.46-.19H7.68a.6.6,0,0,0-.46.19.72.72,0,0,0-.2.47v6.55a.74.74,0,0,0,.2.47.6.6,0,0,0,.46.19h9.18ZM16.67,9.28a.7.7,0,0,0-.94,0,.63.63,0,0,0-.18.46.67.67,0,0,0,.18.47.68.68,0,0,0,.94,0,.66.66,0,0,0,.18-.47A.58.58,0,0,0,16.67,9.28Z" transform="translate(-4.25 -3.61)"/></g></svg>',
    template: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14.27 15.64"><g><path d="M18.18,19.16a1,1,0,0,0,1-1V5.73a1,1,0,0,0-1-1h-2v1h2V18.19H6.37V5.73h2v-1h-2A.94.94,0,0,0,5.68,5a1,1,0,0,0-.29.7V18.18a.94.94,0,0,0,.29.69,1,1,0,0,0,.69.29H18.18ZM9.82,10.31h4.92a.49.49,0,0,0,.35-.15.47.47,0,0,0,.15-.35.49.49,0,0,0-.15-.35.47.47,0,0,0-.35-.15H9.82a.49.49,0,0,0-.35.15.47.47,0,0,0-.15.35.49.49,0,0,0,.15.35.47.47,0,0,0,.35.15Zm5.9,4.92H8.83a.49.49,0,0,0-.35.15.47.47,0,0,0-.15.35.49.49,0,0,0,.15.35.47.47,0,0,0,.35.15h6.89a.49.49,0,0,0,.35-.15.47.47,0,0,0,.15-.35.51.51,0,0,0-.5-.5ZM7.36,12.77a.49.49,0,0,0,.15.35.47.47,0,0,0,.35.15h8.85a.49.49,0,0,0,.35-.15.47.47,0,0,0,.15-.35.49.49,0,0,0-.15-.35.47.47,0,0,0-.35-.15H7.85a.49.49,0,0,0-.35.15.52.52,0,0,0-.14.35Z" transform="translate(-5.14 -3.77)"/><path d="M14.24,6.71a1,1,0,0,0,1-1,1,1,0,0,0-1-1,1,1,0,0,0-1-1h-2a.94.94,0,0,0-.69.28,1,1,0,0,0-.29.7A.94.94,0,0,0,9.62,5a.91.91,0,0,0-.29.69,1,1,0,0,0,.29.7,1,1,0,0,0,.69.29h3.93Z" transform="translate(-5.14 -3.77)"/></g></svg>',
    line_height: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 13.56"><g><path d="M4.4,4.88V8.26a2,2,0,0,0,.5.39s.1,0,.18-.12a.62.62,0,0,0,.17-.28c.06-.19.13-.44.21-.74s.14-.52.19-.66a.58.58,0,0,1,.21-.3,2.41,2.41,0,0,1,.63-.21,3.83,3.83,0,0,1,.88-.12,9.15,9.15,0,0,1,1.31.06.16.16,0,0,1,.11,0,.26.26,0,0,1,.06.14,4,4,0,0,1,0,.49v2l.05,3.77c0,1.41,0,2.68-.05,3.81a1.79,1.79,0,0,1-.11.49,10.68,10.68,0,0,1-1.4.45,1.12,1.12,0,0,0-.69.43v.31l0,.22.61,0c.85-.08,1.54-.12,2.06-.12a19.76,19.76,0,0,1,2.09.08,15.08,15.08,0,0,0,1.64.08,1.4,1.4,0,0,0,.29,0,1.58,1.58,0,0,0,0-.26l-.05-.43a2.26,2.26,0,0,0-.43-.17l-.77-.22-.15,0a2.55,2.55,0,0,1-.78-.28,2.56,2.56,0,0,1-.11-.75l0-1.29,0-3.15V7.53a10.51,10.51,0,0,1,.06-1.2,3.83,3.83,0,0,1,.6,0l1.88,0a2.18,2.18,0,0,1,.38,0,.45.45,0,0,1,.23.17.9.9,0,0,1,.05.25c0,.16.06.35.1.58a3.33,3.33,0,0,0,.14.55A6.39,6.39,0,0,0,15,9a2.91,2.91,0,0,0,.6-.15,2.77,2.77,0,0,0,0-.46l0-.51,0-2.95-.25,0-.38,0L15,4.94a.71.71,0,0,1-.18.15.45.45,0,0,1-.25.07l-.29,0H8.75l-.15,0H7.45a17,17,0,0,1-1.86,0L5.36,5l-.25-.13ZM19.75,16.14h-.69v-9h.69A.4.4,0,0,0,20.13,7c.06-.11,0-.24-.1-.39L18.92,5.15a.52.52,0,0,0-.86,0L17,6.58c-.12.15-.16.28-.1.39s.18.16.38.16h.69v9h-.69a.4.4,0,0,0-.38.16c-.06.11,0,.24.1.39l1.11,1.43a.52.52,0,0,0,.86,0L20,16.69c.12-.15.16-.28.1-.39a.4.4,0,0,0-.38-.16Z" transform="translate(-4.4 -4.86)"/></g></svg>',
    paragraph_style: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.81 15.74"><g><path d="M18.18,3.76v2h-2V19.5h-2V5.73h-2V19.5h-2V11.63a3.94,3.94,0,0,1,0-7.87h7.87Z" transform="translate(-6.37 -3.76)"/></g></svg>',
    text_style: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 13.76 15.74"><g><path d="M17.68,6.71a2.22,2.22,0,0,0,1.06-.22.74.74,0,0,0,.42-.7.73.73,0,0,0-.08-.33.67.67,0,0,0-.17-.22,1,1,0,0,0-.31-.15L18.26,5l-.45-.09A15.27,15.27,0,0,0,13.26,5V4.74c0-.66-.63-1-1.92-1-.24,0-.43.15-.59.46a4,4,0,0,0-.36,1.14h0v0a26.45,26.45,0,0,1-3.5.35A2,2,0,0,0,5.77,6a.84.84,0,0,0-.37.79,2.14,2.14,0,0,0,.41,1.29,1.23,1.23,0,0,0,1.05.63,16.62,16.62,0,0,0,3.29-.45l-.34,3.35c-.16,1.61-.29,2.9-.37,3.86s-.12,1.66-.12,2.09l0,.65a5.15,5.15,0,0,0,.05.6,1.28,1.28,0,0,0,.16.54.34.34,0,0,0,.28.18,1.16,1.16,0,0,0,.79-.46,3.66,3.66,0,0,0,.68-1,22.08,22.08,0,0,0,1-4.33q.49-3.1.78-6.15a24.69,24.69,0,0,1,4.62-.84Z" transform="translate(-5.4 -3.76)"/></g></svg>',
    save: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M18.53,19.5l.2-.05A1.78,1.78,0,0,0,20.13,18l0-.09V7.14a2,2,0,0,0-.28-.64A3.18,3.18,0,0,0,19.43,6c-.5-.52-1-1-1.55-1.54A2.59,2.59,0,0,0,17.37,4a1.83,1.83,0,0,0-.61-.25H6l-.21,0a1.78,1.78,0,0,0-1.4,1.49l0,.1V17.87a2.49,2.49,0,0,0,.09.37,1.79,1.79,0,0,0,1.44,1.23l.09,0Zm-6.25-.6H6.92a.61.61,0,0,1-.68-.48.78.78,0,0,1,0-.22V12.3a.62.62,0,0,1,.69-.68H17.64a.62.62,0,0,1,.69.69V18.2a.64.64,0,0,1-.71.69H12.28ZM12,9.81H8.15a.63.63,0,0,1-.72-.71v-4a.64.64,0,0,1,.72-.72h7.66a.64.64,0,0,1,.72.72v4a.65.65,0,0,1-.74.72ZM13.5,5V9.18h1.78V5Z" transform="translate(-4.41 -3.76)"/></g></svg>',
    blockquote: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 475.082 475.081"><g><path d="M164.45,219.27h-63.954c-7.614,0-14.087-2.664-19.417-7.994c-5.327-5.33-7.994-11.801-7.994-19.417v-9.132c0-20.177,7.139-37.401,21.416-51.678c14.276-14.272,31.503-21.411,51.678-21.411h18.271c4.948,0,9.229-1.809,12.847-5.424c3.616-3.617,5.424-7.898,5.424-12.847V54.819c0-4.948-1.809-9.233-5.424-12.85c-3.617-3.612-7.898-5.424-12.847-5.424h-18.271c-19.797,0-38.684,3.858-56.673,11.563c-17.987,7.71-33.545,18.132-46.68,31.267c-13.134,13.129-23.553,28.688-31.262,46.677C3.855,144.039,0,162.931,0,182.726v200.991c0,15.235,5.327,28.171,15.986,38.834c10.66,10.657,23.606,15.985,38.832,15.985h109.639c15.225,0,28.167-5.328,38.828-15.985c10.657-10.663,15.987-23.599,15.987-38.834V274.088c0-15.232-5.33-28.168-15.994-38.832C192.622,224.6,179.675,219.27,164.45,219.27z"/><path d="M459.103,235.256c-10.656-10.656-23.599-15.986-38.828-15.986h-63.953c-7.61,0-14.089-2.664-19.41-7.994c-5.332-5.33-7.994-11.801-7.994-19.417v-9.132c0-20.177,7.139-37.401,21.409-51.678c14.271-14.272,31.497-21.411,51.682-21.411h18.267c4.949,0,9.233-1.809,12.848-5.424c3.613-3.617,5.428-7.898,5.428-12.847V54.819c0-4.948-1.814-9.233-5.428-12.85c-3.614-3.612-7.898-5.424-12.848-5.424h-18.267c-19.808,0-38.691,3.858-56.685,11.563c-17.984,7.71-33.537,18.132-46.672,31.267c-13.135,13.129-23.559,28.688-31.265,46.677c-7.707,17.987-11.567,36.879-11.567,56.674v200.991c0,15.235,5.332,28.171,15.988,38.834c10.657,10.657,23.6,15.985,38.828,15.985h109.633c15.229,0,28.171-5.328,38.827-15.985c10.664-10.663,15.985-23.599,15.985-38.834V274.088C475.082,258.855,469.76,245.92,459.103,235.256z"/></g></svg>',
    arrow_down: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 8.67"><g><path d="M18.79,7.52a.8.8,0,0,1,.56-.23.82.82,0,0,1,.79.79.8.8,0,0,1-.23.56l-7.07,7.07a.79.79,0,0,1-.57.25.77.77,0,0,1-.57-.25h0L4.64,8.65a.8.8,0,0,1-.23-.57.82.82,0,0,1,.79-.79.8.8,0,0,1,.56.23L12.28,14l3.26-3.26,3.25-3.26Z" transform="translate(-4.41 -7.29)"/></g></svg>',
    align_justify: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm0,5.9H20.15v-2H4.41v2Zm0,3.94H20.15v-2H4.41v2Zm0,3.93h7.87v-2H4.41v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
    align_left: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm11.8,3.94H4.41v2H16.22v-2Zm-11.8,5.9H18.18v-2H4.41v2Zm0,3.93h9.84v-2H4.41v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
    align_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm3.93,5.9H20.15v-2H8.34v2Zm-2,3.94H20.14v-2H6.37v2Zm3.94,3.93h9.84v-2H10.31v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
    align_center: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm2,3.94v2H18.18v-2H6.37Zm-1,5.9H19.16v-2H5.39v2Zm2,3.93H17.2v-2H7.36v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
    font_color: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.61"><g><path d="M18.5,15.57,14.28,4.32h-3.4L6.65,15.57h3l.8-2.26h4.23l.8,2.26h3ZM14,11.07H11.14L12.54,7,13.25,9c.41,1.18.64,1.86.7,2ZM4.41,16.69v2.24H20.15V16.69H4.41Z" transform="translate(-4.41 -4.32)"/></g></svg>',
    highlight_color: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.66 15.74"><g><path d="M12.32,9.31,13.38,13H11.21l.52-1.83q.46-1.61.54-1.83ZM4.44,3.76H20.1V19.5H4.44V3.76ZM14.71,17.32h2.63L13.7,6H10.89L7.26,17.32H9.89l.63-2.24h3.55l.32,1.12c.18.65.29,1,.32,1.12Z" transform="translate(-4.44 -3.76)"/></g></svg>',
    list_bullets: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 12.37"><g><path d="M7.77,16.12a1.59,1.59,0,0,0-.49-1.18,1.62,1.62,0,0,0-1.19-.49,1.68,1.68,0,1,0,0,3.36,1.67,1.67,0,0,0,1.68-1.69Zm0-4.48A1.67,1.67,0,0,0,6.09,10,1.68,1.68,0,0,0,4.9,12.82a1.62,1.62,0,0,0,1.19.49,1.67,1.67,0,0,0,1.68-1.67Zm12.38,3.64a.27.27,0,0,0-.08-.19.28.28,0,0,0-.2-.09H9.19a.28.28,0,0,0-.2.08.29.29,0,0,0-.08.19V17a.27.27,0,0,0,.28.28H19.87a.27.27,0,0,0,.19-.08.24.24,0,0,0,.08-.2V15.28ZM7.77,7.13a1.63,1.63,0,0,0-.49-1.2,1.61,1.61,0,0,0-1.19-.49,1.61,1.61,0,0,0-1.19.49,1.71,1.71,0,0,0,0,2.4,1.62,1.62,0,0,0,1.19.49,1.61,1.61,0,0,0,1.19-.49,1.63,1.63,0,0,0,.49-1.2Zm12.38,3.66a.28.28,0,0,0-.08-.2.29.29,0,0,0-.19-.08H9.19a.27.27,0,0,0-.28.28v1.69a.27.27,0,0,0,.08.19.24.24,0,0,0,.2.08H19.87a.27.27,0,0,0,.19-.08.25.25,0,0,0,.08-.19V10.79Zm0-4.5a.27.27,0,0,0-.08-.19A.25.25,0,0,0,19.88,6H9.19A.28.28,0,0,0,9,6.1a.26.26,0,0,0-.08.19V8A.27.27,0,0,0,9,8.17a.24.24,0,0,0,.2.08H19.87a.27.27,0,0,0,.19-.08A.25.25,0,0,0,20.14,8V6.29Z" transform="translate(-4.41 -5.44)"/></g></svg>',
    list_number: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.69 15.74"><g><path d="M7.66,18a1.24,1.24,0,0,0-.26-.78,1.17,1.17,0,0,0-.72-.42l.85-1V15H4.58v1.34h.94v-.46l.85,0h0c-.11.11-.22.23-.32.35s-.23.27-.37.47L5.39,17l.23.51c.61-.05.92.11.92.49a.42.42,0,0,1-.18.37.79.79,0,0,1-.45.12A1.41,1.41,0,0,1,5,18.15l-.51.77A2.06,2.06,0,0,0,6,19.5a1.8,1.8,0,0,0,1.2-.41A1.38,1.38,0,0,0,7.66,18Zm0-5.54H6.75V13H5.63A.72.72,0,0,1,6,12.51a5.45,5.45,0,0,1,.66-.45,2.71,2.71,0,0,0,.67-.57,1.19,1.19,0,0,0,.31-.81,1.29,1.29,0,0,0-.45-1,1.86,1.86,0,0,0-2-.11,1.51,1.51,0,0,0-.62.7l.74.52A.87.87,0,0,1,6,10.28a.51.51,0,0,1,.35.12.42.42,0,0,1,.13.33.55.55,0,0,1-.21.4,3,3,0,0,1-.5.38c-.19.13-.39.27-.58.42a2,2,0,0,0-.5.6,1.63,1.63,0,0,0-.21.81,3.89,3.89,0,0,0,.05.48h3.2V12.44Zm12.45,2.82a.27.27,0,0,0-.08-.19.28.28,0,0,0-.21-.08H9.1a.32.32,0,0,0-.21.08.24.24,0,0,0-.08.2V17a.27.27,0,0,0,.08.19.3.3,0,0,0,.21.08H19.83a.32.32,0,0,0,.21-.08.25.25,0,0,0,.08-.19V15.26ZM7.69,7.32h-1V3.76H5.8L4.6,4.88l.63.68a1.85,1.85,0,0,0,.43-.48h0l0,2.24H4.74V8.2h3V7.32Zm12.43,3.42a.27.27,0,0,0-.08-.19.28.28,0,0,0-.21-.08H9.1a.32.32,0,0,0-.21.08.24.24,0,0,0-.08.2v1.71a.27.27,0,0,0,.08.19.3.3,0,0,0,.21.08H19.83a.32.32,0,0,0,.21-.08.25.25,0,0,0,.08-.19V10.74Zm0-4.52A.27.27,0,0,0,20,6,.28.28,0,0,0,19.83,6H9.1A.32.32,0,0,0,8.89,6a.24.24,0,0,0-.08.19V7.93a.27.27,0,0,0,.08.19.32.32,0,0,0,.21.08H19.83A.32.32,0,0,0,20,8.12a.26.26,0,0,0,.08-.2V6.22Z" transform="translate(-4.43 -3.76)"/></g></svg>',
    table: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M4.41,8.05V3.76H8.7V8.05H4.41Zm5.71,0V3.76h4.3V8.05h-4.3Zm5.74-4.29h4.29V8.05H15.86V3.76Zm-11.45,10V9.48H8.7v4.3H4.41Zm5.71,0V9.48h4.3v4.3h-4.3Zm5.74,0V9.48h4.29v4.3H15.86ZM4.41,19.5V15.21H8.7V19.5H4.41Zm5.71,0V15.21h4.3V19.5h-4.3Zm5.74,0V15.21h4.29V19.5H15.86Z" transform="translate(-4.41 -3.76)"/></g></svg>',
    horizontal_rule: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 2.24"><g><path d="M20.15,12.75V10.51H4.41v2.24H20.15Z" transform="translate(-4.41 -10.51)"/></g></svg>',
    show_blocks: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.66 15.67"><g><path d="M19.72,5.58a1.64,1.64,0,0,0-1.64-1.64H6.23a1.62,1.62,0,0,0-1.16.48,1.63,1.63,0,0,0-.48,1.16V9.63a1.6,1.6,0,0,0,.48,1.16,1.62,1.62,0,0,0,1.16.47H18.09a1.67,1.67,0,0,0,1.16-.47,1.62,1.62,0,0,0,.48-1.16V5.58Zm-.94,4.05a.68.68,0,0,1-.7.7H6.23a.66.66,0,0,1-.48-.2.74.74,0,0,1-.21-.5V5.58a.66.66,0,0,1,.2-.48.71.71,0,0,1,.48-.21H18.08a.74.74,0,0,1,.5.21.66.66,0,0,1,.2.48ZM6.48,7.72a.21.21,0,0,0,.17-.07.22.22,0,0,0,.07-.17V7.06a1.27,1.27,0,0,1,.11-.52.37.37,0,0,1,.36-.23H8.77A.25.25,0,0,0,9,6.17a.19.19,0,0,0,0-.23.27.27,0,0,0-.2-.12H7.19a.88.88,0,0,0-.72.39,1.51,1.51,0,0,0-.23.85v.42a.24.24,0,0,0,.24.24Zm-.19.81a.21.21,0,0,0,.17-.07.26.26,0,0,0,.07-.17.24.24,0,0,0-.24-.24.2.2,0,0,0-.16.09.2.2,0,0,0-.07.16.22.22,0,0,0,.07.17.23.23,0,0,0,.16.06Zm8.46,5.1a1.63,1.63,0,0,0-.47-1.16A1.61,1.61,0,0,0,13.12,12H6.23a1.6,1.6,0,0,0-1.16.46,1.62,1.62,0,0,0-.48,1.16v4.05a1.64,1.64,0,0,0,1.64,1.64h6.89a1.6,1.6,0,0,0,1.16-.48,1.62,1.62,0,0,0,.47-1.16Zm-.94,4a.7.7,0,0,1-.2.49.65.65,0,0,1-.5.2H6.23a.66.66,0,0,1-.48-.2.75.75,0,0,1-.21-.49v-4a.74.74,0,0,1,.21-.5.66.66,0,0,1,.48-.2h6.89a.68.68,0,0,1,.7.7v4Zm6.15,0v-4a1.6,1.6,0,0,0-.48-1.16A1.67,1.67,0,0,0,18.32,12H17.1a1.63,1.63,0,0,0-1.16.47,1.61,1.61,0,0,0-.47,1.16v4a1.67,1.67,0,0,0,.47,1.16,1.62,1.62,0,0,0,1.16.48h1.22A1.64,1.64,0,0,0,20,17.68Zm-.94-4v4a.75.75,0,0,1-.21.49.62.62,0,0,1-.48.2H17.11a.69.69,0,0,1-.5-.2.7.7,0,0,1-.2-.49v-4a.68.68,0,0,1,.7-.7h1.22a.66.66,0,0,1,.48.2.72.72,0,0,1,.21.5Z" transform="translate(-4.44 -3.79)"/></g></svg>',
    cancel: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M14.15,11.63l5.61,5.61a1.29,1.29,0,0,1,.38.93,1.27,1.27,0,0,1-.4.93,1.25,1.25,0,0,1-.92.4,1.31,1.31,0,0,1-.94-.4l-5.61-5.61L6.67,19.1a1.31,1.31,0,0,1-.94.4,1.24,1.24,0,0,1-.92-.4,1.27,1.27,0,0,1-.4-.93,1.33,1.33,0,0,1,.38-.93l5.61-5.63L4.79,6a1.26,1.26,0,0,1-.38-.93,1.22,1.22,0,0,1,.4-.92,1.28,1.28,0,0,1,.92-.39,1.38,1.38,0,0,1,.94.38l5.61,5.61,5.61-5.61a1.33,1.33,0,0,1,.94-.38,1.26,1.26,0,0,1,.92.39,1.24,1.24,0,0,1,.4.92,1.29,1.29,0,0,1-.39.93L17,8.81l-2.8,2.82Z" transform="translate(-4.41 -3.76)"/></g></svg>',
    image: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.77"><g><path d="M8.77,8.72a.88.88,0,0,1-.61-.27.82.82,0,0,1-.25-.61.89.89,0,0,1,.25-.62A.82.82,0,0,1,8.77,7a.81.81,0,0,1,.61.25.83.83,0,0,1,.27.62.81.81,0,0,1-.25.61.91.91,0,0,1-.63.27Zm9.62-5a1.74,1.74,0,0,1,1.76,1.76V17.76a1.74,1.74,0,0,1-1.76,1.76H6.16A1.74,1.74,0,0,1,4.4,17.76V5.51A1.74,1.74,0,0,1,6.16,3.75H18.39Zm0,1.75H6.16v8L8.53,11.8a.94.94,0,0,1,.54-.17.86.86,0,0,1,.54.2L11.09,13l3.64-4.55a.78.78,0,0,1,.34-.25.85.85,0,0,1,.42-.07.89.89,0,0,1,.39.12.78.78,0,0,1,.28.29l2.24,3.67V5.51Zm0,12.24V15.6L15.3,10.53,11.89,14.8a.89.89,0,0,1-.59.32.82.82,0,0,1-.64-.18L9,13.62,6.16,15.74v2Z" transform="translate(-4.4 -3.75)"/></g></svg>',
    video: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.55"><g><path d="M20.15,10.26V18.9l-3.94-1.57v1.2H4.41V10.66H16.22v1.23l2-.81,2-.82ZM14.64,17h0V12.54h0v-.31H6V17h8.67Zm3.94-.37v-4l-2.37,1v2l1.18.48,1.19.48ZM7.94,9.86A2.77,2.77,0,0,1,5.19,7.11a2.76,2.76,0,0,1,5.51,0A2.78,2.78,0,0,1,7.94,9.86Zm0-3.93a1.21,1.21,0,0,0-.83.35,1.15,1.15,0,0,0-.34.84A1.09,1.09,0,0,0,7.11,8,1.15,1.15,0,0,0,8,8.28,1.13,1.13,0,0,0,9.11,7.12,1.16,1.16,0,0,0,7.94,5.93Zm5.9,3.93a2.34,2.34,0,0,1-1.67-.68,2.3,2.3,0,0,1-.68-1.67,2.35,2.35,0,0,1,4-1.67,2.37,2.37,0,0,1,0,3.34,2.33,2.33,0,0,1-1.68.68Zm0-3.14a.75.75,0,1,0,.55.22.73.73,0,0,0-.55-.22Z" transform="translate(-4.41 -4.35)"/></g></svg>',
    link: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.72"><g><path d="M13.05,13.63a.24.24,0,0,1,.15.22L13.42,16a.19.19,0,0,1-.08.18l-2.12,2.14a4.08,4.08,0,0,1-1.29.85A4,4,0,0,1,4.71,17a3.92,3.92,0,0,1-.3-1.52A4,4,0,0,1,4.71,14a3.91,3.91,0,0,1,.87-1.3L7.7,10.56a.25.25,0,0,1,.2-.06l2.17.22a.21.21,0,0,1,.19.15.24.24,0,0,1,0,.25L7.12,14.23a1.81,1.81,0,0,0,0,2.58,1.78,1.78,0,0,0,1.29.52,1.74,1.74,0,0,0,1.28-.52L12.8,13.7a.24.24,0,0,1,.25-.07ZM19,4.92a4,4,0,0,1,0,5.66L16.86,12.7a.25.25,0,0,1-.17.08l-2.2-.23a.21.21,0,0,1-.19-.15.22.22,0,0,1,0-.25L17.44,9a1.81,1.81,0,0,0,0-2.58,1.78,1.78,0,0,0-1.29-.52,1.74,1.74,0,0,0-1.28.52L11.76,9.57a.21.21,0,0,1-.25,0,.24.24,0,0,1-.16-.21l-.22-2.17a.19.19,0,0,1,.08-.18l2.12-2.14a4.08,4.08,0,0,1,1.29-.85,4.05,4.05,0,0,1,3.06,0,3.85,3.85,0,0,1,1.3.85ZM5.84,9.82a.25.25,0,0,1-.18-.08.19.19,0,0,1-.07-.19l.11-.77a.2.2,0,0,1,.11-.17.24.24,0,0,1,.2,0l2.5.72a.25.25,0,0,1,.15.27.22.22,0,0,1-.23.21l-2.59,0Zm4.12-2-.73-2.5a.27.27,0,0,1,0-.2A.21.21,0,0,1,9.41,5L10.19,5a.25.25,0,0,1,.19,0,.23.23,0,0,1,.08.18l-.05,2.61a.2.2,0,0,1-.19.23h0A.22.22,0,0,1,10,7.85Zm8.76,5.58a.25.25,0,0,1,.18.08.23.23,0,0,1,.06.2l-.11.77a.25.25,0,0,1-.11.17.21.21,0,0,1-.12,0l-.08,0L16,14a.25.25,0,0,1-.15-.27.22.22,0,0,1,.22-.21l1.29,0,1.33,0Zm-4.12,2,.74,2.51a.28.28,0,0,1,0,.2.23.23,0,0,1-.18.11l-.8.11a.23.23,0,0,1-.17-.07.25.25,0,0,1-.08-.18l0-2.61a.22.22,0,0,1,.22-.22.21.21,0,0,1,.26.15Z" transform="translate(-4.41 -3.77)"/></g></svg>',
    math: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.81 15.73"><g><path d="M17.19,5.73a1,1,0,0,0,.71-.29,1,1,0,0,0,.28-.7,1,1,0,0,0-1-1H7.35a1,1,0,0,0-1,1,.77.77,0,0,0,.13.47h0l4.58,6.43L6.68,17.81a1.25,1.25,0,0,0-.29.71.94.94,0,0,0,.28.7.92.92,0,0,0,.69.28H17.2a1,1,0,0,0,.71-.28,1,1,0,0,0,0-1.39.92.92,0,0,0-.71-.29H9.26l3.87-5.43a.86.86,0,0,0,0-.95L9.26,5.73h7.93Z" transform="translate(-6.38 -3.77)"/></g></svg>',
    unlink: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.72"><g><path d="M19,18.32a4,4,0,0,0,0-5.68L15.85,9.5l-1.17,1.55L17.57,14a2,2,0,0,1,.61,1.47,2.08,2.08,0,0,1-2.09,2.09,2,2,0,0,1-1.47-.61l-.38-.37-1.74,1,.8.78a4,4,0,0,0,5.68,0ZM8,9.77a2,2,0,0,1-1.27-1,1.89,1.89,0,0,1-.21-1.57A2.1,2.1,0,0,1,7.45,6,2,2,0,0,1,9,5.76L12.27,7.2l.49-2L9.48,3.9a4,4,0,0,0-3.06.41A3.82,3.82,0,0,0,4.56,6.73a3.8,3.8,0,0,0,.4,3A3.78,3.78,0,0,0,7.39,11.6l5.38,2,.49-2-2.64-.94L8,9.77Z" transform="translate(-4.41 -3.76)"/></g></svg>',
    table_header: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.74"><g><path d="M17,19.5v-.78H15.5v.78H17Zm-3,0v-.78H12.5v.78H14Zm-3,0v-.78H9.53v.78H11Zm-3,0v-.78H6.53v.78H8Zm10.55,0a1.73,1.73,0,0,0,.85-.35,1.67,1.67,0,0,0,.56-.76l-.71-.31a1.21,1.21,0,0,1-.35.4,1.34,1.34,0,0,1-.53.23l.08.38c.06.24.09.38.1.41Zm-13.7-.63.55-.55A.77.77,0,0,1,5.25,18a1.31,1.31,0,0,1-.06-.38v-.38H4.41v.38a2,2,0,0,0,.12.68,1.6,1.6,0,0,0,.35.57Zm15.27-2.12V15.26h-.78v1.49h.78Zm-15-1V14.23H4.41v1.49h.78Zm15-2V12.26h-.78v1.49h.78Zm-15-1V11.22H4.41v1.51h.78Zm15-2V9.26h-.78v1.51h.78Zm-15-1V8.17H4.41V9.74h.78Zm15-2V6.28h-.78V7.77h.78Zm-15-1.11V5.33L4.48,5.1a.77.77,0,0,0-.07.27,2.72,2.72,0,0,0,0,.28v1h.79ZM19.21,5l.63-.4A1.62,1.62,0,0,0,19.16,4a1.94,1.94,0,0,0-.91-.22v.78a1.31,1.31,0,0,1,.56.12.88.88,0,0,1,.4.36ZM6,4.54H7.78V3.76H6a.82.82,0,0,0-.28.06l.12.35c.07.21.1.33.11.36Zm10.8,0V3.76H15.28v.78h1.49Zm-3,0V3.76H12.28v.78h1.49Zm-3,0V3.76H9.28v.78h1.51ZM6,10.84h12.6V6.91H6Z" transform="translate(-4.4 -3.76)"/></g></svg>',
    merge_cell: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 15.74"><g><path d="M18.92,13.5h1.23v4.15A1.84,1.84,0,0,1,18.3,19.5H14V18.27H18.3a.6.6,0,0,0,.44-.18.59.59,0,0,0,.18-.44V13.5ZM18.3,3.76a1.84,1.84,0,0,1,1.85,1.85V9.82H18.92V5.6a.6.6,0,0,0-.18-.44A.59.59,0,0,0,18.3,5H14V3.76H18.3Zm1.85,8.51H15.6L17.26,14l-.86.86-3.14-3.17L16.4,8.51l.86.86L15.62,11h4.54v1.24Zm-13.9,6h4.27V19.5H6.25A1.84,1.84,0,0,1,4.4,17.65V13.5H5.63v4.15a.61.61,0,0,0,.62.62Zm0-14.51h4.27V5H6.25a.6.6,0,0,0-.44.18.57.57,0,0,0-.17.43V9.81H4.41V5.6A1.83,1.83,0,0,1,6.25,3.76Zm5,7.9L8.15,14.83,7.3,14,9,12.27H4.41V11H8.94L7.3,9.38,7.73,9l.43-.43Z" transform="translate(-4.4 -3.76)"/></g></svg>',
    split_cell: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.74"><g><path d="M10.37,12.25H6.74L8.4,13.94l-.87.86L4.41,11.63,7.53,8.5l.87.86L6.74,11h3.62v1.23Zm9.78-.61L17,14.81,16.13,14l1.66-1.69H14.16V11h3.63L16.13,9.37l.43-.43A5.24,5.24,0,0,1,17,8.51ZM18.9,8.22V5.61a.57.57,0,0,0-.18-.43A.65.65,0,0,0,18.29,5H12.88V18.28h5.41a.7.7,0,0,0,.44-.18.57.57,0,0,0,.18-.43V15h1.23v2.64a1.84,1.84,0,0,1-1.85,1.83h-12A1.84,1.84,0,0,1,4.94,19a1.81,1.81,0,0,1-.54-1.29V15H5.63v2.64a.57.57,0,0,0,.18.43.67.67,0,0,0,.44.18h5.41V5H6.25a.7.7,0,0,0-.44.18.56.56,0,0,0-.17.43V8.22H4.41V5.61A1.8,1.8,0,0,1,5,4.31a1.91,1.91,0,0,1,1.31-.55h12a1.89,1.89,0,0,1,1.31.55,1.8,1.8,0,0,1,.54,1.3V8.23H18.9Z" transform="translate(-4.4 -3.76)"/></g></svg>',
    caption: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.79"><g><path d="M4.41,18.52H20.15v-2H4.41ZM20,4.73H18.07V6h.65v.65H20V4.73ZM17,6V4.73H14.55V6H17ZM13.49,6V4.73H11V6h2.47ZM10,6V4.73H7.5V6H10ZM5.79,6h.65V4.73H4.5V6.67H5.8V6ZM4.5,11.34H5.79V8.48H4.5ZM6.44,13.8H5.79v-.65H4.5v1.94H6.44ZM17,15.09V13.8H14.55v1.29H17Zm-3.52,0V13.8H11v1.29h2.47Zm-3.53,0V13.8H7.5v1.29H10ZM20,13.16H18.72v.65h-.65V15.1H20Zm-1.29-1.82H20V8.48h-1.3v2.86Z" transform="translate(-4.41 -4.73)"/></g></svg>',
    edit: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.73"><g><path d="M7.51,5.68h6l1.52-1.57H6.94a2.4,2.4,0,0,0-1.79.82A2.8,2.8,0,0,0,4.41,6.8V17a2.55,2.55,0,0,0,.75,1.8A2.48,2.48,0,0,0,7,19.5H17.22a2.57,2.57,0,0,0,1.83-.74,2.52,2.52,0,0,0,.77-1.8V8.83l-1.58,1.54v6a1.54,1.54,0,0,1-1.53,1.53H7.51A1.54,1.54,0,0,1,6,16.41V7.21A1.52,1.52,0,0,1,7.51,5.68Zm5.63,7.47h0L10.7,10.74l-1,3.38,1.71-.48,1.7-.49Zm.34-.34h0l5.36-5.32L16.4,5.08,11,10.4l1.23,1.21,1.21,1.2ZM19.93,6.4a.82.82,0,0,0,.22-.48A.54.54,0,0,0,20,5.47L18.45,4A.67.67,0,0,0,18,3.77a.7.7,0,0,0-.48.21l-.74.72,2.44,2.43.37-.37.35-.36Z" transform="translate(-4.41 -3.77)"/></g></svg>',
    delete: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 15.74"><g><path d="M19.16,6.71a.94.94,0,0,0,.69-.28.91.91,0,0,0,.29-.68A1,1,0,0,0,19.85,5a.93.93,0,0,0-.69-.3H14.24A.94.94,0,0,0,14,4.06a.92.92,0,0,0-.7-.3h-2a1,1,0,0,0-.7.3.93.93,0,0,0-.28.68H5.39A.92.92,0,0,0,4.7,5a1,1,0,0,0-.29.71.91.91,0,0,0,.29.68,1,1,0,0,0,.69.28H19.16Zm-12.79,1a1,1,0,0,0-.7.3.94.94,0,0,0-.28.69v8.85A1.88,1.88,0,0,0,6,18.93a1.9,1.9,0,0,0,1.39.57H17.2a1.87,1.87,0,0,0,1.39-.58,1.91,1.91,0,0,0,.58-1.39V8.68A1,1,0,0,0,18.88,8a.89.89,0,0,0-.7-.29,1,1,0,0,0-.69.29.92.92,0,0,0-.29.68v7.87a1,1,0,0,1-1,1H8.34a.94.94,0,0,1-.69-.28,1,1,0,0,1-.29-.71V8.68a1,1,0,0,0-1-1Z" transform="translate(-4.41 -3.76)"/></g></svg>',
    modify: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.74"><g><path d="M19.79,15.23a.66.66,0,0,1,.3.38.59.59,0,0,1-.07.48l-.8,1.38a.66.66,0,0,1-.38.3.59.59,0,0,1-.48-.07l-.68-.38a4.55,4.55,0,0,1-1.34.77v.78a.64.64,0,0,1-.18.45.61.61,0,0,1-.45.18h-1.6a.6.6,0,0,1-.44-.18.66.66,0,0,1-.19-.45v-.78a4.36,4.36,0,0,1-1.32-.77l-.69.38a.58.58,0,0,1-.48.07.66.66,0,0,1-.38-.3l-.38-.66h.83a1.77,1.77,0,0,0,1.23-.52,1.72,1.72,0,0,0,.51-1.23v-.18a3,3,0,0,0,.49-.28l.15.09a1.83,1.83,0,0,0,.88.23A1.75,1.75,0,0,0,15.84,14l.88-1.52a1.7,1.7,0,0,0,.17-1.32,1.66,1.66,0,0,0-.3-.61,1.84,1.84,0,0,0-.51-.45l-.15-.09,0-.29,0-.28.15-.09a1,1,0,0,0,.26-.18l0,.06v.78a4.34,4.34,0,0,1,1.34.77l.68-.38a.68.68,0,0,1,.48-.06.64.64,0,0,1,.38.29l.8,1.38a.58.58,0,0,1,.07.48.63.63,0,0,1-.3.38l-.68.4a3.84,3.84,0,0,1,.08.76,4.13,4.13,0,0,1-.08.78l.34.18.32.2ZM10.17,7.86a1.9,1.9,0,0,1,1.35,3.23,1.85,1.85,0,0,1-1.35.55A1.9,1.9,0,0,1,8.83,8.41a1.92,1.92,0,0,1,1.34-.55Zm1.58,7.2a.73.73,0,0,1-.21.49.66.66,0,0,1-.48.2H9.29a.68.68,0,0,1-.69-.69V14.2a4.75,4.75,0,0,1-1.48-.86l-.75.45a.73.73,0,0,1-.7,0,.63.63,0,0,1-.25-.26L4.54,12a.67.67,0,0,1-.08-.53.71.71,0,0,1,.32-.42l.75-.43a4.8,4.8,0,0,1-.08-.85,4.71,4.71,0,0,1,.08-.85l-.74-.44a.71.71,0,0,1-.32-.42.65.65,0,0,1,.07-.54L5.42,6a.66.66,0,0,1,.42-.32l.18,0a.73.73,0,0,1,.35.09l.75.43A4.68,4.68,0,0,1,8.6,5.33V4.45a.68.68,0,0,1,.69-.69h1.77a.64.64,0,0,1,.48.2.73.73,0,0,1,.21.49v.88a4.75,4.75,0,0,1,1.48.85L14,5.75a.67.67,0,0,1,.34-.09l.18,0a.71.71,0,0,1,.42.32l.89,1.54a.67.67,0,0,1,.06.52.73.73,0,0,1-.32.43l-.75.42a4.8,4.8,0,0,1,.08.85,4.71,4.71,0,0,1-.08.85l.75.43a.66.66,0,0,1,.32.42.73.73,0,0,1-.06.54l-.89,1.52a.69.69,0,0,1-.25.26.7.7,0,0,1-.35.09.64.64,0,0,1-.34-.09l-.75-.45a4.87,4.87,0,0,1-1.48.86v.87ZM7.23,9.75a3,3,0,0,0,.86,2.08,2.94,2.94,0,1,0,4.16-4.16,3,3,0,0,0-2.08-.85A2.94,2.94,0,0,0,7.23,9.75Z" transform="translate(-4.44 -3.76)"/></g></svg>',
    revert: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 14.69"><g><path d="M18.26,15V12.3l1.89-2V15a2.58,2.58,0,0,1-.24,1c-.2.58-.75.92-1.65,1H7.56v2L4.41,15.63,7.56,13v2h10.7ZM6.3,8.28V11L4.41,13V8.28a2.58,2.58,0,0,1,.24-1c.2-.58.75-.92,1.65-1H17v-2l3.15,3.34L17,10.3v-2H6.3Z" transform="translate(-4.4 -4.28)"/></g></svg>',
    auto_size: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M6.71,17.19,6.89,16l1.21-.15A6,6,0,0,1,6.81,13.9a5.78,5.78,0,0,1-.45-2.27A6,6,0,0,1,8.1,7.45a5.83,5.83,0,0,1,4.17-1.73l1-1-1-1A7.89,7.89,0,0,0,5,14.64a7.73,7.73,0,0,0,1.71,2.55Zm5.57,2.31h0A7.86,7.86,0,0,0,17.85,6.07L17.67,7.3l-1.21.15a5.9,5.9,0,0,1,1.29,1.92,5.81,5.81,0,0,1,.45,2.26,5.91,5.91,0,0,1-5.9,5.9l-1,1,.49.49.47.5Z" transform="translate(-4.41 -3.76)"/></g></svg>',
    insert_row_below: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M15.7,1.3c-0.1-0.1-0.1-0.2-0.2-0.2L15.3,1H0.4L0.3,1.1c0,0-0.1,0.1-0.1,0.1c0,0-0.1,0.1-0.1,0.1L0,1.4v7.7l0.1,0.1c0,0.1,0.1,0.1,0.2,0.2l0.1,0.1h2.3V9.3l0.1-0.5L3,8.5l0.1-0.2c-0.1,0-0.2,0-0.3,0H1.2v-6h13.3v6h-1.6c-0.1,0-0.2,0-0.3,0l0.1,0.2l0.2,0.4C12.9,9,13,9.2,13,9.3v0.1h2.3l0.2-0.1c0.1,0,0.1-0.1,0.2-0.2l0.1-0.1V1.4L15.7,1.3z"/><path d="M10.5,7.5C9.9,7.1,9.3,6.8,8.6,6.7c-0.2,0-0.5-0.1-0.7,0c-0.2,0-0.5,0-0.7,0C6.6,6.7,6.1,6.9,5.6,7.3C5.2,7.6,4.7,8,4.4,8.4C4.3,8.6,4.2,8.8,4.2,8.9C4.1,9.1,4,9.3,3.9,9.4C3.9,9.6,3.8,9.7,3.8,9.9c0,0.2-0.1,0.3-0.1,0.5v-0.1c-0.1,0.8,0.1,1.6,0.5,2.4c0.4,0.7,1,1.3,1.7,1.7c0.3,0.2,0.6,0.3,0.9,0.3c0.3,0.1,0.7,0.1,1,0.1c0.3,0,0.7,0,1-0.1c0.3-0.1,0.6-0.2,0.9-0.3c0.5-0.3,0.9-0.6,1.3-1c0.3-0.4,0.6-0.8,0.8-1.3c0.1-0.4,0.2-0.9,0.2-1.4c0-0.5-0.1-1-0.3-1.4C11.5,8.6,11.1,8,10.5,7.5z M10.1,11.3H8.5v1.6H8H7.9H7.3v0v-0.1v-1.4H5.7v-0.4v-0.2v-0.6h0h1.5V8.5h1.2v1.6h1.6V11.3z"/></g></svg>',
    insert_row_above: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M0.1,14.5c0.1,0.1,0.1,0.2,0.2,0.2l0.1,0.1h14.9l0.1-0.1c0,0,0.1-0.1,0.1-0.1c0,0,0.1-0.1,0.1-0.1l0.1-0.1V6.7l-0.1-0.1c0-0.1-0.1-0.1-0.2-0.2l-0.1-0.1h-2.3v0.1l-0.1,0.5l-0.2,0.4l-0.1,0.2c0.1,0,0.2,0,0.3,0h1.6v6H1.3v-6h1.6c0.1,0,0.2,0,0.3,0L3.1,7.3L2.9,6.9C2.8,6.8,2.8,6.6,2.7,6.5V6.3H0.4L0.3,6.4c-0.1,0-0.1,0.1-0.2,0.2L0,6.7v7.7L0.1,14.5z"/><path d="M5.3,8.3c0.6,0.5,1.2,0.8,1.9,0.9c0.2,0,0.5,0.1,0.7,0c0.2,0,0.5,0,0.7,0c0.6-0.1,1.1-0.3,1.6-0.6c0.5-0.3,0.9-0.7,1.2-1.2c0.1-0.2,0.2-0.3,0.3-0.5c0.1-0.2,0.2-0.4,0.2-0.5c0.1-0.1,0.1-0.3,0.1-0.4C12,5.8,12,5.6,12,5.4v0.1c0.1-0.8-0.1-1.6-0.5-2.4c-0.4-0.7-1-1.3-1.7-1.7C9.5,1.3,9.2,1.2,8.9,1.1C8.5,1,8.2,1,7.9,1c-0.3,0-0.7,0-1,0.1C6.6,1.2,6.3,1.3,6,1.4C5.5,1.7,5.1,2,4.7,2.4C4.4,2.8,4.1,3.3,3.9,3.8C3.8,4.2,3.7,4.7,3.7,5.2c0,0.5,0.1,1,0.3,1.4C4.3,7.2,4.7,7.8,5.3,8.3z M5.7,4.5h1.6V2.9h0.5h0.1h0.6v0v0.1v1.4H10v0.4v0.2v0.6h0H8.5v1.6H7.3V5.7H5.7V4.5z"/></g></svg>',
    insert_column_left: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M14.5,15.7c0.1-0.1,0.2-0.1,0.2-0.2l0.1-0.1V0.4l-0.1-0.1c0,0-0.1-0.1-0.1-0.1c0,0-0.1-0.1-0.1-0.1L14.4,0H6.7L6.6,0.1c-0.1,0-0.1,0.1-0.2,0.2L6.3,0.4v2.3h0.1l0.5,0.1L7.3,3l0.2,0.1c0-0.1,0-0.2,0-0.3V1.2h6v13.3h-6v-1.6c0-0.1,0-0.2,0-0.3l-0.2,0.1l-0.4,0.2C6.7,12.9,6.6,13,6.4,13H6.3v2.3l0.1,0.2c0,0.1,0.1,0.1,0.2,0.2l0.1,0.1h7.7L14.5,15.7z"/><path d="M8.3,10.5C8.7,10,9,9.3,9.1,8.6c0-0.2,0.1-0.5,0-0.7c0-0.2,0-0.5,0-0.7C9,6.7,8.8,6.1,8.5,5.7C8.2,5.2,7.8,4.8,7.3,4.5C7.2,4.4,7,4.3,6.9,4.2C6.7,4.1,6.5,4,6.4,4C6.2,3.9,6.1,3.9,5.9,3.8c-0.2,0-0.3-0.1-0.5-0.1h0.1C4.7,3.7,3.8,3.9,3.1,4.3C2.4,4.7,1.8,5.3,1.4,6C1.3,6.3,1.2,6.6,1.1,6.9C1,7.2,1,7.6,1,7.9c0,0.3,0,0.7,0.1,1c0.1,0.3,0.2,0.6,0.3,0.9c0.3,0.5,0.6,0.9,1,1.3c0.4,0.3,0.8,0.6,1.3,0.8C4.2,12,4.7,12.1,5.1,12c0.5,0,1-0.1,1.4-0.3C7.2,11.5,7.8,11.1,8.3,10.5zM4.5,10.1V8.5H2.9V8V7.9V7.3h0H3h1.4V5.7h0.4h0.2h0.6v0v1.5h1.6v1.2H5.7v1.6H4.5z"/></g></svg>',
    insert_column_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M1.3,0.1C1.2,0.2,1.1,0.2,1.1,0.3L1,0.4v14.9l0.1,0.1c0,0,0.1,0.1,0.1,0.1c0,0,0.1,0.1,0.1,0.1l0.1,0.1h7.7l0.1-0.1c0.1,0,0.1-0.1,0.2-0.2l0.1-0.1v-2.3H9.3l-0.5-0.1l-0.4-0.2l-0.2-0.1c0,0.1,0,0.2,0,0.3v1.6h-6V1.3h6v1.6c0,0.1,0,0.2,0,0.3l0.2-0.1l0.4-0.2C9,2.9,9.2,2.8,9.3,2.8h0.1V0.5L9.4,0.3c0-0.1-0.1-0.1-0.2-0.2L9.1,0H1.4L1.3,0.1z"/><path d="M7.5,5.3C7,5.8,6.7,6.5,6.6,7.2c0,0.2-0.1,0.5,0,0.7c0,0.2,0,0.5,0,0.7c0.1,0.6,0.3,1.1,0.6,1.6c0.3,0.5,0.7,0.9,1.2,1.2c0.2,0.1,0.3,0.2,0.5,0.3c0.2,0.1,0.4,0.2,0.5,0.2c0.1,0.1,0.3,0.1,0.4,0.1c0.2,0,0.3,0.1,0.5,0.1h-0.1c0.8,0.1,1.6-0.1,2.4-0.5c0.7-0.4,1.3-1,1.7-1.7c0.2-0.3,0.3-0.6,0.3-0.9c0.1-0.3,0.1-0.7,0.1-1c0-0.3,0-0.7-0.1-1c-0.1-0.3-0.2-0.6-0.3-0.9c-0.3-0.5-0.6-0.9-1-1.3C13,4.4,12.5,4.2,12,4c-0.4-0.1-0.9-0.2-1.4-0.2c-0.5,0-1,0.1-1.4,0.2C8.5,4.3,7.9,4.7,7.5,5.3z M11.3,5.7v1.6h1.6v0.5v0.1v0.6h0h-0.1h-1.4v1.6h-0.4h-0.2h-0.6v0V8.5H8.5V7.3h1.6V5.7H11.3z"/></g></svg>',
    delete_row: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 13.83"><g><path d="M4.7,18.46l.12.08H19.73l.12-.08a.58.58,0,0,0,.22-.22l.08-.12,0-7.69-.08-.11a.77.77,0,0,0-.18-.18l-.11-.08-2.31,0-.08.28-.1.29a1.58,1.58,0,0,1-.12.29l-.14.34s0,0,.18,0H18.9v6H5.64v-6H7.35c.14,0,.2,0,.18,0l-.14-.34a2.85,2.85,0,0,1-.12-.29l-.1-.29-.07-.27-2.31,0-.11.08a.77.77,0,0,0-.18.18l-.08.11,0,7.69.08.12a.47.47,0,0,0,.09.12l.13.09ZM12.11,13a4,4,0,0,0,1.46-.21,4.51,4.51,0,0,0,1.31-.71A4,4,0,0,0,16.26,10a4.32,4.32,0,0,0-.08-2.54,4.34,4.34,0,0,0-1-1.52,4.15,4.15,0,0,0-1.54-1,4.34,4.34,0,0,0-1.35-.22A4.07,4.07,0,0,0,11,4.93,3.94,3.94,0,0,0,9.24,6.07,3.92,3.92,0,0,0,8.15,8.88a3.91,3.91,0,0,0,.12.95A4.16,4.16,0,0,0,12.11,13Zm2.35-4.14v.58H10.09V8.27h4.37v.58Z" transform="translate(-4.4 -4.71)"/></g></svg>',
    delete_column: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 13.81 15.74"><g><path d="M5.66,19.42l.12.08,7.69,0,.11-.08a.77.77,0,0,0,.18-.18l.08-.11,0-2.32-.15,0-.45-.15-.42-.18-.17-.07a1,1,0,0,0,0,.27v1.63h-6V5h6V6.62a.9.9,0,0,0,0,.26l.17-.07.42-.17a3.91,3.91,0,0,1,.45-.15l.15,0,0-2.32L13.75,4a.77.77,0,0,0-.18-.18l-.11-.08H5.79l-.13.07a.63.63,0,0,0-.21.22l-.08.12V19.08l.08.12a.47.47,0,0,0,.09.12.35.35,0,0,0,.12.1Zm9-3.67a4.16,4.16,0,0,0,2.36-.51,4.08,4.08,0,0,0,1.67-1.72,4,4,0,0,0,.35-.91,3.79,3.79,0,0,0,.1-1,4.71,4.71,0,0,0-.11-1,5,5,0,0,0-.3-.87,4.25,4.25,0,0,0-1-1.25,4.49,4.49,0,0,0-1.34-.81A4.26,4.26,0,0,0,15,7.48a3.88,3.88,0,0,0-1.41.25A4.32,4.32,0,0,0,11.86,9,4,4,0,0,0,11,10.94a4.4,4.4,0,0,0-.05.68,4.5,4.5,0,0,0,.05.68,3.93,3.93,0,0,0,.61,1.57,4.22,4.22,0,0,0,1.18,1.2,4.59,4.59,0,0,0,.48.27c.2.1.37.17.5.22a2.44,2.44,0,0,0,.45.12,4.61,4.61,0,0,0,.5.07Zm2.54-4.12v.58H12.87V11h4.37v.59Z" transform="translate(-5.37 -3.76)"/></g></svg>',
    fixed_column_width: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6,5H18A1,1 0 0,1 19,6A1,1 0 0,1 18,7H6A1,1 0 0,1 5,6A1,1 0 0,1 6,5M21,2V4H3V2H21M15,8H17V22H15V8M7,8H9V22H7V8M11,8H13V22H11V8Z" /></svg>',
    rotate_left: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M0.5,10.2c0,0.1,0,0.2,0,0.3v0.2l0,0c0.1,0.3,0.3,0.6,0.4,0.9l0,0C1,11.8,1.3,12,1.5,11.9h0.1h0.2h0.1c0.1-0.1,0.3-0.3,0.4-0.5v-0.2c0-0.1,0-0.2-0.1-0.3l0,0c-0.2-0.2-0.3-0.4-0.3-0.7l0,0C1.8,10,1.7,9.9,1.5,9.8c-0.1,0-0.2,0-0.3,0H0.9C0.7,9.9,0.6,10,0.5,10.2L0.5,10.2z"/><path d="M2.2,11.5L2.2,11.5L2.2,11.5z"/><path d="M5.9,3.6L5.9,3.6L5.9,3.6z"/><path d="M0.1,7.9c0,0.3,0,0.6,0,0.9l0,0l0,0l0,0l0,0c0,0.2,0.1,0.3,0.2,0.4l0,0c0.2,0.1,0.3,0.2,0.5,0.2l0,0l0,0c0.2,0,0.4-0.1,0.5-0.3l0,0c0-0.1,0.1-0.3,0.1-0.4V8.6l0,0c0-0.2,0-0.5,0-0.7l0,0c0-0.2-0.1-0.4-0.2-0.5C1.1,7.3,0.9,7.2,0.7,7.2S0.3,7.3,0.2,7.4C0.1,7.5,0,7.7,0.1,7.9z"/><path d="M1.9,12.7L1.9,12.7c0,0.2,0,0.4,0.2,0.5l0,0l0.2,0.3l0,0c0.2,0.1,0.3,0.2,0.5,0.4l0,0l0,0l0,0l0,0C2.9,14,3,14.1,3.2,14.1s0.4-0.1,0.5-0.2c0.1-0.2,0.2-0.3,0.2-0.5v-0.1c0-0.2-0.1-0.4-0.2-0.5l0,0l-0.4-0.4l-0.2-0.2l0,0C3,12.1,2.8,12,2.6,12l0,0c-0.2,0-0.4,0.1-0.5,0.2l0,0C2,12.3,1.9,12.5,1.9,12.7z"/><path d="M6.6,15c0,0.2,0.1,0.4,0.2,0.5c0.1,0.1,0.2,0.2,0.4,0.3l0,0c0.3,0,0.5,0,0.7,0h0.3l0,0c0.2,0,0.4-0.1,0.5-0.2c0.1-0.2,0.2-0.3,0.2-0.5l0,0l0,0c0-0.2-0.1-0.4-0.2-0.5l0,0c-0.1-0.1-0.3-0.2-0.5-0.2l0,0H7.9c-0.1,0-0.3,0-0.5,0l0,0H7.3c-0.2-0.1-0.3,0-0.5,0.1l0,0C6.7,14.6,6.6,14.8,6.6,15L6.6,15L6.6,15L6.6,15z"/><path d="M4.2,7.4C4,7.5,4,7.7,4,7.9c0,0.2,0,0.4,0.2,0.5l0,0l3.2,3.2l0,0c0.1,0.1,0.3,0.2,0.5,0.2s0.3-0.1,0.5-0.2l0,0l3.2-3.2l0,0c0.1-0.1,0.2-0.3,0.2-0.5c0-0.2-0.1-0.4-0.2-0.5l0,0C11.5,7.3,11,6.7,10,5.8l0,0L8.4,4.2l0,0C8.3,4.1,8.1,4,7.9,4S7.5,4.1,7.4,4.2L4.2,7.4L4.2,7.4z M6.8,9L5.7,7.9l2.2-2.2l2.3,2.2l-2.3,2.2C7.7,9.9,7.3,9.5,6.8,9L6.8,9z"/><path d="M4.1,14.1C4,14.2,4,14.3,4,14.4v0.2l0,0c0.1,0.1,0.2,0.3,0.4,0.4l0,0c0.3,0.1,0.6,0.2,0.9,0.4h0.1h0.1l0,0c0.2,0,0.3-0.1,0.5-0.1l0,0c0.2-0.1,0.3-0.3,0.3-0.4l0,0l0,0l0,0l0,0v-0.2c0-0.1-0.1-0.2-0.1-0.3l0,0C6.1,14.2,6,14.1,5.8,14l0,0c-0.3-0.1-0.5-0.2-0.8-0.2l0,0c-0.1-0.1-0.2-0.1-0.3-0.1H4.5C4.3,13.7,4.2,13.9,4.1,14.1z"/><path d="M9.3,14.4c0,0.1-0.1,0.3,0,0.4V15l0,0c0,0.1,0.1,0.3,0.5,0.4c0.1,0.1,0.3,0.1,0.4,0.1l0,0h0.1l0,0c0.3-0.1,0.6-0.2,0.9-0.3l0,0c0.1-0.1,0.2-0.2,0.3-0.4l0.1-0.3c0-0.1-0.1-0.2-0.1-0.3l0,0c-0.1-0.2-0.2-0.3-0.4-0.4l0,0h-0.3c-0.1,0-0.2,0-0.3,0l0,0c-0.2,0.1-0.5,0.2-0.8,0.3l0,0C9.5,14.1,9.4,14.2,9.3,14.4L9.3,14.4z"/><path d="M11.4,14.7L11.4,14.7L11.4,14.7z"/><path d="M9.5,15.3L9.5,15.3L9.5,15.3z"/><path d="M15.9,7.9c0-1-0.2-2-0.6-3l0,0c-0.4-1-1-1.9-1.7-2.6C12.8,1.6,12,1,11,0.6l0,0C10.1,0.2,9,0,8,0C7.3,0,6.5,0.1,5.8,0.3l0,0C5.2,0.5,4.6,0.8,4,1.1L3.1,0.2l0,0C2.9,0.1,2.8,0,2.6,0H2.4l0,0C2.2,0,2,0.2,1.9,0.4l0,0L0.1,4.9l0,0C0,5,0,5.1,0,5.2c0,0.2,0.1,0.4,0.2,0.5l0,0c0.2,0.1,0.3,0.2,0.5,0.2h0.1H1l0,0l4.7-1.8l0,0C5.9,4,6.1,3.8,6.1,3.6V3.4C6.1,3.2,6,3,5.9,2.9l0,0L5.1,2.1c0.4-0.2,0.8-0.4,1.3-0.5c0.5-0.1,1.1-0.2,1.7-0.2c0.9,0,1.7,0.2,2.5,0.5l0,0c0.8,0.3,1.5,0.8,2.1,1.4c0.6,0.6,1.1,1.3,1.4,2.1l0,0c0.3,0.8,0.5,1.6,0.5,2.5s-0.2,1.7-0.5,2.5l0,0c-0.3,0.8-0.8,1.5-1.4,2.1c-0.2,0.2-0.4,0.3-0.6,0.5l0,0c-0.2,0.1-0.3,0.3-0.3,0.5v0.1c0,0.1,0,0.3,0.1,0.4l0,0c0.1,0.2,0.3,0.3,0.5,0.3l0,0c0.1,0,0.3-0.1,0.4-0.2l0,0l0,0l0,0l0,0c0.2-0.2,0.5-0.4,0.7-0.6l0,0l0,0l0,0l0,0c0.7-0.8,1.3-1.6,1.7-2.6C15.6,10,15.8,9,15.9,7.9z M1.9,4C2,3.8,2.1,3.5,2.3,3.1l0,0L2.7,2l1.2,1.2L1.9,4z"/><path d="M6.8,15.5L6.8,15.5L6.8,15.5z"/></g></svg>',
    rotate_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M9.9,15.3L9.9,15.3L9.9,15.3z"/><path d="M6.9,15.1L6.9,15.1c0,0.1,0.1,0.3,0.2,0.4l0,0c0.1,0.2,0.3,0.3,0.5,0.3l0,0h0.3c0.2,0,0.4,0,0.7,0l0,0c0.2-0.1,0.3-0.2,0.4-0.3c0.1-0.1,0.2-0.2,0.2-0.4V15c0-0.2-0.1-0.4-0.2-0.4c-0.2-0.1-0.3-0.2-0.5-0.2H8.4l0,0c-0.1,0-0.3,0-0.5,0H7.6l0,0c-0.2,0-0.4,0.1-0.5,0.2C7,14.7,6.9,14.9,6.9,15.1z"/><path d="M6.5,14.4L6.5,14.4L6.5,14.4z"/><path d="M5.8,5.8L5.8,5.8c-1,0.9-1.5,1.5-1.7,1.6l0,0C4,7.5,4,7.7,4,7.9c0,0.2,0,0.4,0.2,0.5l0,0l3.2,3.2l0,0c0.2,0.1,0.3,0.2,0.5,0.2s0.4-0.1,0.5-0.2l0,0l3.2-3.2l0,0c0.1-0.1,0.2-0.3,0.2-0.5c0-0.2-0.1-0.4-0.2-0.5l0,0L8.4,4.2C8.3,4.1,8.1,4,7.9,4C7.7,4,7.5,4.1,7.4,4.2l0,0L5.8,5.8z M5.6,7.9l2.3-2.2l2.2,2.2L9,9l0,0l0,0l0,0l0,0c-0.5,0.6-0.9,0.9-1.1,1.1L5.6,7.9z"/><path d="M9,15.5L9,15.5L9,15.5z"/><path d="M9.6,14.7v0.2l0,0l0,0l0,0l0,0c0.1,0.2,0.1,0.3,0.3,0.3c0.1,0.1,0.3,0.1,0.4,0.1l0,0h0.1h0.1c0.3-0.1,0.6-0.3,0.9-0.4l0,0c0.1-0.1,0.2-0.2,0.3-0.4l0,0v-0.2c0-0.1,0-0.2-0.1-0.3c-0.1-0.2-0.2-0.3-0.4-0.4H11c-0.1,0-0.2,0.1-0.3,0.1l0,0c-0.2,0.1-0.4,0.2-0.7,0.3l0,0l0,0c-0.1,0.1-0.3,0.2-0.4,0.4C9.6,14.5,9.6,14.6,9.6,14.7z"/><path d="M9,14.5L9,14.5L9,14.5z"/><path d="M9.6,14.4L9.6,14.4L9.6,14.4z"/><path d="M11.7,14L11.7,14L11.7,14z"/><path d="M15.6,7.4L15.6,7.4L15.6,7.4z"/><path d="M15,9.4c0.2,0,0.4,0,0.6-0.2l0,0c0.1-0.1,0.2-0.2,0.2-0.4l0,0l0,0l0,0l0,0c0-0.3,0-0.6,0-0.9c0-0.2-0.1-0.4-0.2-0.5c-0.1-0.1-0.3-0.2-0.5-0.2s-0.4,0.1-0.5,0.2c-0.1,0.1-0.2,0.3-0.2,0.5l0,0c0,0.2,0,0.4,0,0.7l0,0v0.1c0,0.1,0,0.3,0.1,0.4l0,0C14.6,9.3,14.8,9.4,15,9.4L15,9.4L15,9.4z"/><path d="M14,12h0.1h0.2h0.1c0.2,0,0.5-0.2,0.6-0.4l0,0c0.2-0.3,0.3-0.6,0.4-0.9l0,0v-0.2c0-0.1-0.1-0.2-0.1-0.3c-0.1-0.2-0.2-0.3-0.4-0.4h-0.3c-0.1,0-0.2,0-0.3,0C14.2,9.9,14,10,14,10.3l0,0c-0.1,0.2-0.2,0.5-0.3,0.7l0,0c-0.1,0.1-0.1,0.2-0.1,0.3v0.2l0,0l0,0C13.6,11.6,13.8,11.8,14,12z"/><path d="M14.6,7.4L14.6,7.4L14.6,7.4z"/><path d="M4.4,14.2c-0.1,0.1-0.1,0.2-0.1,0.3l0.1,0.2c0,0.2,0.2,0.3,0.3,0.4l0,0c0.3,0.1,0.6,0.3,1.1,0.4l0,0h0.1l0,0c0.1,0,0.2-0.1,0.4-0.2c0.1,0,0.2-0.2,0.3-0.3l0,0v-0.2c0-0.1-0.1-0.3-0.2-0.4c-0.1-0.1-0.2-0.2-0.4-0.3l0,0c-0.2-0.1-0.5-0.2-0.7-0.3l0,0c-0.1,0-0.2,0-0.3,0H4.7l0,0C4.6,13.9,4.4,14,4.4,14.2L4.4,14.2z"/><path d="M11.9,13.3c0,0.2,0.1,0.4,0.2,0.6c0.1,0.1,0.3,0.2,0.5,0.2s0.4-0.1,0.5-0.2l0,0l0,0l0,0l0,0c0.1-0.1,0.3-0.3,0.4-0.4l0,0l0.2-0.3l0,0c0.1-0.2,0.2-0.3,0.2-0.5l0,0c0-0.2-0.1-0.4-0.2-0.5l0,0c-0.1-0.1-0.3-0.2-0.5-0.2l0,0c-0.2,0-0.4,0.1-0.5,0.2l0,0l-0.2,0.2l-0.4,0.4l0,0C12,13,11.9,13.1,11.9,13.3L11.9,13.3z"/><path d="M12.1,13.8L12.1,13.8L12.1,13.8z"/><path d="M11.9,13.3L11.9,13.3L11.9,13.3z"/><path d="M15.9,5.2c0-0.1-0.1-0.2-0.1-0.3l0,0L14,0.4l0,0C13.9,0.2,13.7,0,13.5,0l0,0l0,0h-0.2c-0.2,0-0.4,0.1-0.5,0.2l0,0l-0.9,0.9c-0.5-0.3-1.1-0.6-1.8-0.8l0,0C9.4,0.1,8.7,0,7.9,0c-1,0-2,0.2-3,0.6S3,1.6,2.3,2.3C1.6,3.1,1,3.9,0.6,4.9l0,0C0.2,5.8,0,6.8,0,7.9c0,1,0.2,2,0.6,3s0.9,1.8,1.7,2.6l0,0l0,0l0,0l0,0c0.2,0.2,0.5,0.4,0.7,0.6l0,0l0,0l0,0l0,0c0.2,0.1,0.3,0.2,0.5,0.2l0,0c0.2,0,0.4-0.1,0.6-0.3l0,0c0.1-0.1,0.1-0.3,0.1-0.4v-0.1l0,0C4.1,13.3,4,13.1,3.9,13l0,0c-0.2-0.1-0.4-0.3-0.6-0.5c-0.6-0.6-1.1-1.3-1.4-2.1l0,0C1.6,9.6,1.4,8.8,1.4,7.9s0.2-1.7,0.5-2.5l0,0c0.3-0.8,0.8-1.5,1.4-2.1c0.6-0.6,1.3-1.1,2.1-1.4l0,0C6.2,1.6,7,1.4,7.9,1.4c0.6,0,1.1,0.1,1.7,0.2c0.5,0.1,0.9,0.3,1.3,0.5l-0.8,0.8l0,0C10,3.1,9.9,3.2,9.9,3.4v0.2l0,0l0,0c0,0.2,0.2,0.4,0.4,0.5l0,0l4.5,1.8l0,0H15h0.1c0.2,0,0.4-0.1,0.5-0.2l0,0C15.7,5.6,15.8,5.4,15.9,5.2z M11.8,3.2L13,2l0.4,1.1l0,0c0.2,0.4,0.3,0.7,0.4,0.9L11.8,3.2z"/></g></svg>',
    mirror_horizontal: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14.75 15.74"><g><path d="M13.75,3.76l5.9,15.74h-5.9V3.76ZM4.9,19.5,10.8,3.76V19.5H4.9Z" transform="translate(-4.9 -3.76)"/></g></svg>',
    mirror_vertical: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.75"><g><path d="M20.15,13.1,4.41,19V13.1H20.15ZM4.41,4.25l15.74,5.9H4.41V4.25Z" transform="translate(-4.41 -4.25)"/></g></svg>',
    checked: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 12.1"><g><path d="M4.59,12.23l.12.18L9.43,17.5a.58.58,0,0,0,.84,0L20,7.45h0a.58.58,0,0,0,0-.84l-.85-.85a.58.58,0,0,0-.84,0H18.2l-8.12,8.41a.29.29,0,0,1-.42,0l-3.4-3.63a.58.58,0,0,0-.84,0l-.85.85a.6.6,0,0,0-.14.21.51.51,0,0,0,0,.44c.05.06.1.13.16.19Z" transform="translate(-4.38 -5.58)"/></g></svg>',
    line_break: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19,6a1,1,0,0,0-1,1v4a1,1,0,0,1-1,1H7.41l1.3-1.29A1,1,0,0,0,7.29,9.29l-3,3a1,1,0,0,0-.21.33,1,1,0,0,0,0,.76,1,1,0,0,0,.21.33l3,3a1,1,0,0,0,1.42,0,1,1,0,0,0,0-1.42L7.41,14H17a3,3,0,0,0,3-3V7A1,1,0,0,0,19,6Z"/></svg>',
    audio: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z" /></svg>',
    image_gallery: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="30 30 150 150"><g><path d="M152.775,120.548V51.651c0-12.271-9.984-22.254-22.254-22.254H43.727c-12.271,0-22.254,9.983-22.254,22.254v68.896c0,12.27,9.983,22.254,22.254,22.254h86.795C142.791,142.802,152.775,132.817,152.775,120.548z M36.394,51.651c0-4.042,3.291-7.333,7.333-7.333h86.795c4.042,0,7.332,3.291,7.332,7.333v23.917l-14.938-17.767c-1.41-1.678-3.487-2.649-5.68-2.658h-0.029c-2.184,0-4.255,0.954-5.674,2.613L76.709,98.519l-9.096-9.398c-1.427-1.474-3.392-2.291-5.448-2.273c-2.052,0.025-4.004,0.893-5.396,2.4L36.394,111.32V51.651z M41.684,127.585l20.697-22.416l9.312,9.622c1.461,1.511,3.489,2.334,5.592,2.27c2.101-0.066,4.075-1.013,5.44-2.612l34.436-40.308l20.693,24.613v21.794c0,4.042-3.29,7.332-7.332,7.332H43.727C43.018,127.88,42.334,127.775,41.684,127.585z M182.616,152.5V75.657c0-4.12-3.34-7.46-7.461-7.46c-4.119,0-7.46,3.34-7.46,7.46V152.5c0,4.112-3.347,7.46-7.461,7.46h-94c-4.119,0-7.46,3.339-7.46,7.459c0,4.123,3.341,7.462,7.46,7.462h94C172.576,174.881,182.616,164.841,182.616,152.5z"/></g></svg>',
    bookmark: '<svg viewBox="0 0 24 24"><path d="M17,3H7A2,2 0 0,0 5,5V21L12,18L19,21V5C19,3.89 18.1,3 17,3Z" /></svg>',
    download: '<svg viewBox="0 0 24 24"><path d="M2 12H4V17H20V12H22V17C22 18.11 21.11 19 20 19H4C2.9 19 2 18.11 2 17V12M12 15L17.55 9.54L16.13 8.13L13 11.25V2H11V11.25L7.88 8.13L6.46 9.55L12 15Z" /></svg>',
    dir_ltr: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M9 4v4c-1.1 0-2-.9-2-2s.9-2 2-2m8-2H9C6.79 2 5 3.79 5 6s1.79 4 4 4v5h2V4h2v11h2V4h2V2zm0 12v3H5v2h12v3l4-4-4-4z"/></svg>',
    dir_rtl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M10 4v4c-1.1 0-2-.9-2-2s.9-2 2-2m8-2h-8C7.79 2 6 3.79 6 6s1.79 4 4 4v5h2V4h2v11h2V4h2V2zM8 14l-4 4 4 4v-3h12v-2H8v-3z"/></svg>',
    // Error
    alert_outline: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11,15H13V17H11V15M11,7H13V13H11V7M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20Z" /></svg>',
    // More icons
    more_text: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="10 10 180 180"><g><path d="M49.711,142.188h49.027c2.328,0.002,4.394,1.492,5.129,3.699l9.742,29.252c0.363,1.092,1.385,1.828,2.537,1.83l15.883,0.01c0.859,0,1.667-0.412,2.17-1.109s0.641-1.594,0.37-2.41l-16.625-50.045L86.503,28.953c-0.36-1.097-1.383-1.839-2.537-1.842H64.532c-1.153-0.001-2.178,0.736-2.542,1.831L13.847,173.457c-0.271,0.816-0.135,1.713,0.369,2.412c0.503,0.697,1.311,1.109,2.171,1.109h15.872c1.151,0,2.173-0.736,2.537-1.828l9.793-29.287C45.325,143.66,47.39,142.18,49.711,142.188L49.711,142.188z M53.493,119.098l15.607-46.9c0.744-2.196,2.806-3.674,5.125-3.674s4.381,1.478,5.125,3.674l15.607,46.904c0.537,1.621,0.263,3.402-0.736,4.789c-1.018,1.408-2.649,2.24-4.386,2.24H58.615c-1.736,0-3.368-0.832-4.386-2.24C53.23,122.504,52.956,120.721,53.493,119.098L53.493,119.098z M190.465,63.32c0-2.919-1.015-5.396-3.059-7.428c-2.029-2.031-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.016-7.388,3.047c-2.029,2.032-3.056,4.498-3.056,7.386c0,2.889,1.026,5.354,3.056,7.385c2.032,2.032,4.499,3.059,7.388,3.059c2.887,0,5.354-1.026,7.383-3.059C189.45,68.633,190.465,66.178,190.465,63.32L190.465,63.32z M190.465,101.994c0-2.858-1.015-5.313-3.059-7.333c-2.029-2.042-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.005-7.388,3.047c-2.029,2.021-3.056,4.486-3.056,7.376c0,2.887,1.026,5.352,3.056,7.395c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,107.389,190.465,104.914,190.465,101.994L190.465,101.994z M190.465,140.76c0-2.918-1.015-5.395-3.059-7.438c-2.029-2.041-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.006-7.388,3.047c-2.029,2.043-3.056,4.52-3.056,7.438c0,2.922,1.026,5.398,3.056,7.439c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,146.158,190.465,143.682,190.465,140.76L190.465,140.76z"/></g></svg>',
    more_paragraph: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="10 10 180 180"><g><path d="M128.39,28.499H63.493c-25.558,0-46.354,20.796-46.354,46.354c0,25.559,20.796,46.353,46.354,46.353h9.271v55.625h18.542V47.04h9.271V176.83h18.543V47.04h9.271V28.499z M72.764,102.664h-9.271c-15.337,0-27.813-12.475-27.813-27.812c0-15.336,12.476-27.813,27.813-27.813h9.271V102.664z M190.465,63.32c0-2.919-1.015-5.396-3.059-7.428c-2.029-2.031-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.016-7.388,3.047c-2.029,2.032-3.056,4.498-3.056,7.386c0,2.889,1.026,5.354,3.056,7.385c2.032,2.032,4.499,3.059,7.388,3.059c2.887,0,5.354-1.026,7.383-3.059C189.45,68.633,190.465,66.178,190.465,63.32L190.465,63.32z M190.465,101.994c0-2.858-1.015-5.313-3.059-7.333c-2.029-2.042-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.005-7.388,3.047c-2.029,2.021-3.056,4.486-3.056,7.376c0,2.887,1.026,5.352,3.056,7.395c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,107.389,190.465,104.914,190.465,101.994L190.465,101.994z M190.465,140.76c0-2.918-1.015-5.395-3.059-7.438c-2.029-2.041-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.006-7.388,3.047c-2.029,2.043-3.056,4.52-3.056,7.438c0,2.922,1.026,5.398,3.056,7.439c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,146.158,190.465,143.682,190.465,140.76L190.465,140.76z"/></g></svg>',
    more_plus: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="35 30 140 140"><g><path d="M137.215,102.045c0,3.498-2.835,6.332-6.333,6.332H24.549c-3.498,0-6.334-2.834-6.334-6.332l0,0c0-3.498,2.836-6.333,6.334-6.333h106.333C134.38,95.711,137.215,98.547,137.215,102.045L137.215,102.045z M77.715,161.545c-3.498,0-6.333-2.836-6.333-6.334V48.878c0-3.498,2.836-6.333,6.333-6.333l0,0c3.498,0,6.334,2.835,6.334,6.333v106.333C84.049,158.709,81.213,161.545,77.715,161.545L77.715,161.545z M190.465,63.32c0-2.919-1.015-5.396-3.059-7.428c-2.029-2.031-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.016-7.388,3.047c-2.029,2.032-3.056,4.498-3.056,7.386c0,2.889,1.026,5.354,3.056,7.385c2.032,2.032,4.499,3.059,7.388,3.059c2.887,0,5.354-1.026,7.383-3.059C189.45,68.632,190.465,66.177,190.465,63.32L190.465,63.32z M190.465,101.993c0-2.858-1.015-5.313-3.059-7.333c-2.029-2.042-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.005-7.388,3.047c-2.029,2.021-3.056,4.486-3.056,7.376c0,2.888,1.026,5.353,3.056,7.396c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,107.389,190.465,104.914,190.465,101.993L190.465,101.993z M190.465,140.76c0-2.918-1.015-5.395-3.059-7.438c-2.029-2.041-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.006-7.388,3.047c-2.029,2.043-3.056,4.52-3.056,7.438c0,2.922,1.026,5.398,3.056,7.439c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,146.158,190.465,143.682,190.465,140.76L190.465,140.76z"/></g></svg>',
    more_horizontal: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 3.58"><g><path d="M4.64,10.73a1.84,1.84,0,0,1,.65-.65,1.76,1.76,0,0,1,1.79,0A1.79,1.79,0,0,1,8,11.63a1.84,1.84,0,0,1-.25.9,1.69,1.69,0,0,1-.65.65,1.8,1.8,0,0,1-2.69-1.55A2.08,2.08,0,0,1,4.64,10.73Zm6.09,0a1.84,1.84,0,0,1,.65-.65,1.78,1.78,0,0,1,2.67,1.55,1.73,1.73,0,0,1-.24.9,1.84,1.84,0,0,1-.65.65,1.76,1.76,0,0,1-1.79,0,1.79,1.79,0,0,1-.64-2.44Zm6.08,0a1.69,1.69,0,0,1,.65-.65,1.76,1.76,0,0,1,1.79,0,1.79,1.79,0,0,1,.9,1.54,1.73,1.73,0,0,1-.24.9,1.84,1.84,0,0,1-.65.65,1.8,1.8,0,0,1-2.69-1.55A2,2,0,0,1,16.81,10.73Z" transform="translate(-4.39 -9.84)"/></g></svg>',
    more_vertical: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 3.94 15.75"><g><path d="M12.28,7.69a1.92,1.92,0,0,1-1.39-.58,2,2,0,0,1-.58-1.39,1.92,1.92,0,0,1,.58-1.39,2,2,0,0,1,1.39-.58,1.92,1.92,0,0,1,1.39.58,2,2,0,0,1,.58,1.39,1.92,1.92,0,0,1-.58,1.39,2,2,0,0,1-1.39.58Zm0,2a1.92,1.92,0,0,1,1.39.58,2,2,0,0,1,.58,1.39A1.92,1.92,0,0,1,13.67,13a2,2,0,0,1-1.39.58A1.92,1.92,0,0,1,10.89,13a2,2,0,0,1-.58-1.39,2,2,0,0,1,2-2Zm0,5.9a1.92,1.92,0,0,1,1.39.58,2,2,0,0,1,.58,1.39,1.92,1.92,0,0,1-.58,1.39,2,2,0,0,1-1.39.58,1.92,1.92,0,0,1-1.39-.58,2,2,0,0,1-.58-1.39,1.92,1.92,0,0,1,.58-1.39,1.94,1.94,0,0,1,1.39-.58Z" transform="translate(-10.31 -3.75)"/></g></svg>',
    // Not currently used
    attachment: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8.38 15.68"><g><path d="M15.23,6h1v9.78a3.88,3.88,0,0,1-1.31,2.45,4,4,0,0,1-6.57-2.45V7A3,3,0,0,1,9.2,4.89a3,3,0,0,1,5,2.09v8.31a1.92,1.92,0,0,1-.58,1.39,2,2,0,0,1-1.39.58,1.92,1.92,0,0,1-1.39-.58,2,2,0,0,1-.58-1.39V8h1v7.32a1,1,0,0,0,.29.69,1,1,0,0,0,.69.28A.9.9,0,0,0,13,16a1,1,0,0,0,.29-.69V7a1.92,1.92,0,0,0-.58-1.39A2,2,0,0,0,11.27,5a1.92,1.92,0,0,0-1.39.58A2,2,0,0,0,9.33,7v8.31a3,3,0,1,0,5.9,0V6Z" transform="translate(-8.08 -3.78)"/></g></svg>',
    map: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.7 15.62"><g><path d="M12.05,12.42a2.93,2.93,0,1,1,2.07-5A2.88,2.88,0,0,1,15,9.49a3,3,0,0,1-.86,2.07,2.89,2.89,0,0,1-2.07.86Zm0-5.36a2.43,2.43,0,0,0-1.72,4.16,2.48,2.48,0,0,0,1.72.72,2.44,2.44,0,0,0,0-4.88Zm0-3.3A5.84,5.84,0,0,1,17.9,9.62a9.94,9.94,0,0,1-1.73,5A33.59,33.59,0,0,1,12.84,19a1.52,1.52,0,0,1-.23.2,1,1,0,0,1-.55.2h0a1,1,0,0,1-.55-.2,1.52,1.52,0,0,1-.23-.2,33.59,33.59,0,0,1-3.33-4.32,9.93,9.93,0,0,1-1.72-5,5.84,5.84,0,0,1,5.85-5.86ZM12,18.34l.08.05.06-.06a35.58,35.58,0,0,0,3.06-3.93,9.35,9.35,0,0,0,1.74-4.77,4.88,4.88,0,0,0-4.88-4.88A4.79,4.79,0,0,0,8.6,6.17,4.84,4.84,0,0,0,7.17,9.62,9.29,9.29,0,0,0,8.91,14.4,36,36,0,0,0,12,18.34Z" transform="translate(-6.2 -3.76)"/></g></svg>',
    magic_stick: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 15.75"><g><path d="M19.86,19.21a1,1,0,0,0,.28-.68,1,1,0,0,0-.28-.7L13,10.93a1,1,0,0,0-.7-.28,1,1,0,0,0-.68,1.65l6.9,6.9a1,1,0,0,0,.69.29.93.93,0,0,0,.69-.28ZM9.19,8.55a3,3,0,0,0,1.68,0,14.12,14.12,0,0,0,1.41-.32A11.26,11.26,0,0,0,10.8,7.06c-.56-.36-.86-.56-.91-.58S10,5.91,10,5.11s0-1.26-.15-1.37a4.35,4.35,0,0,0-1.19.71c-.53.4-.81.62-.87.68a9,9,0,0,0-2-.6,6.84,6.84,0,0,0-.76-.09s0,.27.08.77a8.6,8.6,0,0,0,.61,2q-.09.09-.69.87a3.59,3.59,0,0,0-.68,1.17c.12.17.57.23,1.36.15S7,9.26,7.15,9.23s.21.36.57.91a10.49,10.49,0,0,0,1.14,1.48c0-.1.14-.57.31-1.4a3,3,0,0,0,0-1.67Z" transform="translate(-4.41 -3.74)"/></g></svg>',
    empty_file: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12.78 15.75"><g><path d="M14.73,3.76,18.67,7.7v9.84a2,2,0,0,1-2,2H7.84a1.89,1.89,0,0,1-1.38-.58,2,2,0,0,1-.57-1.39V5.73a1.93,1.93,0,0,1,.57-1.38,2,2,0,0,1,1.38-.58h6.62l.26,0v0Zm2.95,4.92h-2a1.93,1.93,0,0,1-1.38-.57,2,2,0,0,1-.58-1.4V6.17c0-.36,0-.84,0-1.43H7.85a1,1,0,0,0-.7.29,1,1,0,0,0-.29.7V17.54a1,1,0,0,0,.29.69,1,1,0,0,0,.69.29h8.85a1,1,0,0,0,.71-.29.92.92,0,0,0,.28-.69Zm0-1L14.73,4.74v2A1,1,0,0,0,15,7.4a1,1,0,0,0,.69.29Z" transform="translate(-5.89 -3.76)"/></g></svg>'
  };

  // ../../node_modules/suneditor/src/lib/constructor.js
  var import_en = __toESM(require_en());

  // ../../node_modules/suneditor/src/lib/util.js
  var util = {
    _d: null,
    _w: null,
    isIE: null,
    isIE_Edge: null,
    isOSX_IOS: null,
    isChromium: null,
    isMobile: null,
    isResizeObserverSupported: null,
    _propertiesInit: function() {
      if (this._d) return;
      this._d = document;
      this._w = window;
      this.isIE = navigator.userAgent.indexOf("Trident") > -1;
      this.isIE_Edge = navigator.userAgent.indexOf("Trident") > -1 || navigator.appVersion.indexOf("Edge") > -1;
      this.isOSX_IOS = /(Mac|iPhone|iPod|iPad)/.test(navigator.platform);
      this.isChromium = !!window.chrome;
      this.isResizeObserverSupported = typeof ResizeObserver === "function";
      this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    },
    _allowedEmptyNodeList: ".se-component, pre, blockquote, hr, li, table, img, iframe, video, audio, canvas",
    /**
     * @description HTML Reserved Word Converter.
     * @param {String} contents 
     * @returns {String} HTML string
     * @private
     */
    _HTMLConvertor: function(contents) {
      const ec = { "&": "&amp;", "\xA0": "&nbsp;", "'": "&apos;", '"': "&quot;", "<": "&lt;", ">": "&gt;" };
      return contents.replace(/&|\u00A0|'|"|<|>/g, function(m) {
        return typeof ec[m] === "string" ? ec[m] : m;
      });
    },
    /**
     * @description Unicode Character 'ZERO WIDTH SPACE' (\u200B)
     */
    zeroWidthSpace: String.fromCharCode(8203),
    /**
     * @description Regular expression to find 'zero width space' (/\u200B/g)
     */
    zeroWidthRegExp: new RegExp(String.fromCharCode(8203), "g"),
    /**
     * @description Regular expression to find only 'zero width space' (/^\u200B+$/)
     */
    onlyZeroWidthRegExp: new RegExp("^" + String.fromCharCode(8203) + "+$"),
    fontValueMap: {
      "xx-small": 1,
      "x-small": 2,
      "small": 3,
      "medium": 4,
      "large": 5,
      "x-large": 6,
      "xx-large": 7
    },
    /**
     * @description A method that checks If the text is blank or to see if it contains 'ZERO WIDTH SPACE' or empty (util.zeroWidthSpace)
     * @param {String|Node} text String value or Node
     * @returns {Boolean}
     */
    onlyZeroWidthSpace: function(text) {
      if (text === null || text === void 0) return false;
      if (typeof text !== "string") text = text.textContent;
      return text === "" || this.onlyZeroWidthRegExp.test(text);
    },
    /**
     * @description Gets XMLHttpRequest object
     * @returns {XMLHttpRequest|ActiveXObject}
     */
    getXMLHttpRequest: function() {
      if (this._w.ActiveXObject) {
        try {
          return new ActiveXObject("Msxml2.XMLHTTP");
        } catch (e) {
          try {
            return new ActiveXObject("Microsoft.XMLHTTP");
          } catch (e1) {
            return null;
          }
        }
      } else if (this._w.XMLHttpRequest) {
        return new XMLHttpRequest();
      } else {
        return null;
      }
    },
    /**
     * @description Object.values
     * @param {Object|null} obj Object parameter.
     * @returns {Array}
     */
    getValues: function(obj) {
      return !obj ? [] : this._w.Object.keys(obj).map(function(i) {
        return obj[i];
      });
    },
    /**
     * @description Convert the CamelCase To the KebabCase.
     * @param {String|Array} param [Camel string]
     * @returns {String|Array}
     */
    camelToKebabCase: function(param) {
      if (typeof param === "string") {
        return param.replace(/[A-Z]/g, function(letter) {
          return "-" + letter.toLowerCase();
        });
      } else {
        return param.map(function(str) {
          return util.camelToKebabCase(str);
        });
      }
    },
    /**
     * @description Convert the KebabCase To the CamelCase.
     * @param {String|Array} param [KebabCase string]
     * @returns {String|Array}
     */
    kebabToCamelCase: function(param) {
      if (typeof param === "string") {
        return param.replace(/-[a-zA-Z]/g, function(letter) {
          return letter.replace("-", "").toUpperCase();
        });
      } else {
        return param.map(function(str) {
          return util.camelToKebabCase(str);
        });
      }
    },
    /**
     * @description Create Element node
     * @param {String} elementName Element name
     * @returns {Element}
     */
    createElement: function(elementName) {
      return this._d.createElement(elementName);
    },
    /**
     * @description Create text node
     * @param {String} text text contents
     * @returns {Node}
     */
    createTextNode: function(text) {
      return this._d.createTextNode(text || "");
    },
    /**
     * @description The editor checks tags by string.
     * If there is "<" or ">" in the attribute of tag, HTML is broken when checking the tag.
     * When using an attribute with "<" or ">", use "HTMLEncoder" to save. (ex: math(katex))
     * @param {String} contents HTML or Text string
     * @returns {String}
     */
    HTMLEncoder: function(contents) {
      const ec = { "<": "$lt;", ">": "$gt;" };
      return contents.replace(/<|>/g, function(m) {
        return typeof ec[m] === "string" ? ec[m] : m;
      });
    },
    /**
     * @description The editor checks tags by string.
     * If there is "<" or ">" in the attribute of tag, HTML is broken when checking the tag.
     * Decoder of data stored as "HTMLEncoder" (ex: math(katex))
     * @param {String} contents HTML or Text string
     * @returns {String}
     */
    HTMLDecoder: function(contents) {
      const ec = { "$lt;": "<", "$gt;": ">" };
      return contents.replace(/\$lt;|\$gt;/g, function(m) {
        return typeof ec[m] === "string" ? ec[m] : m;
      });
    },
    /**
     * @description This method run Object.prototype.hasOwnProperty.call(obj, key)
     * @param {Object} obj Object
     * @param {String} key obj.key
     * @returns {Boolean}
     */
    hasOwn: function(obj, key) {
      return this._hasOwn.call(obj, key);
    },
    _hasOwn: Object.prototype.hasOwnProperty,
    /**
     * @deprecated
     * @description Get the the tag path of the arguments value
     * If not found, return the first found value
     * @param {Array} nameArray File name array
     * @param {String} extension js, css
     * @returns {String}
     */
    getIncludePath: function(nameArray, extension) {
      let path = "";
      const pathList = [];
      const tagName = extension === "js" ? "script" : "link";
      const src = extension === "js" ? "src" : "href";
      let fileName = "(?:";
      for (let i = 0, len = nameArray.length; i < len; i++) {
        fileName += nameArray[i] + (i < len - 1 ? "|" : ")");
      }
      const regExp = new this._w.RegExp("(^|.*[\\/])" + fileName + "(\\.[^\\/]+)?." + extension + "(?:\\?.*|;.*)?$", "i");
      const extRegExp = new this._w.RegExp(".+\\." + extension + "(?:\\?.*|;.*)?$", "i");
      for (let c = this._d.getElementsByTagName(tagName), i = 0; i < c.length; i++) {
        if (extRegExp.test(c[i][src])) {
          pathList.push(c[i]);
        }
      }
      for (let i = 0; i < pathList.length; i++) {
        let editorTag = pathList[i][src].match(regExp);
        if (editorTag) {
          path = editorTag[0];
          break;
        }
      }
      if (path === "") path = pathList.length > 0 ? pathList[0][src] : "";
      -1 === path.indexOf(":/") && "//" !== path.slice(0, 2) && (path = 0 === path.indexOf("/") ? location.href.match(/^.*?:\/\/[^\/]*/)[0] + path : location.href.match(/^[^\?]*\/(?:)/)[0] + path);
      if (!path) throw "[SUNEDITOR.util.getIncludePath.fail] The SUNEDITOR installation path could not be automatically detected. (name: +" + name + ", extension: " + extension + ")";
      return path;
    },
    /**
     * @deprecated
     * @description Returns the CSS text that has been applied to the current page.
     * @param {Document|null} doc To get the CSS text of an document(core._wd). If null get the current document.
     * @returns {String} Styles string
     */
    getPageStyle: function(doc) {
      let cssText = "";
      const sheets = (doc || this._d).styleSheets;
      for (let i = 0, len = sheets.length, rules; i < len; i++) {
        try {
          rules = sheets[i].cssRules;
        } catch (e) {
          continue;
        }
        if (rules) {
          for (let c = 0, cLen = rules.length; c < cLen; c++) {
            cssText += rules[c].cssText;
          }
        }
      }
      return cssText;
    },
    /**
     * @description Get the argument iframe's document object
     * @param {Element} iframe Iframe element (context.element.wysiwygFrame)
     * @returns {Document}
     */
    getIframeDocument: function(iframe) {
      let wDocument = iframe.contentWindow || iframe.contentDocument;
      if (wDocument.document) wDocument = wDocument.document;
      return wDocument;
    },
    /**
     * @description Get attributes of argument element to string ('class="---" name="---" ')
     * @param {Element} element Element object
     * @param {Array|null} exceptAttrs Array of attribute names to exclude from the result
     * @returns {String}
     */
    getAttributesToString: function(element, exceptAttrs) {
      if (!element.attributes) return "";
      const attrs = element.attributes;
      let attrString = "";
      for (let i = 0, len = attrs.length; i < len; i++) {
        if (exceptAttrs && exceptAttrs.indexOf(attrs[i].name) > -1) continue;
        attrString += attrs[i].name + '="' + attrs[i].value + '" ';
      }
      return attrString;
    },
    /**
     * @descriptionGets Get the length in bytes of a string.
     * referencing code: "https://github.com/shaan1974/myrdin/blob/master/expressions/string.js#L11"
     * @param {String} text String text
     * @returns {Number}
     */
    getByteLength: function(text) {
      if (!text || !text.toString) return 0;
      text = text.toString();
      const encoder = this._w.encodeURIComponent;
      let cr, cl;
      if (this.isIE_Edge) {
        cl = this._w.unescape(encoder(text)).length;
        cr = 0;
        if (encoder(text).match(/(%0A|%0D)/gi) !== null) {
          cr = encoder(text).match(/(%0A|%0D)/gi).length;
        }
        return cl + cr;
      } else {
        cl = new this._w.TextEncoder("utf-8").encode(text).length;
        cr = 0;
        if (encoder(text).match(/(%0A|%0D)/gi) !== null) {
          cr = encoder(text).match(/(%0A|%0D)/gi).length;
        }
        return cl + cr;
      }
    },
    /**
     * @description It is judged whether it is the edit region top div element or iframe's body tag.
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isWysiwygDiv: function(element) {
      return element && element.nodeType === 1 && (this.hasClass(element, "se-wrapper-wysiwyg") || /^BODY$/i.test(element.nodeName));
    },
    /**
     * @description It is judged whether it is the contenteditable property is false.
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isNonEditable: function(element) {
      return element && element.nodeType === 1 && element.getAttribute("contenteditable") === "false";
    },
    /**
     * @description It is judged whether it is a node related to the text style.
     * (strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code)
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isTextStyleElement: function(element) {
      return element && element.nodeType !== 3 && /^(strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)$/i.test(element.nodeName);
    },
    /**
     * @description It is judged whether it is the input element (INPUT, TEXTAREA)
     * @param {Node} element The node to check
     * @returns 
     */
    isInputElement: function(element) {
      return element && element.nodeType === 1 && /^(INPUT|TEXTAREA)$/i.test(element.nodeName);
    },
    /**
     * @description It is judged whether it is the format element (P, DIV, H[1-6], PRE, LI | class="__se__format__replace_xxx")
     * Format element also contain "free format Element"
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isFormatElement: function(element) {
      return element && element.nodeType === 1 && (/^(P|DIV|H[1-6]|PRE|LI|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, "(\\s|^)__se__format__replace_.+(\\s|$)|(\\s|^)__se__format__free_.+(\\s|$)")) && !this.isComponent(element) && !this.isWysiwygDiv(element);
    },
    /**
     * @description It is judged whether it is the range format element. (BLOCKQUOTE, OL, UL, FIGCAPTION, TABLE, THEAD, TBODY, TR, TH, TD | class="__se__format__range_xxx")
     * Range format element is wrap the "format element" and "component"
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isRangeFormatElement: function(element) {
      return element && element.nodeType === 1 && (/^(BLOCKQUOTE|OL|UL|FIGCAPTION|TABLE|THEAD|TBODY|TR|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, "(\\s|^)__se__format__range_.+(\\s|$)"));
    },
    /**
     * @description It is judged whether it is the closure range format element. (TH, TD | class="__se__format__range__closure_xxx")
     * Closure range format elements is included in the range format element.
     *  - Closure range format element is wrap the "format element" and "component"
     * ※ You cannot exit this format with the Enter key or Backspace key.
     * ※ Use it only in special cases. ([ex] format of table cells)
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isClosureRangeFormatElement: function(element) {
      return element && element.nodeType === 1 && (/^(TH|TD)$/i.test(element.nodeName) || this.hasClass(element, "(\\s|^)__se__format__range__closure_.+(\\s|$)"));
    },
    /**
     * @description It is judged whether it is the free format element. (PRE | class="__se__format__free_xxx")
     * Free format elements is included in the format element.
     * Free format elements's line break is "BR" tag.
     * ※ Entering the Enter key in the space on the last line ends "Free Format" and appends "Format".
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isFreeFormatElement: function(element) {
      return element && element.nodeType === 1 && (/^PRE$/i.test(element.nodeName) || this.hasClass(element, "(\\s|^)__se__format__free_.+(\\s|$)")) && !this.isComponent(element) && !this.isWysiwygDiv(element);
    },
    /**
     * @description It is judged whether it is the closure free format element. (class="__se__format__free__closure_xxx")
     * Closure free format elements is included in the free format element.
     *  - Closure free format elements's line break is "BR" tag.
     * ※ You cannot exit this format with the Enter key or Backspace key.
     * ※ Use it only in special cases. ([ex] format of table cells)
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isClosureFreeFormatElement: function(element) {
      return element && element.nodeType === 1 && this.hasClass(element, "(\\s|^)__se__format__free__closure_.+(\\s|$)");
    },
    /**
     * @description It is judged whether it is the component[img, iframe, video, audio, table] cover(class="se-component") and table, hr
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isComponent: function(element) {
      return element && (/se-component/.test(element.className) || /^(TABLE|HR)$/.test(element.nodeName));
    },
    /**
     * @description Checks for "__se__uneditable" in the class list.
     * Components with class "__se__uneditable" cannot be modified.
     * @param {Element} element The element to check
     * @returns {Boolean}
     */
    isUneditableComponent: function(element) {
      return element && this.hasClass(element, "__se__uneditable");
    },
    /**
     * @description It is judged whether it is the component [img, iframe] cover(class="se-component")
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isMediaComponent: function(element) {
      return element && /se-component/.test(element.className);
    },
    /**
     * @description It is judged whether it is the not checking node. (class="katex", "__se__tag")
     * @param {Node} element The node to check
     * @returns {Boolean}
     */
    isNotCheckingNode: function(element) {
      return element && /katex|__se__tag/.test(element.className);
    },
    /**
     * @description If a parent node that contains an argument node finds a format node (util.isFormatElement), it returns that node.
     * @param {Node} element Reference node.
     * @param {Function|null} validation Additional validation function.
     * @returns {Element|null}
     */
    getFormatElement: function(element, validation) {
      if (!element) return null;
      if (!validation) {
        validation = function() {
          return true;
        };
      }
      while (element) {
        if (this.isWysiwygDiv(element)) return null;
        if (this.isRangeFormatElement(element)) element.firstElementChild;
        if (this.isFormatElement(element) && validation(element)) return element;
        element = element.parentNode;
      }
      return null;
    },
    /**
     * @description If a parent node that contains an argument node finds a format node (util.isRangeFormatElement), it returns that node.
     * @param {Node} element Reference node.
     * @param {Function|null} validation Additional validation function.
     * @returns {Element|null}
     */
    getRangeFormatElement: function(element, validation) {
      if (!element) return null;
      if (!validation) {
        validation = function() {
          return true;
        };
      }
      while (element) {
        if (this.isWysiwygDiv(element)) return null;
        if (this.isRangeFormatElement(element) && !/^(THEAD|TBODY|TR)$/i.test(element.nodeName) && validation(element)) return element;
        element = element.parentNode;
      }
      return null;
    },
    /**
     * @description If a parent node that contains an argument node finds a free format node (util.isFreeFormatElement), it returns that node.
     * @param {Node} element Reference node.
     * @param {Function|null} validation Additional validation function.
     * @returns {Element|null}
     */
    getFreeFormatElement: function(element, validation) {
      if (!element) return null;
      if (!validation) {
        validation = function() {
          return true;
        };
      }
      while (element) {
        if (this.isWysiwygDiv(element)) return null;
        if (this.isFreeFormatElement(element) && validation(element)) return element;
        element = element.parentNode;
      }
      return null;
    },
    /**
     * @description If a parent node that contains an argument node finds a closure free format node (util.isClosureFreeFormatElement), it returns that node.
     * @param {Node} element Reference node.
     * @param {Function|null} validation Additional validation function.
     * @returns {Element|null}
     */
    getClosureFreeFormatElement: function(element, validation) {
      if (!element) return null;
      if (!validation) {
        validation = function() {
          return true;
        };
      }
      while (element) {
        if (this.isWysiwygDiv(element)) return null;
        if (this.isClosureFreeFormatElement(element) && validation(element)) return element;
        element = element.parentNode;
      }
      return null;
    },
    /**
     * @description Add style and className of copyEl to originEl
     * @param {Element} originEl Origin element
     * @param {Element} copyEl Element to copy
     * @param {Array|null} blacklist Blacklist array(LowerCase)
     */
    copyTagAttributes: function(originEl, copyEl, blacklist) {
      if (copyEl.style.cssText) {
        const copyStyles = copyEl.style;
        for (let i = 0, len = copyStyles.length; i < len; i++) {
          originEl.style[copyStyles[i]] = copyStyles[copyStyles[i]];
        }
      }
      const attrs = copyEl.attributes;
      for (let i = 0, len = attrs.length, name2; i < len; i++) {
        name2 = attrs[i].name.toLowerCase();
        if (blacklist && blacklist.indexOf(name2) > -1 || !attrs[i].value) originEl.removeAttribute(name2);
        else if (name2 !== "style") originEl.setAttribute(attrs[i].name, attrs[i].value);
      }
    },
    /**
     * @description Copy and apply attributes of format tag that should be maintained. (style, class) Ignore "__se__format__" class
     * @param {Element} originEl Origin element
     * @param {Element} copyEl Element to copy
     */
    copyFormatAttributes: function(originEl, copyEl) {
      copyEl = copyEl.cloneNode(false);
      copyEl.className = copyEl.className.replace(/(\s|^)__se__format__[^\s]+/g, "");
      this.copyTagAttributes(originEl, copyEl);
    },
    /**
     * @description Get the item from the array that matches the condition.
     * @param {Array|HTMLCollection|NodeList} array Array to get item
     * @param {Function|null} validation Conditional function
     * @param {Boolean} multi If true, returns all items that meet the criteria otherwise, returns an empty array.
     * If false, returns only one item that meet the criteria otherwise return null.
     * @returns {Array|Node|null}
     */
    getArrayItem: function(array, validation, multi) {
      if (!array || array.length === 0) return null;
      validation = validation || function() {
        return true;
      };
      const arr = [];
      for (let i = 0, len = array.length, a; i < len; i++) {
        a = array[i];
        if (validation(a)) {
          if (!multi) return a;
          else arr.push(a);
        }
      }
      return !multi ? null : arr;
    },
    /**
     * @description Check if an array contains an element 
     * @param {Array|HTMLCollection|NodeList} array element array
     * @param {Node} element The element to check for
     * @returns {Boolean}
     */
    arrayIncludes: function(array, element) {
      for (let i = 0; i < array.length; i++) {
        if (array[i] === element) {
          return true;
        }
      }
      return false;
    },
    /**
     * @description Get the index of the argument value in the element array
     * @param {Array|HTMLCollection|NodeList} array element array
     * @param {Node} element The element to find index
     * @returns {Number}
     */
    getArrayIndex: function(array, element) {
      let idx = -1;
      for (let i = 0, len = array.length; i < len; i++) {
        if (array[i] === element) {
          idx = i;
          break;
        }
      }
      return idx;
    },
    /**
     * @description Get the next index of the argument value in the element array
     * @param {Array|HTMLCollection|NodeList} array element array
     * @param {Node} item The element to find index
     * @returns {Number}
     */
    nextIdx: function(array, item) {
      let idx = this.getArrayIndex(array, item);
      if (idx === -1) return -1;
      return idx + 1;
    },
    /**
     * @description Get the previous index of the argument value in the element array
     * @param {Array|HTMLCollection|NodeList} array Element array
     * @param {Node} item The element to find index
     * @returns {Number}
     */
    prevIdx: function(array, item) {
      let idx = this.getArrayIndex(array, item);
      if (idx === -1) return -1;
      return idx - 1;
    },
    /**
     * @description Returns the index compared to other sibling nodes.
     * @param {Node} node The Node to find index
     * @returns {Number}
     */
    getPositionIndex: function(node) {
      let idx = 0;
      while (node = node.previousSibling) {
        idx += 1;
      }
      return idx;
    },
    /**
     * @description Returns the position of the "node" in the "parentNode" in a numerical array.
     * ex) <p><span>aa</span><span>bb</span></p> : getNodePath(node: "bb", parentNode: "<P>") -> [1, 0]
     * @param {Node} node The Node to find position path
     * @param {Node|null} parentNode Parent node. If null, wysiwyg div area
     * @param {Object|null} _newOffsets If you send an object of the form "{s: 0, e: 0}", the text nodes that are attached together are merged into one, centered on the "node" argument.
     * "_newOffsets.s" stores the length of the combined characters after "node" and "_newOffsets.e" stores the length of the combined characters before "node".
     * Do not use unless absolutely necessary.
     * @returns {Array}
     */
    getNodePath: function(node, parentNode, _newOffsets) {
      const path = [];
      let finds = true;
      this.getParentElement(node, function(el) {
        if (el === parentNode) finds = false;
        if (finds && !this.isWysiwygDiv(el)) {
          if (_newOffsets && el.nodeType === 3) {
            let temp = null, tempText = null;
            _newOffsets.s = _newOffsets.e = 0;
            let previous = el.previousSibling;
            while (previous && previous.nodeType === 3) {
              tempText = previous.textContent.replace(this.zeroWidthRegExp, "");
              _newOffsets.s += tempText.length;
              el.textContent = tempText + el.textContent;
              temp = previous;
              previous = previous.previousSibling;
              this.removeItem(temp);
            }
            let next = el.nextSibling;
            while (next && next.nodeType === 3) {
              tempText = next.textContent.replace(this.zeroWidthRegExp, "");
              _newOffsets.e += tempText.length;
              el.textContent += tempText;
              temp = next;
              next = next.nextSibling;
              this.removeItem(temp);
            }
          }
          path.push(el);
        }
        return false;
      }.bind(this));
      return path.map(this.getPositionIndex).reverse();
    },
    /**
     * @description Returns the node in the location of the path array obtained from "util.getNodePath".
     * @param {Array} offsets Position array, array obtained from "util.getNodePath"
     * @param {Node} parentNode Base parent element
     * @returns {Node}
     */
    getNodeFromPath: function(offsets, parentNode) {
      let current = parentNode;
      let nodes;
      for (let i = 0, len = offsets.length; i < len; i++) {
        nodes = current.childNodes;
        if (nodes.length === 0) break;
        if (nodes.length <= offsets[i]) {
          current = nodes[nodes.length - 1];
        } else {
          current = nodes[offsets[i]];
        }
      }
      return current;
    },
    /**
     * @description Compares the style and class for equal values.
     * Returns true if both are text nodes.
     * @param {Node} a Node to compare
     * @param {Node} b Node to compare
     * @returns {Boolean}
     */
    isSameAttributes: function(a, b) {
      if (a.nodeType === 3 && b.nodeType === 3) return true;
      if (a.nodeType === 3 || b.nodeType === 3) return false;
      const style_a = a.style;
      const style_b = b.style;
      let compStyle = 0;
      for (let i = 0, len = style_a.length; i < len; i++) {
        if (style_a[style_a[i]] === style_b[style_a[i]]) compStyle++;
      }
      const class_a = a.classList;
      const class_b = b.classList;
      const reg = this._w.RegExp;
      let compClass = 0;
      for (let i = 0, len = class_a.length; i < len; i++) {
        if (reg("(s|^)" + class_a[i] + "(s|$)").test(class_b.value)) compClass++;
      }
      return compStyle === style_b.length && compStyle === style_a.length && (compClass === class_b.length && compClass === class_a.length);
    },
    /**
     * @description Check the line element(util.isFormatElement) is empty.
     * @param {Element} element Format element node
     * @returns {Boolean}
     */
    isEmptyLine: function(element) {
      return !element || !element.parentNode || !element.querySelector("IMG, IFRAME, AUDIO, VIDEO, CANVAS, TABLE") && element.children.length === 0 && this.onlyZeroWidthSpace(element.textContent);
    },
    /**
     * @description Check the span's attributes are empty.
     * @param {Element|null} element Element node
     * @returns {Boolean}
     */
    isSpanWithoutAttr: function(element) {
      return !!element && element.nodeType === 1 && /^SPAN$/i.test(element.nodeName) && !element.className && !element.style.cssText;
    },
    /**
     * @description Check the node is a list (ol, ul)
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isList: function(node) {
      return node && /^(OL|UL)$/i.test(typeof node === "string" ? node : node.nodeName);
    },
    /**
     * @description Check the node is a list cell (li)
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isListCell: function(node) {
      return node && /^LI$/i.test(typeof node === "string" ? node : node.nodeName);
    },
    /**
     * @description Check the node is a table (table, thead, tbody, tr, th, td)
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isTable: function(node) {
      return node && /^(TABLE|THEAD|TBODY|TR|TH|TD)$/i.test(typeof node === "string" ? node : node.nodeName);
    },
    /**
     * @description Check the node is a table cell (td, th)
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isCell: function(node) {
      return node && /^(TD|TH)$/i.test(typeof node === "string" ? node : node.nodeName);
    },
    /**
     * @description Check the node is a break node (BR)
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isBreak: function(node) {
      return node && /^BR$/i.test(typeof node === "string" ? node : node.nodeName);
    },
    /**
     * @description Check the node is a anchor node (A)
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isAnchor: function(node) {
      return node && /^A$/i.test(typeof node === "string" ? node : node.nodeName);
    },
    /**
     * @description Check the node is a media node (img, iframe, audio, video, canvas)
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isMedia: function(node) {
      return node && /^(IMG|IFRAME|AUDIO|VIDEO|CANVAS)$/i.test(typeof node === "string" ? node : node.nodeName);
    },
    /**
     * @description Check the node is a figure tag or util.isMedia()
     * @param {Node|String} node The element or element name to check
     * @returns {Boolean}
     */
    isFigures: function(node) {
      return node && (this.isMedia(node) || /^(FIGURE)$/i.test(typeof node === "string" ? node : node.nodeName));
    },
    /**
     * @description Checks for numeric (with decimal point).
     * @param {String|Number} text Text string or number
     * @returns {Boolean}
     */
    isNumber: function(text) {
      return !!text && /^-?\d+(\.\d+)?$/.test(text + "");
    },
    /**
     * @description Get a number.
     * @param {String|Number} text Text string or number
     * @param {Number} maxDec Maximum number of decimal places (-1 : Infinity)
     * @returns {Number}
     */
    getNumber: function(text, maxDec) {
      if (!text) return 0;
      let number = (text + "").match(/-?\d+(\.\d+)?/);
      if (!number || !number[0]) return 0;
      number = number[0];
      return maxDec < 0 ? number * 1 : maxDec === 0 ? this._w.Math.round(number * 1) : (number * 1).toFixed(maxDec) * 1;
    },
    /**
     * @description Get all "children" of the argument value element (Without text nodes)
     * @param {Element} element element to get child node
     * @param {Function|null} validation Conditional function
     * @returns {Array}
     */
    getListChildren: function(element, validation) {
      const children2 = [];
      if (!element || !element.children || element.children.length === 0) return children2;
      validation = validation || function() {
        return true;
      };
      (function recursionFunc(current) {
        if (element !== current && validation(current)) {
          children2.push(current);
        }
        if (!!current.children) {
          for (let i = 0, len = current.children.length; i < len; i++) {
            recursionFunc(current.children[i]);
          }
        }
      })(element);
      return children2;
    },
    /**
     * @description Get all "childNodes" of the argument value element (Include text nodes)
     * @param {Node} element element to get child node
     * @param {Function|null} validation Conditional function
     * @returns {Array}
     */
    getListChildNodes: function(element, validation) {
      const children2 = [];
      if (!element || element.childNodes.length === 0) return children2;
      validation = validation || function() {
        return true;
      };
      (function recursionFunc(current) {
        if (element !== current && validation(current)) {
          children2.push(current);
        }
        for (let i = 0, len = current.childNodes.length; i < len; i++) {
          recursionFunc(current.childNodes[i]);
        }
      })(element);
      return children2;
    },
    /**
     * @description Returns the number of parents nodes.
     * "0" when the parent node is the WYSIWYG area.
     * "-1" when the element argument is the WYSIWYG area.
     * @param {Node} element The element to check
     * @returns {Number}
     */
    getElementDepth: function(element) {
      if (!element || this.isWysiwygDiv(element)) return -1;
      let depth = 0;
      element = element.parentNode;
      while (element && !this.isWysiwygDiv(element)) {
        depth += 1;
        element = element.parentNode;
      }
      return depth;
    },
    /**
     * @description Compares two elements to find a common ancestor, and returns the order of the two elements.
     * @param {Node} a Node to compare.
     * @param {Node} b Node to compare.
     * @returns {Object} { ancesstor, a, b, result: (a > b ? 1 : a < b ? -1 : 0) };
     */
    compareElements: function(a, b) {
      let aNode = a, bNode = b;
      while (aNode && bNode && aNode.parentNode !== bNode.parentNode) {
        aNode = aNode.parentNode;
        bNode = bNode.parentNode;
      }
      if (!aNode || !bNode) return { ancestor: null, a, b, result: 0 };
      const children2 = aNode.parentNode.childNodes;
      const aIndex = this.getArrayIndex(children2, aNode);
      const bIndex = this.getArrayIndex(children2, bNode);
      return {
        ancestor: aNode.parentNode,
        a: aNode,
        b: bNode,
        result: aIndex > bIndex ? 1 : aIndex < bIndex ? -1 : 0
      };
    },
    /**
     * @description Get the parent element of the argument value.
     * A tag that satisfies the query condition is imported.
     * Returns null if not found.
     * @param {Node} element Reference element
     * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.
     * Not use it like jquery.
     * Only one condition can be entered at a time.
     * @returns {Element|null}
     */
    getParentElement: function(element, query) {
      let check;
      if (typeof query === "function") {
        check = query;
      } else {
        let attr;
        if (/^\./.test(query)) {
          attr = "className";
          query = query.split(".")[1];
        } else if (/^#/.test(query)) {
          attr = "id";
          query = "^" + query.split("#")[1] + "$";
        } else if (/^:/.test(query)) {
          attr = "name";
          query = "^" + query.split(":")[1] + "$";
        } else {
          attr = "nodeName";
          query = "^" + query + "$";
        }
        const regExp = new this._w.RegExp(query, "i");
        check = function(el) {
          return regExp.test(el[attr]);
        };
      }
      while (element && !check(element)) {
        if (this.isWysiwygDiv(element)) {
          return null;
        }
        element = element.parentNode;
      }
      return element;
    },
    /**
     * @description Gets the previous sibling last child. If there is no sibling, then it'll take it from the closest ancestor with child
     * Returns null if not found.
     * @param {Node} node Reference element
     * @param {Node|null} ceiling Highest boundary allowed
     * @returns {Node|null}
     */
    getPreviousDeepestNode: function(node, ceiling) {
      let previousNode = node.previousSibling;
      if (!previousNode) {
        for (let parentNode = node.parentNode; parentNode; parentNode = parentNode.parentNode) {
          if (parentNode === ceiling) return null;
          if (parentNode.previousSibling) {
            previousNode = parentNode.previousSibling;
            break;
          }
        }
        if (!previousNode) return null;
      }
      while (previousNode.lastChild) previousNode = previousNode.lastChild;
      return previousNode;
    },
    /**
     * @description Gets the next sibling first child. If there is no sibling, then it'll take it from the closest ancestor with child
     * Returns null if not found.
     * @param {Node} node Reference element
     * @param {Node|null} ceiling Highest boundary allowed
     * @returns {Node|null}
     */
    getNextDeepestNode: function(node, ceiling) {
      let nextNode = node.nextSibling;
      if (!nextNode) {
        for (let parentNode = node.parentNode; parentNode; parentNode = parentNode.parentNode) {
          if (parentNode === ceiling) return null;
          if (parentNode.nextSibling) {
            nextNode = parentNode.nextSibling;
            break;
          }
        }
        if (!nextNode) return null;
      }
      while (nextNode.firstChild) nextNode = nextNode.firstChild;
      return nextNode;
    },
    /**
     * @description Get the child element of the argument value.
     * A tag that satisfies the query condition is imported.
     * Returns null if not found.
     * @param {Node} element Reference element
     * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.
     * @param {Boolean} last If true returns the last node among the found child nodes. (default: first node)
     * Not use it like jquery.
     * Only one condition can be entered at a time.
     * @returns {Element|null}
     */
    getChildElement: function(element, query, last) {
      let check;
      if (typeof query === "function") {
        check = query;
      } else {
        let attr;
        if (/^\./.test(query)) {
          attr = "className";
          query = query.split(".")[1];
        } else if (/^#/.test(query)) {
          attr = "id";
          query = "^" + query.split("#")[1] + "$";
        } else if (/^:/.test(query)) {
          attr = "name";
          query = "^" + query.split(":")[1] + "$";
        } else {
          attr = "nodeName";
          query = "^" + (query === "text" ? "#" + query : query) + "$";
        }
        const regExp = new this._w.RegExp(query, "i");
        check = function(el) {
          return regExp.test(el[attr]);
        };
      }
      const childList = this.getListChildNodes(element, function(current) {
        return check(current);
      });
      return childList[last ? childList.length - 1 : 0];
    },
    /**
     * @description 1. The first node of all the child nodes of the "first" element is returned.
     * 2. The last node of all the child nodes of the "last" element is returned.
     * 3. When there is no "last" element, the first and last nodes of all the children of the "first" element are returned.
     * { sc: "first", ec: "last" }
     * @param {Node} first First element
     * @param {Node|null} last Last element
     * @returns {Object}
     */
    getEdgeChildNodes: function(first, last) {
      if (!first) return;
      if (!last) last = first;
      while (first && first.nodeType === 1 && first.childNodes.length > 0 && !this.isBreak(first)) first = first.firstChild;
      while (last && last.nodeType === 1 && last.childNodes.length > 0 && !this.isBreak(last)) last = last.lastChild;
      return {
        sc: first,
        ec: last || first
      };
    },
    /**
     * @description Returns the position of the left and top of argument. {left:0, top:0}
     * @param {Node} element Target node
     * @param {Element|null} wysiwygFrame When use iframe option, iframe object should be sent (context.element.wysiwygFrame)
     * @returns {Object}
     */
    getOffset: function(element, wysiwygFrame) {
      let offsetLeft = 0;
      let offsetTop = 0;
      let offsetElement = element.nodeType === 3 ? element.parentElement : element;
      const wysiwyg = this.getParentElement(element, this.isWysiwygDiv.bind(this));
      while (offsetElement && !this.hasClass(offsetElement, "se-container") && offsetElement !== wysiwyg) {
        offsetLeft += offsetElement.offsetLeft;
        offsetTop += offsetElement.offsetTop;
        offsetElement = offsetElement.offsetParent;
      }
      const iframe = wysiwygFrame && /iframe/i.test(wysiwygFrame.nodeName);
      return {
        left: offsetLeft + (iframe ? wysiwygFrame.parentElement.offsetLeft : 0),
        top: offsetTop - (wysiwyg ? wysiwyg.scrollTop : 0) + (iframe ? wysiwygFrame.parentElement.offsetTop : 0)
      };
    },
    /**
     * @description It compares the start and end indexes of "a" and "b" and returns the number of overlapping indexes in the range.
     * ex) 1, 5, 4, 6 => "2" (4 ~ 5)
     * @param {Number} aStart Start index of "a"
     * @param {Number} aEnd End index of "a"
     * @param {Number} bStart Start index of "b"
     * @param {Number} bEnd Start index of "b"
     * @returns {Number}
     */
    getOverlapRangeAtIndex: function(aStart, aEnd, bStart, bEnd) {
      if (aStart <= bEnd ? aEnd < bStart : aEnd > bStart) return 0;
      const overlap = (aStart > bStart ? aStart : bStart) - (aEnd < bEnd ? aEnd : bEnd);
      return (overlap < 0 ? overlap * -1 : overlap) + 1;
    },
    /**
     * @description Set the text content value of the argument value element
     * @param {Node} element Element to replace text content
     * @param {String} txt Text to be applied
     */
    changeTxt: function(element, txt) {
      if (!element || !txt) return;
      element.textContent = txt;
    },
    /**
     * @description Replace element
     * @param {Element} element Target element
     * @param {String|Element} newElement String or element of the new element to apply
     */
    changeElement: function(element, newElement) {
      if (typeof newElement === "string") {
        if (element.outerHTML) {
          element.outerHTML = newElement;
        } else {
          const doc = this.createElement("DIV");
          doc.innerHTML = newElement;
          newElement = doc.firstChild;
          element.parentNode.replaceChild(newElement, element);
        }
      } else if (newElement.nodeType === 1) {
        element.parentNode.replaceChild(newElement, element);
      }
    },
    /**
     * @description Set style, if all styles are deleted, the style properties are deleted.
     * @param {Element} element Element to set style
     * @param {String} styleName Style attribute name (marginLeft, textAlign...)
     * @param {String|Number} value Style value
     */
    setStyle: function(element, styleName, value) {
      element.style[styleName] = value;
      if (!value && !element.style.cssText) {
        element.removeAttribute("style");
      }
    },
    /**
     * @description Determine whether any of the matched elements are assigned the given class
     * @param {Element} element Elements to search class name
     * @param {String} className Class name to search for
     * @returns {Boolean}
     */
    hasClass: function(element, className) {
      if (!element) return;
      return new this._w.RegExp(className).test(element.className);
    },
    /**
     * @description Append the className value of the argument value element
     * @param {Element} element Elements to add class name
     * @param {String} className Class name to be add
     */
    addClass: function(element, className) {
      if (!element) return;
      const check = new this._w.RegExp("(\\s|^)" + className + "(\\s|$)");
      if (check.test(element.className)) return;
      element.className += (element.className.length > 0 ? " " : "") + className;
    },
    /**
     * @description Delete the className value of the argument value element
     * @param {Element} element Elements to remove class name
     * @param {String} className Class name to be remove
     */
    removeClass: function(element, className) {
      if (!element) return;
      const check = new this._w.RegExp("(\\s|^)" + className + "(\\s|$)");
      element.className = element.className.replace(check, " ").trim();
      if (!element.className.trim()) element.removeAttribute("class");
    },
    /**
     * @description Argument value If there is no class name, insert it and delete the class name if it exists
     * @param {Element} element Elements to replace class name
     * @param {String} className Class name to be change
     * @returns {Boolean|undefined}
     */
    toggleClass: function(element, className) {
      if (!element) return;
      let result = false;
      const check = new this._w.RegExp("(\\s|^)" + className + "(\\s|$)");
      if (check.test(element.className)) {
        element.className = element.className.replace(check, " ").trim();
      } else {
        element.className += " " + className;
        result = true;
      }
      if (!element.className.trim()) element.removeAttribute("class");
      return result;
    },
    /**
     * @description Checks if element can't be easily enabled
     * @param {Element} element Element to check for
     */
    isImportantDisabled: function(element) {
      return element.hasAttribute("data-important-disabled");
    },
    /**
     * @description In the predefined code view mode, the buttons except the executable button are changed to the 'disabled' state.
     * core.codeViewDisabledButtons (An array of buttons whose class name is not "se-code-view-enabled")
     * core.resizingDisabledButtons (An array of buttons whose class name is not "se-resizing-enabled")
     * @param {Boolean} disabled Disabled value
     * @param {Array|HTMLCollection|NodeList} buttonList Button array
     * @param {Boolean} important If priveleged mode should be used (Necessary to switch importantDisabled buttons)
     */
    setDisabledButtons: function(disabled, buttonList, important) {
      for (let i = 0, len = buttonList.length; i < len; i++) {
        let button = buttonList[i];
        if (important || !this.isImportantDisabled(button)) button.disabled = disabled;
        if (important) {
          if (disabled) {
            button.setAttribute("data-important-disabled", "");
          } else {
            button.removeAttribute("data-important-disabled");
          }
        }
      }
    },
    /**
     * @description Delete argumenu value element
     * @param {Node} item Node to be remove
     */
    removeItem: function(item) {
      if (!item) return;
      if (typeof item.remove === "function") item.remove();
      else if (item.parentNode) item.parentNode.removeChild(item);
    },
    /**
     * @description Delete all parent nodes that match the condition.
     * Returns an {sc: previousSibling, ec: nextSibling}(the deleted node reference) or null.
     * @param {Node} item Node to be remove
     * @param {Function|null} validation Validation function. default(Deleted if it only have breakLine and blanks)
     * @param {Element|null} stopParent Stop when the parent node reaches stopParent
     * @returns {Object|null} {sc: previousSibling, ec: nextSibling}
     */
    removeItemAllParents: function(item, validation, stopParent) {
      if (!item) return null;
      let cc = null;
      if (!validation) {
        validation = function(current) {
          if (current === stopParent || this.isComponent(current)) return false;
          const text = current.textContent.trim();
          return text.length === 0 || /^(\n|\u200B)+$/.test(text);
        }.bind(this);
      }
      (function recursionFunc(element) {
        if (!util.isWysiwygDiv(element)) {
          const parent = element.parentNode;
          if (parent && validation(element)) {
            cc = {
              sc: element.previousElementSibling,
              ec: element.nextElementSibling
            };
            util.removeItem(element);
            recursionFunc(parent);
          }
        }
      })(item);
      return cc;
    },
    /**
     * @description Detach Nested all nested lists under the "baseNode".
     * Returns a list with nested removed.
     * @param {Node} baseNode Element on which to base.
     * @param {Boolean} all If true, it also detach all nested lists of a returned list.
     * @returns {Element}
     */
    detachNestedList: function(baseNode, all) {
      const rNode = this._deleteNestedList(baseNode);
      let rangeElement, cNodes;
      if (rNode) {
        rangeElement = rNode.cloneNode(false);
        cNodes = rNode.childNodes;
        const index = this.getPositionIndex(baseNode);
        while (cNodes[index]) {
          rangeElement.appendChild(cNodes[index]);
        }
      } else {
        rangeElement = baseNode;
      }
      let rChildren;
      if (!all) {
        const depth = this.getElementDepth(baseNode) + 2;
        rChildren = this.getListChildren(baseNode, function(current) {
          return this.isListCell(current) && !current.previousElementSibling && this.getElementDepth(current) === depth;
        }.bind(this));
      } else {
        rChildren = this.getListChildren(rangeElement, function(current) {
          return this.isListCell(current) && !current.previousElementSibling;
        }.bind(this));
      }
      for (let i = 0, len = rChildren.length; i < len; i++) {
        this._deleteNestedList(rChildren[i]);
      }
      if (rNode) {
        rNode.parentNode.insertBefore(rangeElement, rNode.nextSibling);
        if (cNodes && cNodes.length === 0) this.removeItem(rNode);
      }
      return rangeElement === baseNode ? rangeElement.parentNode : rangeElement;
    },
    /**
     * @description Sub function of util.detachNestedList method.
     * @private
     */
    _deleteNestedList: function(baseNode) {
      const baseParent = baseNode.parentNode;
      let sibling = baseParent;
      let parent = sibling.parentNode;
      let liSibling, liParent, child, index, c;
      while (this.isListCell(parent)) {
        index = this.getPositionIndex(baseNode);
        liSibling = parent.nextElementSibling;
        liParent = parent.parentNode;
        child = sibling;
        while (child) {
          sibling = sibling.nextSibling;
          if (this.isList(child)) {
            c = child.childNodes;
            while (c[index]) {
              liParent.insertBefore(c[index], liSibling);
            }
            if (c.length === 0) this.removeItem(child);
          } else {
            liParent.appendChild(child);
          }
          child = sibling;
        }
        sibling = liParent;
        parent = liParent.parentNode;
      }
      if (baseParent.children.length === 0) this.removeItem(baseParent);
      return liParent;
    },
    /**
     * @description Split all tags based on "baseNode"
     * Returns the last element of the splited tag.
     * @param {Node} baseNode Element or text node on which to base
     * @param {Number|Node|null} offset Text offset of "baseNode" (Only valid when "baseNode" is a text node)
     * @param {Number} depth The nesting depth of the element being split. (default: 0)
     * @returns {Element}
     */
    splitElement: function(baseNode, offset, depth) {
      if (this.isWysiwygDiv(baseNode)) return baseNode;
      if (offset && !this.isNumber(offset)) {
        const children3 = baseNode.childNodes;
        let index2 = this.getPositionIndex(offset);
        const prev = baseNode.cloneNode(false);
        const next2 = baseNode.cloneNode(false);
        for (let i = 0, len = children3.length; i < len; i++) {
          if (i < index2) prev.appendChild(children3[i]);
          else if (i > index2) next2.appendChild(children3[i]);
          else continue;
          i--;
          len--;
          index2--;
        }
        if (prev.childNodes.length > 0) baseNode.parentNode.insertBefore(prev, baseNode);
        if (next2.childNodes.length > 0) baseNode.parentNode.insertBefore(next2, baseNode.nextElementSibling);
        return baseNode;
      }
      const bp = baseNode.parentNode;
      let index = 0;
      let suffixIndex = 1;
      let next = true;
      let newEl, children2, temp;
      if (!depth || depth < 0) depth = 0;
      if (baseNode.nodeType === 3) {
        index = this.getPositionIndex(baseNode);
        if (offset >= 0 && baseNode.length !== offset) {
          baseNode.splitText(offset);
          const after = this.getNodeFromPath([index + 1], bp);
          if (this.onlyZeroWidthSpace(after)) after.data = this.zeroWidthSpace;
        }
      } else if (baseNode.nodeType === 1) {
        if (offset === 0) {
          while (baseNode.firstChild) {
            baseNode = baseNode.firstChild;
          }
          if (baseNode.nodeType === 3) {
            const after = this.createTextNode(this.zeroWidthSpace);
            baseNode.parentNode.insertBefore(after, baseNode);
            baseNode = after;
          }
        }
        if (!baseNode.previousSibling) {
          if (this.getElementDepth(baseNode) === depth) next = false;
        } else {
          baseNode = baseNode.previousSibling;
        }
      }
      if (baseNode.nodeType === 1) suffixIndex = 0;
      let depthEl = baseNode;
      while (this.getElementDepth(depthEl) > depth) {
        index = this.getPositionIndex(depthEl) + suffixIndex;
        depthEl = depthEl.parentNode;
        temp = newEl;
        newEl = depthEl.cloneNode(false);
        children2 = depthEl.childNodes;
        if (temp) {
          if (this.isListCell(newEl) && this.isList(temp) && temp.firstElementChild) {
            newEl.innerHTML = temp.firstElementChild.innerHTML;
            util.removeItem(temp.firstElementChild);
            if (temp.children.length > 0) newEl.appendChild(temp);
          } else {
            newEl.appendChild(temp);
          }
        }
        while (children2[index]) {
          newEl.appendChild(children2[index]);
        }
      }
      if (depthEl.childNodes.length <= 1 && (!depthEl.firstChild || depthEl.firstChild.textContent.length === 0)) depthEl.innerHTML = "<br>";
      const pElement = depthEl.parentNode;
      if (next) depthEl = depthEl.nextSibling;
      if (!newEl) return depthEl;
      this.mergeSameTags(newEl, null, false);
      this.mergeNestedTags(newEl, function(current) {
        return this.isList(current);
      }.bind(this));
      if (newEl.childNodes.length > 0) pElement.insertBefore(newEl, depthEl);
      else newEl = depthEl;
      if (this.isListCell(newEl) && newEl.children && this.isList(newEl.children[0])) {
        newEl.insertBefore(this.createElement("BR"), newEl.children[0]);
      }
      if (bp.childNodes.length === 0) this.removeItem(bp);
      return newEl;
    },
    /**
     * @description Use with "npdePath (util.getNodePath)" to merge the same attributes and tags if they are present and modify the nodepath.
     * If "offset" has been changed, it will return as much "offset" as it has been modified.
     * An array containing change offsets is returned in the order of the "nodePathArray" array.
     * @param {Element} element Element
     * @param {Array|null} nodePathArray Array of NodePath object ([util.getNodePath(), ..])
     * @param {Boolean} onlyText If true, non-text nodes(!util._isIgnoreNodeChange) like 'span', 'strong'.. are ignored.
     * @returns {Array} [offset, ..]
     */
    mergeSameTags: function(element, nodePathArray, onlyText) {
      const inst = this;
      const nodePathLen = nodePathArray ? nodePathArray.length : 0;
      let offsets = null;
      if (nodePathLen) {
        offsets = this._w.Array.apply(null, new this._w.Array(nodePathLen)).map(this._w.Number.prototype.valueOf, 0);
      }
      (function recursionFunc(current, depth, depthIndex) {
        const children2 = current.childNodes;
        for (let i = 0, len = children2.length, child, next; i < len; i++) {
          child = children2[i];
          next = children2[i + 1];
          if (!child) break;
          if (onlyText && inst._isIgnoreNodeChange(child) || !onlyText && (inst.isTable(child) || inst.isListCell(child) || inst.isFormatElement(child) && !inst.isFreeFormatElement(child))) {
            if (inst.isTable(child) || inst.isListCell(child)) {
              recursionFunc(child, depth + 1, i);
            }
            continue;
          }
          if (len === 1 && current.nodeName === child.nodeName && current.parentNode) {
            if (nodePathLen) {
              let path, c, p, cDepth, spliceDepth;
              for (let n = 0; n < nodePathLen; n++) {
                path = nodePathArray[n];
                if (path && path[depth] === i) {
                  c = child, p = current, cDepth = depth, spliceDepth = true;
                  while (cDepth >= 0) {
                    if (inst.getArrayIndex(p.childNodes, c) !== path[cDepth]) {
                      spliceDepth = false;
                      break;
                    }
                    c = child.parentNode;
                    p = c.parentNode;
                    cDepth--;
                  }
                  if (spliceDepth) {
                    path.splice(depth, 1);
                    path[depth] = i;
                  }
                }
              }
            }
            inst.copyTagAttributes(child, current);
            current.parentNode.insertBefore(child, current);
            inst.removeItem(current);
          }
          if (!next) {
            if (child.nodeType === 1) recursionFunc(child, depth + 1, i);
            break;
          }
          if (child.nodeName === next.nodeName && inst.isSameAttributes(child, next) && child.href === next.href) {
            const childs = child.childNodes;
            let childLength = 0;
            for (let n = 0, nLen = childs.length; n < nLen; n++) {
              if (childs[n].textContent.length > 0) childLength++;
            }
            const l = child.lastChild;
            const r = next.firstChild;
            let addOffset = 0;
            if (l && r) {
              const textOffset = l.nodeType === 3 && r.nodeType === 3;
              addOffset = l.textContent.length;
              let tempL = l.previousSibling;
              while (tempL && tempL.nodeType === 3) {
                addOffset += tempL.textContent.length;
                tempL = tempL.previousSibling;
              }
              if (childLength > 0 && l.nodeType === 3 && r.nodeType === 3 && (l.textContent.length > 0 || r.textContent.length > 0)) childLength--;
              if (nodePathLen) {
                let path = null;
                for (let n = 0; n < nodePathLen; n++) {
                  path = nodePathArray[n];
                  if (path && path[depth] > i) {
                    if (depth > 0 && path[depth - 1] !== depthIndex) continue;
                    path[depth] -= 1;
                    if (path[depth + 1] >= 0 && path[depth] === i) {
                      path[depth + 1] += childLength;
                      if (textOffset) {
                        if (l && l.nodeType === 3 && r && r.nodeType === 3) {
                          offsets[n] += addOffset;
                        }
                      }
                    }
                  }
                }
              }
            }
            if (child.nodeType === 3) {
              addOffset = child.textContent.length;
              child.textContent += next.textContent;
              if (nodePathLen) {
                let path = null;
                for (let n = 0; n < nodePathLen; n++) {
                  path = nodePathArray[n];
                  if (path && path[depth] > i) {
                    if (depth > 0 && path[depth - 1] !== depthIndex) continue;
                    path[depth] -= 1;
                    if (path[depth + 1] >= 0 && path[depth] === i) {
                      path[depth + 1] += childLength;
                      offsets[n] += addOffset;
                    }
                  }
                }
              }
            } else {
              child.innerHTML += next.innerHTML;
            }
            inst.removeItem(next);
            i--;
          } else if (child.nodeType === 1) {
            recursionFunc(child, depth + 1, i);
          }
        }
      })(element, 0, 0);
      return offsets;
    },
    /**
     * @description Remove nested tags without other child nodes.
     * @param {Element} element Element object
     * @param {Function|String|null} validation Validation function / String("tag1|tag2..") / If null, all tags are applicable.
     */
    mergeNestedTags: function(element, validation) {
      if (typeof validation === "string") {
        validation = function(current) {
          return this.test(current.tagName);
        }.bind(new this._w.RegExp("^(" + (validation ? validation : ".+") + ")$", "i"));
      } else if (typeof validation !== "function") {
        validation = function() {
          return true;
        };
      }
      (function recursionFunc(current) {
        let children2 = current.children;
        if (children2.length === 1 && children2[0].nodeName === current.nodeName && validation(current)) {
          const temp = children2[0];
          children2 = temp.children;
          while (children2[0]) {
            current.appendChild(children2[0]);
          }
          current.removeChild(temp);
        }
        for (let i = 0, len = current.children.length; i < len; i++) {
          recursionFunc(current.children[i]);
        }
      })(element);
    },
    /**
     * @description Delete a empty child node of argument element.
     * @param {Element} element Element node
     * @param {Node|null} notRemoveNode Do not remove node
     * @param {boolean} forceDelete When all child nodes are deleted, the parent node is also deleted.
     */
    removeEmptyNode: function(element, notRemoveNode, forceDelete) {
      const inst = this;
      if (notRemoveNode) {
        notRemoveNode = inst.getParentElement(notRemoveNode, function(current) {
          return element === current.parentElement;
        });
      }
      (function recursionFunc(current) {
        if (inst._notTextNode(current) || current === notRemoveNode || inst.isNonEditable(current)) return 0;
        if (current !== element && inst.onlyZeroWidthSpace(current.textContent) && (!current.firstChild || !inst.isBreak(current.firstChild)) && !current.querySelector(inst._allowedEmptyNodeList)) {
          if (current.parentNode) {
            current.parentNode.removeChild(current);
            return -1;
          }
        } else {
          const children2 = current.children;
          for (let i = 0, len = children2.length, r = 0; i < len; i++) {
            if (!children2[i + r] || inst.isComponent(children2[i + r])) continue;
            r += recursionFunc(children2[i + r]);
          }
        }
        return 0;
      })(element);
      if (element.childNodes.length === 0) {
        if (forceDelete) {
          this.removeItem(element);
        } else {
          element.innerHTML = "<br>";
        }
      }
    },
    /**
     * @description Remove whitespace between tags in HTML string.
     * @param {String} html HTML string
     * @returns {String}
     */
    htmlRemoveWhiteSpace: function(html2) {
      if (!html2) return "";
      return html2.trim().replace(/<\/?(?!strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)[^>^<]+>\s+(?=<)/ig, function(m) {
        return m.replace(/\n/g, "").replace(/\s+/, " ");
      });
    },
    /**
     * @description HTML code compression
     * @param {string} html HTML string
     * @returns {string} HTML string
     */
    htmlCompress: function(html2) {
      return html2.replace(/\n/g, "").replace(/(>)(?:\s+)(<)/g, "$1$2");
    },
    /**
     * @description Sort a element array by depth of element.
     * @param {Array} array Array object
     * @param {Boolean} des true: descending order / false: ascending order
     */
    sortByDepth: function(array, des) {
      const t = !des ? -1 : 1;
      const f = t * -1;
      array.sort(function(a, b) {
        if (!this.isListCell(a) || !this.isListCell(b)) return 0;
        a = this.getElementDepth(a);
        b = this.getElementDepth(b);
        return a > b ? t : a < b ? f : 0;
      }.bind(this));
    },
    /**
     * @description Escape a string for safe use in regular expressions.
     * @param {String} string String to escape
     * @returns {String}
     */
    escapeStringRegexp: function(string) {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    },
    _isExcludeSelectionElement: function(element) {
      return !/FIGCAPTION/i.test(element.nodeName) && (this.isComponent(element) || /FIGURE/i.test(element.nodeName));
    },
    /**
     * @description Nodes that need to be added without modification when changing text nodes
     * @param {Node} element Element to check
     * @returns {Boolean}
     * @private
     */
    _isIgnoreNodeChange: function(element) {
      return element && element.nodeType !== 3 && (this.isNonEditable(element) || !this.isTextStyleElement(element));
    },
    /**
     * @description Nodes that must remain undetached when changing text nodes (A, Label, Code, Span:font-size)
     * @param {Node|String} element Element to check
     * @returns {Boolean}
     * @private
     */
    _isMaintainedNode: function(element) {
      return element && element.nodeType !== 3 && /^(a|label|code|summary)$/i.test(typeof element === "string" ? element : element.nodeName);
    },
    /**
     * @description Node with font-size style
     * @param {Node} element Element to check
     * @returns {Boolean}
     * @private
     */
    _isSizeNode: function(element) {
      return element && element.nodeType !== 3 && this.isTextStyleElement(element) && !!element.style.fontSize;
    },
    /**
     * @description Nodes without text
     * @param {Node} element Element to check
     * @returns {Boolean}
     * @private
     */
    _notTextNode: function(element) {
      return element && element.nodeType !== 3 && (this.isComponent(element) || /^(br|input|select|canvas|img|iframe|audio|video)$/i.test(typeof element === "string" ? element : element.nodeName));
    },
    /**
     * @deprecated
     * @description Check disallowed tags
     * @param {Node} element Element to check
     * @returns {Boolean}
     * @private
     */
    _disallowedTags: function(element) {
      return /^(meta|script|link|style|[a-z]+\:[a-z]+)$/i.test(element.nodeName);
    },
    /**
     * @description Create whitelist RegExp object.
     * Return RegExp format: new RegExp("<\\/?\\b(?!" + list + ")\\b[^>^<]*+>", "gi")
     * @param {String} list Tags list ("br|p|div|pre...")
     * @returns {RegExp}
     */
    createTagsWhitelist: function(list2) {
      return new RegExp("<\\/?\\b(?!\\b" + (list2 || "").replace(/\|/g, "\\b|\\b") + "\\b)[^>]*>", "gi");
    },
    /**
     * @description Create blacklist RegExp object.
     * Return RegExp format: new RegExp("<\\/?\\b(?:" + list + ")\\b[^>^<]*+>", "gi")
     * @param {String} list Tags list ("br|p|div|pre...")
     * @returns {RegExp}
     */
    createTagsBlacklist: function(list2) {
      return new RegExp("<\\/?\\b(?:\\b" + (list2 || "^").replace(/\|/g, "\\b|\\b") + "\\b)[^>]*>", "gi");
    },
    /**
     * @description Fix tags that do not fit the editor format.
     * @param {Element} documentFragment Document fragment "DOCUMENT_FRAGMENT_NODE" (nodeType === 11)
     * @param {RegExp} htmlCheckWhitelistRegExp Editor tags whitelist (core._htmlCheckWhitelistRegExp)
     * @param {RegExp} htmlCheckBlacklistRegExp Editor tags blacklist (core._htmlCheckBlacklistRegExp)
     * @param {Function} classNameFilter Class name filter function
     * @private
     */
    _consistencyCheckOfHTML: function(documentFragment, htmlCheckWhitelistRegExp, htmlCheckBlacklistRegExp, classNameFilter) {
      const removeTags = [], emptyTags = [], wrongList = [], withoutFormatCells = [];
      const wrongTags = this.getListChildNodes(documentFragment, function(current) {
        if (current.nodeType !== 1) {
          if (this.isList(current.parentElement)) removeTags.push(current);
          return false;
        }
        if (htmlCheckBlacklistRegExp.test(current.nodeName) || !htmlCheckWhitelistRegExp.test(current.nodeName) && current.childNodes.length === 0 && this.isNotCheckingNode(current)) {
          removeTags.push(current);
          return false;
        }
        const nrtag = !this.getParentElement(current, this.isNotCheckingNode);
        if (!this.isTable(current) && !this.isListCell(current) && !this.isAnchor(current) && (this.isFormatElement(current) || this.isRangeFormatElement(current) || this.isTextStyleElement(current)) && current.childNodes.length === 0 && nrtag) {
          emptyTags.push(current);
          return false;
        }
        if (this.isList(current.parentNode) && !this.isList(current) && !this.isListCell(current)) {
          wrongList.push(current);
          return false;
        }
        if (this.isCell(current)) {
          const fel = current.firstElementChild;
          if (!this.isFormatElement(fel) && !this.isRangeFormatElement(fel) && !this.isComponent(fel)) {
            withoutFormatCells.push(current);
            return false;
          }
        }
        if (nrtag && current.className) {
          const className = new this._w.Array(current.classList).map(classNameFilter).join(" ").trim();
          if (className) current.className = className;
          else current.removeAttribute("class");
        }
        const result = current.parentNode !== documentFragment && nrtag && (this.isListCell(current) && !this.isList(current.parentNode) || (this.isFormatElement(current) || this.isComponent(current)) && !this.isRangeFormatElement(current.parentNode) && !this.getParentElement(current, this.isComponent));
        return result;
      }.bind(this));
      for (let i = 0, len = removeTags.length; i < len; i++) {
        this.removeItem(removeTags[i]);
      }
      const checkTags = [];
      for (let i = 0, len = wrongTags.length, t, p; i < len; i++) {
        t = wrongTags[i];
        p = t.parentNode;
        if (!p || !p.parentNode) continue;
        if (this.getParentElement(t, this.isListCell)) {
          const cellChildren = t.childNodes;
          for (let j = cellChildren.length - 1; len >= 0; j--) {
            p.insertBefore(t, cellChildren[j]);
          }
          checkTags.push(t);
        } else {
          p.parentNode.insertBefore(t, p);
          checkTags.push(p);
        }
      }
      for (let i = 0, len = checkTags.length, t; i < len; i++) {
        t = checkTags[i];
        if (this.onlyZeroWidthSpace(t.textContent.trim())) {
          this.removeItem(t);
        }
      }
      for (let i = 0, len = emptyTags.length; i < len; i++) {
        this.removeItem(emptyTags[i]);
      }
      for (let i = 0, len = wrongList.length, t, tp, children2, p; i < len; i++) {
        t = wrongList[i];
        p = t.parentNode;
        if (!p) continue;
        tp = this.createElement("LI");
        if (this.isFormatElement(t)) {
          children2 = t.childNodes;
          while (children2[0]) {
            tp.appendChild(children2[0]);
          }
          p.insertBefore(tp, t);
          this.removeItem(t);
        } else {
          t = t.nextSibling;
          tp.appendChild(wrongList[i]);
          p.insertBefore(tp, t);
        }
      }
      for (let i = 0, len = withoutFormatCells.length, t, f; i < len; i++) {
        t = withoutFormatCells[i];
        f = this.createElement("DIV");
        f.innerHTML = t.textContent.trim().length === 0 && t.children.length === 0 ? "<br>" : t.innerHTML;
        t.innerHTML = f.outerHTML;
      }
    },
    _setDefaultOptionStyle: function(options2, defaultStyle) {
      let optionStyle = "";
      if (options2.height) optionStyle += "height:" + options2.height + ";";
      if (options2.minHeight) optionStyle += "min-height:" + options2.minHeight + ";";
      if (options2.maxHeight) optionStyle += "max-height:" + options2.maxHeight + ";";
      if (options2.position) optionStyle += "position:" + options2.position + ";";
      if (options2.width) optionStyle += "width:" + options2.width + ";";
      if (options2.minWidth) optionStyle += "min-width:" + options2.minWidth + ";";
      if (options2.maxWidth) optionStyle += "max-width:" + options2.maxWidth + ";";
      let top = "", frame = "", editor = "";
      defaultStyle = optionStyle + defaultStyle;
      const styleArr = defaultStyle.split(";");
      for (let i = 0, len = styleArr.length, s; i < len; i++) {
        s = styleArr[i].trim();
        if (!s) continue;
        if (/^(min-|max-)?width\s*:/.test(s) || /^(z-index|position)\s*:/.test(s)) {
          top += s + ";";
          continue;
        }
        if (/^(min-|max-)?height\s*:/.test(s)) {
          if (/^height/.test(s) && s.split(":")[1].trim() === "auto") {
            options2.height = "auto";
          }
          frame += s + ";";
          continue;
        }
        editor += s + ";";
      }
      return {
        top,
        frame,
        editor
      };
    },
    _setIframeDocument: function(frame, options2) {
      frame.setAttribute("scrolling", "auto");
      frame.contentDocument.head.innerHTML = '<meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">' + this._setIframeCssTags(options2);
      frame.contentDocument.body.className = options2._editableClass;
      frame.contentDocument.body.setAttribute("contenteditable", true);
      frame.contentDocument.body.setAttribute("autocorrect", "off");
    },
    _setIframeCssTags: function(options2) {
      const linkNames = options2.iframeCSSFileName;
      const wRegExp = this._w.RegExp;
      let tagString = "";
      for (let f = 0, len = linkNames.length, path; f < len; f++) {
        path = [];
        if (/(^https?:\/\/)|(^data:text\/css,)/.test(linkNames[f])) {
          path.push(linkNames[f]);
        } else {
          const CSSFileName = new wRegExp("(^|.*[\\/])" + linkNames[f] + "(\\..+)?\\.css(?:\\?.*|;.*)?$", "i");
          for (let c = document.getElementsByTagName("link"), i = 0, len2 = c.length, styleTag; i < len2; i++) {
            styleTag = c[i].href.match(CSSFileName);
            if (styleTag) path.push(styleTag[0]);
          }
        }
        if (!path || path.length === 0) throw '[SUNEDITOR.constructor.iframe.fail] The suneditor CSS files installation path could not be automatically detected. Please set the option property "iframeCSSFileName" before creating editor instances.';
        for (let i = 0, len2 = path.length; i < len2; i++) {
          tagString += '<link href="' + path[i] + '" rel="stylesheet">';
        }
      }
      return tagString + (options2.height === "auto" ? "<style>\n/** Iframe height auto */\nbody{height: min-content; overflow: hidden;}\n</style>" : "");
    }
  };
  var util_default = util;

  // ../../node_modules/suneditor/src/lib/constructor.js
  var constructor_default = {
    /**
     * @description document create
     * @param {Element} element Textarea
     * @param {Object} options Options
     * @returns {Object}
     */
    init: function(element, options2) {
      if (typeof options2 !== "object") options2 = {};
      const doc = document;
      this._initOptions(element, options2);
      const top_div = doc.createElement("DIV");
      top_div.className = "sun-editor" + (options2.rtl ? " se-rtl" : "");
      if (element.id) top_div.id = "suneditor_" + element.id;
      const relative = doc.createElement("DIV");
      relative.className = "se-container";
      const tool_bar = this._createToolBar(doc, options2.buttonList, options2.plugins, options2);
      const toolbarShadow = tool_bar.element.cloneNode(false);
      toolbarShadow.className += " se-toolbar-shadow";
      tool_bar.element.style.visibility = "hidden";
      if (tool_bar.pluginCallButtons.math) this._checkKatexMath(options2.katex);
      const arrow = doc.createElement("DIV");
      arrow.className = "se-arrow";
      const sticky_dummy = doc.createElement("DIV");
      sticky_dummy.className = "se-toolbar-sticky-dummy";
      const editor_div = doc.createElement("DIV");
      editor_div.className = "se-wrapper";
      const initElements = this._initElements(options2, top_div, tool_bar.element, arrow);
      const bottomBar = initElements.bottomBar;
      const wysiwyg_div = initElements.wysiwygFrame;
      const placeholder_span = initElements.placeholder;
      let textarea = initElements.codeView;
      const resizing_bar = bottomBar.resizingBar;
      const navigation = bottomBar.navigation;
      const char_wrapper = bottomBar.charWrapper;
      const char_counter = bottomBar.charCounter;
      const loading_box = doc.createElement("DIV");
      loading_box.className = "se-loading-box sun-editor-common";
      loading_box.innerHTML = '<div class="se-loading-effect"></div>';
      const line_breaker = doc.createElement("DIV");
      line_breaker.className = "se-line-breaker";
      line_breaker.innerHTML = '<button class="se-btn">' + options2.icons.line_break + "</button>";
      const line_breaker_t = doc.createElement("DIV");
      line_breaker_t.className += "se-line-breaker-component";
      const line_breaker_b = line_breaker_t.cloneNode(true);
      line_breaker_t.innerHTML = line_breaker_b.innerHTML = options2.icons.line_break;
      const resize_back = doc.createElement("DIV");
      resize_back.className = "se-resizing-back";
      const focusTemp = doc.createElement("INPUT");
      focusTemp.tabIndex = -1;
      focusTemp.style.cssText = "position: fixed !important; top: -10000px !important; display: block !important; width: 0 !important; height: 0 !important; margin: 0 !important; padding: 0 !important;";
      const toolbarContainer = options2.toolbarContainer;
      if (toolbarContainer) {
        toolbarContainer.appendChild(tool_bar.element);
        toolbarContainer.appendChild(toolbarShadow);
      }
      const resizingBarContainer = options2.resizingBarContainer;
      if (resizing_bar && resizingBarContainer) resizingBarContainer.appendChild(resizing_bar);
      editor_div.appendChild(textarea);
      if (placeholder_span) editor_div.appendChild(placeholder_span);
      if (!toolbarContainer) {
        relative.appendChild(tool_bar.element);
        relative.appendChild(toolbarShadow);
      }
      relative.appendChild(sticky_dummy);
      relative.appendChild(editor_div);
      relative.appendChild(resize_back);
      relative.appendChild(loading_box);
      relative.appendChild(line_breaker);
      relative.appendChild(line_breaker_t);
      relative.appendChild(line_breaker_b);
      relative.appendChild(focusTemp);
      if (resizing_bar && !resizingBarContainer) relative.appendChild(resizing_bar);
      top_div.appendChild(relative);
      textarea = this._checkCodeMirror(options2, textarea);
      return {
        constructed: {
          _top: top_div,
          _relative: relative,
          _toolBar: tool_bar.element,
          _toolbarShadow: toolbarShadow,
          _menuTray: tool_bar._menuTray,
          _editorArea: editor_div,
          _wysiwygArea: wysiwyg_div,
          _codeArea: textarea,
          _placeholder: placeholder_span,
          _resizingBar: resizing_bar,
          _navigation: navigation,
          _charWrapper: char_wrapper,
          _charCounter: char_counter,
          _loading: loading_box,
          _lineBreaker: line_breaker,
          _lineBreaker_t: line_breaker_t,
          _lineBreaker_b: line_breaker_b,
          _resizeBack: resize_back,
          _stickyDummy: sticky_dummy,
          _arrow: arrow,
          _focusTemp: focusTemp
        },
        options: options2,
        plugins: tool_bar.plugins,
        pluginCallButtons: tool_bar.pluginCallButtons,
        _responsiveButtons: tool_bar.responsiveButtons
      };
    },
    /**
     * @description Check the CodeMirror option to apply the CodeMirror and return the CodeMirror element.
     * @param {Object} options options
     * @param {Element} textarea textarea element
     * @private
     */
    _checkCodeMirror: function(options2, textarea) {
      if (options2.codeMirror) {
        const cmOptions = [{
          mode: "htmlmixed",
          htmlMode: true,
          lineNumbers: true,
          lineWrapping: true
        }, options2.codeMirror.options || {}].reduce(function(init, option) {
          for (let key in option) {
            if (util_default.hasOwn(option, key)) init[key] = option[key];
          }
          return init;
        }, {});
        if (options2.height === "auto") {
          cmOptions.viewportMargin = Infinity;
          cmOptions.height = "auto";
        }
        const cm = options2.codeMirror.src.fromTextArea(textarea, cmOptions);
        cm.display.wrapper.style.cssText = textarea.style.cssText;
        options2.codeMirrorEditor = cm;
        textarea = cm.display.wrapper;
        textarea.className += " se-wrapper-code-mirror";
      }
      return textarea;
    },
    /**
     * @description Check for a katex object.
     * @param {Object} katex katex object
     * @private
     */
    _checkKatexMath: function(katex) {
      if (!katex) throw Error('[SUNEDITOR.create.fail] To use the math button you need to add a "katex" object to the options.');
      const katexOptions = [{
        throwOnError: false
      }, katex.options || {}].reduce(function(init, option) {
        for (let key in option) {
          if (util_default.hasOwn(option, key)) init[key] = option[key];
        }
        return init;
      }, {});
      katex.options = katexOptions;
    },
    /**
     * @description Add or reset options
     * @param {Object} mergeOptions New options property
     * @param {Object} context Context object of core
     * @param {Object} originOptions Origin options
     * @returns {Object} pluginCallButtons
     * @private
     */
    _setOptions: function(mergeOptions, context, originOptions) {
      this._initOptions(context.element.originElement, mergeOptions);
      const el = context.element;
      const relative = el.relative;
      const editorArea = el.editorArea;
      const isNewToolbarContainer = mergeOptions.toolbarContainer && mergeOptions.toolbarContainer !== originOptions.toolbarContainer;
      const isNewToolbar = mergeOptions.lang !== originOptions.lang || mergeOptions.buttonList !== originOptions.buttonList || mergeOptions.mode !== originOptions.mode || isNewToolbarContainer;
      const tool_bar = this._createToolBar(document, isNewToolbar ? mergeOptions.buttonList : originOptions.buttonList, mergeOptions.plugins, mergeOptions);
      if (tool_bar.pluginCallButtons.math) this._checkKatexMath(mergeOptions.katex);
      const arrow = document.createElement("DIV");
      arrow.className = "se-arrow";
      if (isNewToolbar) {
        tool_bar.element.style.visibility = "hidden";
        if (isNewToolbarContainer) {
          mergeOptions.toolbarContainer.appendChild(tool_bar.element);
          el.toolbar.parentElement.removeChild(el.toolbar);
        } else {
          el.toolbar.parentElement.replaceChild(tool_bar.element, el.toolbar);
        }
        el.toolbar = tool_bar.element;
        el._menuTray = tool_bar._menuTray;
        el._arrow = arrow;
      }
      const initElements = this._initElements(mergeOptions, el.topArea, isNewToolbar ? tool_bar.element : el.toolbar, arrow);
      const bottomBar = initElements.bottomBar;
      const wysiwygFrame = initElements.wysiwygFrame;
      const placeholder_span = initElements.placeholder;
      let code = initElements.codeView;
      if (el.resizingBar) util_default.removeItem(el.resizingBar);
      if (bottomBar.resizingBar) {
        if (mergeOptions.resizingBarContainer && mergeOptions.resizingBarContainer !== originOptions.resizingBarContainer) {
          mergeOptions.resizingBarContainer.appendChild(bottomBar.resizingBar);
        } else {
          relative.appendChild(bottomBar.resizingBar);
        }
      }
      editorArea.innerHTML = "";
      editorArea.appendChild(code);
      if (placeholder_span) editorArea.appendChild(placeholder_span);
      code = this._checkCodeMirror(mergeOptions, code);
      el.resizingBar = bottomBar.resizingBar;
      el.navigation = bottomBar.navigation;
      el.charWrapper = bottomBar.charWrapper;
      el.charCounter = bottomBar.charCounter;
      el.wysiwygFrame = wysiwygFrame;
      el.code = code;
      el.placeholder = placeholder_span;
      if (mergeOptions.rtl) util_default.addClass(el.topArea, "se-rtl");
      else util_default.removeClass(el.topArea, "se-rtl");
      return {
        callButtons: tool_bar.pluginCallButtons,
        plugins: tool_bar.plugins,
        toolbar: tool_bar
      };
    },
    /**
     * @description Initialize property of suneditor elements
     * @param {Object} options Options
     * @param {Element} topDiv Suneditor top div
     * @param {Element} toolBar Tool bar
     * @param {Element} toolBarArrow Tool bar arrow (balloon editor)
     * @returns {Object} Bottom bar elements (resizingBar, navigation, charWrapper, charCounter)
     * @private
     */
    _initElements: function(options2, topDiv, toolBar, toolBarArrow) {
      topDiv.style.cssText = options2._editorStyles.top;
      if (/inline/i.test(options2.mode)) {
        toolBar.className += " se-toolbar-inline";
        toolBar.style.width = options2.toolbarWidth;
      } else if (/balloon/i.test(options2.mode)) {
        toolBar.className += " se-toolbar-balloon";
        toolBar.style.width = options2.toolbarWidth;
        toolBar.appendChild(toolBarArrow);
      }
      const wysiwygDiv = document.createElement(!options2.iframe ? "DIV" : "IFRAME");
      wysiwygDiv.className = "se-wrapper-inner se-wrapper-wysiwyg";
      if (!options2.iframe) {
        wysiwygDiv.setAttribute("contenteditable", true);
        wysiwygDiv.setAttribute("autocorrect", "off");
        wysiwygDiv.setAttribute("scrolling", "auto");
        for (let key in options2.iframeAttributes) {
          wysiwygDiv.setAttribute(key, options2.iframeAttributes[key]);
        }
        wysiwygDiv.className += " " + options2._editableClass;
        wysiwygDiv.style.cssText = options2._editorStyles.frame + options2._editorStyles.editor;
        wysiwygDiv.className += options2.className;
      } else {
        wysiwygDiv.allowFullscreen = true;
        wysiwygDiv.frameBorder = 0;
        wysiwygDiv.style.cssText = options2._editorStyles.frame;
        wysiwygDiv.className += options2.className;
      }
      const textarea = document.createElement("TEXTAREA");
      textarea.className = "se-wrapper-inner se-wrapper-code" + options2.className;
      textarea.style.cssText = options2._editorStyles.frame;
      textarea.style.display = "none";
      if (options2.height === "auto") textarea.style.overflow = "hidden";
      let resizingBar = null;
      let navigation = null;
      let charWrapper = null;
      let charCounter = null;
      if (options2.resizingBar) {
        resizingBar = document.createElement("DIV");
        resizingBar.className = "se-resizing-bar sun-editor-common";
        navigation = document.createElement("DIV");
        navigation.className = "se-navigation sun-editor-common";
        resizingBar.appendChild(navigation);
        if (options2.charCounter) {
          charWrapper = document.createElement("DIV");
          charWrapper.className = "se-char-counter-wrapper";
          if (options2.charCounterLabel) {
            const charLabel = document.createElement("SPAN");
            charLabel.className = "se-char-label";
            charLabel.textContent = options2.charCounterLabel;
            charWrapper.appendChild(charLabel);
          }
          charCounter = document.createElement("SPAN");
          charCounter.className = "se-char-counter";
          charCounter.textContent = "0";
          charWrapper.appendChild(charCounter);
          if (options2.maxCharCount > 0) {
            const char_max = document.createElement("SPAN");
            char_max.textContent = " / " + options2.maxCharCount;
            charWrapper.appendChild(char_max);
          }
          resizingBar.appendChild(charWrapper);
        }
      }
      let placeholder = null;
      if (options2.placeholder) {
        placeholder = document.createElement("SPAN");
        placeholder.className = "se-placeholder";
        placeholder.innerText = options2.placeholder;
      }
      return {
        bottomBar: {
          resizingBar,
          navigation,
          charWrapper,
          charCounter
        },
        wysiwygFrame: wysiwygDiv,
        codeView: textarea,
        placeholder
      };
    },
    /**
     * @description Initialize options
     * @param {Element} element Options object
     * @param {Object} options Options object
     * @private
     */
    _initOptions: function(element, options2) {
      const plugins = {};
      if (options2.plugins) {
        const _plugins = options2.plugins;
        const pluginsValues = _plugins.length ? _plugins : Object.keys(_plugins).map(function(name2) {
          return _plugins[name2];
        });
        for (let i = 0, len = pluginsValues.length, p; i < len; i++) {
          p = pluginsValues[i].default || pluginsValues[i];
          plugins[p.name] = p;
        }
      }
      options2.plugins = plugins;
      options2.strictMode = options2.strictMode !== false;
      options2.lang = options2.lang || import_en.default;
      options2.value = typeof options2.value === "string" ? options2.value : null;
      options2.allowedClassNames = new util_default._w.RegExp((options2.allowedClassNames && typeof options2.allowedClassNames === "string" ? options2.allowedClassNames + "|" : "") + "^__se__|se-|katex");
      options2.historyStackDelayTime = typeof options2.historyStackDelayTime === "number" ? options2.historyStackDelayTime : 400;
      options2.frameAttrbutes = options2.frameAttrbutes || {};
      options2.defaultTag = typeof options2.defaultTag === "string" && options2.defaultTag.length > 0 ? options2.defaultTag : "p";
      const textTags = options2.textTags = [{ bold: "STRONG", underline: "U", italic: "EM", strike: "DEL", sub: "SUB", sup: "SUP" }, options2.textTags || {}].reduce(function(_default, _new) {
        for (let key in _new) {
          _default[key] = _new[key];
        }
        return _default;
      }, {});
      options2._textTagsMap = {
        "strong": textTags.bold.toLowerCase(),
        "b": textTags.bold.toLowerCase(),
        "u": textTags.underline.toLowerCase(),
        "ins": textTags.underline.toLowerCase(),
        "em": textTags.italic.toLowerCase(),
        "i": textTags.italic.toLowerCase(),
        "del": textTags.strike.toLowerCase(),
        "strike": textTags.strike.toLowerCase(),
        "s": textTags.strike.toLowerCase(),
        "sub": textTags.sub.toLowerCase(),
        "sup": textTags.sup.toLowerCase()
      };
      options2._defaultCommand = {
        bold: options2.textTags.bold,
        underline: options2.textTags.underline,
        italic: options2.textTags.italic,
        strike: options2.textTags.strike,
        subscript: options2.textTags.sub,
        superscript: options2.textTags.sup
      };
      options2.__allowedScriptTag = options2.__allowedScriptTag === true;
      const whitelist = "br|p|div|pre|blockquote|h1|h2|h3|h4|h5|h6|ol|ul|li|hr|figure|figcaption|img|iframe|audio|video|source|table|thead|tbody|tr|th|td|a|b|strong|var|i|em|u|ins|s|span|strike|del|sub|sup|code|svg|path|details|summary";
      options2.tagsBlacklist = options2.tagsBlacklist || "";
      options2._defaultTagsWhitelist = (typeof options2._defaultTagsWhitelist === "string" ? options2._defaultTagsWhitelist : whitelist) + (options2.__allowedScriptTag ? "|script" : "");
      options2._editorTagsWhitelist = options2.addTagsWhitelist === "*" ? "*" : this._setWhitelist(options2._defaultTagsWhitelist + (typeof options2.addTagsWhitelist === "string" && options2.addTagsWhitelist.length > 0 ? "|" + options2.addTagsWhitelist : ""), options2.tagsBlacklist);
      options2.pasteTagsBlacklist = options2.tagsBlacklist + (options2.tagsBlacklist && options2.pasteTagsBlacklist ? "|" + options2.pasteTagsBlacklist : options2.pasteTagsBlacklist || "");
      options2.pasteTagsWhitelist = options2.pasteTagsWhitelist === "*" ? "*" : this._setWhitelist(typeof options2.pasteTagsWhitelist === "string" ? options2.pasteTagsWhitelist : options2._editorTagsWhitelist, options2.pasteTagsBlacklist);
      options2.attributesWhitelist = !options2.attributesWhitelist || typeof options2.attributesWhitelist !== "object" ? null : options2.attributesWhitelist;
      options2.attributesBlacklist = !options2.attributesBlacklist || typeof options2.attributesBlacklist !== "object" ? null : options2.attributesBlacklist;
      options2.mode = options2.mode || "classic";
      options2.rtl = !!options2.rtl;
      options2.lineAttrReset = ["id"].concat(options2.lineAttrReset && typeof options2.lineAttrReset === "string" ? options2.lineAttrReset.toLowerCase().split("|") : []);
      options2._editableClass = "sun-editor-editable" + (options2.rtl ? " se-rtl" : "");
      options2._printClass = typeof options2._printClass === "string" ? options2._printClass : null;
      options2.toolbarWidth = options2.toolbarWidth ? util_default.isNumber(options2.toolbarWidth) ? options2.toolbarWidth + "px" : options2.toolbarWidth : "auto";
      options2.toolbarContainer = typeof options2.toolbarContainer === "string" ? document.querySelector(options2.toolbarContainer) : options2.toolbarContainer;
      options2.stickyToolbar = /balloon/i.test(options2.mode) || !!options2.toolbarContainer ? -1 : options2.stickyToolbar === void 0 ? 0 : /^\d+/.test(options2.stickyToolbar) ? util_default.getNumber(options2.stickyToolbar, 0) : -1;
      options2.hideToolbar = !!options2.hideToolbar;
      options2.fullScreenOffset = options2.fullScreenOffset === void 0 ? 0 : /^\d+/.test(options2.fullScreenOffset) ? util_default.getNumber(options2.fullScreenOffset, 0) : 0;
      options2.fullPage = !!options2.fullPage;
      options2.iframe = options2.fullPage || !!options2.iframe;
      options2.iframeAttributes = options2.iframeAttributes || {};
      options2.iframeCSSFileName = options2.iframe ? typeof options2.iframeCSSFileName === "string" ? [options2.iframeCSSFileName] : options2.iframeCSSFileName || ["suneditor"] : null;
      options2.previewTemplate = typeof options2.previewTemplate === "string" ? options2.previewTemplate : null;
      options2.printTemplate = typeof options2.printTemplate === "string" ? options2.printTemplate : null;
      options2.codeMirror = options2.codeMirror ? options2.codeMirror.src ? options2.codeMirror : { src: options2.codeMirror } : null;
      options2.katex = options2.katex ? options2.katex.src ? options2.katex : { src: options2.katex } : null;
      options2.mathFontSize = !!options2.mathFontSize ? options2.mathFontSize : [
        { text: "1", value: "1em" },
        { text: "1.5", value: "1.5em" },
        { text: "2", value: "2em" },
        { text: "2.5", value: "2.5em" }
      ];
      options2.position = typeof options2.position === "string" ? options2.position : null;
      options2.display = options2.display || (element.style.display === "none" || !element.style.display ? "block" : element.style.display);
      options2.popupDisplay = options2.popupDisplay || "full";
      options2.resizingBar = options2.resizingBar === void 0 ? /inline|balloon/i.test(options2.mode) ? false : true : options2.resizingBar;
      options2.showPathLabel = !options2.resizingBar ? false : typeof options2.showPathLabel === "boolean" ? options2.showPathLabel : true;
      options2.resizeEnable = options2.resizeEnable === void 0 ? true : !!options2.resizeEnable;
      options2.resizingBarContainer = typeof options2.resizingBarContainer === "string" ? document.querySelector(options2.resizingBarContainer) : options2.resizingBarContainer;
      options2.charCounter = options2.maxCharCount > 0 ? true : typeof options2.charCounter === "boolean" ? options2.charCounter : false;
      options2.charCounterType = typeof options2.charCounterType === "string" ? options2.charCounterType : "char";
      options2.charCounterLabel = typeof options2.charCounterLabel === "string" ? options2.charCounterLabel.trim() : null;
      options2.maxCharCount = util_default.isNumber(options2.maxCharCount) && options2.maxCharCount > -1 ? options2.maxCharCount * 1 : null;
      options2.width = options2.width ? util_default.isNumber(options2.width) ? options2.width + "px" : options2.width : element.clientWidth ? element.clientWidth + "px" : "100%";
      options2.minWidth = (util_default.isNumber(options2.minWidth) ? options2.minWidth + "px" : options2.minWidth) || "";
      options2.maxWidth = (util_default.isNumber(options2.maxWidth) ? options2.maxWidth + "px" : options2.maxWidth) || "";
      options2.height = options2.height ? util_default.isNumber(options2.height) ? options2.height + "px" : options2.height : element.clientHeight ? element.clientHeight + "px" : "auto";
      options2.minHeight = (util_default.isNumber(options2.minHeight) ? options2.minHeight + "px" : options2.minHeight) || "";
      options2.maxHeight = (util_default.isNumber(options2.maxHeight) ? options2.maxHeight + "px" : options2.maxHeight) || "";
      options2.className = typeof options2.className === "string" && options2.className.length > 0 ? " " + options2.className : "";
      options2.defaultStyle = typeof options2.defaultStyle === "string" ? options2.defaultStyle : "";
      options2.font = !options2.font ? ["Arial", "Comic Sans MS", "Courier New", "Impact", "Georgia", "tahoma", "Trebuchet MS", "Verdana"] : options2.font;
      options2.fontSize = !options2.fontSize ? null : options2.fontSize;
      options2.formats = !options2.formats ? null : options2.formats;
      options2.colorList = !options2.colorList ? null : options2.colorList;
      options2.lineHeights = !options2.lineHeights ? null : options2.lineHeights;
      options2.paragraphStyles = !options2.paragraphStyles ? null : options2.paragraphStyles;
      options2.textStyles = !options2.textStyles ? null : options2.textStyles;
      options2.fontSizeUnit = typeof options2.fontSizeUnit === "string" ? options2.fontSizeUnit.trim().toLowerCase() || "px" : "px";
      options2.alignItems = typeof options2.alignItems === "object" ? options2.alignItems : options2.rtl ? ["right", "center", "left", "justify"] : ["left", "center", "right", "justify"];
      options2.imageResizing = options2.imageResizing === void 0 ? true : options2.imageResizing;
      options2.imageHeightShow = options2.imageHeightShow === void 0 ? true : !!options2.imageHeightShow;
      options2.imageAlignShow = options2.imageAlignShow === void 0 ? true : !!options2.imageAlignShow;
      options2.imageWidth = !options2.imageWidth ? "auto" : util_default.isNumber(options2.imageWidth) ? options2.imageWidth + "px" : options2.imageWidth;
      options2.imageHeight = !options2.imageHeight ? "auto" : util_default.isNumber(options2.imageHeight) ? options2.imageHeight + "px" : options2.imageHeight;
      options2.imageSizeOnlyPercentage = !!options2.imageSizeOnlyPercentage;
      options2._imageSizeUnit = options2.imageSizeOnlyPercentage ? "%" : "px";
      options2.imageRotation = options2.imageRotation !== void 0 ? options2.imageRotation : !(options2.imageSizeOnlyPercentage || !options2.imageHeightShow);
      options2.imageFileInput = options2.imageFileInput === void 0 ? true : options2.imageFileInput;
      options2.imageUrlInput = options2.imageUrlInput === void 0 || !options2.imageFileInput ? true : options2.imageUrlInput;
      options2.imageUploadHeader = options2.imageUploadHeader || null;
      options2.imageUploadUrl = typeof options2.imageUploadUrl === "string" ? options2.imageUploadUrl : null;
      options2.imageUploadSizeLimit = /\d+/.test(options2.imageUploadSizeLimit) ? util_default.getNumber(options2.imageUploadSizeLimit, 0) : null;
      options2.imageMultipleFile = !!options2.imageMultipleFile;
      options2.imageAccept = typeof options2.imageAccept !== "string" || options2.imageAccept.trim() === "*" ? "image/*" : options2.imageAccept.trim() || "image/*";
      options2.imageGalleryUrl = typeof options2.imageGalleryUrl === "string" ? options2.imageGalleryUrl : null;
      options2.imageGalleryHeader = options2.imageGalleryHeader || null;
      options2.videoResizing = options2.videoResizing === void 0 ? true : options2.videoResizing;
      options2.videoHeightShow = options2.videoHeightShow === void 0 ? true : !!options2.videoHeightShow;
      options2.videoAlignShow = options2.videoAlignShow === void 0 ? true : !!options2.videoAlignShow;
      options2.videoRatioShow = options2.videoRatioShow === void 0 ? true : !!options2.videoRatioShow;
      options2.videoWidth = !options2.videoWidth || !util_default.getNumber(options2.videoWidth, 0) ? "" : util_default.isNumber(options2.videoWidth) ? options2.videoWidth + "px" : options2.videoWidth;
      options2.videoHeight = !options2.videoHeight || !util_default.getNumber(options2.videoHeight, 0) ? "" : util_default.isNumber(options2.videoHeight) ? options2.videoHeight + "px" : options2.videoHeight;
      options2.videoSizeOnlyPercentage = !!options2.videoSizeOnlyPercentage;
      options2._videoSizeUnit = options2.videoSizeOnlyPercentage ? "%" : "px";
      options2.videoRotation = options2.videoRotation !== void 0 ? options2.videoRotation : !(options2.videoSizeOnlyPercentage || !options2.videoHeightShow);
      options2.videoRatio = util_default.getNumber(options2.videoRatio, 4) || 0.5625;
      options2.videoRatioList = !options2.videoRatioList ? null : options2.videoRatioList;
      options2.youtubeQuery = (options2.youtubeQuery || "").replace("?", "");
      options2.vimeoQuery = (options2.vimeoQuery || "").replace("?", "");
      options2.videoFileInput = !!options2.videoFileInput;
      options2.videoUrlInput = options2.videoUrlInput === void 0 || !options2.videoFileInput ? true : options2.videoUrlInput;
      options2.videoUploadHeader = options2.videoUploadHeader || null;
      options2.videoUploadUrl = typeof options2.videoUploadUrl === "string" ? options2.videoUploadUrl : null;
      options2.videoUploadSizeLimit = /\d+/.test(options2.videoUploadSizeLimit) ? util_default.getNumber(options2.videoUploadSizeLimit, 0) : null;
      options2.videoMultipleFile = !!options2.videoMultipleFile;
      options2.videoTagAttrs = options2.videoTagAttrs || null;
      options2.videoIframeAttrs = options2.videoIframeAttrs || null;
      options2.videoAccept = typeof options2.videoAccept !== "string" || options2.videoAccept.trim() === "*" ? "video/*" : options2.videoAccept.trim() || "video/*";
      options2.audioWidth = !options2.audioWidth ? "" : util_default.isNumber(options2.audioWidth) ? options2.audioWidth + "px" : options2.audioWidth;
      options2.audioHeight = !options2.audioHeight ? "" : util_default.isNumber(options2.audioHeight) ? options2.audioHeight + "px" : options2.audioHeight;
      options2.audioFileInput = !!options2.audioFileInput;
      options2.audioUrlInput = options2.audioUrlInput === void 0 || !options2.audioFileInput ? true : options2.audioUrlInput;
      options2.audioUploadHeader = options2.audioUploadHeader || null;
      options2.audioUploadUrl = typeof options2.audioUploadUrl === "string" ? options2.audioUploadUrl : null;
      options2.audioUploadSizeLimit = /\d+/.test(options2.audioUploadSizeLimit) ? util_default.getNumber(options2.audioUploadSizeLimit, 0) : null;
      options2.audioMultipleFile = !!options2.audioMultipleFile;
      options2.audioTagAttrs = options2.audioTagAttrs || null;
      options2.audioAccept = typeof options2.audioAccept !== "string" || options2.audioAccept.trim() === "*" ? "audio/*" : options2.audioAccept.trim() || "audio/*";
      options2.tableCellControllerPosition = typeof options2.tableCellControllerPosition === "string" ? options2.tableCellControllerPosition.toLowerCase() : "cell";
      options2.linkTargetNewWindow = !!options2.linkTargetNewWindow;
      options2.linkProtocol = typeof options2.linkProtocol === "string" ? options2.linkProtocol : null;
      options2.linkRel = Array.isArray(options2.linkRel) ? options2.linkRel : [];
      options2.linkRelDefault = options2.linkRelDefault || {};
      options2.tabDisable = !!options2.tabDisable;
      options2.shortcutsDisable = Array.isArray(options2.shortcutsDisable) ? options2.shortcutsDisable : [];
      options2.shortcutsHint = options2.shortcutsHint === void 0 ? true : !!options2.shortcutsHint;
      options2.callBackSave = !options2.callBackSave ? null : options2.callBackSave;
      options2.templates = !options2.templates ? null : options2.templates;
      options2.placeholder = typeof options2.placeholder === "string" ? options2.placeholder : null;
      options2.mediaAutoSelect = options2.mediaAutoSelect === void 0 ? true : !!options2.mediaAutoSelect;
      options2.buttonList = !!options2.buttonList ? options2.buttonList : [
        ["undo", "redo"],
        ["bold", "underline", "italic", "strike", "subscript", "superscript"],
        ["removeFormat"],
        ["outdent", "indent"],
        ["fullScreen", "showBlocks", "codeView"],
        ["preview", "print"]
      ];
      if (options2.rtl) {
        options2.buttonList = options2.buttonList.reverse();
      }
      options2.icons = !options2.icons || typeof options2.icons !== "object" ? defaultIcons_default : [defaultIcons_default, options2.icons].reduce(function(_default, _new) {
        for (let key in _new) {
          if (util_default.hasOwn(_new, key)) _default[key] = _new[key];
        }
        return _default;
      }, {});
      options2.icons = !options2.rtl ? options2.icons : [options2.icons, options2.icons.rtl].reduce(function(_default, _new) {
        for (let key in _new) {
          if (util_default.hasOwn(_new, key)) _default[key] = _new[key];
        }
        return _default;
      }, {});
      options2.__listCommonStyle = options2.__listCommonStyle || ["fontSize", "color", "fontFamily", "fontWeight", "fontStyle"];
      options2._editorStyles = util_default._setDefaultOptionStyle(options2, options2.defaultStyle);
    },
    _setWhitelist: function(whitelist, blacklist) {
      if (typeof blacklist !== "string") return whitelist;
      blacklist = blacklist.split("|");
      whitelist = whitelist.split("|");
      for (let i = 0, len = blacklist.length, index; i < len; i++) {
        index = whitelist.indexOf(blacklist[i]);
        if (index > -1) whitelist.splice(index, 1);
      }
      return whitelist.join("|");
    },
    /**
     * @description Suneditor's Default button list
     * @param {Object} options options
     * @private
     */
    _defaultButtons: function(options2) {
      const icons = options2.icons;
      const lang = options2.lang;
      const cmd = util_default.isOSX_IOS ? "\u2318" : "CTRL";
      const addShift = util_default.isOSX_IOS ? "\u21E7" : "+SHIFT";
      const shortcutsDisable = !options2.shortcutsHint ? ["bold", "strike", "underline", "italic", "undo", "indent", "save"] : options2.shortcutsDisable;
      const indentKey = options2.rtl ? ["[", "]"] : ["]", "["];
      const indentIcon = options2.rtl ? [icons.outdent, icons.indent] : [icons.indent, icons.outdent];
      return {
        /** default command */
        bold: ["", lang.toolbar.bold + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("bold") > -1 ? "" : cmd + '+<span class="se-shortcut-key">B</span>') + "</span>", "bold", "", icons.bold],
        underline: ["", lang.toolbar.underline + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("underline") > -1 ? "" : cmd + '+<span class="se-shortcut-key">U</span>') + "</span>", "underline", "", icons.underline],
        italic: ["", lang.toolbar.italic + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("italic") > -1 ? "" : cmd + '+<span class="se-shortcut-key">I</span>') + "</span>", "italic", "", icons.italic],
        strike: ["", lang.toolbar.strike + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("strike") > -1 ? "" : cmd + addShift + '+<span class="se-shortcut-key">S</span>') + "</span>", "strike", "", icons.strike],
        subscript: ["", lang.toolbar.subscript, "SUB", "", icons.subscript],
        superscript: ["", lang.toolbar.superscript, "SUP", "", icons.superscript],
        removeFormat: ["", lang.toolbar.removeFormat, "removeFormat", "", icons.erase],
        indent: ["", lang.toolbar.indent + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("indent") > -1 ? "" : cmd + '+<span class="se-shortcut-key">' + indentKey[0] + "</span>") + "</span>", "indent", "", indentIcon[0]],
        outdent: ["", lang.toolbar.outdent + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("indent") > -1 ? "" : cmd + '+<span class="se-shortcut-key">' + indentKey[1] + "</span>") + "</span>", "outdent", "", indentIcon[1]],
        fullScreen: ["se-code-view-enabled se-resizing-enabled", lang.toolbar.fullScreen, "fullScreen", "", icons.expansion],
        showBlocks: ["", lang.toolbar.showBlocks, "showBlocks", "", icons.show_blocks],
        codeView: ["se-code-view-enabled se-resizing-enabled", lang.toolbar.codeView, "codeView", "", icons.code_view],
        undo: ["", lang.toolbar.undo + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("undo") > -1 ? "" : cmd + '+<span class="se-shortcut-key">Z</span>') + "</span>", "undo", "", icons.undo],
        redo: ["", lang.toolbar.redo + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("undo") > -1 ? "" : cmd + '+<span class="se-shortcut-key">Y</span> / ' + cmd + addShift + '+<span class="se-shortcut-key">Z</span>') + "</span>", "redo", "", icons.redo],
        preview: ["se-resizing-enabled", lang.toolbar.preview, "preview", "", icons.preview],
        print: ["se-resizing-enabled", lang.toolbar.print, "print", "", icons.print],
        dir: ["", lang.toolbar[options2.rtl ? "dir_ltr" : "dir_rtl"], "dir", "", icons[options2.rtl ? "dir_ltr" : "dir_rtl"]],
        dir_ltr: ["", lang.toolbar.dir_ltr, "dir_ltr", "", icons.dir_ltr],
        dir_rtl: ["", lang.toolbar.dir_rtl, "dir_rtl", "", icons.dir_rtl],
        save: ["se-resizing-enabled", lang.toolbar.save + '<span class="se-shortcut">' + (shortcutsDisable.indexOf("save") > -1 ? "" : cmd + '+<span class="se-shortcut-key">S</span>') + "</span>", "save", "", icons.save],
        /** plugins - command */
        blockquote: ["", lang.toolbar.tag_blockquote, "blockquote", "command", icons.blockquote],
        /** plugins - submenu */
        font: ["se-btn-select se-btn-tool-font", lang.toolbar.font, "font", "submenu", '<span class="txt">' + lang.toolbar.font + "</span>" + icons.arrow_down],
        formatBlock: ["se-btn-select se-btn-tool-format", lang.toolbar.formats, "formatBlock", "submenu", '<span class="txt">' + lang.toolbar.formats + "</span>" + icons.arrow_down],
        fontSize: ["se-btn-select se-btn-tool-size", lang.toolbar.fontSize, "fontSize", "submenu", '<span class="txt">' + lang.toolbar.fontSize + "</span>" + icons.arrow_down],
        fontColor: ["", lang.toolbar.fontColor, "fontColor", "submenu", icons.font_color],
        hiliteColor: ["", lang.toolbar.hiliteColor, "hiliteColor", "submenu", icons.highlight_color],
        align: ["se-btn-align", lang.toolbar.align, "align", "submenu", options2.rtl ? icons.align_right : icons.align_left],
        list: ["", lang.toolbar.list, "list", "submenu", icons.list_number],
        horizontalRule: ["btn_line", lang.toolbar.horizontalRule, "horizontalRule", "submenu", icons.horizontal_rule],
        table: ["", lang.toolbar.table, "table", "submenu", icons.table],
        lineHeight: ["", lang.toolbar.lineHeight, "lineHeight", "submenu", icons.line_height],
        template: ["", lang.toolbar.template, "template", "submenu", icons.template],
        paragraphStyle: ["", lang.toolbar.paragraphStyle, "paragraphStyle", "submenu", icons.paragraph_style],
        textStyle: ["", lang.toolbar.textStyle, "textStyle", "submenu", icons.text_style],
        /** plugins - dialog */
        link: ["", lang.toolbar.link, "link", "dialog", icons.link],
        image: ["", lang.toolbar.image, "image", "dialog", icons.image],
        video: ["", lang.toolbar.video, "video", "dialog", icons.video],
        audio: ["", lang.toolbar.audio, "audio", "dialog", icons.audio],
        math: ["", lang.toolbar.math, "math", "dialog", icons.math],
        /** plugins - fileBrowser */
        imageGallery: ["", lang.toolbar.imageGallery, "imageGallery", "fileBrowser", icons.image_gallery]
      };
    },
    /**
     * @description Create a group div containing each module
     * @returns {Object}
     * @private
     */
    _createModuleGroup: function() {
      const oDiv = util_default.createElement("DIV");
      oDiv.className = "se-btn-module se-btn-module-border";
      const oUl = util_default.createElement("UL");
      oUl.className = "se-menu-list";
      oDiv.appendChild(oUl);
      return {
        "div": oDiv,
        "ul": oUl
      };
    },
    /**
     * @description Create a button element
     * @param {string} buttonClass className in button
     * @param {string} title Title in button
     * @param {string} dataCommand The data-command property of the button
     * @param {string} dataDisplay The data-display property of the button ('dialog', 'submenu', 'command')
     * @param {string} innerHTML Html in button
     * @param {string} _disabled Button disabled
     * @param {Object} _icons Icons
     * @returns {Object}
     * @private
     */
    _createButton: function(buttonClass, title, dataCommand, dataDisplay, innerHTML, _disabled, _icons) {
      const oLi = util_default.createElement("LI");
      const oButton = util_default.createElement("BUTTON");
      const label = title || dataCommand;
      oButton.setAttribute("type", "button");
      oButton.setAttribute("class", "se-btn" + (buttonClass ? " " + buttonClass : "") + " se-tooltip");
      oButton.setAttribute("data-command", dataCommand);
      oButton.setAttribute("data-display", dataDisplay);
      oButton.setAttribute("aria-label", label.replace(/<span .+<\/span>/, ""));
      oButton.setAttribute("tabindex", "-1");
      if (!innerHTML) innerHTML = '<span class="se-icon-text">!</span>';
      if (/^default\./i.test(innerHTML)) {
        innerHTML = _icons[innerHTML.replace(/^default\./i, "")];
      }
      if (/^text\./i.test(innerHTML)) {
        innerHTML = innerHTML.replace(/^text\./i, "");
        oButton.className += " se-btn-more-text";
      }
      innerHTML += '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + label + "</span></span>";
      if (_disabled) oButton.setAttribute("disabled", true);
      oButton.innerHTML = innerHTML;
      oLi.appendChild(oButton);
      return {
        "li": oLi,
        "button": oButton
      };
    },
    /**
     * @description Create editor HTML
     * @param {Array} doc document object
     * @param {Array} buttonList option.buttonList
     * @param {Object|null} plugins Plugins
     * @param {Array} options options
     * @returns {Object} { element: (Element) Toolbar element, plugins: (Array|null) Plugins Array, pluginCallButtons: (Object), responsiveButtons: (Array) }
     * @private
     */
    _createToolBar: function(doc, buttonList, plugins, options2) {
      const separator_vertical = doc.createElement("DIV");
      separator_vertical.className = "se-toolbar-separator-vertical";
      const tool_bar = doc.createElement("DIV");
      tool_bar.className = "se-toolbar sun-editor-common";
      const _buttonTray = doc.createElement("DIV");
      _buttonTray.className = "se-btn-tray";
      tool_bar.appendChild(_buttonTray);
      buttonList = JSON.parse(JSON.stringify(buttonList));
      const icons = options2.icons;
      const defaultButtonList = this._defaultButtons(options2);
      const pluginCallButtons = {};
      const responsiveButtons = [];
      let module = null;
      let button = null;
      let moduleElement = null;
      let buttonElement = null;
      let pluginName = "";
      let vertical = false;
      const moreLayer = util_default.createElement("DIV");
      moreLayer.className = "se-toolbar-more-layer";
      buttonGroupLoop:
        for (let i = 0, more, moreContainer, moreCommand, buttonGroup, align; i < buttonList.length; i++) {
          more = false;
          align = "";
          buttonGroup = buttonList[i];
          moduleElement = this._createModuleGroup();
          if (typeof buttonGroup === "object") {
            for (let j = 0, moreButton; j < buttonGroup.length; j++) {
              button = buttonGroup[j];
              moreButton = false;
              if (/^\%\d+/.test(button) && j === 0) {
                buttonGroup[0] = button.replace(/[^\d]/g, "");
                responsiveButtons.push(buttonGroup);
                buttonList.splice(i--, 1);
                continue buttonGroupLoop;
              }
              if (typeof button === "object") {
                if (typeof button.add === "function") {
                  pluginName = button.name;
                  module = defaultButtonList[pluginName];
                  plugins[pluginName] = button;
                } else {
                  pluginName = button.name;
                  module = [button.buttonClass, button.title, button.name, button.dataDisplay, button.innerHTML, button._disabled];
                }
              } else {
                if (/^\-/.test(button)) {
                  align = button.substr(1);
                  moduleElement.div.className += " module-float-" + align;
                  continue;
                }
                if (/^\#/.test(button)) {
                  const option = button.substr(1);
                  if (option === "fix") moduleElement.ul.className += " se-menu-dir-fix";
                  continue;
                }
                if (/^\:/.test(button)) {
                  moreButton = true;
                  const matched = button.match(/^\:([^\-]+)\-([^\-]+)\-([^\-]+)/);
                  moreCommand = "__se__" + matched[1].trim();
                  const title = matched[2].trim();
                  const innerHTML = matched[3].trim();
                  module = ["se-btn-more", title, moreCommand, "MORE", innerHTML];
                } else {
                  module = defaultButtonList[button];
                }
                pluginName = button;
                if (!module) {
                  const custom = plugins[pluginName];
                  if (!custom) throw Error("[SUNEDITOR.create.toolbar.fail] The button name of a plugin that does not exist. [" + pluginName + "]");
                  module = [custom.buttonClass, custom.title, custom.name, custom.display, custom.innerHTML, custom._disabled];
                }
              }
              buttonElement = this._createButton(module[0], module[1], module[2], module[3], module[4], module[5], icons);
              (more ? moreContainer : moduleElement.ul).appendChild(buttonElement.li);
              if (plugins[pluginName]) {
                pluginCallButtons[pluginName] = buttonElement.button;
              }
              if (moreButton) {
                more = true;
                moreContainer = util_default.createElement("DIV");
                moreContainer.className = "se-more-layer " + moreCommand;
                moreContainer.innerHTML = '<div class="se-more-form"><ul class="se-menu-list"' + (align ? ' style="float: ' + align + ';"' : "") + "></ul></div>";
                moreLayer.appendChild(moreContainer);
                moreContainer = moreContainer.firstElementChild.firstElementChild;
              }
            }
            if (vertical) {
              const sv = separator_vertical.cloneNode(false);
              _buttonTray.appendChild(sv);
            }
            _buttonTray.appendChild(moduleElement.div);
            vertical = true;
          } else if (/^\/$/.test(buttonGroup)) {
            const enterDiv = doc.createElement("DIV");
            enterDiv.className = "se-btn-module-enter";
            _buttonTray.appendChild(enterDiv);
            vertical = false;
          }
        }
      switch (_buttonTray.children.length) {
        case 0:
          _buttonTray.style.display = "none";
          break;
        case 1:
          util_default.removeClass(_buttonTray.firstElementChild, "se-btn-module-border");
          break;
        default:
          if (options2.rtl) {
            const sv = separator_vertical.cloneNode(false);
            sv.style.float = _buttonTray.lastElementChild.style.float;
            _buttonTray.appendChild(sv);
          }
      }
      if (responsiveButtons.length > 0) responsiveButtons.unshift(buttonList);
      if (moreLayer.children.length > 0) _buttonTray.appendChild(moreLayer);
      const _menuTray = doc.createElement("DIV");
      _menuTray.className = "se-menu-tray";
      tool_bar.appendChild(_menuTray);
      const tool_cover = doc.createElement("DIV");
      tool_cover.className = "se-toolbar-cover";
      tool_bar.appendChild(tool_cover);
      if (options2.hideToolbar) tool_bar.style.display = "none";
      return {
        "element": tool_bar,
        "plugins": plugins,
        "pluginCallButtons": pluginCallButtons,
        "responsiveButtons": responsiveButtons,
        "_menuTray": _menuTray,
        "_buttonTray": _buttonTray
      };
    }
  };

  // ../../node_modules/suneditor/src/lib/context.js
  var _Context = function(element, cons, options2) {
    return {
      element: {
        originElement: element,
        topArea: cons._top,
        relative: cons._relative,
        toolbar: cons._toolBar,
        _toolbarShadow: cons._toolbarShadow,
        _buttonTray: cons._toolBar.querySelector(".se-btn-tray"),
        _menuTray: cons._menuTray,
        resizingBar: cons._resizingBar,
        navigation: cons._navigation,
        charWrapper: cons._charWrapper,
        charCounter: cons._charCounter,
        editorArea: cons._editorArea,
        wysiwygFrame: cons._wysiwygArea,
        wysiwyg: cons._wysiwygArea,
        // if (options.iframe) cons._wysiwygArea.contentDocument.body
        code: cons._codeArea,
        placeholder: cons._placeholder,
        loading: cons._loading,
        lineBreaker: cons._lineBreaker,
        lineBreaker_t: cons._lineBreaker_t,
        lineBreaker_b: cons._lineBreaker_b,
        resizeBackground: cons._resizeBack,
        _stickyDummy: cons._stickyDummy,
        _arrow: cons._arrow,
        _focusTemp: cons._focusTemp
      },
      tool: {
        cover: cons._toolBar.querySelector(".se-toolbar-cover"),
        bold: cons._toolBar.querySelector('[data-command="bold"]'),
        underline: cons._toolBar.querySelector('[data-command="underline"]'),
        italic: cons._toolBar.querySelector('[data-command="italic"]'),
        strike: cons._toolBar.querySelector('[data-command="strike"]'),
        sub: cons._toolBar.querySelector('[data-command="SUB"]'),
        sup: cons._toolBar.querySelector('[data-command="SUP"]'),
        undo: cons._toolBar.querySelector('[data-command="undo"]'),
        redo: cons._toolBar.querySelector('[data-command="redo"]'),
        save: cons._toolBar.querySelector('[data-command="save"]'),
        outdent: cons._toolBar.querySelector('[data-command="outdent"]'),
        indent: cons._toolBar.querySelector('[data-command="indent"]'),
        fullScreen: cons._toolBar.querySelector('[data-command="fullScreen"]'),
        showBlocks: cons._toolBar.querySelector('[data-command="showBlocks"]'),
        codeView: cons._toolBar.querySelector('[data-command="codeView"]'),
        dir: cons._toolBar.querySelector('[data-command="dir"]'),
        dir_ltr: cons._toolBar.querySelector('[data-command="dir_ltr"]'),
        dir_rtl: cons._toolBar.querySelector('[data-command="dir_rtl"]')
      },
      options: options2,
      option: options2
    };
  };
  var context_default = _Context;

  // ../../node_modules/suneditor/src/lib/history.js
  function history_default(core, change) {
    const _w = core._w;
    const util2 = core.util;
    const delayTime = core.options.historyStackDelayTime;
    let editor = core.context.element;
    let undo = core.context.tool.undo;
    let redo = core.context.tool.redo;
    let pushDelay = null;
    let stackIndex = 0;
    let stack = [];
    function setContentsFromStack() {
      const item = stack[stackIndex];
      editor.wysiwyg.innerHTML = item.contents;
      core.setRange(util2.getNodeFromPath(item.s.path, editor.wysiwyg), item.s.offset, util2.getNodeFromPath(item.e.path, editor.wysiwyg), item.e.offset);
      core.focus();
      if (stack.length <= 1) {
        if (undo) undo.setAttribute("disabled", true);
        if (redo) redo.setAttribute("disabled", true);
      } else {
        if (stackIndex === 0) {
          if (undo) undo.setAttribute("disabled", true);
          if (redo) redo.removeAttribute("disabled");
        } else if (stackIndex === stack.length - 1) {
          if (undo) undo.removeAttribute("disabled");
          if (redo) redo.setAttribute("disabled", true);
        } else {
          if (undo) undo.removeAttribute("disabled");
          if (redo) redo.removeAttribute("disabled");
        }
      }
      core.controllersOff();
      core._checkComponents();
      core._setCharCount();
      core._resourcesStateChange();
      change();
    }
    function pushStack() {
      core._checkComponents();
      const current = editor.wysiwyg.innerHTML;
      if (!current || !!stack[stackIndex] && current === stack[stackIndex].contents) return;
      stackIndex++;
      const range = core._variable._range;
      if (stack.length > stackIndex) {
        stack = stack.slice(0, stackIndex);
        if (redo) redo.setAttribute("disabled", true);
      }
      if (!range) {
        stack[stackIndex] = {
          contents: current,
          s: { path: [0, 0], offset: [0, 0] },
          e: { path: 0, offset: 0 }
        };
      } else {
        stack[stackIndex] = {
          contents: current,
          s: {
            path: util2.getNodePath(range.startContainer, null, null),
            offset: range.startOffset
          },
          e: {
            path: util2.getNodePath(range.endContainer, null, null),
            offset: range.endOffset
          }
        };
      }
      if (stackIndex === 1 && undo) undo.removeAttribute("disabled");
      core._setCharCount();
      change();
    }
    return {
      /**
       * @description History stack
       */
      stack,
      /**
       * @description Saving the current status to the history object stack
       * If "delay" is true, it will be saved after (options.historyStackDelayTime || 400) miliseconds
       * If the function is called again with the "delay" argument true before it is saved, the delay time is renewal
       * You can specify the delay time by sending a number.
       * @param {Boolean|Number} delay If true, Add stack without delay time.
       */
      push: function(delay) {
        _w.setTimeout(core._resourcesStateChange.bind(core));
        const time = typeof delay === "number" ? delay > 0 ? delay : 0 : !delay ? 0 : delayTime;
        if (!time || pushDelay) {
          _w.clearTimeout(pushDelay);
          if (!time) {
            pushStack();
            return;
          }
        }
        pushDelay = _w.setTimeout(function() {
          _w.clearTimeout(pushDelay);
          pushDelay = null;
          pushStack();
        }, time);
      },
      /**
       * @description Undo function
       */
      undo: function() {
        if (stackIndex > 0) {
          stackIndex--;
          setContentsFromStack();
        }
      },
      /**
       * @description Redo function
       */
      redo: function() {
        if (stack.length - 1 > stackIndex) {
          stackIndex++;
          setContentsFromStack();
        }
      },
      /**
       * @description Go to the history stack for that index.
       * If "index" is -1, go to the last stack
       */
      go: function(index) {
        stackIndex = index < 0 ? stack.length - 1 : index;
        setContentsFromStack();
      },
      /**
       * @description Get the current history stack index.
       * @returns {Number} Current Stack index
       */
      getCurrentIndex: function() {
        return stackIndex;
      },
      /**
       * @description Reset the history object
       */
      reset: function(ignoreChangeEvent) {
        if (undo) undo.setAttribute("disabled", true);
        if (redo) redo.setAttribute("disabled", true);
        core._variable.isChanged = false;
        if (core.context.tool.save) core.context.tool.save.setAttribute("disabled", true);
        stack.splice(0);
        stackIndex = 0;
        stack[stackIndex] = {
          contents: core.getContents(true),
          s: {
            path: [0, 0],
            offset: 0
          },
          e: {
            path: [0, 0],
            offset: 0
          }
        };
        if (!ignoreChangeEvent) change();
      },
      /**
       * @description Reset the disabled state of the buttons to fit the current stack.
       * @private
       */
      _resetCachingButton: function() {
        editor = core.context.element;
        undo = core.context.tool.undo;
        redo = core.context.tool.redo;
        if (stackIndex === 0) {
          if (undo) undo.setAttribute("disabled", true);
          if (redo && stackIndex === stack.length - 1) redo.setAttribute("disabled", true);
          core._variable.isChanged = false;
          if (core.context.tool.save) core.context.tool.save.setAttribute("disabled", true);
        } else if (stackIndex === stack.length - 1) {
          if (redo) redo.setAttribute("disabled", true);
        }
      },
      /**
       * @description Remove all stacks and remove the timeout function.
       * @private
       */
      _destroy: function() {
        if (pushDelay) _w.clearTimeout(pushDelay);
        stack = null;
      }
    };
  }

  // ../../node_modules/suneditor/src/plugins/modules/_notice.js
  var notice_default = {
    name: "notice",
    /**
     * @description Constructor
     * @param {Object} core Core object 
     */
    add: function(core) {
      const context = core.context;
      context.notice = {};
      let notice_div = core.util.createElement("DIV");
      let notice_span = core.util.createElement("SPAN");
      let notice_button = core.util.createElement("BUTTON");
      notice_div.className = "se-notice";
      notice_button.className = "close";
      notice_button.setAttribute("aria-label", "Close");
      notice_button.setAttribute("title", core.lang.dialogBox.close);
      notice_button.innerHTML = core.icons.cancel;
      notice_div.appendChild(notice_span);
      notice_div.appendChild(notice_button);
      context.notice.modal = notice_div;
      context.notice.message = notice_span;
      notice_button.addEventListener("click", this.onClick_cancel.bind(core));
      context.element.editorArea.appendChild(notice_div);
      notice_div = null;
    },
    /**
     * @description Event when clicking the cancel button
     * @param {MouseEvent} e Event object
     */
    onClick_cancel: function(e) {
      e.preventDefault();
      e.stopPropagation();
      this.plugins.notice.close.call(this);
    },
    /**
     * @description  Open the notice panel
     * @param {String} text Notice message
     */
    open: function(text) {
      this.context.notice.message.textContent = text;
      this.context.notice.modal.style.display = "block";
    },
    /**
     * @description  Open the notice panel
     */
    close: function() {
      this.context.notice.modal.style.display = "none";
    }
  };

  // ../../node_modules/suneditor/src/lib/core.js
  function core_default(context, pluginCallButtons, plugins, lang, options2, _responsiveButtons) {
    const _d = context.element.originElement.ownerDocument || document;
    const _w = _d.defaultView || window;
    const util2 = util_default;
    const icons = options2.icons;
    const core = {
      _d,
      _w,
      _parser: new _w.DOMParser(),
      _prevRtl: options2.rtl,
      _editorHeight: 0,
      _editorHeightPadding: 0,
      _listCamel: options2.__listCommonStyle,
      _listKebab: util2.camelToKebabCase(options2.__listCommonStyle),
      __focusTemp: context.element._focusTemp,
      /**
       * @description Document object of the iframe if created as an iframe || _d
       * @private
       */
      _wd: null,
      /**
       * @description Window object of the iframe if created as an iframe || _w
       * @private
       */
      _ww: null,
      /**
       * @description Closest ShadowRoot to editor if found
       * @private
       */
      _shadowRoot: null,
      /**
       * @description Block controller mousedown events in "shadowRoot" environment
       * @private
       */
      _shadowRootControllerEventTarget: null,
      /**
       * @description Util object
       */
      util: util2,
      /**
       * @description Functions object
       */
      functions: null,
      /**
       * @description Editor options
       */
      options: null,
      /**
       * @description Computed style of the wysiwyg area (window.getComputedStyle(context.element.wysiwyg))
       */
      wwComputedStyle: null,
      /**
       * @description Notice object
       */
      notice: notice_default,
      /**
       * @description Default icons object
       */
      icons,
      /**
       * @description History object for undo, redo
       */
      history: null,
      /**
       * @description Elements and user options parameters of the suneditor
       */
      context,
      /**
       * @description Plugin buttons
       */
      pluginCallButtons,
      /**
       * @description Loaded plugins
       */
      plugins: plugins || {},
      /**
       * @description Whether the plugin is initialized
       */
      initPlugins: {},
      /**
       * @description Object for managing submenu elements
       * @private
       */
      _targetPlugins: {},
      /**
       * @description Save rendered submenus and containers
       * @private
       */
      _menuTray: {},
      /**
       * @description loaded language
       */
      lang,
      /**
       * @description The selection node (core.getSelectionNode()) to which the effect was last applied
       */
      effectNode: null,
      /**
       * @description submenu element
       */
      submenu: null,
      /**
       * @description container element
       */
      container: null,
      /**
       * @description current subment name
       * @private
       */
      _submenuName: "",
      /**
       * @description binded submenuOff method
       * @private
       */
      _bindedSubmenuOff: null,
      /**
       * @description binded containerOff method
       * @private
       */
      _bindedContainerOff: null,
      /**
       * @description active button element in submenu
       */
      submenuActiveButton: null,
      /**
       * @description active button element in container
       */
      containerActiveButton: null,
      /**
       * @description The elements array to be processed unvisible when the controllersOff function is executed (resizing, link modified button, table controller)
       */
      controllerArray: [],
      /**
       * @description The name of the plugin that called the currently active controller
       */
      currentControllerName: "",
      /**
       * @description The target element of current controller
       */
      currentControllerTarget: null,
      /**
       * @description The file component object of current selected file tag (getFileComponent)
       */
      currentFileComponentInfo: null,
      /**
       * @description An array of buttons whose class name is not "se-code-view-enabled"
       */
      codeViewDisabledButtons: [],
      /**
       * @description An array of buttons whose class name is not "se-resizing-enabled"
       */
      resizingDisabledButtons: [],
      /**
       * @description active more layer element in submenu
       * @private
       */
      _moreLayerActiveButton: null,
      /**
       * @description Tag whitelist RegExp object used in "_consistencyCheckOfHTML" method
       * ^(options._editorTagsWhitelist)$
       * @private
       */
      _htmlCheckWhitelistRegExp: null,
      /**
       * @description Tag blacklist RegExp object used in "_consistencyCheckOfHTML" method
       * @private
       */
      _htmlCheckBlacklistRegExp: null,
      /**
       * @description RegExp when using check disallowd tags. (b, i, ins, strike, s)
       * @private
       */
      _disallowedTextTagsRegExp: null,
      /**
       * @description Editor tags whitelist (RegExp object)
       * util.createTagsWhitelist(options._editorTagsWhitelist)
       */
      editorTagsWhitelistRegExp: null,
      /**
       * @description Editor tags blacklist (RegExp object)
       * util.createTagsBlacklist(options.tagsBlacklist)
       */
      editorTagsBlacklistRegExp: null,
      /**
       * @description Tag whitelist when pasting (RegExp object)
       * util.createTagsWhitelist(options.pasteTagsWhitelist)
       */
      pasteTagsWhitelistRegExp: null,
      /**
       * @description Tag blacklist when pasting (RegExp object)
       * util.createTagsBlacklist(options.pasteTagsBlacklist)
       */
      pasteTagsBlacklistRegExp: null,
      /**
       * @description Boolean value of whether the editor has focus
       */
      hasFocus: false,
      /**
       * @description Boolean value of whether the editor is disabled
       */
      isDisabled: false,
      /**
       * @description Boolean value of whether the editor is readOnly
       */
      isReadOnly: false,
      /**
       * @description Attributes whitelist used by the cleanHTML method
       * @private
       */
      _attributesWhitelistRegExp: null,
      _attributesWhitelistRegExp_all_data: null,
      /**
       * @description Attributes blacklist used by the cleanHTML method
       * @private
       */
      _attributesBlacklistRegExp: null,
      /**
       * @description Attributes of tags whitelist used by the cleanHTML method
       * @private
       */
      _attributesTagsWhitelist: null,
      /**
       * @description Attributes of tags blacklist used by the cleanHTML method
       * @private
       */
      _attributesTagsBlacklist: null,
      /**
       * @description binded controllersOff method
       * @private
       */
      _bindControllersOff: null,
      /**
       * @description Is inline mode?
       * @private
       */
      _isInline: null,
      /**
       * @description Is balloon|balloon-always mode?
       * @private
       */
      _isBalloon: null,
      /**
       * @description Is balloon-always mode?
       * @private
       */
      _isBalloonAlways: null,
      /**
       * @description Required value when using inline mode to sticky toolbar
       * @private
       */
      _inlineToolbarAttr: { top: "", width: "", isShow: false },
      /**
       * @description Variable that controls the "blur" event in the editor of inline or balloon mode when the focus is moved to submenu
       * @private
       */
      _notHideToolbar: false,
      /**
       * @description Variable value that sticky toolbar mode
       * @private
       */
      _sticky: false,
      /**
       * @description Variables for controlling focus and blur events
       * @private
       */
      _antiBlur: false,
      /**
       * @description Component line breaker element
       * @private
       */
      _lineBreaker: null,
      _lineBreakerButton: null,
      /**
       * @description If true, (initialize, reset) all indexes of image, video information
       * @private
       */
      _componentsInfoInit: true,
      _componentsInfoReset: false,
      /**
       * @description Plugins array with "active" method.
       * "activePlugins" runs the "add" method when creating the editor.
       */
      activePlugins: null,
      /**
       * @description Information of tags that should maintain HTML structure, style, class name, etc. (In use by "math" plugin)
       * When inserting "html" such as paste, it is executed on the "html" to be inserted. (core.cleanHTML)
       * Basic Editor Actions:
       * 1. All classes not starting with "__se__" or "se-" in the editor are removed.
       * 2. The style of all tags except the "span" tag is removed from the editor.
       * "managedTagsInfo" structure ex:
       * managedTagsInfo: {
       *   query: '.__se__xxx, se-xxx'
       *   map: {
       *     '__se__xxx': method.bind(core),
       *     'se-xxx': method.bind(core),
       *   }
       * }
       * @example
       * Define in the following return format in the "managedTagInfo" function of the plugin.
       * managedTagInfo() => {
       *  return {
       *    className: 'string', // Class name to identify the tag. ("__se__xxx", "se-xxx")
       *    // Change the html of the "element". ("element" is the element found with "className".)
       *    // "method" is executed by binding "core".
       *    method: function (element) {
       *      // this === core
       *      element.innerHTML = // (rendered html);
       *    }
       *  }
       * }
       */
      managedTagsInfo: null,
      /**
       * @description cashing: options.charCounterType === 'byte-html'
       * @private
       */
      _charTypeHTML: false,
      /**
       * @description Array of "checkFileInfo" functions with the core bound
       * (Plugins with "checkFileInfo" and "resetFileInfo" methods)
       * "fileInfoPlugins" runs the "add" method when creating the editor.
       * "checkFileInfo" method is always call just before the "change" event.
       * @private
       */
      _fileInfoPluginsCheck: null,
      /**
       * @description Array of "resetFileInfo" functions with the core bound
       * (Plugins with "checkFileInfo" and "resetFileInfo" methods)
       * "checkFileInfo" method is always call just before the "functions.setOptions" method.
       * @private
       */
      _fileInfoPluginsReset: null,
      /**
       * @description Variables for file component management
       * @private
       */
      _fileManager: {
        tags: null,
        regExp: null,
        queryString: null,
        pluginRegExp: null,
        pluginMap: null
      },
      /**
       * @description Elements that need to change text or className for each selection change
       * After creating the editor, "activePlugins" are added.
       * @property {Element} STRONG bold button
       * @property {Element} U underline button
       * @property {Element} EM italic button
       * @property {Element} DEL strike button
       * @property {Element} SUB subscript button
       * @property {Element} SUP superscript button
       * @property {Element} OUTDENT outdent button
       * @property {Element} INDENT indent button
       */
      commandMap: {},
      /**
       * @description CSS properties related to style tags 
       * @private
       */
      _commandMapStyles: {
        STRONG: ["font-weight"],
        U: ["text-decoration"],
        EM: ["font-style"],
        DEL: ["text-decoration"]
      },
      /**
       * @description Style button related to edit area
       * @property {Element} fullScreen fullScreen button element
       * @property {Element} showBlocks showBlocks button element
       * @property {Element} codeView codeView button element
       * @private
       */
      _styleCommandMap: null,
      /**
       * @private
       */
      _cleanStyleRegExp: {
        div: new _w.RegExp("\\s*[^-a-zA-Z](.+)\\s*:[^;]+(?!;)*", "ig"),
        span: new _w.RegExp("\\s*[^-a-zA-Z](font-family|font-size|color|background-color)\\s*:[^;]+(?!;)*", "ig"),
        format: new _w.RegExp("\\s*[^-a-zA-Z](text-align|margin-left|margin-right|width|height|line-height)\\s*:[^;]+(?!;)*", "ig"),
        fontSizeUnit: new _w.RegExp("\\d+" + options2.fontSizeUnit + "$", "i")
      },
      /**
       * @description Variables used internally in editor operation
       * @property {Boolean} isCodeView State of code view
       * @property {Boolean} isFullScreen State of full screen
       * @property {Number} innerHeight_fullScreen InnerHeight in editor when in full screen
       * @property {Number} resizeClientY Remember the vertical size of the editor before resizing the editor (Used when calculating during resize operation)
       * @property {Number} tabSize Indent size of tab (4)
       * @property {Number} codeIndent Indent size of Code view mode (2)
       * @property {Number} minResizingSize Minimum size of editing area when resized {Number} (.se-wrapper-inner {min-height: 65px;} || 65)
       * @property {Array} currentNodes  An array of the current cursor's node structure
       * @private
       */
      _variable: {
        isChanged: false,
        isCodeView: false,
        isFullScreen: false,
        innerHeight_fullScreen: 0,
        resizeClientY: 0,
        tabSize: 4,
        codeIndent: 2,
        minResizingSize: util2.getNumber(context.element.wysiwygFrame.style.minHeight || "65", 0),
        currentNodes: [],
        currentNodesMap: [],
        _range: null,
        _selectionNode: null,
        _originCssText: context.element.topArea.style.cssText,
        _bodyOverflow: "",
        _editorAreaOriginCssText: "",
        _wysiwygOriginCssText: "",
        _codeOriginCssText: "",
        _fullScreenAttrs: { sticky: false, balloon: false, inline: false },
        _lineBreakComp: null,
        _lineBreakDir: ""
      },
      /**
       * @description Temp variable for set line attrs
       * @private
       */
      _formatAttrsTemp: null,
      /**
       * @description Save the current buttons states to "allCommandButtons" object
       * @private
       */
      _saveButtonStates: function() {
        if (!this.allCommandButtons) this.allCommandButtons = {};
        const currentButtons = this.context.element._buttonTray.querySelectorAll(".se-menu-list button[data-display]");
        for (let i = 0, element, command; i < currentButtons.length; i++) {
          element = currentButtons[i];
          command = element.getAttribute("data-command");
          this.allCommandButtons[command] = element;
        }
      },
      /**
       * @description Recover the current buttons states from "allCommandButtons" object
       * @private
       */
      _recoverButtonStates: function() {
        if (this.allCommandButtons) {
          const currentButtons = this.context.element._buttonTray.querySelectorAll(".se-menu-list button[data-display]");
          for (let i = 0, button, command, oldButton; i < currentButtons.length; i++) {
            button = currentButtons[i];
            command = button.getAttribute("data-command");
            oldButton = this.allCommandButtons[command];
            if (oldButton) {
              button.parentElement.replaceChild(oldButton, button);
              if (this.context.tool[command]) this.context.tool[command] = oldButton;
            }
          }
        }
      },
      /**
       * @description If the plugin is not added, add the plugin and call the 'add' function.
       * If the plugin is added call callBack function.
       * @param {String} pluginName The name of the plugin to call
       * @param {function} callBackFunction Function to be executed immediately after module call
       * @param {Element|null} _target Plugin target button (This is not necessary if you have a button list when creating the editor)
       */
      callPlugin: function(pluginName, callBackFunction, _target) {
        _target = _target || pluginCallButtons[pluginName];
        if (!this.plugins[pluginName]) {
          throw Error('[SUNEDITOR.core.callPlugin.fail] The called plugin does not exist or is in an invalid format. (pluginName:"' + pluginName + '")');
        } else if (!this.initPlugins[pluginName]) {
          this.plugins[pluginName].add(this, _target);
          this.initPlugins[pluginName] = true;
        } else if (typeof this._targetPlugins[pluginName] === "object" && !!_target) {
          this.initMenuTarget(pluginName, _target, this._targetPlugins[pluginName]);
        }
        if (this.plugins[pluginName].active && !this.commandMap[pluginName] && !!_target) {
          this.commandMap[pluginName] = _target;
          this.activePlugins.push(pluginName);
        }
        if (typeof callBackFunction === "function") callBackFunction();
      },
      /**
       * @description If the module is not added, add the module and call the 'add' function
       * @param {Array} moduleArray module object's Array [dialog, resizing]
       */
      addModule: function(moduleArray) {
        for (let i = 0, len = moduleArray.length, moduleName; i < len; i++) {
          moduleName = moduleArray[i].name;
          if (!this.plugins[moduleName]) {
            this.plugins[moduleName] = moduleArray[i];
          }
          if (!this.initPlugins[moduleName]) {
            this.initPlugins[moduleName] = true;
            if (typeof this.plugins[moduleName].add === "function") this.plugins[moduleName].add(this);
          }
        }
      },
      /**
       * @description Gets the current editor-relative scroll offset.
       * @returns {Object} {top, left}
       */
      getGlobalScrollOffset: function() {
        let t = 0, l = 0;
        let el = context.element.topArea;
        while (el) {
          t += el.scrollTop;
          l += el.scrollLeft;
          el = el.parentElement;
        }
        el = this._shadowRoot ? this._shadowRoot.host : null;
        while (el) {
          t += el.scrollTop;
          l += el.scrollLeft;
          el = el.parentElement;
        }
        return {
          top: t,
          left: l
        };
      },
      /**
       * @description Method for managing submenu element.
       * You must add the "submenu" element using the this method at custom plugin.
       * @param {String} pluginName Plugin name
       * @param {Element|null} target Target button
       * @param {Element} menu Submenu element
       */
      initMenuTarget: function(pluginName, target, menu) {
        if (!target) {
          this._targetPlugins[pluginName] = menu;
        } else {
          context.element._menuTray.appendChild(menu);
          this._targetPlugins[pluginName] = true;
          this._menuTray[target.getAttribute("data-command")] = menu;
        }
      },
      /**
       * @description Enable submenu
       * @param {Element} element Submenu's button element to call
       */
      submenuOn: function(element) {
        if (this._bindedSubmenuOff) this._bindedSubmenuOff();
        if (this._bindControllersOff) this.controllersOff();
        const submenuName = this._submenuName = element.getAttribute("data-command");
        const menu = this.submenu = this._menuTray[submenuName];
        this.submenuActiveButton = element;
        this._setMenuPosition(element, menu);
        this._bindedSubmenuOff = this.submenuOff.bind(this);
        this.addDocEvent("mousedown", this._bindedSubmenuOff, false);
        if (this.plugins[submenuName].on) this.plugins[submenuName].on.call(this);
        this._antiBlur = true;
      },
      /**
       * @description Disable submenu
       */
      submenuOff: function() {
        this.removeDocEvent("mousedown", this._bindedSubmenuOff);
        this._bindedSubmenuOff = null;
        if (this.submenu) {
          this._submenuName = "";
          this.submenu.style.display = "none";
          this.submenu = null;
          util2.removeClass(this.submenuActiveButton, "on");
          this.submenuActiveButton = null;
          this._notHideToolbar = false;
        }
        this._antiBlur = false;
      },
      /**
       * @description Disable more layer
       */
      moreLayerOff: function() {
        if (this._moreLayerActiveButton) {
          const layer = context.element.toolbar.querySelector("." + this._moreLayerActiveButton.getAttribute("data-command"));
          layer.style.display = "none";
          util2.removeClass(this._moreLayerActiveButton, "on");
          this._moreLayerActiveButton = null;
        }
      },
      /**
       * @description Enable container
       * @param {Element} element Container's button element to call
       */
      containerOn: function(element) {
        if (this._bindedContainerOff) this._bindedContainerOff();
        const containerName = this._containerName = element.getAttribute("data-command");
        const menu = this.container = this._menuTray[containerName];
        this.containerActiveButton = element;
        this._setMenuPosition(element, menu);
        this._bindedContainerOff = this.containerOff.bind(this);
        this.addDocEvent("mousedown", this._bindedContainerOff, false);
        if (this.plugins[containerName].on) this.plugins[containerName].on.call(this);
        this._antiBlur = true;
      },
      /**
       * @description Disable container
       */
      containerOff: function() {
        this.removeDocEvent("mousedown", this._bindedContainerOff);
        this._bindedContainerOff = null;
        if (this.container) {
          this._containerName = "";
          this.container.style.display = "none";
          this.container = null;
          util2.removeClass(this.containerActiveButton, "on");
          this.containerActiveButton = null;
          this._notHideToolbar = false;
        }
        this._antiBlur = false;
      },
      /**
       * @description Set the menu position. (submenu, container)
       * @param {*} element Button element
       * @param {*} menu Menu element
       * @private
       */
      _setMenuPosition: function(element, menu) {
        menu.style.visibility = "hidden";
        menu.style.display = "block";
        menu.style.height = "";
        util2.addClass(element, "on");
        const toolbar = this.context.element.toolbar;
        const toolbarW = toolbar.offsetWidth;
        const toolbarOffset = event._getEditorOffsets(context.element.toolbar);
        const menuW = menu.offsetWidth;
        const l = element.parentElement.offsetLeft + 3;
        if (options2.rtl) {
          const elementW = element.offsetWidth;
          const rtlW = menuW > elementW ? menuW - elementW : 0;
          const rtlL = rtlW > 0 ? 0 : elementW - menuW;
          menu.style.left = l - rtlW + rtlL + "px";
          if (toolbarOffset.left > event._getEditorOffsets(menu).left) {
            menu.style.left = "0px";
          }
        } else {
          const overLeft = toolbarW <= menuW ? 0 : toolbarW - (l + menuW);
          if (overLeft < 0) menu.style.left = l + overLeft + "px";
          else menu.style.left = l + "px";
        }
        let t = 0;
        let offsetEl = element;
        while (offsetEl && offsetEl !== toolbar) {
          t += offsetEl.offsetTop;
          offsetEl = offsetEl.offsetParent;
        }
        const bt = t;
        if (this._isBalloon) {
          t += toolbar.offsetTop + element.offsetHeight;
        } else {
          t -= element.offsetHeight;
        }
        const toolbarTop = toolbarOffset.top;
        const menuHeight = menu.offsetHeight;
        const scrollTop = this.getGlobalScrollOffset().top;
        const menuHeight_bottom = _w.innerHeight - (toolbarTop - scrollTop + bt + element.parentElement.offsetHeight);
        if (menuHeight_bottom < menuHeight) {
          let menuTop = -1 * (menuHeight - bt + 3);
          const insTop = toolbarTop - scrollTop + menuTop;
          const menuHeight_top = menuHeight + (insTop < 0 ? insTop : 0);
          if (menuHeight_top > menuHeight_bottom) {
            menu.style.height = menuHeight_top + "px";
            menuTop = -1 * (menuHeight_top - bt + 3);
          } else {
            menu.style.height = menuHeight_bottom + "px";
            menuTop = bt + element.parentElement.offsetHeight;
          }
          menu.style.top = menuTop + "px";
        } else {
          menu.style.top = bt + element.parentElement.offsetHeight + "px";
        }
        menu.style.visibility = "";
      },
      /**
       * @description Show controller at editor area (controller elements, function, "controller target element(@Required)", "controller name(@Required)", etc..)
       * @param {*} arguments controller elements, functions..
       */
      controllersOn: function() {
        if (this._bindControllersOff) this._bindControllersOff();
        this.controllerArray = [];
        for (let i = 0, arg; i < arguments.length; i++) {
          arg = arguments[i];
          if (!arg) continue;
          if (typeof arg === "string") {
            this.currentControllerName = arg;
            continue;
          }
          if (typeof arg === "function") {
            this.controllerArray.push(arg);
            continue;
          }
          if (!util2.hasClass(arg, "se-controller")) {
            this.currentControllerTarget = arg;
            this.currentFileComponentInfo = this.getFileComponent(arg);
            continue;
          }
          if (arg.style) {
            arg.style.display = "block";
            if (this._shadowRoot && this._shadowRootControllerEventTarget.indexOf(arg) === -1) {
              arg.addEventListener("mousedown", function(e) {
                e.preventDefault();
                e.stopPropagation();
              });
              this._shadowRootControllerEventTarget.push(arg);
            }
          }
          this.controllerArray.push(arg);
        }
        this._bindControllersOff = this.controllersOff.bind(this);
        this.addDocEvent("mousedown", this._bindControllersOff, false);
        this.addDocEvent("keydown", this._bindControllersOff, false);
        this._antiBlur = true;
        if (typeof functions.showController === "function") functions.showController(this.currentControllerName, this.controllerArray, this);
      },
      /**
       * @description Hide controller at editor area (link button, image resize button..)
       * @param {KeyboardEvent|MouseEvent|null} e Event object when called from mousedown and keydown events registered in "core.controllersOn"
       */
      controllersOff: function(e) {
        this._lineBreaker.style.display = "none";
        const len = this.controllerArray.length;
        if (e && e.target && len > 0) {
          for (let i = 0; i < len; i++) {
            if (typeof this.controllerArray[i].contains === "function" && this.controllerArray[i].contains(e.target)) return;
          }
        }
        if (this._fileManager.pluginRegExp.test(this.currentControllerName) && e && e.type === "keydown" && e.keyCode !== 27) return;
        context.element.lineBreaker_t.style.display = context.element.lineBreaker_b.style.display = "none";
        this._variable._lineBreakComp = null;
        this.currentControllerName = "";
        this.currentControllerTarget = null;
        this.currentFileComponentInfo = null;
        this.effectNode = null;
        if (!this._bindControllersOff) return;
        this.removeDocEvent("mousedown", this._bindControllersOff);
        this.removeDocEvent("keydown", this._bindControllersOff);
        this._bindControllersOff = null;
        if (len > 0) {
          for (let i = 0; i < len; i++) {
            if (typeof this.controllerArray[i] === "function") this.controllerArray[i]();
            else this.controllerArray[i].style.display = "none";
          }
          this.controllerArray = [];
        }
        this._antiBlur = false;
      },
      /**
       * @description Specify the position of the controller.
       * @param {Element} controller Controller element.
       * @param {Element} referEl Element that is the basis of the controller's position.
       * @param {String} position Type of position ("top" | "bottom")
       * When using the "top" position, there should not be an arrow on the controller.
       * When using the "bottom" position there should be an arrow on the controller.
       * @param {Object} addOffset These are the left and top values that need to be added specially. 
       * This argument is required. - {left: 0, top: 0}
       * Please enter the value based on ltr mode.
       * Calculated automatically in rtl mode.
       */
      setControllerPosition: function(controller, referEl, position, addOffset) {
        if (options2.rtl) addOffset.left *= -1;
        const offset = util2.getOffset(referEl, context.element.wysiwygFrame);
        controller.style.visibility = "hidden";
        controller.style.display = "block";
        const topMargin = position === "top" ? -(controller.offsetHeight + 2) : referEl.offsetHeight + 12;
        controller.style.top = offset.top + topMargin + addOffset.top + "px";
        const l = offset.left - context.element.wysiwygFrame.scrollLeft + addOffset.left;
        const controllerW = controller.offsetWidth;
        const referElW = referEl.offsetWidth;
        const allow = util2.hasClass(controller.firstElementChild, "se-arrow") ? controller.firstElementChild : null;
        if (options2.rtl) {
          const rtlW = controllerW > referElW ? controllerW - referElW : 0;
          const rtlL = rtlW > 0 ? 0 : referElW - controllerW;
          controller.style.left = l - rtlW + rtlL + "px";
          if (rtlW > 0) {
            if (allow) allow.style.left = (controllerW - 14 < 10 + rtlW ? controllerW - 14 : 10 + rtlW) + "px";
          }
          const overSize = context.element.wysiwygFrame.offsetLeft - controller.offsetLeft;
          if (overSize > 0) {
            controller.style.left = "0px";
            if (allow) allow.style.left = overSize + "px";
          }
        } else {
          controller.style.left = l + "px";
          const overSize = context.element.wysiwygFrame.offsetWidth - (controller.offsetLeft + controllerW);
          if (overSize < 0) {
            controller.style.left = controller.offsetLeft + overSize + "px";
            if (allow) allow.style.left = 20 - overSize + "px";
          } else {
            if (allow) allow.style.left = "20px";
          }
        }
        controller.style.visibility = "";
      },
      /**
       * @description javascript execCommand
       * @param {String} command javascript execCommand function property
       * @param {Boolean|undefined} showDefaultUI javascript execCommand function property
       * @param {String|undefined} value javascript execCommand function property
       */
      execCommand: function(command, showDefaultUI, value) {
        this._wd.execCommand(command, showDefaultUI, command === "formatBlock" ? "<" + value + ">" : value);
        this.history.push(true);
      },
      /**
       * @description Focus to wysiwyg area using "native focus function"
       */
      nativeFocus: function() {
        this.__focus();
        this._editorRange();
      },
      /**
       * @description Focus method
       * @private
       */
      __focus: function() {
        const caption = util2.getParentElement(this.getSelectionNode(), "figcaption");
        if (caption) {
          caption.focus();
        } else {
          context.element.wysiwyg.focus();
        }
      },
      /**
       * @description Focus to wysiwyg area
       */
      focus: function() {
        if (context.element.wysiwygFrame.style.display === "none") return;
        if (options2.iframe) {
          this.nativeFocus();
        } else {
          try {
            const range = this.getRange();
            if (range.startContainer === range.endContainer && util2.isWysiwygDiv(range.startContainer)) {
              const currentNode = range.commonAncestorContainer.children[range.startOffset];
              if (!util2.isFormatElement(currentNode) && !util2.isComponent(currentNode)) {
                const format = util2.createElement(options2.defaultTag);
                const br2 = util2.createElement("BR");
                format.appendChild(br2);
                context.element.wysiwyg.insertBefore(format, currentNode);
                this.setRange(br2, 0, br2, 0);
                return;
              }
            }
            this.setRange(range.startContainer, range.startOffset, range.endContainer, range.endOffset);
          } catch (e) {
            this.nativeFocus();
          }
        }
        event._applyTagEffects();
        if (this._isBalloon) event._toggleToolbarBalloon();
      },
      /**
       * @description If "focusEl" is a component, then that component is selected; if it is a format element, the last text is selected
       * If "focusEdge" is null, then selected last element
       * @param {Element|null} focusEl Focus element
       */
      focusEdge: function(focusEl) {
        if (!focusEl) focusEl = context.element.wysiwyg.lastElementChild;
        const fileComponentInfo = this.getFileComponent(focusEl);
        if (fileComponentInfo) {
          this.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName);
        } else if (focusEl) {
          focusEl = util2.getChildElement(focusEl, function(current) {
            return current.childNodes.length === 0 || current.nodeType === 3;
          }, true);
          if (!focusEl) this.nativeFocus();
          else this.setRange(focusEl, focusEl.textContent.length, focusEl, focusEl.textContent.length);
        } else {
          this.focus();
        }
      },
      /**
       * @description Focusout to wysiwyg area (.blur())
       */
      blur: function() {
        if (options2.iframe) {
          context.element.wysiwygFrame.blur();
        } else {
          context.element.wysiwyg.blur();
        }
      },
      /**
       * @description Set current editor's range object and return.
       * @param {Node} startCon The startContainer property of the selection object.
       * @param {Number} startOff The startOffset property of the selection object.
       * @param {Node} endCon The endContainer property of the selection object.
       * @param {Number} endOff The endOffset property of the selection object.
       * @returns {Object} Range object.
       */
      setRange: function(startCon, startOff, endCon, endOff) {
        if (!startCon || !endCon) return;
        if (startOff > startCon.textContent.length) startOff = startCon.textContent.length;
        if (endOff > endCon.textContent.length) endOff = endCon.textContent.length;
        if (util2.isFormatElement(startCon)) {
          startCon = startCon.childNodes[startOff] || startCon.childNodes[startOff - 1] || startCon;
          startOff = startOff > 0 ? startCon.nodeType === 1 ? 1 : startCon.textContent ? startCon.textContent.length : 0 : 0;
        }
        if (util2.isFormatElement(endCon)) {
          endCon = endCon.childNodes[endOff] || endCon.childNodes[endOff - 1] || endCon;
          endOff = endOff > 0 ? endCon.nodeType === 1 ? 1 : endCon.textContent ? endCon.textContent.length : 0 : 0;
        }
        const range = this._wd.createRange();
        try {
          range.setStart(startCon, startOff);
          range.setEnd(endCon, endOff);
        } catch (error) {
          console.warn("[SUNEDITOR.core.focus.error] " + error);
          this.nativeFocus();
          return;
        }
        const selection = this.getSelection();
        if (selection.removeAllRanges) {
          selection.removeAllRanges();
        }
        selection.addRange(range);
        this._rangeInfo(range, this.getSelection());
        if (options2.iframe) this.__focus();
        return range;
      },
      /**
       * @description Remove range object and button effect
       */
      removeRange: function() {
        this._variable._range = null;
        this._variable._selectionNode = null;
        if (this.hasFocus) this.getSelection().removeAllRanges();
        this._setKeyEffect([]);
      },
      /**
       * @description Get current editor's range object
       * @returns {Object}
       */
      getRange: function() {
        const range = this._variable._range || this._createDefaultRange();
        const selection = this.getSelection();
        if (range.collapsed === selection.isCollapsed || !context.element.wysiwyg.contains(selection.focusNode)) return range;
        if (selection.rangeCount > 0) {
          this._variable._range = selection.getRangeAt(0);
          return this._variable._range;
        } else {
          const sc = selection.anchorNode, ec = selection.focusNode, so = selection.anchorOffset, eo = selection.focusOffset;
          const compareValue = util2.compareElements(sc, ec);
          const rightDir = compareValue.ancestor && (compareValue.result === 0 ? so <= eo : compareValue.result > 1 ? true : false);
          return this.setRange(
            rightDir ? sc : ec,
            rightDir ? so : eo,
            rightDir ? ec : sc,
            rightDir ? eo : so
          );
        }
      },
      /**
       * @description If the "range" object is a non-editable area, add a line at the top of the editor and update the "range" object.
       * Returns a new "range" or argument "range".
       * @param {Object} range core.getRange()
       * @param {Element|null} container If there is "container" argument, it creates a line in front of the container.
       * @returns {Object} range
       */
      getRange_addLine: function(range, container) {
        if (this._selectionVoid(range)) {
          const wysiwyg = context.element.wysiwyg;
          const op = util2.createElement(options2.defaultTag);
          op.innerHTML = "<br>";
          wysiwyg.insertBefore(op, container && container !== wysiwyg ? container.nextElementSibling : wysiwyg.firstElementChild);
          this.setRange(op.firstElementChild, 0, op.firstElementChild, 1);
          range = this._variable._range;
        }
        return range;
      },
      /**
       * @description Get window selection obejct
       * @returns {Object}
       */
      getSelection: function() {
        const selection = this._shadowRoot && this._shadowRoot.getSelection ? this._shadowRoot.getSelection() : this._ww.getSelection();
        if (!this._variable._range && !context.element.wysiwyg.contains(selection.focusNode)) {
          selection.removeAllRanges();
          selection.addRange(this._createDefaultRange());
        }
        return selection;
      },
      /**
       * @description Get current select node
       * @returns {Node}
       */
      getSelectionNode: function() {
        if (!context.element.wysiwyg.contains(this._variable._selectionNode)) this._editorRange();
        if (!this._variable._selectionNode) {
          const selectionNode = util2.getChildElement(context.element.wysiwyg.firstChild, function(current) {
            return current.childNodes.length === 0 || current.nodeType === 3;
          }, false);
          if (!selectionNode) {
            this._editorRange();
          } else {
            this._variable._selectionNode = selectionNode;
            return selectionNode;
          }
        }
        return this._variable._selectionNode;
      },
      /**
       * @description Saving the range object and the currently selected node of editor
       * @private
       */
      _editorRange: function() {
        const activeEl = this._wd.activeElement;
        if (util2.isInputElement(activeEl)) {
          this._variable._selectionNode = activeEl;
          return activeEl;
        }
        const selection = this.getSelection();
        if (!selection) return null;
        let range = null;
        if (selection.rangeCount > 0) {
          range = selection.getRangeAt(0);
        } else {
          range = this._createDefaultRange();
        }
        this._rangeInfo(range, selection);
      },
      /**
       * @description Set "range" and "selection" info.
       * @param {Object} range range object.
       * @param {Object} selection selection object.
       */
      _rangeInfo: function(range, selection) {
        let selectionNode = null;
        this._variable._range = range;
        if (range.collapsed) {
          if (util2.isWysiwygDiv(range.commonAncestorContainer)) selectionNode = range.commonAncestorContainer.children[range.startOffset] || range.commonAncestorContainer;
          else selectionNode = range.commonAncestorContainer;
        } else {
          selectionNode = selection.extentNode || selection.anchorNode;
        }
        this._variable._selectionNode = selectionNode;
      },
      /**
       * @description Return the range object of editor's first child node
       * @returns {Object}
       * @private
       */
      _createDefaultRange: function() {
        const wysiwyg = context.element.wysiwyg;
        const range = this._wd.createRange();
        let firstFormat = wysiwyg.firstElementChild;
        let focusEl = null;
        if (!firstFormat) {
          firstFormat = util2.createElement(options2.defaultTag);
          focusEl = util2.createElement("BR");
          firstFormat.appendChild(focusEl);
          wysiwyg.appendChild(firstFormat);
        } else {
          focusEl = firstFormat.firstChild;
          if (!focusEl) {
            focusEl = util2.createElement("BR");
            firstFormat.appendChild(focusEl);
          }
        }
        range.setStart(focusEl, 0);
        range.setEnd(focusEl, 0);
        return range;
      },
      /**
       * @description Returns true if there is no valid "selection".
       * @param {Object} range core.getRange()
       * @returns {Object} range
       * @private
       */
      _selectionVoid: function(range) {
        const comm = range.commonAncestorContainer;
        return util2.isWysiwygDiv(range.startContainer) && util2.isWysiwygDiv(range.endContainer) || /FIGURE/i.test(comm.nodeName) || this._fileManager.regExp.test(comm.nodeName) || util2.isMediaComponent(comm);
      },
      /**
       * @description Reset range object to text node selected status.
       * @returns {Boolean} Returns false if there is no valid selection.
       * @private
       */
      _resetRangeToTextNode: function() {
        const range = this.getRange();
        if (this._selectionVoid(range)) return false;
        let startCon = range.startContainer;
        let startOff = range.startOffset;
        let endCon = range.endContainer;
        let endOff = range.endOffset;
        let tempCon, tempOffset, tempChild;
        if (util2.isFormatElement(startCon)) {
          if (!startCon.childNodes[startOff]) {
            startCon = startCon.lastChild || startCon;
            startOff = startCon.textContent.length;
          } else {
            startCon = startCon.childNodes[startOff] || startCon;
            startOff = 0;
          }
          while (startCon && startCon.nodeType === 1 && startCon.firstChild) {
            startCon = startCon.firstChild || startCon;
            startOff = 0;
          }
        }
        if (util2.isFormatElement(endCon)) {
          endCon = endCon.childNodes[endOff] || endCon.lastChild || endCon;
          while (endCon && endCon.nodeType === 1 && endCon.lastChild) {
            endCon = endCon.lastChild;
          }
          endOff = endCon.textContent.length;
        }
        tempCon = util2.isWysiwygDiv(startCon) ? context.element.wysiwyg.firstChild : startCon;
        tempOffset = startOff;
        if (util2.isBreak(tempCon) || tempCon.nodeType === 1 && tempCon.childNodes.length > 0) {
          const onlyBreak = util2.isBreak(tempCon);
          if (!onlyBreak) {
            while (tempCon && !util2.isBreak(tempCon) && tempCon.nodeType === 1) {
              tempCon = tempCon.childNodes[tempOffset] || tempCon.nextElementSibling || tempCon.nextSibling;
              tempOffset = 0;
            }
            let format = util2.getFormatElement(tempCon, null);
            if (format === util2.getRangeFormatElement(format, null)) {
              format = util2.createElement(util2.getParentElement(tempCon, util2.isCell) ? "DIV" : options2.defaultTag);
              tempCon.parentNode.insertBefore(format, tempCon);
              format.appendChild(tempCon);
            }
          }
          if (util2.isBreak(tempCon)) {
            const emptyText = util2.createTextNode(util2.zeroWidthSpace);
            tempCon.parentNode.insertBefore(emptyText, tempCon);
            tempCon = emptyText;
            if (onlyBreak) {
              if (startCon === endCon) {
                endCon = tempCon;
                endOff = 1;
              }
            }
          }
        }
        startCon = tempCon;
        startOff = tempOffset;
        tempCon = util2.isWysiwygDiv(endCon) ? context.element.wysiwyg.lastChild : endCon;
        tempOffset = endOff;
        if (util2.isBreak(tempCon) || tempCon.nodeType === 1 && tempCon.childNodes.length > 0) {
          const onlyBreak = util2.isBreak(tempCon);
          if (!onlyBreak) {
            while (tempCon && !util2.isBreak(tempCon) && tempCon.nodeType === 1) {
              tempChild = tempCon.childNodes;
              if (tempChild.length === 0) break;
              tempCon = tempChild[tempOffset > 0 ? tempOffset - 1 : tempOffset] || !/FIGURE/i.test(tempChild[0].nodeName) ? tempChild[0] : tempCon.previousElementSibling || tempCon.previousSibling || startCon;
              tempOffset = tempOffset > 0 ? tempCon.textContent.length : tempOffset;
            }
            let format = util2.getFormatElement(tempCon, null);
            if (format === util2.getRangeFormatElement(format, null)) {
              format = util2.createElement(util2.isCell(format) ? "DIV" : options2.defaultTag);
              tempCon.parentNode.insertBefore(format, tempCon);
              format.appendChild(tempCon);
            }
          }
          if (util2.isBreak(tempCon)) {
            const emptyText = util2.createTextNode(util2.zeroWidthSpace);
            tempCon.parentNode.insertBefore(emptyText, tempCon);
            tempCon = emptyText;
            tempOffset = 1;
            if (onlyBreak && !tempCon.previousSibling) {
              util2.removeItem(endCon);
            }
          }
        }
        endCon = tempCon;
        endOff = tempOffset;
        this.setRange(startCon, startOff, endCon, endOff);
        return true;
      },
      /**
       * @description Returns a "formatElement"(util.isFormatElement) array from the currently selected range.
       * @param {Function|null} validation The validation function. (Replaces the default validation function-util.isFormatElement(current))
       * @returns {Array}
       */
      getSelectedElements: function(validation) {
        if (!this._resetRangeToTextNode()) return [];
        let range = this.getRange();
        if (util2.isWysiwygDiv(range.startContainer)) {
          const children2 = context.element.wysiwyg.children;
          if (children2.length === 0) return [];
          this.setRange(children2[0], 0, children2[children2.length - 1], children2[children2.length - 1].textContent.trim().length);
          range = this.getRange();
        }
        const startCon = range.startContainer;
        const endCon = range.endContainer;
        const commonCon = range.commonAncestorContainer;
        const lineNodes = util2.getListChildren(commonCon, function(current) {
          return validation ? validation(current) : util2.isFormatElement(current);
        });
        if (!util2.isWysiwygDiv(commonCon) && !util2.isRangeFormatElement(commonCon)) lineNodes.unshift(util2.getFormatElement(commonCon, null));
        if (startCon === endCon || lineNodes.length === 1) return lineNodes;
        let startLine = util2.getFormatElement(startCon, null);
        let endLine = util2.getFormatElement(endCon, null);
        let startIdx = null;
        let endIdx = null;
        const onlyTable = function(current) {
          return util2.isTable(current) ? /^TABLE$/i.test(current.nodeName) : true;
        };
        let startRangeEl = util2.getRangeFormatElement(startLine, onlyTable);
        let endRangeEl = util2.getRangeFormatElement(endLine, onlyTable);
        if (util2.isTable(startRangeEl) && util2.isListCell(startRangeEl.parentNode)) startRangeEl = startRangeEl.parentNode;
        if (util2.isTable(endRangeEl) && util2.isListCell(endRangeEl.parentNode)) endRangeEl = endRangeEl.parentNode;
        const sameRange = startRangeEl === endRangeEl;
        for (let i = 0, len = lineNodes.length, line; i < len; i++) {
          line = lineNodes[i];
          if (startLine === line || !sameRange && line === startRangeEl) {
            startIdx = i;
            continue;
          }
          if (endLine === line || !sameRange && line === endRangeEl) {
            endIdx = i;
            break;
          }
        }
        if (startIdx === null) startIdx = 0;
        if (endIdx === null) endIdx = lineNodes.length - 1;
        return lineNodes.slice(startIdx, endIdx + 1);
      },
      /**
       * @description Get format elements and components from the selected area. (P, DIV, H[1-6], OL, UL, TABLE..)
       * If some of the component are included in the selection, get the entire that component.
       * @param {Boolean} removeDuplicate If true, if there is a parent and child tag among the selected elements, the child tag is excluded.
       * @returns {Array}
       */
      getSelectedElementsAndComponents: function(removeDuplicate) {
        const commonCon = this.getRange().commonAncestorContainer;
        const myComponent = util2.getParentElement(commonCon, util2.isComponent);
        const selectedLines = util2.isTable(commonCon) ? this.getSelectedElements(null) : this.getSelectedElements(function(current) {
          const component4 = this.getParentElement(current, this.isComponent);
          return this.isFormatElement(current) && (!component4 || component4 === myComponent) || this.isComponent(current) && !this.getFormatElement(current);
        }.bind(util2));
        if (removeDuplicate) {
          for (let i = 0, len = selectedLines.length; i < len; i++) {
            for (let j = i - 1; j >= 0; j--) {
              if (selectedLines[j].contains(selectedLines[i])) {
                selectedLines.splice(i, 1);
                i--;
                len--;
                break;
              }
            }
          }
        }
        return selectedLines;
      },
      /**
       * @description Determine if this offset is the edge offset of container
       * @param {Node} container The node of the selection object. (range.startContainer..)
       * @param {Number} offset The offset of the selection object. (core.getRange().startOffset...)
       * @param {String|undefined} dir Select check point - Both edge, Front edge or End edge. ("front": Front edge, "end": End edge, undefined: Both edge)
       * @returns {Boolean}
       */
      isEdgePoint: function(container, offset, dir) {
        return dir !== "end" && offset === 0 || (!dir || dir !== "front") && !container.nodeValue && offset === 1 || (!dir || dir === "end") && !!container.nodeValue && offset === container.nodeValue.length;
      },
      /**
       * @description Check if the container and offset values are the edges of the format tag
       * @param {Node} container The node of the selection object. (range.startContainer..)
       * @param {Number} offset The offset of the selection object. (core.getRange().startOffset...)
       * @param {String} dir Select check point - "front": Front edge, "end": End edge, undefined: Both edge.
       * @returns {Array|null}
       * @private
       */
      _isEdgeFormat: function(node, offset, dir) {
        if (!this.isEdgePoint(node, offset, dir)) return false;
        const result = [];
        dir = dir === "front" ? "previousSibling" : "nextSibling";
        while (node && !util2.isFormatElement(node) && !util2.isWysiwygDiv(node)) {
          if (!node[dir] || util2.isBreak(node[dir]) && !node[dir][dir]) {
            if (node.nodeType === 1) result.push(node.cloneNode(false));
            node = node.parentNode;
          } else {
            return null;
          }
        }
        return result;
      },
      /**
       * @description Show loading box
       */
      showLoading: function() {
        context.element.loading.style.display = "block";
      },
      /**
       * @description Close loading box
       */
      closeLoading: function() {
        context.element.loading.style.display = "none";
      },
      /**
       * @description Append format element to sibling node of argument element.
       * If the "formatNodeName" argument value is present, the tag of that argument value is inserted,
       * If not, the currently selected format tag is inserted.
       * @param {Element} element Insert as siblings of that element
       * @param {String|Element|null} formatNode Node name or node obejct to be inserted
       * @returns {Element}
       */
      appendFormatTag: function(element, formatNode) {
        if (!element || !element.parentNode) return null;
        const currentFormatEl = util2.getFormatElement(this.getSelectionNode(), null);
        let oFormat = null;
        if (!util2.isFormatElement(element) && util2.isFreeFormatElement(currentFormatEl || element.parentNode)) {
          oFormat = util2.createElement("BR");
        } else {
          const oFormatName = formatNode ? typeof formatNode === "string" ? formatNode : formatNode.nodeName : util2.isFormatElement(currentFormatEl) && !util2.isRangeFormatElement(currentFormatEl) && !util2.isFreeFormatElement(currentFormatEl) ? currentFormatEl.nodeName : options2.defaultTag;
          oFormat = util2.createElement(oFormatName);
          oFormat.innerHTML = "<br>";
          if (formatNode && typeof formatNode !== "string" || !formatNode && util2.isFormatElement(currentFormatEl)) {
            util2.copyTagAttributes(oFormat, formatNode || currentFormatEl, ["id"]);
          }
        }
        if (util2.isCell(element)) element.insertBefore(oFormat, element.nextElementSibling);
        else element.parentNode.insertBefore(oFormat, element.nextElementSibling);
        return oFormat;
      },
      /**
       * @description The method to insert a element and return. (used elements : table, hr, image, video)
       * If "element" is "HR", insert and return the new line.
       * @param {Element} element Element to be inserted
       * @param {Boolean} notHistoryPush When true, it does not update the history stack and the selection object and return EdgeNodes (util.getEdgeChildNodes)
       * @param {Boolean} checkCharCount If true, if "options.maxCharCount" is exceeded when "element" is added, null is returned without addition.
       * @param {Boolean} notSelect If true, Do not automatically select the inserted component.
       * @returns {Element}
       */
      insertComponent: function(element, notHistoryPush, checkCharCount, notSelect) {
        if (this.isReadOnly || checkCharCount && !this.checkCharCount(element, null)) {
          return null;
        }
        const r = this.removeNode();
        this.getRange_addLine(this.getRange(), r.container);
        let oNode = null;
        let selectionNode = this.getSelectionNode();
        let formatEl = util2.getFormatElement(selectionNode, null);
        if (util2.isListCell(formatEl)) {
          this.insertNode(element, selectionNode === formatEl ? null : r.container.nextSibling, false);
          if (!element.nextSibling) element.parentNode.appendChild(util2.createElement("BR"));
        } else {
          if (this.getRange().collapsed && (r.container.nodeType === 3 || util2.isBreak(r.container))) {
            const depthFormat = util2.getParentElement(r.container, function(current) {
              return this.isRangeFormatElement(current);
            }.bind(util2));
            oNode = util2.splitElement(r.container, r.offset, !depthFormat ? 0 : util2.getElementDepth(depthFormat) + 1);
            if (oNode) formatEl = oNode.previousSibling;
          }
          this.insertNode(element, util2.isRangeFormatElement(formatEl) ? null : formatEl, false);
          if (formatEl && util2.onlyZeroWidthSpace(formatEl)) util2.removeItem(formatEl);
        }
        if (!notSelect) {
          this.setRange(element, 0, element, 0);
          const fileComponentInfo = this.getFileComponent(element);
          if (fileComponentInfo) {
            this.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName);
          } else if (oNode) {
            oNode = util2.getEdgeChildNodes(oNode, null).sc || oNode;
            this.setRange(oNode, 0, oNode, 0);
          }
        }
        if (!notHistoryPush) this.history.push(1);
        return oNode || element;
      },
      /**
       * @description Gets the file component and that plugin name
       * return: {target, component, pluginName} | null
       * @param {Element} element Target element (figure tag, component div, file tag)
       * @returns {Object|null}
       */
      getFileComponent: function(element) {
        if (!this._fileManager.queryString || !element) return null;
        let target, pluginName;
        if (/^FIGURE$/i.test(element.nodeName) || /se-component/.test(element.className)) {
          target = element.querySelector(this._fileManager.queryString);
        }
        if (!target && element.nodeName && this._fileManager.regExp.test(element.nodeName)) {
          target = element;
        }
        if (target) {
          pluginName = this._fileManager.pluginMap[target.nodeName.toLowerCase()];
          if (pluginName) {
            return {
              target,
              component: util2.getParentElement(target, util2.isComponent),
              pluginName
            };
          }
        }
        return null;
      },
      /**
       * @description The component(image, video) is selected and the resizing module is called.
       * @param {Element} element Element tag (img, iframe, video)
       * @param {String} pluginName Plugin name (image, video)
       */
      selectComponent: function(element, pluginName) {
        if (util2.isUneditableComponent(util2.getParentElement(element, util2.isComponent)) || util2.isUneditableComponent(element)) return false;
        if (!this.hasFocus) this.focus();
        const plugin = this.plugins[pluginName];
        if (!plugin) return;
        _w.setTimeout(function() {
          if (typeof plugin.select === "function") this.callPlugin(pluginName, plugin.select.bind(this, element), null);
          this._setComponentLineBreaker(element);
        }.bind(this));
      },
      /**
       * @description Set line breaker of component
       * @param {Element} element Element tag (img, iframe, video)
       * @private
       */
      _setComponentLineBreaker: function(element) {
        this._lineBreaker.style.display = "none";
        const container = util2.getParentElement(element, util2.isComponent);
        const t_style = context.element.lineBreaker_t.style;
        const b_style = context.element.lineBreaker_b.style;
        const target = this.context.resizing.resizeContainer.style.display === "block" ? this.context.resizing.resizeContainer : element;
        const isList = util2.isListCell(container.parentNode);
        let componentTop, wScroll, w;
        if (isList ? !container.previousSibling : !util2.isFormatElement(container.previousElementSibling)) {
          this._variable._lineBreakComp = container;
          wScroll = context.element.wysiwyg.scrollTop;
          componentTop = util2.getOffset(element, context.element.wysiwygFrame).top + wScroll;
          w = target.offsetWidth / 2 / 2;
          t_style.top = componentTop - wScroll - 12 + "px";
          t_style.left = util2.getOffset(target).left + w + "px";
          t_style.display = "block";
        } else {
          t_style.display = "none";
        }
        if (isList ? !container.nextSibling : !util2.isFormatElement(container.nextElementSibling)) {
          if (!componentTop) {
            this._variable._lineBreakComp = container;
            wScroll = context.element.wysiwyg.scrollTop;
            componentTop = util2.getOffset(element, context.element.wysiwygFrame).top + wScroll;
            w = target.offsetWidth / 2 / 2;
          }
          b_style.top = componentTop + target.offsetHeight - wScroll - 12 + "px";
          b_style.left = util2.getOffset(target).left + target.offsetWidth - w - 24 + "px";
          b_style.display = "block";
        } else {
          b_style.display = "none";
        }
      },
      _checkDuplicateNode: function(oNode, parentNode) {
        (function recursionFunc(current) {
          core._dupleCheck(current, parentNode);
          const childNodes = current.childNodes;
          for (let i = 0, len = childNodes.length; i < len; i++) {
            recursionFunc(childNodes[i]);
          }
        })(oNode);
      },
      _dupleCheck: function(oNode, parentNode) {
        if (!util2.isTextStyleElement(oNode)) return;
        const oStyles = (oNode.style.cssText.match(/[^;]+;/g) || []).map(function(v) {
          return v.trim();
        });
        const nodeName = oNode.nodeName;
        if (/^span$/i.test(nodeName) && oStyles.length === 0) return oNode;
        let duple = false;
        (function recursionFunc(ancestor) {
          if (util2.isWysiwygDiv(ancestor) || !util2.isTextStyleElement(ancestor)) return;
          if (ancestor.nodeName === nodeName) {
            duple = true;
            const styles = ancestor.style.cssText.match(/[^;]+;/g) || [];
            for (let i = 0, len = styles.length, j; i < len; i++) {
              if ((j = oStyles.indexOf(styles[i].trim())) > -1) {
                oStyles.splice(j, 1);
              }
            }
            for (let i = 0, len = ancestor.classList.length; i < len; i++) {
              oNode.classList.remove(ancestor.classList[i]);
            }
          }
          recursionFunc(ancestor.parentElement);
        })(parentNode);
        if (duple) {
          if (!(oNode.style.cssText = oStyles.join(" "))) {
            oNode.setAttribute("style", "");
            oNode.removeAttribute("style");
          }
          if (!oNode.attributes.length) {
            oNode.setAttribute("data-se-duple", "true");
          }
        }
        return oNode;
      },
      /**
       * @description Delete selected node and insert argument value node and return.
       * If the "afterNode" exists, it is inserted after the "afterNode"
       * Inserting a text node merges with both text nodes on both sides and returns a new "{ container, startOffset, endOffset }".
       * @param {Node} oNode Element to be inserted
       * @param {Node|null} afterNode If the node exists, it is inserted after the node
       * @param {Boolean} checkCharCount If true, if "options.maxCharCount" is exceeded when "element" is added, null is returned without addition.
       * @returns {Object|Node|null}
       */
      insertNode: function(oNode, afterNode, checkCharCount) {
        if (this.isReadOnly || checkCharCount && !this.checkCharCount(oNode, null)) {
          return null;
        }
        let fNode = null;
        let range = this.getRange();
        let line = util2.isListCell(range.commonAncestorContainer) ? range.commonAncestorContainer : util2.getFormatElement(this.getSelectionNode(), null);
        let insertListCell = util2.isListCell(line) && (util2.isListCell(oNode) || util2.isList(oNode));
        let parentNode, originAfter, tempAfterNode, tempParentNode = null;
        const freeFormat = util2.isFreeFormatElement(line);
        const isFormats = !freeFormat && (util2.isFormatElement(oNode) || util2.isRangeFormatElement(oNode)) || util2.isComponent(oNode);
        if (insertListCell) {
          tempAfterNode = afterNode || util2.isList(oNode) ? line.lastChild : line.nextElementSibling;
          tempParentNode = util2.isList(oNode) ? line : (tempAfterNode || line).parentNode;
        }
        if (!afterNode && (isFormats || util2.isComponent(oNode) || util2.isMedia(oNode))) {
          const isEdge = this.isEdgePoint(range.endContainer, range.endOffset, "end");
          const r = this.removeNode();
          const container = r.container;
          const prevContainer = container === r.prevContainer && range.collapsed ? null : r.prevContainer;
          if (insertListCell && prevContainer) {
            tempParentNode = prevContainer.nodeType === 3 ? prevContainer.parentNode : prevContainer;
            if (tempParentNode.contains(container)) {
              let sameParent = true;
              tempAfterNode = container;
              while (tempAfterNode.parentNode && tempAfterNode.parentNode !== tempParentNode) {
                tempAfterNode = tempAfterNode.parentNode;
                sameParent = false;
              }
              if (sameParent && container === prevContainer) tempAfterNode = tempAfterNode.nextSibling;
            } else {
              tempAfterNode = null;
            }
          } else if (insertListCell && util2.isListCell(container) && !line.parentElement) {
            line = util2.createElement("LI");
            tempParentNode.appendChild(line);
            container.appendChild(tempParentNode);
            tempAfterNode = null;
          } else if (container.nodeType === 3 || util2.isBreak(container) || insertListCell) {
            const depthFormat = util2.getParentElement(container, function(current) {
              return this.isRangeFormatElement(current) || this.isListCell(current);
            }.bind(util2));
            afterNode = util2.splitElement(container, r.offset, !depthFormat ? 0 : util2.getElementDepth(depthFormat) + 1);
            if (!afterNode) {
              tempAfterNode = afterNode = line;
            } else if (insertListCell) {
              if (line.contains(container)) {
                const subList = util2.isList(line.lastElementChild);
                let newCell = null;
                if (!isEdge) {
                  newCell = line.cloneNode(false);
                  newCell.appendChild(afterNode.textContent.trim() ? afterNode : util2.createTextNode(util2.zeroWidthSpace));
                }
                if (subList) {
                  if (!newCell) {
                    newCell = line.cloneNode(false);
                    newCell.appendChild(util2.createTextNode(util2.zeroWidthSpace));
                  }
                  newCell.appendChild(line.lastElementChild);
                }
                if (newCell) {
                  line.parentNode.insertBefore(newCell, line.nextElementSibling);
                  tempAfterNode = afterNode = newCell;
                }
              }
            } else {
              afterNode = afterNode.previousSibling;
            }
          }
        }
        range = !afterNode && !isFormats ? this.getRange_addLine(this.getRange(), null) : this.getRange();
        const commonCon = range.commonAncestorContainer;
        const startOff = range.startOffset;
        const endOff = range.endOffset;
        const formatRange = range.startContainer === commonCon && util2.isFormatElement(commonCon);
        const startCon = formatRange ? commonCon.childNodes[startOff] || commonCon.childNodes[0] || range.startContainer : range.startContainer;
        const endCon = formatRange ? commonCon.childNodes[endOff] || commonCon.childNodes[commonCon.childNodes.length - 1] || range.endContainer : range.endContainer;
        if (!insertListCell) {
          if (!afterNode) {
            parentNode = startCon;
            if (startCon.nodeType === 3) {
              parentNode = startCon.parentNode;
            }
            if (range.collapsed) {
              if (commonCon.nodeType === 3) {
                if (commonCon.textContent.length > endOff) afterNode = commonCon.splitText(endOff);
                else afterNode = commonCon.nextSibling;
              } else {
                if (!util2.isBreak(parentNode)) {
                  let c = parentNode.childNodes[startOff];
                  const focusNode = c && c.nodeType === 3 && util2.onlyZeroWidthSpace(c) && util2.isBreak(c.nextSibling) ? c.nextSibling : c;
                  if (focusNode) {
                    if (!focusNode.nextSibling && util2.isBreak(focusNode)) {
                      parentNode.removeChild(focusNode);
                      afterNode = null;
                    } else {
                      afterNode = util2.isBreak(focusNode) && !util2.isBreak(oNode) ? focusNode : focusNode.nextSibling;
                    }
                  } else {
                    afterNode = null;
                  }
                } else {
                  afterNode = parentNode;
                  parentNode = parentNode.parentNode;
                }
              }
            } else {
              const isSameContainer = startCon === endCon;
              if (isSameContainer) {
                if (this.isEdgePoint(endCon, endOff)) afterNode = endCon.nextSibling;
                else afterNode = endCon.splitText(endOff);
                let removeNode = startCon;
                if (!this.isEdgePoint(startCon, startOff)) removeNode = startCon.splitText(startOff);
                parentNode.removeChild(removeNode);
                if (parentNode.childNodes.length === 0 && isFormats) {
                  parentNode.innerHTML = "<br>";
                }
              } else {
                const removedTag = this.removeNode();
                const container = removedTag.container;
                const prevContainer = removedTag.prevContainer;
                if (container && container.childNodes.length === 0 && isFormats) {
                  if (util2.isFormatElement(container)) {
                    container.innerHTML = "<br>";
                  } else if (util2.isRangeFormatElement(container)) {
                    container.innerHTML = "<" + options2.defaultTag + "><br></" + options2.defaultTag + ">";
                  }
                }
                if (util2.isListCell(container) && oNode.nodeType === 3) {
                  parentNode = container;
                  afterNode = null;
                } else if (!isFormats && prevContainer) {
                  parentNode = prevContainer.nodeType === 3 ? prevContainer.parentNode : prevContainer;
                  if (parentNode.contains(container)) {
                    let sameParent = true;
                    afterNode = container;
                    while (afterNode.parentNode && afterNode.parentNode !== parentNode) {
                      afterNode = afterNode.parentNode;
                      sameParent = false;
                    }
                    if (sameParent && container === prevContainer) afterNode = afterNode.nextSibling;
                  } else {
                    afterNode = null;
                  }
                } else if (util2.isWysiwygDiv(container) && !util2.isFormatElement(oNode)) {
                  parentNode = container.appendChild(util2.createElement(options2.defaultTag));
                  afterNode = null;
                } else {
                  afterNode = isFormats ? endCon : container === prevContainer ? container.nextSibling : container;
                  parentNode = !afterNode || !afterNode.parentNode ? commonCon : afterNode.parentNode;
                }
                while (afterNode && !util2.isFormatElement(afterNode) && afterNode.parentNode !== commonCon) {
                  afterNode = afterNode.parentNode;
                }
              }
            }
          } else {
            parentNode = afterNode.parentNode;
            afterNode = afterNode.nextSibling;
            originAfter = true;
          }
        }
        try {
          if (!insertListCell) {
            if (util2.isWysiwygDiv(afterNode) || parentNode === context.element.wysiwyg.parentNode) {
              parentNode = context.element.wysiwyg;
              afterNode = null;
            }
            if (util2.isFormatElement(oNode) || util2.isRangeFormatElement(oNode) || !util2.isListCell(parentNode) && util2.isComponent(oNode)) {
              const oldParent = parentNode;
              if (util2.isList(afterNode)) {
                parentNode = afterNode;
                afterNode = null;
              } else if (util2.isListCell(afterNode)) {
                parentNode = afterNode.previousElementSibling || afterNode;
              } else if (!originAfter && !afterNode) {
                const r = this.removeNode();
                const container = r.container.nodeType === 3 ? util2.isListCell(util2.getFormatElement(r.container, null)) ? r.container : util2.getFormatElement(r.container, null) || r.container.parentNode : r.container;
                const rangeCon = util2.isWysiwygDiv(container) || util2.isRangeFormatElement(container);
                parentNode = rangeCon ? container : container.parentNode;
                afterNode = rangeCon ? null : container.nextSibling;
              }
              if (oldParent.childNodes.length === 0 && parentNode !== oldParent) util2.removeItem(oldParent);
            }
            if (isFormats && !freeFormat && !util2.isRangeFormatElement(parentNode) && !util2.isListCell(parentNode) && !util2.isWysiwygDiv(parentNode)) {
              afterNode = parentNode.nextElementSibling;
              parentNode = parentNode.parentNode;
            }
            if (util2.isWysiwygDiv(parentNode) && (oNode.nodeType === 3 || util2.isBreak(oNode))) {
              const fomatNode = util2.createElement(options2.defaultTag);
              fomatNode.appendChild(oNode);
              fNode = oNode;
              oNode = fomatNode;
            }
          }
          if (insertListCell) {
            if (!tempParentNode.parentNode) {
              parentNode = context.element.wysiwyg;
              afterNode = null;
            } else {
              parentNode = tempParentNode;
              afterNode = tempAfterNode;
            }
          } else {
            afterNode = parentNode === afterNode ? parentNode.lastChild : afterNode;
          }
          if (util2.isListCell(oNode) && !util2.isList(parentNode)) {
            if (util2.isListCell(parentNode)) {
              afterNode = parentNode.nextElementSibling;
              parentNode = parentNode.parentNode;
            } else {
              const ul = util2.createElement("ol");
              parentNode.insertBefore(ul, afterNode);
              parentNode = ul;
              afterNode = null;
            }
            insertListCell = true;
          }
          this._checkDuplicateNode(oNode, parentNode);
          parentNode.insertBefore(oNode, afterNode);
          if (insertListCell) {
            if (util2.onlyZeroWidthSpace(line.textContent.trim())) {
              util2.removeItem(line);
              oNode = oNode.lastChild;
            } else {
              const chList = util2.getArrayItem(line.children, util2.isList);
              if (chList) {
                if (oNode !== chList) {
                  oNode.appendChild(chList);
                  oNode = chList.previousSibling;
                } else {
                  parentNode.appendChild(oNode);
                  oNode = parentNode;
                }
                if (util2.onlyZeroWidthSpace(line.textContent.trim())) {
                  util2.removeItem(line);
                }
              }
            }
          }
        } catch (error) {
          parentNode.appendChild(oNode);
          console.warn("[SUNEDITOR.insertNode.warn] " + error);
        } finally {
          if (fNode) oNode = fNode;
          const dupleNodes = parentNode.querySelectorAll("[data-se-duple]");
          if (dupleNodes.length > 0) {
            for (let i = 0, len = dupleNodes.length, d, c, ch, parent; i < len; i++) {
              d = dupleNodes[i];
              ch = d.childNodes;
              parent = d.parentNode;
              while (ch[0]) {
                c = ch[0];
                parent.insertBefore(c, d);
              }
              if (d === oNode) oNode = c;
              util2.removeItem(d);
            }
          }
          if ((util2.isFormatElement(oNode) || util2.isComponent(oNode)) && startCon === endCon) {
            const cItem = util2.getFormatElement(commonCon, null);
            if (cItem && cItem.nodeType === 1 && util2.isEmptyLine(cItem)) {
              util2.removeItem(cItem);
            }
          }
          if (freeFormat && (util2.isFormatElement(oNode) || util2.isRangeFormatElement(oNode))) {
            oNode = this._setIntoFreeFormat(oNode);
          }
          if (!util2.isComponent(oNode)) {
            let offset = 1;
            if (oNode.nodeType === 3) {
              offset = oNode.textContent.length;
              this.setRange(oNode, offset, oNode, offset);
            } else if (!util2.isBreak(oNode) && !util2.isListCell(oNode) && util2.isFormatElement(parentNode)) {
              let zeroWidth = null;
              if (!oNode.previousSibling || util2.isBreak(oNode.previousSibling)) {
                zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
                oNode.parentNode.insertBefore(zeroWidth, oNode);
              }
              if (!oNode.nextSibling || util2.isBreak(oNode.nextSibling)) {
                zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
                oNode.parentNode.insertBefore(zeroWidth, oNode.nextSibling);
              }
              if (util2._isIgnoreNodeChange(oNode)) {
                oNode = oNode.nextSibling;
                offset = 0;
              }
            }
            this.setRange(oNode, offset, oNode, offset);
          }
          return oNode;
        }
      },
      _setIntoFreeFormat: function(oNode) {
        const parentNode = oNode.parentNode;
        let oNodeChildren, lastONode;
        while (util2.isFormatElement(oNode) || util2.isRangeFormatElement(oNode)) {
          oNodeChildren = oNode.childNodes;
          lastONode = null;
          while (oNodeChildren[0]) {
            lastONode = oNodeChildren[0];
            if (util2.isFormatElement(lastONode) || util2.isRangeFormatElement(lastONode)) {
              this._setIntoFreeFormat(lastONode);
              if (!oNode.parentNode) break;
              oNodeChildren = oNode.childNodes;
              continue;
            }
            parentNode.insertBefore(lastONode, oNode);
          }
          if (oNode.childNodes.length === 0) util2.removeItem(oNode);
          oNode = util2.createElement("BR");
          parentNode.insertBefore(oNode, lastONode.nextSibling);
        }
        return oNode;
      },
      /**
       * @description Delete the currently selected nodes and reset selection range
       * Returns {container: "the last element after deletion", offset: "offset", prevContainer: "previousElementSibling Of the deleted area"}
       * @returns {Object}
       */
      removeNode: function() {
        this._resetRangeToTextNode();
        const range = this.getRange();
        if (range.startContainer === range.endContainer) {
          const fileComponent = util2.getParentElement(range.startContainer, util2.isMediaComponent);
          if (fileComponent) {
            const br2 = util2.createElement("BR");
            const format = util2.createElement(options2.defaultTag);
            format.appendChild(br2);
            util2.changeElement(fileComponent, format);
            core.setRange(format, 0, format, 0);
            this.history.push(true);
            return {
              container: format,
              offset: 0,
              prevContainer: null
            };
          }
        }
        const isStartEdge = range.startOffset === 0;
        const isEndEdge = core.isEdgePoint(range.endContainer, range.endOffset, "end");
        let prevContainer = null;
        let startPrevEl = null;
        let endNextEl = null;
        if (isStartEdge) {
          startPrevEl = util2.getFormatElement(range.startContainer);
          if (startPrevEl) {
            prevContainer = startPrevEl.previousElementSibling;
            startPrevEl = prevContainer;
          }
        }
        if (isEndEdge) {
          endNextEl = util2.getFormatElement(range.endContainer);
          endNextEl = endNextEl ? endNextEl.nextElementSibling : endNextEl;
        }
        let container, offset = 0;
        let startCon = range.startContainer;
        let endCon = range.endContainer;
        let startOff = range.startOffset;
        let endOff = range.endOffset;
        const commonCon = range.commonAncestorContainer.nodeType === 3 && range.commonAncestorContainer.parentNode === startCon.parentNode ? startCon.parentNode : range.commonAncestorContainer;
        if (commonCon === startCon && commonCon === endCon) {
          startCon = commonCon.children[startOff];
          endCon = commonCon.children[endOff];
          startOff = endOff = 0;
        }
        if (!startCon || !endCon) return {
          container: commonCon,
          offset: 0
        };
        if (startCon === endCon && range.collapsed) {
          if (startCon.textContent && util2.onlyZeroWidthSpace(startCon.textContent.substr(startOff))) {
            return {
              container: startCon,
              offset: startOff,
              prevContainer: startCon && startCon.parentNode ? startCon : null
            };
          }
        }
        let beforeNode = null;
        let afterNode = null;
        const childNodes = util2.getListChildNodes(commonCon, null);
        let startIndex = util2.getArrayIndex(childNodes, startCon);
        let endIndex = util2.getArrayIndex(childNodes, endCon);
        if (childNodes.length > 0 && startIndex > -1 && endIndex > -1) {
          for (let i = startIndex + 1, startNode = startCon; i >= 0; i--) {
            if (childNodes[i] === startNode.parentNode && childNodes[i].firstChild === startNode && startOff === 0) {
              startIndex = i;
              startNode = startNode.parentNode;
            }
          }
          for (let i = endIndex - 1, endNode = endCon; i > startIndex; i--) {
            if (childNodes[i] === endNode.parentNode && childNodes[i].nodeType === 1) {
              childNodes.splice(i, 1);
              endNode = endNode.parentNode;
              --endIndex;
            }
          }
        } else {
          if (childNodes.length === 0) {
            if (util2.isFormatElement(commonCon) || util2.isRangeFormatElement(commonCon) || util2.isWysiwygDiv(commonCon) || util2.isBreak(commonCon) || util2.isMedia(commonCon)) {
              return {
                container: commonCon,
                offset: 0
              };
            } else if (commonCon.nodeType === 3) {
              return {
                container: commonCon,
                offset: endOff
              };
            }
            childNodes.push(commonCon);
            startCon = endCon = commonCon;
          } else {
            startCon = endCon = childNodes[0];
            if (util2.isBreak(startCon) || util2.onlyZeroWidthSpace(startCon)) {
              return {
                container: util2.isMedia(commonCon) ? commonCon : startCon,
                offset: 0
              };
            }
          }
          startIndex = endIndex = 0;
        }
        for (let i = startIndex; i <= endIndex; i++) {
          const item = childNodes[i];
          if (item.length === 0 || item.nodeType === 3 && item.data === void 0) {
            this._nodeRemoveListItem(item);
            continue;
          }
          if (item === startCon) {
            if (startCon.nodeType === 1) {
              if (util2.isComponent(startCon)) continue;
              else beforeNode = util2.createTextNode(startCon.textContent);
            } else {
              if (item === endCon) {
                beforeNode = util2.createTextNode(startCon.substringData(0, startOff) + endCon.substringData(endOff, endCon.length - endOff));
                offset = startOff;
              } else {
                beforeNode = util2.createTextNode(startCon.substringData(0, startOff));
              }
            }
            if (beforeNode.length > 0) {
              startCon.data = beforeNode.data;
            } else {
              this._nodeRemoveListItem(startCon);
            }
            if (item === endCon) break;
            continue;
          }
          if (item === endCon) {
            if (endCon.nodeType === 1) {
              if (util2.isComponent(endCon)) continue;
              else afterNode = util2.createTextNode(endCon.textContent);
            } else {
              afterNode = util2.createTextNode(endCon.substringData(endOff, endCon.length - endOff));
            }
            if (afterNode.length > 0) {
              endCon.data = afterNode.data;
            } else {
              this._nodeRemoveListItem(endCon);
            }
            continue;
          }
          this._nodeRemoveListItem(item);
        }
        const endUl = util2.getParentElement(endCon, "ul");
        const startLi = util2.getParentElement(startCon, "li");
        if (endUl && startLi && startLi.contains(endUl)) {
          container = endUl.previousSibling;
          offset = container.textContent.length;
        } else {
          container = endCon && endCon.parentNode ? endCon : startCon && startCon.parentNode ? startCon : range.endContainer || range.startContainer;
          offset = !isStartEdge && !isEndEdge ? offset : isEndEdge ? container.textContent.length : 0;
        }
        if (!util2.isWysiwygDiv(container) && container.childNodes.length === 0) {
          const rc = util2.removeItemAllParents(container, null, null);
          if (rc) container = rc.sc || rc.ec || context.element.wysiwyg;
        }
        if (!util2.getFormatElement(container) && !(startCon && startCon.parentNode)) {
          if (endNextEl) {
            container = endNextEl;
            offset = 0;
          } else if (startPrevEl) {
            container = startPrevEl;
            offset = 1;
          }
        }
        this.setRange(container, offset, container, offset);
        this.history.push(true);
        return {
          container,
          offset,
          prevContainer
        };
      },
      _nodeRemoveListItem: function(item) {
        const format = util2.getFormatElement(item, null);
        util2.removeItem(item);
        if (!util2.isListCell(format)) return;
        util2.removeItemAllParents(format, null, null);
        if (format && util2.isList(format.firstChild)) {
          format.insertBefore(util2.createTextNode(util2.zeroWidthSpace), format.firstChild);
        }
      },
      /**
       * @description Appended all selected format Element to the argument element and insert
       * @param {Element} rangeElement Element of wrap the arguments (BLOCKQUOTE...)
       */
      applyRangeFormatElement: function(rangeElement) {
        this.getRange_addLine(this.getRange(), null);
        const rangeLines = this.getSelectedElementsAndComponents(false);
        if (!rangeLines || rangeLines.length === 0) return;
        linesLoop:
          for (let i = 0, len = rangeLines.length, line, nested, fEl, lEl, f, l; i < len; i++) {
            line = rangeLines[i];
            if (!util2.isListCell(line)) continue;
            nested = line.lastElementChild;
            if (nested && util2.isListCell(line.nextElementSibling) && rangeLines.indexOf(line.nextElementSibling) > -1) {
              lEl = nested.lastElementChild;
              if (rangeLines.indexOf(lEl) > -1) {
                let list2 = null;
                while (list2 = lEl.lastElementChild) {
                  if (util2.isList(list2)) {
                    if (rangeLines.indexOf(list2.lastElementChild) > -1) {
                      lEl = list2.lastElementChild;
                    } else {
                      continue linesLoop;
                    }
                  }
                }
                fEl = nested.firstElementChild;
                f = rangeLines.indexOf(fEl);
                l = rangeLines.indexOf(lEl);
                rangeLines.splice(f, l - f + 1);
                len = rangeLines.length;
                continue;
              }
            }
          }
        let last = rangeLines[rangeLines.length - 1];
        let standTag, beforeTag, pElement;
        if (util2.isRangeFormatElement(last) || util2.isFormatElement(last)) {
          standTag = last;
        } else {
          standTag = util2.getRangeFormatElement(last, null) || util2.getFormatElement(last, null);
        }
        if (util2.isCell(standTag)) {
          beforeTag = null;
          pElement = standTag;
        } else {
          beforeTag = standTag.nextSibling;
          pElement = standTag.parentNode;
        }
        let parentDepth = util2.getElementDepth(standTag);
        let listParent = null;
        const lineArr = [];
        const removeItems = function(parent, origin, before) {
          let cc = null;
          if (parent !== origin && !util2.isTable(origin)) {
            if (origin && util2.getElementDepth(parent) === util2.getElementDepth(origin)) return before;
            cc = util2.removeItemAllParents(origin, null, parent);
          }
          return cc ? cc.ec : before;
        };
        for (let i = 0, len = rangeLines.length, line, originParent, depth, before, nextLine, nextList, nested; i < len; i++) {
          line = rangeLines[i];
          originParent = line.parentNode;
          if (!originParent || rangeElement.contains(originParent)) continue;
          depth = util2.getElementDepth(line);
          if (util2.isList(originParent)) {
            if (listParent === null) {
              if (nextList) {
                listParent = nextList;
                nested = true;
                nextList = null;
              } else {
                listParent = originParent.cloneNode(false);
              }
            }
            lineArr.push(line);
            nextLine = rangeLines[i + 1];
            if (i === len - 1 || nextLine && nextLine.parentNode !== originParent) {
              if (nextLine && line.contains(nextLine.parentNode)) {
                nextList = nextLine.parentNode.cloneNode(false);
              }
              let list2 = originParent.parentNode, p;
              while (util2.isList(list2)) {
                p = util2.createElement(list2.nodeName);
                p.appendChild(listParent);
                listParent = p;
                list2 = list2.parentNode;
              }
              const edge2 = this.detachRangeFormatElement(originParent, lineArr, null, true, true);
              if (parentDepth >= depth) {
                parentDepth = depth;
                pElement = edge2.cc;
                beforeTag = removeItems(pElement, originParent, edge2.ec);
                if (beforeTag) pElement = beforeTag.parentNode;
              } else if (pElement === edge2.cc) {
                beforeTag = edge2.ec;
              }
              if (pElement !== edge2.cc) {
                before = removeItems(pElement, edge2.cc, before);
                if (before !== void 0) beforeTag = before;
                else beforeTag = edge2.cc;
              }
              for (let c = 0, cLen = edge2.removeArray.length; c < cLen; c++) {
                listParent.appendChild(edge2.removeArray[c]);
              }
              if (!nested) rangeElement.appendChild(listParent);
              if (nextList) edge2.removeArray[edge2.removeArray.length - 1].appendChild(nextList);
              listParent = null;
              nested = false;
            }
          } else {
            if (parentDepth >= depth) {
              parentDepth = depth;
              pElement = originParent;
              beforeTag = line.nextSibling;
            }
            rangeElement.appendChild(line);
            if (pElement !== originParent) {
              before = removeItems(pElement, originParent);
              if (before !== void 0) beforeTag = before;
            }
          }
        }
        this.effectNode = null;
        util2.mergeSameTags(rangeElement, null, false);
        util2.mergeNestedTags(rangeElement, function(current) {
          return this.isList(current);
        }.bind(util2));
        if (beforeTag && util2.getElementDepth(beforeTag) > 0 && (util2.isList(beforeTag.parentNode) || util2.isList(beforeTag.parentNode.parentNode))) {
          const depthFormat = util2.getParentElement(beforeTag, function(current) {
            return this.isRangeFormatElement(current) && !this.isList(current);
          }.bind(util2));
          const splitRange = util2.splitElement(beforeTag, null, !depthFormat ? 0 : util2.getElementDepth(depthFormat) + 1);
          splitRange.parentNode.insertBefore(rangeElement, splitRange);
        } else {
          pElement.insertBefore(rangeElement, beforeTag);
          removeItems(rangeElement, beforeTag);
        }
        const edge = util2.getEdgeChildNodes(rangeElement.firstElementChild, rangeElement.lastElementChild);
        if (rangeLines.length > 1) {
          this.setRange(edge.sc, 0, edge.ec, edge.ec.textContent.length);
        } else {
          this.setRange(edge.ec, edge.ec.textContent.length, edge.ec, edge.ec.textContent.length);
        }
        this.history.push(false);
      },
      /**
       * @description The elements of the "selectedFormats" array are detached from the "rangeElement" element. ("LI" tags are converted to "P" tags)
       * When "selectedFormats" is null, all elements are detached and return {cc: parentNode, sc: nextSibling, ec: previousSibling, removeArray: [Array of removed elements]}.
       * @param {Element} rangeElement Range format element (PRE, BLOCKQUOTE, OL, UL...)
       * @param {Array|null} selectedFormats Array of format elements (P, DIV, LI...) to remove.
       * If null, Applies to all elements and return {cc: parentNode, sc: nextSibling, ec: previousSibling}
       * @param {Element|null} newRangeElement The node(rangeElement) to replace the currently wrapped node.
       * @param {Boolean} remove If true, deleted without detached.
       * @param {Boolean} notHistoryPush When true, it does not update the history stack and the selection object and return EdgeNodes (util.getEdgeChildNodes)
       * @returns {Object}
       */
      detachRangeFormatElement: function(rangeElement, selectedFormats, newRangeElement, remove, notHistoryPush) {
        const range = this.getRange();
        let so = range.startOffset;
        let eo = range.endOffset;
        let children2 = util2.getListChildNodes(rangeElement, function(current) {
          return current.parentNode === rangeElement;
        });
        let parent = rangeElement.parentNode;
        let firstNode = null;
        let lastNode = null;
        let rangeEl = rangeElement.cloneNode(false);
        const removeArray = [];
        const newList = util2.isList(newRangeElement);
        let insertedNew = false;
        let reset = false;
        let moveComplete = false;
        function appendNode(parent2, insNode, sibling, originNode) {
          if (util2.onlyZeroWidthSpace(insNode)) {
            insNode.innerHTML = util2.zeroWidthSpace;
            so = eo = 1;
          }
          if (insNode.nodeType === 3) {
            parent2.insertBefore(insNode, sibling);
            return insNode;
          }
          const insChildren = (moveComplete ? insNode : originNode).childNodes;
          let format = insNode.cloneNode(false);
          let first = null;
          let c = null;
          while (insChildren[0]) {
            c = insChildren[0];
            if (util2._notTextNode(c) && !util2.isBreak(c) && !util2.isListCell(format)) {
              if (format.childNodes.length > 0) {
                if (!first) first = format;
                parent2.insertBefore(format, sibling);
                format = insNode.cloneNode(false);
              }
              parent2.insertBefore(c, sibling);
              if (!first) first = c;
            } else {
              format.appendChild(c);
            }
          }
          if (format.childNodes.length > 0) {
            if (util2.isListCell(parent2) && util2.isListCell(format) && util2.isList(sibling)) {
              if (newList) {
                first = sibling;
                while (sibling) {
                  format.appendChild(sibling);
                  sibling = sibling.nextSibling;
                }
                parent2.parentNode.insertBefore(format, parent2.nextElementSibling);
              } else {
                const originNext = originNode.nextElementSibling;
                const detachRange = util2.detachNestedList(originNode, false);
                if (rangeElement !== detachRange || originNext !== originNode.nextElementSibling) {
                  const fChildren = format.childNodes;
                  while (fChildren[0]) {
                    originNode.appendChild(fChildren[0]);
                  }
                  rangeElement = detachRange;
                  reset = true;
                }
              }
            } else {
              parent2.insertBefore(format, sibling);
            }
            if (!first) first = format;
          }
          return first;
        }
        for (let i = 0, len = children2.length, insNode, lineIndex, next; i < len; i++) {
          insNode = children2[i];
          if (insNode.nodeType === 3 && util2.isList(rangeEl)) continue;
          moveComplete = false;
          if (remove && i === 0) {
            if (!selectedFormats || selectedFormats.length === len || selectedFormats[0] === insNode) {
              firstNode = rangeElement.previousSibling;
            } else {
              firstNode = rangeEl;
            }
          }
          if (selectedFormats) lineIndex = selectedFormats.indexOf(insNode);
          if (selectedFormats && lineIndex === -1) {
            if (!rangeEl) rangeEl = rangeElement.cloneNode(false);
            rangeEl.appendChild(insNode);
          } else {
            if (selectedFormats) next = selectedFormats[lineIndex + 1];
            if (rangeEl && rangeEl.children.length > 0) {
              parent.insertBefore(rangeEl, rangeElement);
              rangeEl = null;
            }
            if (!newList && util2.isListCell(insNode)) {
              if (next && util2.getElementDepth(insNode) !== util2.getElementDepth(next) && (util2.isListCell(parent) || util2.getArrayItem(insNode.children, util2.isList, false))) {
                const insNext = insNode.nextElementSibling;
                const detachRange = util2.detachNestedList(insNode, false);
                if (rangeElement !== detachRange || insNext !== insNode.nextElementSibling) {
                  rangeElement = detachRange;
                  reset = true;
                }
              } else {
                const inner = insNode;
                insNode = util2.createElement(remove ? inner.nodeName : util2.isList(rangeElement.parentNode) || util2.isListCell(rangeElement.parentNode) ? "LI" : util2.isCell(rangeElement.parentNode) ? "DIV" : options2.defaultTag);
                const isCell = util2.isListCell(insNode);
                const innerChildren = inner.childNodes;
                while (innerChildren[0]) {
                  if (util2.isList(innerChildren[0]) && !isCell) break;
                  insNode.appendChild(innerChildren[0]);
                }
                util2.copyFormatAttributes(insNode, inner);
                moveComplete = true;
              }
            } else {
              insNode = insNode.cloneNode(false);
            }
            if (!reset) {
              if (!remove) {
                if (newRangeElement) {
                  if (!insertedNew) {
                    parent.insertBefore(newRangeElement, rangeElement);
                    insertedNew = true;
                  }
                  insNode = appendNode(newRangeElement, insNode, null, children2[i]);
                } else {
                  insNode = appendNode(parent, insNode, rangeElement, children2[i]);
                }
                if (!reset) {
                  if (selectedFormats) {
                    lastNode = insNode;
                    if (!firstNode) {
                      firstNode = insNode;
                    }
                  } else if (!firstNode) {
                    firstNode = lastNode = insNode;
                  }
                }
              } else {
                removeArray.push(insNode);
                util2.removeItem(children2[i]);
              }
              if (reset) {
                reset = moveComplete = false;
                children2 = util2.getListChildNodes(rangeElement, function(current) {
                  return current.parentNode === rangeElement;
                });
                rangeEl = rangeElement.cloneNode(false);
                parent = rangeElement.parentNode;
                i = -1;
                len = children2.length;
                continue;
              }
            }
          }
        }
        const rangeParent = rangeElement.parentNode;
        let rangeRight = rangeElement.nextSibling;
        if (rangeEl && rangeEl.children.length > 0) {
          rangeParent.insertBefore(rangeEl, rangeRight);
        }
        if (newRangeElement) firstNode = newRangeElement.previousSibling;
        else if (!firstNode) firstNode = rangeElement.previousSibling;
        rangeRight = rangeElement.nextSibling !== rangeEl ? rangeElement.nextSibling : rangeEl ? rangeEl.nextSibling : null;
        if (rangeElement.children.length === 0 || rangeElement.textContent.length === 0) {
          util2.removeItem(rangeElement);
        } else {
          util2.removeEmptyNode(rangeElement, null, false);
        }
        let edge = null;
        if (remove) {
          edge = {
            cc: rangeParent,
            sc: firstNode,
            so,
            ec: rangeRight,
            eo,
            removeArray
          };
        } else {
          if (!firstNode) firstNode = lastNode;
          if (!lastNode) lastNode = firstNode;
          const childEdge = util2.getEdgeChildNodes(firstNode, lastNode.parentNode ? firstNode : lastNode);
          edge = {
            cc: (childEdge.sc || childEdge.ec).parentNode,
            sc: childEdge.sc,
            so,
            ec: childEdge.ec,
            eo,
            removeArray: null
          };
        }
        this.effectNode = null;
        if (notHistoryPush) return edge;
        if (!remove && edge) {
          if (!selectedFormats) {
            this.setRange(edge.sc, 0, edge.sc, 0);
          } else {
            this.setRange(edge.sc, so, edge.ec, eo);
          }
        }
        this.history.push(false);
      },
      /**
       * @description "selectedFormats" array are detached from the list element.
       * The return value is applied when the first and last lines of "selectedFormats" are "LI" respectively.
       * @param {Array} selectedFormats Array of format elements (LI, P...) to remove.
       * @param {Boolean} remove If true, deleted without detached.
       * @returns {Object} {sc: <LI>, ec: <LI>}.
       */
      detachList: function(selectedFormats, remove) {
        let rangeArr = {};
        let listFirst = false;
        let listLast = false;
        let first = null;
        let last = null;
        const passComponent = function(current) {
          return !this.isComponent(current);
        }.bind(util2);
        for (let i = 0, len = selectedFormats.length, r, o, lastIndex, isList; i < len; i++) {
          lastIndex = i === len - 1;
          o = util2.getRangeFormatElement(selectedFormats[i], passComponent);
          isList = util2.isList(o);
          if (!r && isList) {
            r = o;
            rangeArr = { r, f: [util2.getParentElement(selectedFormats[i], "LI")] };
            if (i === 0) listFirst = true;
          } else if (r && isList) {
            if (r !== o) {
              const edge = this.detachRangeFormatElement(rangeArr.f[0].parentNode, rangeArr.f, null, remove, true);
              o = selectedFormats[i].parentNode;
              if (listFirst) {
                first = edge.sc;
                listFirst = false;
              }
              if (lastIndex) last = edge.ec;
              if (isList) {
                r = o;
                rangeArr = { r, f: [util2.getParentElement(selectedFormats[i], "LI")] };
                if (lastIndex) listLast = true;
              } else {
                r = null;
              }
            } else {
              rangeArr.f.push(util2.getParentElement(selectedFormats[i], "LI"));
              if (lastIndex) listLast = true;
            }
          }
          if (lastIndex && util2.isList(r)) {
            const edge = this.detachRangeFormatElement(rangeArr.f[0].parentNode, rangeArr.f, null, remove, true);
            if (listLast || len === 1) last = edge.ec;
            if (listFirst) first = edge.sc || last;
          }
        }
        return {
          sc: first,
          ec: last
        };
      },
      /**
       * @description Add, update, and delete nodes from selected text.
       * 1. If there is a node in the "appendNode" argument, a node with the same tags and attributes as "appendNode" is added to the selection text.
       * 2. If it is in the same tag, only the tag's attributes are changed without adding a tag.
       * 3. If the "appendNode" argument is null, the node of the selection is update or remove without adding a new node.
       * 4. The same style as the style attribute of the "styleArray" argument is deleted.
       *    (Styles should be put with attribute names from css. ["background-color"])
       * 5. The same class name as the class attribute of the "styleArray" argument is deleted.
       *    (The class name is preceded by "." [".className"])
       * 6. Use a list of styles and classes of "appendNode" in "styleArray" to avoid duplicate property values.
       * 7. If a node with all styles and classes removed has the same tag name as "appendNode" or "removeNodeArray", or "appendNode" is null, that node is deleted.
       * 8. Regardless of the style and class of the node, the tag with the same name as the "removeNodeArray" argument value is deleted.
       * 9. If the "strictRemove" argument is true, only nodes with all styles and classes removed from the nodes of "removeNodeArray" are removed.
       *10. It won't work if the parent node has the same class and same value style.
       *    However, if there is a value in "removeNodeArray", it works and the text node is separated even if there is no node to replace.
       * @param {Element|null} appendNode The element to be added to the selection. If it is null, only delete the node.
       * @param {Array|null} styleArray The style or className attribute name Array to check (['font-size'], ['.className'], ['font-family', 'color', '.className']...])
       * @param {Array|null} removeNodeArray An array of node names to remove types from, remove all formats when "appendNode" is null and there is an empty array or null value. (['span'], ['strong', 'em'] ...])
       * @param {Boolean|null} strictRemove If true, only nodes with all styles and classes removed from the nodes of "removeNodeArray" are removed.
       */
      nodeChange: function(appendNode, styleArray, removeNodeArray, strictRemove) {
        this._resetRangeToTextNode();
        let range = this.getRange_addLine(this.getRange(), null);
        styleArray = styleArray && styleArray.length > 0 ? styleArray : false;
        removeNodeArray = removeNodeArray && removeNodeArray.length > 0 ? removeNodeArray : false;
        const isRemoveNode = !appendNode;
        const isRemoveFormat = isRemoveNode && !removeNodeArray && !styleArray;
        let startCon = range.startContainer;
        let startOff = range.startOffset;
        let endCon = range.endContainer;
        let endOff = range.endOffset;
        if (isRemoveFormat && range.collapsed && util2.isFormatElement(startCon.parentNode) || startCon === endCon && startCon.nodeType === 1 && util2.isNonEditable(startCon)) {
          const format = startCon.parentNode;
          if (!util2.isListCell(format) || !util2.getValues(format.style).some(function(k) {
            return this._listKebab.indexOf(k) > -1;
          }.bind(this))) return;
        }
        if (range.collapsed && !isRemoveFormat) {
          if (startCon.nodeType === 1 && !util2.isBreak(startCon) && !util2.isComponent(startCon)) {
            let afterNode = null;
            const focusNode = startCon.childNodes[startOff];
            if (focusNode) {
              if (!focusNode.nextSibling) {
                afterNode = null;
              } else {
                afterNode = util2.isBreak(focusNode) ? focusNode : focusNode.nextSibling;
              }
            }
            const zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
            startCon.insertBefore(zeroWidth, afterNode);
            this.setRange(zeroWidth, 1, zeroWidth, 1);
            range = this.getRange();
            startCon = range.startContainer;
            startOff = range.startOffset;
            endCon = range.endContainer;
            endOff = range.endOffset;
          }
        }
        if (util2.isFormatElement(startCon)) {
          startCon = startCon.childNodes[startOff] || startCon.firstChild;
          startOff = 0;
        }
        if (util2.isFormatElement(endCon)) {
          endCon = endCon.childNodes[endOff] || endCon.lastChild;
          endOff = endCon.textContent.length;
        }
        if (isRemoveNode) {
          appendNode = util2.createElement("DIV");
        }
        const wRegExp = _w.RegExp;
        const newNodeName = appendNode.nodeName;
        if (!isRemoveFormat && startCon === endCon && !removeNodeArray && appendNode) {
          let sNode = startCon;
          let checkCnt = 0;
          const checkAttrs = [];
          const checkStyles = appendNode.style;
          for (let i = 0, len = checkStyles.length; i < len; i++) {
            checkAttrs.push(checkStyles[i]);
          }
          const ckeckClasses = appendNode.classList;
          for (let i = 0, len = ckeckClasses.length; i < len; i++) {
            checkAttrs.push("." + ckeckClasses[i]);
          }
          if (checkAttrs.length > 0) {
            while (!util2.isFormatElement(sNode) && !util2.isWysiwygDiv(sNode)) {
              for (let i = 0; i < checkAttrs.length; i++) {
                if (sNode.nodeType === 1) {
                  const s = checkAttrs[i];
                  const classReg = /^\./.test(s) ? new wRegExp("\\s*" + s.replace(/^\./, "") + "(\\s+|$)", "ig") : false;
                  const styleCheck = isRemoveNode ? !!sNode.style[s] : !!sNode.style[s] && !!appendNode.style[s] && sNode.style[s] === appendNode.style[s];
                  const classCheck = classReg === false ? false : isRemoveNode ? !!sNode.className.match(classReg) : !!sNode.className.match(classReg) && !!appendNode.className.match(classReg);
                  if (styleCheck || classCheck) {
                    checkCnt++;
                  }
                }
              }
              sNode = sNode.parentNode;
            }
            if (checkCnt >= checkAttrs.length) return;
          }
        }
        let start = {}, end = {};
        let newNode, styleRegExp = "", classRegExp = "", removeNodeRegExp = "";
        if (styleArray) {
          for (let i = 0, len = styleArray.length, s; i < len; i++) {
            s = styleArray[i];
            if (/^\./.test(s)) {
              classRegExp += (classRegExp ? "|" : "\\s*(?:") + s.replace(/^\./, "");
            } else {
              styleRegExp += (styleRegExp ? "|" : "(?:;|^|\\s)(?:") + s;
            }
          }
          if (styleRegExp) {
            styleRegExp += ")\\s*:[^;]*\\s*(?:;|$)";
            styleRegExp = new wRegExp(styleRegExp, "ig");
          }
          if (classRegExp) {
            classRegExp += ")(?=\\s+|$)";
            classRegExp = new wRegExp(classRegExp, "ig");
          }
        }
        if (removeNodeArray) {
          removeNodeRegExp = "^(?:" + removeNodeArray[0];
          for (let i = 1; i < removeNodeArray.length; i++) {
            removeNodeRegExp += "|" + removeNodeArray[i];
          }
          removeNodeRegExp += ")$";
          removeNodeRegExp = new wRegExp(removeNodeRegExp, "i");
        }
        const wBoolean = _w.Boolean;
        const _removeCheck = { v: false };
        const validation = function(checkNode) {
          const vNode = checkNode.cloneNode(false);
          if (vNode.nodeType === 3 || util2.isBreak(vNode)) return vNode;
          if (isRemoveFormat) return null;
          const tagRemove = !removeNodeRegExp && isRemoveNode || removeNodeRegExp && removeNodeRegExp.test(vNode.nodeName);
          if (tagRemove && !strictRemove) {
            _removeCheck.v = true;
            return null;
          }
          const originStyle = vNode.style.cssText;
          let style = "";
          if (styleRegExp && originStyle.length > 0) {
            style = originStyle.replace(styleRegExp, "").trim();
            if (style !== originStyle) _removeCheck.v = true;
          }
          const originClasses = vNode.className;
          let classes = "";
          if (classRegExp && originClasses.length > 0) {
            classes = originClasses.replace(classRegExp, "").trim();
            if (classes !== originClasses) _removeCheck.v = true;
          }
          if (isRemoveNode) {
            if ((classRegExp || !originClasses) && (styleRegExp || !originStyle) && !style && !classes && tagRemove) {
              _removeCheck.v = true;
              return null;
            }
          }
          if (style || classes || vNode.nodeName !== newNodeName || wBoolean(styleRegExp) !== wBoolean(originStyle) || wBoolean(classRegExp) !== wBoolean(originClasses)) {
            if (styleRegExp && originStyle.length > 0) vNode.style.cssText = style;
            if (!vNode.style.cssText) {
              vNode.removeAttribute("style");
            }
            if (classRegExp && originClasses.length > 0) vNode.className = classes.trim();
            if (!vNode.className.trim()) {
              vNode.removeAttribute("class");
            }
            if (!vNode.style.cssText && !vNode.className && (vNode.nodeName === newNodeName || tagRemove)) {
              _removeCheck.v = true;
              return null;
            }
            return vNode;
          }
          _removeCheck.v = true;
          return null;
        };
        const lineNodes = this.getSelectedElements(null);
        range = this.getRange();
        startCon = range.startContainer;
        startOff = range.startOffset;
        endCon = range.endContainer;
        endOff = range.endOffset;
        if (!util2.getFormatElement(startCon, null)) {
          startCon = util2.getChildElement(lineNodes[0], function(current) {
            return current.nodeType === 3;
          }, false);
          startOff = 0;
        }
        if (!util2.getFormatElement(endCon, null)) {
          endCon = util2.getChildElement(lineNodes[lineNodes.length - 1], function(current) {
            return current.nodeType === 3;
          }, false);
          endOff = endCon.textContent.length;
        }
        const oneLine = util2.getFormatElement(startCon, null) === util2.getFormatElement(endCon, null);
        const endLength = lineNodes.length - (oneLine ? 0 : 1);
        newNode = appendNode.cloneNode(false);
        const isRemoveAnchor = isRemoveFormat || isRemoveNode && function(arr) {
          for (let n = 0, len = arr.length; n < len; n++) {
            if (util2._isMaintainedNode(arr[n]) || util2._isSizeNode(arr[n])) return true;
          }
          return false;
        }(removeNodeArray);
        const isSizeNode = isRemoveNode || util2._isSizeNode(newNode);
        const _getMaintainedNode = this._util_getMaintainedNode.bind(util2, isRemoveAnchor, isSizeNode);
        const _isMaintainedNode = this._util_isMaintainedNode.bind(util2, isRemoveAnchor, isSizeNode);
        if (oneLine) {
          if (this._resetCommonListCell(lineNodes[0], styleArray)) range = this.setRange(startCon, startOff, endCon, endOff);
          const newRange = this._nodeChange_oneLine(lineNodes[0], newNode, validation, startCon, startOff, endCon, endOff, isRemoveFormat, isRemoveNode, range.collapsed, _removeCheck, _getMaintainedNode, _isMaintainedNode);
          start.container = newRange.startContainer;
          start.offset = newRange.startOffset;
          end.container = newRange.endContainer;
          end.offset = newRange.endOffset;
          if (start.container === end.container && util2.onlyZeroWidthSpace(start.container)) {
            start.offset = end.offset = 1;
          }
          this._setCommonListStyle(newRange.ancestor, null);
        } else {
          let appliedCommonList = false;
          if (endLength > 0 && this._resetCommonListCell(lineNodes[endLength], styleArray)) appliedCommonList = true;
          if (this._resetCommonListCell(lineNodes[0], styleArray)) appliedCommonList = true;
          if (appliedCommonList) this.setRange(startCon, startOff, endCon, endOff);
          if (endLength > 0) {
            newNode = appendNode.cloneNode(false);
            end = this._nodeChange_endLine(lineNodes[endLength], newNode, validation, endCon, endOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode);
          }
          for (let i = endLength - 1, newRange; i > 0; i--) {
            this._resetCommonListCell(lineNodes[i], styleArray);
            newNode = appendNode.cloneNode(false);
            newRange = this._nodeChange_middleLine(lineNodes[i], newNode, validation, isRemoveFormat, isRemoveNode, _removeCheck, end.container);
            if (newRange.endContainer && newRange.ancestor.contains(newRange.endContainer)) {
              end.ancestor = null;
              end.container = newRange.endContainer;
            }
            this._setCommonListStyle(newRange.ancestor, null);
          }
          newNode = appendNode.cloneNode(false);
          start = this._nodeChange_startLine(lineNodes[0], newNode, validation, startCon, startOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode, end.container);
          if (start.endContainer) {
            end.ancestor = null;
            end.container = start.endContainer;
          }
          if (endLength <= 0) {
            end = start;
          } else if (!end.container) {
            end.ancestor = null;
            end.container = start.container;
            end.offset = start.container.textContent.length;
          }
          this._setCommonListStyle(start.ancestor, null);
          this._setCommonListStyle(end.ancestor || util2.getFormatElement(end.container), null);
        }
        this.controllersOff();
        this.setRange(start.container, start.offset, end.container, end.offset);
        this.history.push(false);
      },
      /**
       * @description Reset common style of list cell
       * @param {Element} el List cell element. <li>
       * @param {Array|null} styleArray Style array
       * @private
       */
      _resetCommonListCell: function(el, styleArray) {
        if (!util2.isListCell(el)) return;
        if (!styleArray) styleArray = this._listKebab;
        const children2 = util2.getArrayItem(el.childNodes, function(current) {
          return !util2.isBreak(current);
        }, true);
        const elStyles = el.style;
        const ec = [], ek = [], elKeys = util2.getValues(elStyles);
        for (let i = 0, len = this._listKebab.length; i < len; i++) {
          if (elKeys.indexOf(this._listKebab[i]) > -1 && styleArray.indexOf(this._listKebab[i]) > -1) {
            ec.push(this._listCamel[i]);
            ek.push(this._listKebab[i]);
          }
        }
        if (!ec.length) return;
        const refer = util2.createElement("SPAN");
        for (let i = 0, len = ec.length; i < len; i++) {
          refer.style[ec[i]] = elStyles[ek[i]];
          elStyles.removeProperty(ek[i]);
        }
        let sel = refer.cloneNode(false);
        let r = null, appliedEl = false;
        for (let i = 0, len = children2.length, c, s; i < len; i++) {
          c = children2[i];
          if (options2._textTagsMap[c.nodeName.toLowerCase()]) continue;
          s = util2.getValues(c.style);
          if (s.length === 0 || ec.some(function(k) {
            return s.indexOf(k) === -1;
          }) && s.some(function(k) {
            ec.indexOf(k) > -1;
          })) {
            r = c.nextSibling;
            sel.appendChild(c);
          } else if (sel.childNodes.length > 0) {
            el.insertBefore(sel, r);
            sel = refer.cloneNode(false);
            r = null;
            appliedEl = true;
          }
        }
        if (sel.childNodes.length > 0) {
          el.insertBefore(sel, r);
          appliedEl = true;
        }
        if (!elStyles.length) {
          el.removeAttribute("style");
        }
        return appliedEl;
      },
      /**
       * @description If certain styles are applied to all child nodes of the list cell, the style of the list cell is also changed. (bold, color, size)
       * @param {Element} el List cell element. <li>
       * @param {Element|null} child Variable for recursive call. ("null" on the first call)
       * @private
       */
      _setCommonListStyle: function(el, child) {
        if (!util2.isListCell(el)) return;
        const children2 = util2.getArrayItem((child || el).childNodes, function(current) {
          return !util2.isBreak(current);
        }, true);
        child = children2[0];
        if (!child || children2.length > 1 || child.nodeType !== 1) return;
        const childStyle = child.style;
        const elStyle = el.style;
        const nodeName = child.nodeName.toLowerCase();
        let appliedEl = false;
        if (options2._textTagsMap[nodeName] === options2._defaultCommand.bold.toLowerCase()) elStyle.fontWeight = "bold";
        if (options2._textTagsMap[nodeName] === options2._defaultCommand.italic.toLowerCase()) elStyle.fontStyle = "italic";
        const cKeys = util2.getValues(childStyle);
        if (cKeys.length > 0) {
          for (let i = 0, len = this._listCamel.length; i < len; i++) {
            if (cKeys.indexOf(this._listKebab[i]) > -1) {
              elStyle[this._listCamel[i]] = childStyle[this._listCamel[i]];
              childStyle.removeProperty(this._listKebab[i]);
              appliedEl = true;
            }
          }
        }
        this._setCommonListStyle(el, child);
        if (!appliedEl) return;
        if (!childStyle.length) {
          const ch = child.childNodes;
          const p = child.parentNode;
          const n = child.nextSibling;
          while (ch.length > 0) {
            p.insertBefore(ch[0], n);
          }
          util2.removeItem(child);
        }
      },
      /**
       * @description Strip remove node
       * @param {Node} removeNode The remove node
       * @private
       */
      _stripRemoveNode: function(removeNode) {
        const element = removeNode.parentNode;
        if (!removeNode || removeNode.nodeType === 3 || !element) return;
        const children2 = removeNode.childNodes;
        while (children2[0]) {
          element.insertBefore(children2[0], removeNode);
        }
        element.removeChild(removeNode);
      },
      /**
       * @description Return the parent maintained tag. (bind and use a util object)
       * @param {Element} element Element
       * @returns {Element}
       * @private
       */
      _util_getMaintainedNode: function(_isRemove, _isSizeNode, element) {
        if (!element || _isRemove) return null;
        return this.getParentElement(element, this._isMaintainedNode.bind(this)) || (!_isSizeNode ? this.getParentElement(element, this._isSizeNode.bind(this)) : null);
      },
      /**
       * @description Check if element is a tag that should be persisted. (bind and use a util object)
       * @param {Element} element Element
       * @returns {Element}
       * @private
       */
      _util_isMaintainedNode: function(_isRemove, _isSizeNode, element) {
        if (!element || _isRemove || element.nodeType !== 1) return false;
        const anchor = this._isMaintainedNode(element);
        return this.getParentElement(element, this._isMaintainedNode.bind(this)) ? anchor : anchor || (!_isSizeNode ? this._isSizeNode(element) : false);
      },
      /**
       * @description wraps text nodes of line selected text.
       * @param {Element} element The node of the line that contains the selected text node.
       * @param {Element} newInnerNode The dom that will wrap the selected text area
       * @param {Function} validation Check if the node should be stripped.
       * @param {Node} startCon The startContainer property of the selection object.
       * @param {Number} startOff The startOffset property of the selection object.
       * @param {Node} endCon The endContainer property of the selection object.
       * @param {Number} endOff The endOffset property of the selection object.
       * @param {Boolean} isRemoveFormat Is the remove all formats command?
       * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
       * @param {Boolean} collapsed range.collapsed
       * @returns {{ancestor: *, startContainer: *, startOffset: *, endContainer: *, endOffset: *}}
       * @private
       */
      _nodeChange_oneLine: function(element, newInnerNode, validation, startCon, startOff, endCon, endOff, isRemoveFormat, isRemoveNode, collapsed, _removeCheck, _getMaintainedNode, _isMaintainedNode) {
        let parentCon = startCon.parentNode;
        while (!parentCon.nextSibling && !parentCon.previousSibling && !util2.isFormatElement(parentCon.parentNode) && !util2.isWysiwygDiv(parentCon.parentNode)) {
          if (parentCon.nodeName === newInnerNode.nodeName) break;
          parentCon = parentCon.parentNode;
        }
        if (!isRemoveNode && parentCon === endCon.parentNode && parentCon.nodeName === newInnerNode.nodeName) {
          if (util2.onlyZeroWidthSpace(startCon.textContent.slice(0, startOff)) && util2.onlyZeroWidthSpace(endCon.textContent.slice(endOff))) {
            const children2 = parentCon.childNodes;
            let sameTag = true;
            for (let i = 0, len = children2.length, c, s, e, z; i < len; i++) {
              c = children2[i];
              z = !util2.onlyZeroWidthSpace(c);
              if (c === startCon) {
                s = true;
                continue;
              }
              if (c === endCon) {
                e = true;
                continue;
              }
              if (!s && z || s && e && z) {
                sameTag = false;
                break;
              }
            }
            if (sameTag) {
              util2.copyTagAttributes(parentCon, newInnerNode);
              return {
                ancestor: element,
                startContainer: startCon,
                startOffset: startOff,
                endContainer: endCon,
                endOffset: endOff
              };
            }
          }
        }
        _removeCheck.v = false;
        const el = element;
        const nNodeArray = [newInnerNode];
        const pNode = element.cloneNode(false);
        const isSameNode = startCon === endCon;
        let startContainer = startCon;
        let startOffset = startOff;
        let endContainer = endCon;
        let endOffset = endOff;
        let startPass = false;
        let endPass = false;
        let pCurrent, newNode, appendNode, cssText, anchorNode;
        const wRegExp = _w.RegExp;
        function checkCss(vNode) {
          const regExp = new wRegExp("(?:;|^|\\s)(?:" + cssText + "null)\\s*:[^;]*\\s*(?:;|$)", "ig");
          let style = "";
          if (regExp && vNode.style.cssText.length > 0) {
            style = regExp.test(vNode.style.cssText);
          }
          return !style;
        }
        (function recursionFunc(current, ancestor) {
          const childNodes = current.childNodes;
          for (let i = 0, len = childNodes.length, vNode; i < len; i++) {
            let child = childNodes[i];
            if (!child) continue;
            let coverNode = ancestor;
            let cloneNode;
            if (!startPass && child === startContainer) {
              let line = pNode;
              anchorNode = _getMaintainedNode(child);
              const prevNode = util2.createTextNode(startContainer.nodeType === 1 ? "" : startContainer.substringData(0, startOffset));
              const textNode = util2.createTextNode(
                startContainer.nodeType === 1 ? "" : startContainer.substringData(
                  startOffset,
                  isSameNode ? endOffset >= startOffset ? endOffset - startOffset : startContainer.data.length - startOffset : startContainer.data.length - startOffset
                )
              );
              if (anchorNode) {
                const a = _getMaintainedNode(ancestor);
                if (a && a.parentNode !== line) {
                  let m = a;
                  let p = null;
                  while (m.parentNode !== line) {
                    ancestor = p = m.parentNode.cloneNode(false);
                    while (m.childNodes[0]) {
                      p.appendChild(m.childNodes[0]);
                    }
                    m.appendChild(p);
                    m = m.parentNode;
                  }
                  m.parentNode.appendChild(a);
                }
                anchorNode = anchorNode.cloneNode(false);
              }
              if (!util2.onlyZeroWidthSpace(prevNode)) {
                ancestor.appendChild(prevNode);
              }
              const prevAnchorNode = _getMaintainedNode(ancestor);
              if (!!prevAnchorNode) anchorNode = prevAnchorNode;
              if (anchorNode) line = anchorNode;
              newNode = child;
              pCurrent = [];
              cssText = "";
              while (newNode !== line && newNode !== el && newNode !== null) {
                vNode = _isMaintainedNode(newNode) ? null : validation(newNode);
                if (vNode && newNode.nodeType === 1 && checkCss(newNode)) {
                  pCurrent.push(vNode);
                  cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(":")) + "|";
                }
                newNode = newNode.parentNode;
              }
              const childNode = pCurrent.pop() || textNode;
              appendNode = newNode = childNode;
              while (pCurrent.length > 0) {
                newNode = pCurrent.pop();
                appendNode.appendChild(newNode);
                appendNode = newNode;
              }
              newInnerNode.appendChild(childNode);
              line.appendChild(newInnerNode);
              if (anchorNode && !_getMaintainedNode(endContainer)) {
                newInnerNode = newInnerNode.cloneNode(false);
                pNode.appendChild(newInnerNode);
                nNodeArray.push(newInnerNode);
              }
              startContainer = textNode;
              startOffset = 0;
              startPass = true;
              if (newNode !== textNode) newNode.appendChild(startContainer);
              if (!isSameNode) continue;
            }
            if (!endPass && child === endContainer) {
              anchorNode = _getMaintainedNode(child);
              const afterNode = util2.createTextNode(endContainer.nodeType === 1 ? "" : endContainer.substringData(endOffset, endContainer.length - endOffset));
              const textNode = util2.createTextNode(isSameNode || endContainer.nodeType === 1 ? "" : endContainer.substringData(0, endOffset));
              if (anchorNode) {
                anchorNode = anchorNode.cloneNode(false);
              } else if (_isMaintainedNode(newInnerNode.parentNode) && !anchorNode) {
                newInnerNode = newInnerNode.cloneNode(false);
                pNode.appendChild(newInnerNode);
                nNodeArray.push(newInnerNode);
              }
              if (!util2.onlyZeroWidthSpace(afterNode)) {
                newNode = child;
                cssText = "";
                pCurrent = [];
                const anchors = [];
                while (newNode !== pNode && newNode !== el && newNode !== null) {
                  if (newNode.nodeType === 1 && checkCss(newNode)) {
                    if (_isMaintainedNode(newNode)) anchors.push(newNode.cloneNode(false));
                    else pCurrent.push(newNode.cloneNode(false));
                    cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(":")) + "|";
                  }
                  newNode = newNode.parentNode;
                }
                pCurrent = pCurrent.concat(anchors);
                cloneNode = appendNode = newNode = pCurrent.pop() || afterNode;
                while (pCurrent.length > 0) {
                  newNode = pCurrent.pop();
                  appendNode.appendChild(newNode);
                  appendNode = newNode;
                }
                pNode.appendChild(cloneNode);
                newNode.textContent = afterNode.data;
              }
              if (anchorNode && cloneNode) {
                const afterAnchorNode = _getMaintainedNode(cloneNode);
                if (afterAnchorNode) {
                  anchorNode = afterAnchorNode;
                }
              }
              newNode = child;
              pCurrent = [];
              cssText = "";
              while (newNode !== pNode && newNode !== el && newNode !== null) {
                vNode = _isMaintainedNode(newNode) ? null : validation(newNode);
                if (vNode && newNode.nodeType === 1 && checkCss(newNode)) {
                  pCurrent.push(vNode);
                  cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(":")) + "|";
                }
                newNode = newNode.parentNode;
              }
              const childNode = pCurrent.pop() || textNode;
              appendNode = newNode = childNode;
              while (pCurrent.length > 0) {
                newNode = pCurrent.pop();
                appendNode.appendChild(newNode);
                appendNode = newNode;
              }
              if (anchorNode) {
                newInnerNode = newInnerNode.cloneNode(false);
                newInnerNode.appendChild(childNode);
                anchorNode.insertBefore(newInnerNode, anchorNode.firstChild);
                pNode.appendChild(anchorNode);
                nNodeArray.push(newInnerNode);
                anchorNode = null;
              } else {
                newInnerNode.appendChild(childNode);
              }
              endContainer = textNode;
              endOffset = textNode.data.length;
              endPass = true;
              if (!isRemoveFormat && collapsed) {
                newInnerNode = textNode;
                textNode.textContent = util2.zeroWidthSpace;
              }
              if (newNode !== textNode) newNode.appendChild(endContainer);
              continue;
            }
            if (startPass) {
              if (child.nodeType === 1 && !util2.isBreak(child)) {
                if (util2._isIgnoreNodeChange(child)) {
                  pNode.appendChild(child.cloneNode(true));
                  if (!collapsed) {
                    newInnerNode = newInnerNode.cloneNode(false);
                    pNode.appendChild(newInnerNode);
                    nNodeArray.push(newInnerNode);
                  }
                } else {
                  recursionFunc(child, child);
                }
                continue;
              }
              newNode = child;
              pCurrent = [];
              cssText = "";
              const anchors = [];
              while (newNode.parentNode !== null && newNode !== el && newNode !== newInnerNode) {
                vNode = endPass ? newNode.cloneNode(false) : validation(newNode);
                if (newNode.nodeType === 1 && !util2.isBreak(child) && vNode && checkCss(newNode)) {
                  if (_isMaintainedNode(newNode)) {
                    if (!anchorNode) anchors.push(vNode);
                  } else {
                    pCurrent.push(vNode);
                  }
                  cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(":")) + "|";
                }
                newNode = newNode.parentNode;
              }
              pCurrent = pCurrent.concat(anchors);
              const childNode = pCurrent.pop() || child;
              appendNode = newNode = childNode;
              while (pCurrent.length > 0) {
                newNode = pCurrent.pop();
                appendNode.appendChild(newNode);
                appendNode = newNode;
              }
              if (_isMaintainedNode(newInnerNode.parentNode) && !_isMaintainedNode(childNode) && !util2.onlyZeroWidthSpace(newInnerNode)) {
                newInnerNode = newInnerNode.cloneNode(false);
                pNode.appendChild(newInnerNode);
                nNodeArray.push(newInnerNode);
              }
              if (!endPass && !anchorNode && _isMaintainedNode(childNode)) {
                newInnerNode = newInnerNode.cloneNode(false);
                const aChildren = childNode.childNodes;
                for (let a = 0, aLen = aChildren.length; a < aLen; a++) {
                  newInnerNode.appendChild(aChildren[a]);
                }
                childNode.appendChild(newInnerNode);
                pNode.appendChild(childNode);
                nNodeArray.push(newInnerNode);
                if (newInnerNode.children.length > 0) ancestor = newNode;
                else ancestor = newInnerNode;
              } else if (childNode === child) {
                if (!endPass) ancestor = newInnerNode;
                else ancestor = pNode;
              } else if (endPass) {
                pNode.appendChild(childNode);
                ancestor = newNode;
              } else {
                newInnerNode.appendChild(childNode);
                ancestor = newNode;
              }
              if (anchorNode && child.nodeType === 3) {
                if (_getMaintainedNode(child)) {
                  const ancestorAnchorNode = util2.getParentElement(ancestor, function(current2) {
                    return this._isMaintainedNode(current2.parentNode) || current2.parentNode === pNode;
                  }.bind(util2));
                  anchorNode.appendChild(ancestorAnchorNode);
                  newInnerNode = ancestorAnchorNode.cloneNode(false);
                  nNodeArray.push(newInnerNode);
                  pNode.appendChild(newInnerNode);
                } else {
                  anchorNode = null;
                }
              }
            }
            cloneNode = child.cloneNode(false);
            ancestor.appendChild(cloneNode);
            if (child.nodeType === 1 && !util2.isBreak(child)) coverNode = cloneNode;
            recursionFunc(child, coverNode);
          }
        })(element, pNode);
        if (isRemoveNode && !isRemoveFormat && !_removeCheck.v) {
          return {
            ancestor: element,
            startContainer: startCon,
            startOffset: startOff,
            endContainer: endCon,
            endOffset: endOff
          };
        }
        isRemoveFormat = isRemoveFormat && isRemoveNode;
        if (isRemoveFormat) {
          for (let i = 0; i < nNodeArray.length; i++) {
            let removeNode = nNodeArray[i];
            let textNode, textNode_s, textNode_e;
            if (collapsed) {
              textNode = util2.createTextNode(util2.zeroWidthSpace);
              pNode.replaceChild(textNode, removeNode);
            } else {
              const rChildren = removeNode.childNodes;
              textNode_s = rChildren[0];
              while (rChildren[0]) {
                textNode_e = rChildren[0];
                pNode.insertBefore(textNode_e, removeNode);
              }
              util2.removeItem(removeNode);
            }
            if (i === 0) {
              if (collapsed) {
                startContainer = endContainer = textNode;
              } else {
                startContainer = textNode_s;
                endContainer = textNode_e;
              }
            }
          }
        } else {
          if (isRemoveNode) {
            for (let i = 0; i < nNodeArray.length; i++) {
              this._stripRemoveNode(nNodeArray[i]);
            }
          }
          if (collapsed) {
            startContainer = endContainer = newInnerNode;
          }
        }
        util2.removeEmptyNode(pNode, newInnerNode, false);
        if (collapsed) {
          startOffset = startContainer.textContent.length;
          endOffset = endContainer.textContent.length;
        }
        const endConReset = isRemoveFormat || endContainer.textContent.length === 0;
        if (!util2.isBreak(endContainer) && endContainer.textContent.length === 0) {
          util2.removeItem(endContainer);
          endContainer = startContainer;
        }
        endOffset = endConReset ? endContainer.textContent.length : endOffset;
        const newStartOffset = { s: 0, e: 0 };
        const startPath = util2.getNodePath(startContainer, pNode, newStartOffset);
        const mergeEndCon = !endContainer.parentNode;
        if (mergeEndCon) endContainer = startContainer;
        const newEndOffset = { s: 0, e: 0 };
        const endPath = util2.getNodePath(endContainer, pNode, !mergeEndCon && !endConReset ? newEndOffset : null);
        startOffset += newStartOffset.s;
        endOffset = collapsed ? startOffset : mergeEndCon ? startContainer.textContent.length : endConReset ? endOffset + newStartOffset.s : endOffset + newEndOffset.s;
        const newOffsets = util2.mergeSameTags(pNode, [startPath, endPath], true);
        element.parentNode.replaceChild(pNode, element);
        startContainer = util2.getNodeFromPath(startPath, pNode);
        endContainer = util2.getNodeFromPath(endPath, pNode);
        return {
          ancestor: pNode,
          startContainer,
          startOffset: startOffset + newOffsets[0],
          endContainer,
          endOffset: endOffset + newOffsets[1]
        };
      },
      /**
       * @description wraps first line selected text.
       * @param {Element} element The node of the line that contains the selected text node.
       * @param {Element} newInnerNode The dom that will wrap the selected text area
       * @param {Function} validation Check if the node should be stripped.
       * @param {Node} startCon The startContainer property of the selection object.
       * @param {Number} startOff The startOffset property of the selection object.
       * @param {Boolean} isRemoveFormat Is the remove all formats command?
       * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
       * @returns {null|Node} If end container is renewed, returned renewed node
       * @returns {Object} { ancestor, container, offset, endContainer }
       * @private
       */
      _nodeChange_startLine: function(element, newInnerNode, validation, startCon, startOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode, _endContainer) {
        let parentCon = startCon.parentNode;
        while (!parentCon.nextSibling && !parentCon.previousSibling && !util2.isFormatElement(parentCon.parentNode) && !util2.isWysiwygDiv(parentCon.parentNode)) {
          if (parentCon.nodeName === newInnerNode.nodeName) break;
          parentCon = parentCon.parentNode;
        }
        if (!isRemoveNode && parentCon.nodeName === newInnerNode.nodeName && !util2.isFormatElement(parentCon) && !parentCon.nextSibling && util2.onlyZeroWidthSpace(startCon.textContent.slice(0, startOff))) {
          let sameTag = true;
          let s = startCon.previousSibling;
          while (s) {
            if (!util2.onlyZeroWidthSpace(s)) {
              sameTag = false;
              break;
            }
            s = s.previousSibling;
          }
          if (sameTag) {
            util2.copyTagAttributes(parentCon, newInnerNode);
            return {
              ancestor: element,
              container: startCon,
              offset: startOff
            };
          }
        }
        _removeCheck.v = false;
        const el = element;
        const nNodeArray = [newInnerNode];
        const pNode = element.cloneNode(false);
        let container = startCon;
        let offset = startOff;
        let passNode = false;
        let pCurrent, newNode, appendNode, anchorNode;
        (function recursionFunc(current, ancestor) {
          const childNodes = current.childNodes;
          for (let i = 0, len = childNodes.length, vNode, cloneChild; i < len; i++) {
            const child = childNodes[i];
            if (!child) continue;
            let coverNode = ancestor;
            if (passNode && !util2.isBreak(child)) {
              if (child.nodeType === 1) {
                if (util2._isIgnoreNodeChange(child)) {
                  newInnerNode = newInnerNode.cloneNode(false);
                  cloneChild = child.cloneNode(true);
                  pNode.appendChild(cloneChild);
                  pNode.appendChild(newInnerNode);
                  nNodeArray.push(newInnerNode);
                  if (_endContainer && child.contains(_endContainer)) {
                    const endPath = util2.getNodePath(_endContainer, child);
                    _endContainer = util2.getNodeFromPath(endPath, cloneChild);
                  }
                } else {
                  recursionFunc(child, child);
                }
                continue;
              }
              newNode = child;
              pCurrent = [];
              const anchors = [];
              while (newNode.parentNode !== null && newNode !== el && newNode !== newInnerNode) {
                vNode = validation(newNode);
                if (newNode.nodeType === 1 && vNode) {
                  if (_isMaintainedNode(newNode)) {
                    if (!anchorNode) anchors.push(vNode);
                  } else {
                    pCurrent.push(vNode);
                  }
                }
                newNode = newNode.parentNode;
              }
              pCurrent = pCurrent.concat(anchors);
              const isTopNode = pCurrent.length > 0;
              const childNode = pCurrent.pop() || child;
              appendNode = newNode = childNode;
              while (pCurrent.length > 0) {
                newNode = pCurrent.pop();
                appendNode.appendChild(newNode);
                appendNode = newNode;
              }
              if (_isMaintainedNode(newInnerNode.parentNode) && !_isMaintainedNode(childNode)) {
                newInnerNode = newInnerNode.cloneNode(false);
                pNode.appendChild(newInnerNode);
                nNodeArray.push(newInnerNode);
              }
              if (!anchorNode && _isMaintainedNode(childNode)) {
                newInnerNode = newInnerNode.cloneNode(false);
                const aChildren = childNode.childNodes;
                for (let a = 0, aLen = aChildren.length; a < aLen; a++) {
                  newInnerNode.appendChild(aChildren[a]);
                }
                childNode.appendChild(newInnerNode);
                pNode.appendChild(childNode);
                ancestor = !_isMaintainedNode(newNode) ? newNode : newInnerNode;
                nNodeArray.push(newInnerNode);
              } else if (isTopNode) {
                newInnerNode.appendChild(childNode);
                ancestor = newNode;
              } else {
                ancestor = newInnerNode;
              }
              if (anchorNode && child.nodeType === 3) {
                if (_getMaintainedNode(child)) {
                  const ancestorAnchorNode = util2.getParentElement(ancestor, function(current2) {
                    return this._isMaintainedNode(current2.parentNode) || current2.parentNode === pNode;
                  }.bind(util2));
                  anchorNode.appendChild(ancestorAnchorNode);
                  newInnerNode = ancestorAnchorNode.cloneNode(false);
                  nNodeArray.push(newInnerNode);
                  pNode.appendChild(newInnerNode);
                } else {
                  anchorNode = null;
                }
              }
            }
            if (!passNode && child === container) {
              let line = pNode;
              anchorNode = _getMaintainedNode(child);
              const prevNode = util2.createTextNode(container.nodeType === 1 ? "" : container.substringData(0, offset));
              const textNode = util2.createTextNode(container.nodeType === 1 ? "" : container.substringData(offset, container.length - offset));
              if (anchorNode) {
                const a = _getMaintainedNode(ancestor);
                if (a && a.parentNode !== line) {
                  let m = a;
                  let p = null;
                  while (m.parentNode !== line) {
                    ancestor = p = m.parentNode.cloneNode(false);
                    while (m.childNodes[0]) {
                      p.appendChild(m.childNodes[0]);
                    }
                    m.appendChild(p);
                    m = m.parentNode;
                  }
                  m.parentNode.appendChild(a);
                }
                anchorNode = anchorNode.cloneNode(false);
              }
              if (!util2.onlyZeroWidthSpace(prevNode)) {
                ancestor.appendChild(prevNode);
              }
              const prevAnchorNode = _getMaintainedNode(ancestor);
              if (!!prevAnchorNode) anchorNode = prevAnchorNode;
              if (anchorNode) line = anchorNode;
              newNode = ancestor;
              pCurrent = [];
              while (newNode !== line && newNode !== null) {
                vNode = validation(newNode);
                if (newNode.nodeType === 1 && vNode) {
                  pCurrent.push(vNode);
                }
                newNode = newNode.parentNode;
              }
              const childNode = pCurrent.pop() || ancestor;
              appendNode = newNode = childNode;
              while (pCurrent.length > 0) {
                newNode = pCurrent.pop();
                appendNode.appendChild(newNode);
                appendNode = newNode;
              }
              if (childNode !== ancestor) {
                newInnerNode.appendChild(childNode);
                ancestor = newNode;
              } else {
                ancestor = newInnerNode;
              }
              if (util2.isBreak(child)) newInnerNode.appendChild(child.cloneNode(false));
              line.appendChild(newInnerNode);
              container = textNode;
              offset = 0;
              passNode = true;
              ancestor.appendChild(container);
              continue;
            }
            vNode = !passNode ? child.cloneNode(false) : validation(child);
            if (vNode) {
              ancestor.appendChild(vNode);
              if (child.nodeType === 1 && !util2.isBreak(child)) coverNode = vNode;
            }
            recursionFunc(child, coverNode);
          }
        })(element, pNode);
        if (isRemoveNode && !isRemoveFormat && !_removeCheck.v) {
          return {
            ancestor: element,
            container: startCon,
            offset: startOff,
            endContainer: _endContainer
          };
        }
        isRemoveFormat = isRemoveFormat && isRemoveNode;
        if (isRemoveFormat) {
          for (let i = 0; i < nNodeArray.length; i++) {
            let removeNode = nNodeArray[i];
            const rChildren = removeNode.childNodes;
            const textNode = rChildren[0];
            while (rChildren[0]) {
              pNode.insertBefore(rChildren[0], removeNode);
            }
            util2.removeItem(removeNode);
            if (i === 0) container = textNode;
          }
        } else if (isRemoveNode) {
          newInnerNode = newInnerNode.firstChild;
          for (let i = 0; i < nNodeArray.length; i++) {
            this._stripRemoveNode(nNodeArray[i]);
          }
        }
        if (!isRemoveFormat && pNode.childNodes.length === 0) {
          if (element.childNodes) {
            container = element.childNodes[0];
          } else {
            container = util2.createTextNode(util2.zeroWidthSpace);
            element.appendChild(container);
          }
        } else {
          util2.removeEmptyNode(pNode, newInnerNode, false);
          if (util2.onlyZeroWidthSpace(pNode.textContent)) {
            container = pNode.firstChild;
            offset = 0;
          }
          const offsets = { s: 0, e: 0 };
          const path = util2.getNodePath(container, pNode, offsets);
          offset += offsets.s;
          const newOffsets = util2.mergeSameTags(pNode, [path], true);
          element.parentNode.replaceChild(pNode, element);
          container = util2.getNodeFromPath(path, pNode);
          offset += newOffsets[0];
        }
        return {
          ancestor: pNode,
          container,
          offset,
          endContainer: _endContainer
        };
      },
      /**
       * @description wraps mid lines selected text.
       * @param {Element} element The node of the line that contains the selected text node.
       * @param {Element} newInnerNode The dom that will wrap the selected text area
       * @param {Function} validation Check if the node should be stripped.
       * @param {Boolean} isRemoveFormat Is the remove all formats command?
       * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
       * @param {Node} _endContainer Offset node of last line already modified (end.container)
       * @returns {Object} { ancestor, endContainer: "If end container is renewed, returned renewed node" }
       * @private
       */
      _nodeChange_middleLine: function(element, newInnerNode, validation, isRemoveFormat, isRemoveNode, _removeCheck, _endContainer) {
        if (!isRemoveNode) {
          let endPath = null;
          if (_endContainer && element.contains(_endContainer)) endPath = util2.getNodePath(_endContainer, element);
          const tempNode = element.cloneNode(true);
          const newNodeName = newInnerNode.nodeName;
          const newCssText = newInnerNode.style.cssText;
          const newClass = newInnerNode.className;
          let children2 = tempNode.childNodes;
          let i = 0, len = children2.length;
          for (let child; i < len; i++) {
            child = children2[i];
            if (child.nodeType === 3) break;
            if (child.nodeName === newNodeName) {
              child.style.cssText += newCssText;
              util2.addClass(child, newClass);
            } else if (!util2.isBreak(child) && util2._isIgnoreNodeChange(child)) {
              continue;
            } else if (len === 1) {
              children2 = child.childNodes;
              len = children2.length;
              i = -1;
              continue;
            } else {
              break;
            }
          }
          if (len > 0 && i === len) {
            element.innerHTML = tempNode.innerHTML;
            return {
              ancestor: element,
              endContainer: endPath ? util2.getNodeFromPath(endPath, element) : null
            };
          }
        }
        _removeCheck.v = false;
        const pNode = element.cloneNode(false);
        const nNodeArray = [newInnerNode];
        let noneChange = true;
        (function recursionFunc(current, ancestor) {
          const childNodes = current.childNodes;
          for (let i = 0, len = childNodes.length, vNode, cloneChild; i < len; i++) {
            let child = childNodes[i];
            if (!child) continue;
            let coverNode = ancestor;
            if (!util2.isBreak(child) && util2._isIgnoreNodeChange(child)) {
              if (newInnerNode.childNodes.length > 0) {
                pNode.appendChild(newInnerNode);
                newInnerNode = newInnerNode.cloneNode(false);
              }
              cloneChild = child.cloneNode(true);
              pNode.appendChild(cloneChild);
              pNode.appendChild(newInnerNode);
              nNodeArray.push(newInnerNode);
              ancestor = newInnerNode;
              if (_endContainer && child.contains(_endContainer)) {
                const endPath = util2.getNodePath(_endContainer, child);
                _endContainer = util2.getNodeFromPath(endPath, cloneChild);
              }
              continue;
            } else {
              vNode = validation(child);
              if (vNode) {
                noneChange = false;
                ancestor.appendChild(vNode);
                if (child.nodeType === 1) coverNode = vNode;
              }
            }
            if (!util2.isBreak(child)) recursionFunc(child, coverNode);
          }
        })(element, newInnerNode);
        if (noneChange || isRemoveNode && !isRemoveFormat && !_removeCheck.v) return { ancestor: element, endContainer: _endContainer };
        pNode.appendChild(newInnerNode);
        if (isRemoveFormat && isRemoveNode) {
          for (let i = 0; i < nNodeArray.length; i++) {
            let removeNode = nNodeArray[i];
            const rChildren = removeNode.childNodes;
            while (rChildren[0]) {
              pNode.insertBefore(rChildren[0], removeNode);
            }
            util2.removeItem(removeNode);
          }
        } else if (isRemoveNode) {
          newInnerNode = newInnerNode.firstChild;
          for (let i = 0; i < nNodeArray.length; i++) {
            this._stripRemoveNode(nNodeArray[i]);
          }
        }
        util2.removeEmptyNode(pNode, newInnerNode, false);
        util2.mergeSameTags(pNode, null, true);
        element.parentNode.replaceChild(pNode, element);
        return { ancestor: pNode, endContainer: _endContainer };
      },
      /**
       * @description wraps last line selected text.
       * @param {Element} element The node of the line that contains the selected text node.
       * @param {Element} newInnerNode The dom that will wrap the selected text area
       * @param {Function} validation Check if the node should be stripped.
       * @param {Node} endCon The endContainer property of the selection object.
       * @param {Number} endOff The endOffset property of the selection object.
       * @param {Boolean} isRemoveFormat Is the remove all formats command?
       * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
       * @returns {Object} { ancestor, container, offset }
       * @private
       */
      _nodeChange_endLine: function(element, newInnerNode, validation, endCon, endOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode) {
        let parentCon = endCon.parentNode;
        while (!parentCon.nextSibling && !parentCon.previousSibling && !util2.isFormatElement(parentCon.parentNode) && !util2.isWysiwygDiv(parentCon.parentNode)) {
          if (parentCon.nodeName === newInnerNode.nodeName) break;
          parentCon = parentCon.parentNode;
        }
        if (!isRemoveNode && parentCon.nodeName === newInnerNode.nodeName && !util2.isFormatElement(parentCon) && !parentCon.previousSibling && util2.onlyZeroWidthSpace(endCon.textContent.slice(endOff))) {
          let sameTag = true;
          let e = endCon.nextSibling;
          while (e) {
            if (!util2.onlyZeroWidthSpace(e)) {
              sameTag = false;
              break;
            }
            e = e.nextSibling;
          }
          if (sameTag) {
            util2.copyTagAttributes(parentCon, newInnerNode);
            return {
              ancestor: element,
              container: endCon,
              offset: endOff
            };
          }
        }
        _removeCheck.v = false;
        const el = element;
        const nNodeArray = [newInnerNode];
        const pNode = element.cloneNode(false);
        let container = endCon;
        let offset = endOff;
        let passNode = false;
        let pCurrent, newNode, appendNode, anchorNode;
        (function recursionFunc(current, ancestor) {
          const childNodes = current.childNodes;
          for (let i = childNodes.length - 1, vNode; 0 <= i; i--) {
            const child = childNodes[i];
            if (!child) continue;
            let coverNode = ancestor;
            if (passNode && !util2.isBreak(child)) {
              if (child.nodeType === 1) {
                if (util2._isIgnoreNodeChange(child)) {
                  newInnerNode = newInnerNode.cloneNode(false);
                  const cloneChild = child.cloneNode(true);
                  pNode.insertBefore(cloneChild, ancestor);
                  pNode.insertBefore(newInnerNode, cloneChild);
                  nNodeArray.push(newInnerNode);
                } else {
                  recursionFunc(child, child);
                }
                continue;
              }
              newNode = child;
              pCurrent = [];
              const anchors = [];
              while (newNode.parentNode !== null && newNode !== el && newNode !== newInnerNode) {
                vNode = validation(newNode);
                if (vNode && newNode.nodeType === 1) {
                  if (_isMaintainedNode(newNode)) {
                    if (!anchorNode) anchors.push(vNode);
                  } else {
                    pCurrent.push(vNode);
                  }
                }
                newNode = newNode.parentNode;
              }
              pCurrent = pCurrent.concat(anchors);
              const isTopNode = pCurrent.length > 0;
              const childNode = pCurrent.pop() || child;
              appendNode = newNode = childNode;
              while (pCurrent.length > 0) {
                newNode = pCurrent.pop();
                appendNode.appendChild(newNode);
                appendNode = newNode;
              }
              if (_isMaintainedNode(newInnerNode.parentNode) && !_isMaintainedNode(childNode)) {
                newInnerNode = newInnerNode.cloneNode(false);
                pNode.insertBefore(newInnerNode, pNode.firstChild);
                nNodeArray.push(newInnerNode);
              }
              if (!anchorNode && _isMaintainedNode(childNode)) {
                newInnerNode = newInnerNode.cloneNode(false);
                const aChildren = childNode.childNodes;
                for (let a = 0, aLen = aChildren.length; a < aLen; a++) {
                  newInnerNode.appendChild(aChildren[a]);
                }
                childNode.appendChild(newInnerNode);
                pNode.insertBefore(childNode, pNode.firstChild);
                nNodeArray.push(newInnerNode);
                if (newInnerNode.children.length > 0) ancestor = newNode;
                else ancestor = newInnerNode;
              } else if (isTopNode) {
                newInnerNode.insertBefore(childNode, newInnerNode.firstChild);
                ancestor = newNode;
              } else {
                ancestor = newInnerNode;
              }
              if (anchorNode && child.nodeType === 3) {
                if (_getMaintainedNode(child)) {
                  const ancestorAnchorNode = util2.getParentElement(ancestor, function(current2) {
                    return this._isMaintainedNode(current2.parentNode) || current2.parentNode === pNode;
                  }.bind(util2));
                  anchorNode.appendChild(ancestorAnchorNode);
                  newInnerNode = ancestorAnchorNode.cloneNode(false);
                  nNodeArray.push(newInnerNode);
                  pNode.insertBefore(newInnerNode, pNode.firstChild);
                } else {
                  anchorNode = null;
                }
              }
            }
            if (!passNode && child === container) {
              anchorNode = _getMaintainedNode(child);
              const afterNode = util2.createTextNode(container.nodeType === 1 ? "" : container.substringData(offset, container.length - offset));
              const textNode = util2.createTextNode(container.nodeType === 1 ? "" : container.substringData(0, offset));
              if (anchorNode) {
                anchorNode = anchorNode.cloneNode(false);
                const a = _getMaintainedNode(ancestor);
                if (a && a.parentNode !== pNode) {
                  let m = a;
                  let p = null;
                  while (m.parentNode !== pNode) {
                    ancestor = p = m.parentNode.cloneNode(false);
                    while (m.childNodes[0]) {
                      p.appendChild(m.childNodes[0]);
                    }
                    m.appendChild(p);
                    m = m.parentNode;
                  }
                  m.parentNode.insertBefore(a, m.parentNode.firstChild);
                }
                anchorNode = anchorNode.cloneNode(false);
              } else if (_isMaintainedNode(newInnerNode.parentNode) && !anchorNode) {
                newInnerNode = newInnerNode.cloneNode(false);
                pNode.appendChild(newInnerNode);
                nNodeArray.push(newInnerNode);
              }
              if (!util2.onlyZeroWidthSpace(afterNode)) {
                ancestor.insertBefore(afterNode, ancestor.firstChild);
              }
              newNode = ancestor;
              pCurrent = [];
              while (newNode !== pNode && newNode !== null) {
                vNode = _isMaintainedNode(newNode) ? null : validation(newNode);
                if (vNode && newNode.nodeType === 1) {
                  pCurrent.push(vNode);
                }
                newNode = newNode.parentNode;
              }
              const childNode = pCurrent.pop() || ancestor;
              appendNode = newNode = childNode;
              while (pCurrent.length > 0) {
                newNode = pCurrent.pop();
                appendNode.appendChild(newNode);
                appendNode = newNode;
              }
              if (childNode !== ancestor) {
                newInnerNode.insertBefore(childNode, newInnerNode.firstChild);
                ancestor = newNode;
              } else {
                ancestor = newInnerNode;
              }
              if (util2.isBreak(child)) newInnerNode.appendChild(child.cloneNode(false));
              if (anchorNode) {
                anchorNode.insertBefore(newInnerNode, anchorNode.firstChild);
                pNode.insertBefore(anchorNode, pNode.firstChild);
                anchorNode = null;
              } else {
                pNode.insertBefore(newInnerNode, pNode.firstChild);
              }
              container = textNode;
              offset = textNode.data.length;
              passNode = true;
              ancestor.insertBefore(container, ancestor.firstChild);
              continue;
            }
            vNode = !passNode ? child.cloneNode(false) : validation(child);
            if (vNode) {
              ancestor.insertBefore(vNode, ancestor.firstChild);
              if (child.nodeType === 1 && !util2.isBreak(child)) coverNode = vNode;
            }
            recursionFunc(child, coverNode);
          }
        })(element, pNode);
        if (isRemoveNode && !isRemoveFormat && !_removeCheck.v) {
          return {
            ancestor: element,
            container: endCon,
            offset: endOff
          };
        }
        isRemoveFormat = isRemoveFormat && isRemoveNode;
        if (isRemoveFormat) {
          for (let i = 0; i < nNodeArray.length; i++) {
            let removeNode = nNodeArray[i];
            const rChildren = removeNode.childNodes;
            let textNode = null;
            while (rChildren[0]) {
              textNode = rChildren[0];
              pNode.insertBefore(textNode, removeNode);
            }
            util2.removeItem(removeNode);
            if (i === nNodeArray.length - 1) {
              container = textNode;
              offset = textNode.textContent.length;
            }
          }
        } else if (isRemoveNode) {
          newInnerNode = newInnerNode.firstChild;
          for (let i = 0; i < nNodeArray.length; i++) {
            this._stripRemoveNode(nNodeArray[i]);
          }
        }
        if (!isRemoveFormat && pNode.childNodes.length === 0) {
          if (element.childNodes) {
            container = element.childNodes[0];
          } else {
            container = util2.createTextNode(util2.zeroWidthSpace);
            element.appendChild(container);
          }
        } else {
          if (!isRemoveNode && newInnerNode.textContent.length === 0) {
            util2.removeEmptyNode(pNode, null, false);
            return {
              ancestor: null,
              container: null,
              offset: 0
            };
          }
          util2.removeEmptyNode(pNode, newInnerNode, false);
          if (util2.onlyZeroWidthSpace(pNode.textContent)) {
            container = pNode.firstChild;
            offset = container.textContent.length;
          } else if (util2.onlyZeroWidthSpace(container)) {
            container = newInnerNode;
            offset = 1;
          }
          const offsets = { s: 0, e: 0 };
          const path = util2.getNodePath(container, pNode, offsets);
          offset += offsets.s;
          const newOffsets = util2.mergeSameTags(pNode, [path], true);
          element.parentNode.replaceChild(pNode, element);
          container = util2.getNodeFromPath(path, pNode);
          offset += newOffsets[0];
        }
        return {
          ancestor: pNode,
          container,
          offset: container.nodeType === 1 && offset === 1 ? container.childNodes.length : offset
        };
      },
      /**
       * @description Run plugin calls and basic commands.
       * @param {String} command Command string
       * @param {String} display Display type string ('command', 'submenu', 'dialog', 'container')
       * @param {Element} target The element of command button
       */
      actionCall: function(command, display, target) {
        if (display) {
          if (/more/i.test(display)) {
            if (target !== this._moreLayerActiveButton) {
              const layer = context.element.toolbar.querySelector("." + command);
              if (layer) {
                if (this._moreLayerActiveButton) this.moreLayerOff();
                this._moreLayerActiveButton = target;
                layer.style.display = "block";
                event._showToolbarBalloon();
                event._showToolbarInline();
              }
              util2.addClass(target, "on");
            } else {
              const layer = context.element.toolbar.querySelector("." + this._moreLayerActiveButton.getAttribute("data-command"));
              if (layer) {
                this.moreLayerOff();
                event._showToolbarBalloon();
                event._showToolbarInline();
              }
            }
            return;
          }
          if (/container/.test(display) && (this._menuTray[command] === null || target !== this.containerActiveButton)) {
            this.callPlugin(command, this.containerOn.bind(this, target), target);
            return;
          }
          if (this.isReadOnly && util2.arrayIncludes(this.resizingDisabledButtons, target)) return;
          if (/submenu/.test(display) && (this._menuTray[command] === null || target !== this.submenuActiveButton)) {
            this.callPlugin(command, this.submenuOn.bind(this, target), target);
            return;
          } else if (/dialog/.test(display)) {
            this.callPlugin(command, this.plugins[command].open.bind(this), target);
            return;
          } else if (/command/.test(display)) {
            this.callPlugin(command, this.plugins[command].action.bind(this), target);
          } else if (/fileBrowser/.test(display)) {
            this.callPlugin(command, this.plugins[command].open.bind(this, null), target);
          }
        } else if (command) {
          this.commandHandler(target, command);
        }
        if (/submenu/.test(display)) {
          this.submenuOff();
        } else if (!/command/.test(display)) {
          this.submenuOff();
          this.containerOff();
        }
      },
      /**
       * @description Execute command of command button(All Buttons except submenu and dialog)
       * (selectAll, codeView, fullScreen, indent, outdent, undo, redo, removeFormat, print, preview, showBlocks, save, bold, underline, italic, strike, subscript, superscript, copy, cut, paste)
       * @param {Element|null} target The element of command button
       * @param {String} command Property of command button (data-value)
       */
      commandHandler: function(target, command) {
        if (core.isReadOnly && !/copy|cut|selectAll|codeView|fullScreen|print|preview|showBlocks/.test(command)) return;
        switch (command) {
          case "copy":
          case "cut":
            this.execCommand(command);
            break;
          case "paste":
            break;
          case "selectAll":
            this.containerOff();
            const wysiwyg = context.element.wysiwyg;
            let first = util2.getChildElement(wysiwyg.firstChild, function(current) {
              return current.childNodes.length === 0 || current.nodeType === 3;
            }, false) || wysiwyg.firstChild;
            let last = util2.getChildElement(wysiwyg.lastChild, function(current) {
              return current.childNodes.length === 0 || current.nodeType === 3;
            }, true) || wysiwyg.lastChild;
            if (!first || !last) return;
            if (util2.isMedia(first)) {
              const info = this.getFileComponent(first);
              const br2 = util2.createElement("BR");
              const format = util2.createElement(options2.defaultTag);
              format.appendChild(br2);
              first = info ? info.component : first;
              first.parentNode.insertBefore(format, first);
              first = br2;
            }
            if (util2.isMedia(last)) {
              const br2 = util2.createElement("BR");
              const format = util2.createElement(options2.defaultTag);
              format.appendChild(br2);
              wysiwyg.appendChild(format);
              last = br2;
            }
            event._showToolbarBalloon(this.setRange(first, 0, last, last.textContent.length));
            break;
          case "codeView":
            this.toggleCodeView();
            break;
          case "fullScreen":
            this.toggleFullScreen(target);
            break;
          case "indent":
          case "outdent":
            this.indent(command);
            break;
          case "undo":
            this.history.undo();
            break;
          case "redo":
            this.history.redo();
            break;
          case "removeFormat":
            this.removeFormat();
            this.focus();
            break;
          case "print":
            this.print();
            break;
          case "preview":
            this.preview();
            break;
          case "showBlocks":
            this.toggleDisplayBlocks();
            break;
          case "dir":
            this.setDir(options2.rtl ? "ltr" : "rtl");
            break;
          case "dir_ltr":
            this.setDir("ltr");
            break;
          case "dir_rtl":
            this.setDir("rtl");
            break;
          case "save":
            if (typeof options2.callBackSave === "function") {
              options2.callBackSave(this.getContents(false), this._variable.isChanged);
            } else if (this._variable.isChanged && typeof functions.save === "function") {
              functions.save();
            } else {
              throw Error("[SUNEDITOR.core.commandHandler.fail] Please register call back function in creation option. (callBackSave : Function)");
            }
            this._variable.isChanged = false;
            if (context.tool.save) context.tool.save.setAttribute("disabled", true);
            break;
          default:
            command = options2._defaultCommand[command.toLowerCase()] || command;
            if (!this.commandMap[command]) this.commandMap[command] = target;
            const nodesMap = this._variable.currentNodesMap;
            const cmd = nodesMap.indexOf(command) > -1 ? null : util2.createElement(command);
            let removeNode = command;
            if (/^SUB$/i.test(command) && nodesMap.indexOf("SUP") > -1) {
              removeNode = "SUP";
            } else if (/^SUP$/i.test(command) && nodesMap.indexOf("SUB") > -1) {
              removeNode = "SUB";
            }
            this.nodeChange(cmd, this._commandMapStyles[command] || null, [removeNode], false);
            this.focus();
        }
      },
      /**
       * @description Remove format of the currently selected range
       */
      removeFormat: function() {
        this.nodeChange(null, null, null, null);
      },
      /**
       * @description This method implements indentation to selected range.
       * Setted "margin-left" to "25px" in the top "P" tag of the parameter node.
       * @param {String} command Separator ("indent" or "outdent")
       */
      indent: function(command) {
        const range = this.getRange();
        const rangeLines = this.getSelectedElements(null);
        const cells = [];
        const shift = "indent" !== command;
        const marginDir = options2.rtl ? "marginRight" : "marginLeft";
        let sc = range.startContainer;
        let ec = range.endContainer;
        let so = range.startOffset;
        let eo = range.endOffset;
        for (let i = 0, len = rangeLines.length, f, margin; i < len; i++) {
          f = rangeLines[i];
          if (!util2.isListCell(f) || !this.plugins.list) {
            margin = /\d+/.test(f.style[marginDir]) ? util2.getNumber(f.style[marginDir], 0) : 0;
            if (shift) {
              margin -= 25;
            } else {
              margin += 25;
            }
            util2.setStyle(f, marginDir, margin <= 0 ? "" : margin + "px");
          } else {
            if (shift || f.previousElementSibling) {
              cells.push(f);
            }
          }
        }
        if (cells.length > 0) {
          this.plugins.list.editInsideList.call(this, shift, cells);
        }
        this.effectNode = null;
        this.setRange(sc, so, ec, eo);
        this.history.push(false);
      },
      /**
       * @description Add or remove the class name of "body" so that the code block is visible
       */
      toggleDisplayBlocks: function() {
        const wysiwyg = context.element.wysiwyg;
        util2.toggleClass(wysiwyg, "se-show-block");
        if (util2.hasClass(wysiwyg, "se-show-block")) {
          util2.addClass(this._styleCommandMap.showBlocks, "active");
        } else {
          util2.removeClass(this._styleCommandMap.showBlocks, "active");
        }
        this._resourcesStateChange();
      },
      /**
       * @description Changes to code view or wysiwyg view
       */
      toggleCodeView: function() {
        const isCodeView = this._variable.isCodeView;
        this.controllersOff();
        util2.setDisabledButtons(!isCodeView, this.codeViewDisabledButtons);
        if (isCodeView) {
          if (!util2.isNonEditable(context.element.wysiwygFrame)) this._setCodeDataToEditor();
          context.element.wysiwygFrame.scrollTop = 0;
          context.element.code.style.display = "none";
          context.element.wysiwygFrame.style.display = "block";
          this._variable._codeOriginCssText = this._variable._codeOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, "display: none");
          this._variable._wysiwygOriginCssText = this._variable._wysiwygOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, "display: block");
          if (options2.height === "auto" && !options2.codeMirrorEditor) context.element.code.style.height = "0px";
          this._variable.isCodeView = false;
          if (!this._variable.isFullScreen) {
            this._notHideToolbar = false;
            if (/balloon|balloon-always/i.test(options2.mode)) {
              context.element._arrow.style.display = "";
              this._isInline = false;
              this._isBalloon = true;
              event._hideToolbar();
            }
          }
          this.nativeFocus();
          util2.removeClass(this._styleCommandMap.codeView, "active");
          if (!util2.isNonEditable(context.element.wysiwygFrame)) {
            this.history.push(false);
            this.history._resetCachingButton();
          }
        } else {
          this._setEditorDataToCodeView();
          this._variable._codeOriginCssText = this._variable._codeOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, "display: block");
          this._variable._wysiwygOriginCssText = this._variable._wysiwygOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, "display: none");
          if (this._variable.isFullScreen) context.element.code.style.height = "100%";
          else if (options2.height === "auto" && !options2.codeMirrorEditor) context.element.code.style.height = context.element.code.scrollHeight > 0 ? context.element.code.scrollHeight + "px" : "auto";
          if (options2.codeMirrorEditor) options2.codeMirrorEditor.refresh();
          this._variable.isCodeView = true;
          if (!this._variable.isFullScreen) {
            this._notHideToolbar = true;
            if (this._isBalloon) {
              context.element._arrow.style.display = "none";
              context.element.toolbar.style.left = "";
              this._isInline = true;
              this._isBalloon = false;
              event._showToolbarInline();
            }
          }
          this._variable._range = null;
          context.element.code.focus();
          util2.addClass(this._styleCommandMap.codeView, "active");
        }
        this._checkPlaceholder();
        if (this.isReadOnly) util2.setDisabledButtons(true, this.resizingDisabledButtons);
        if (typeof functions.toggleCodeView === "function") functions.toggleCodeView(this._variable.isCodeView, this);
      },
      /**
       * @description Convert the data of the code view and put it in the WYSIWYG area.
       * @private
       */
      _setCodeDataToEditor: function() {
        const code_html = this._getCodeView();
        if (options2.fullPage) {
          const parseDocument = this._parser.parseFromString(code_html, "text/html");
          if (!this.options.__allowedScriptTag) {
            const headChildren = parseDocument.head.children;
            for (let i = 0, len = headChildren.length; i < len; i++) {
              if (/^script$/i.test(headChildren[i].tagName)) {
                parseDocument.head.removeChild(headChildren[i]);
                i--, len--;
              }
            }
          }
          let headers = parseDocument.head.innerHTML;
          if (!parseDocument.head.querySelector('link[rel="stylesheet"]') || this.options.height === "auto" && !parseDocument.head.querySelector("style")) {
            headers += util2._setIframeCssTags(this.options);
          }
          this._wd.head.innerHTML = headers;
          this._wd.body.innerHTML = this.convertContentsForEditor(parseDocument.body.innerHTML);
          const attrs = parseDocument.body.attributes;
          for (let i = 0, len = attrs.length; i < len; i++) {
            if (attrs[i].name === "contenteditable") continue;
            this._wd.body.setAttribute(attrs[i].name, attrs[i].value);
          }
          if (!util2.hasClass(this._wd.body, "sun-editor-editable")) {
            const editableClasses = options2._editableClass.split(" ");
            for (let i = 0; i < editableClasses.length; i++) {
              util2.addClass(this._wd.body, options2._editableClass[i]);
            }
          }
        } else {
          context.element.wysiwyg.innerHTML = code_html.length > 0 ? this.convertContentsForEditor(code_html) : "<" + options2.defaultTag + "><br></" + options2.defaultTag + ">";
        }
      },
      /**
       * @description Convert the data of the WYSIWYG area and put it in the code view area.
       * @private
       */
      _setEditorDataToCodeView: function() {
        const codeContents = this.convertHTMLForCodeView(context.element.wysiwyg, false);
        let codeValue = "";
        if (options2.fullPage) {
          const attrs = util2.getAttributesToString(this._wd.body, null);
          codeValue = "<!DOCTYPE html>\n<html>\n" + this._wd.head.outerHTML.replace(/>(?!\n)/g, ">\n") + "<body " + attrs + ">\n" + codeContents + "</body>\n</html>";
        } else {
          codeValue = codeContents;
        }
        context.element.code.style.display = "block";
        context.element.wysiwygFrame.style.display = "none";
        this._setCodeView(codeValue);
      },
      /**
       * @description Changes to full screen or default screen
       * @param {Element|null} element full screen button
       */
      toggleFullScreen: function(element) {
        const topArea = context.element.topArea;
        const toolbar = context.element.toolbar;
        const editorArea = context.element.editorArea;
        const wysiwygFrame = context.element.wysiwygFrame;
        const code = context.element.code;
        const _var = this._variable;
        this.controllersOff();
        const wasToolbarHidden = toolbar.style.display === "none" || this._isInline && !this._inlineToolbarAttr.isShow;
        if (!_var.isFullScreen) {
          _var.isFullScreen = true;
          _var._fullScreenAttrs.inline = this._isInline;
          _var._fullScreenAttrs.balloon = this._isBalloon;
          if (this._isInline || this._isBalloon) {
            this._isInline = false;
            this._isBalloon = false;
          }
          if (!!options2.toolbarContainer) context.element.relative.insertBefore(toolbar, editorArea);
          topArea.style.position = "fixed";
          topArea.style.top = "0";
          topArea.style.left = "0";
          topArea.style.width = "100%";
          topArea.style.maxWidth = "100%";
          topArea.style.height = "100%";
          topArea.style.zIndex = "2147483647";
          if (context.element._stickyDummy.style.display !== "") {
            _var._fullScreenAttrs.sticky = true;
            context.element._stickyDummy.style.display = "none";
            util2.removeClass(toolbar, "se-toolbar-sticky");
          }
          _var._bodyOverflow = _d.body.style.overflow;
          _d.body.style.overflow = "hidden";
          _var._editorAreaOriginCssText = editorArea.style.cssText;
          _var._wysiwygOriginCssText = wysiwygFrame.style.cssText;
          _var._codeOriginCssText = code.style.cssText;
          editorArea.style.cssText = toolbar.style.cssText = "";
          wysiwygFrame.style.cssText = (wysiwygFrame.style.cssText.match(/\s?display(\s+)?:(\s+)?[a-zA-Z]+;/) || [""])[0] + options2._editorStyles.editor;
          code.style.cssText = (code.style.cssText.match(/\s?display(\s+)?:(\s+)?[a-zA-Z]+;/) || [""])[0];
          toolbar.style.width = wysiwygFrame.style.height = code.style.height = "100%";
          toolbar.style.position = "relative";
          toolbar.style.display = "block";
          _var.innerHeight_fullScreen = _w.innerHeight - toolbar.offsetHeight;
          editorArea.style.height = _var.innerHeight_fullScreen - options2.fullScreenOffset + "px";
          if (element) util2.changeElement(element.firstElementChild, icons.reduction);
          if (options2.iframe && options2.height === "auto") {
            editorArea.style.overflow = "auto";
            this._iframeAutoHeight();
          }
          context.element.topArea.style.marginTop = options2.fullScreenOffset + "px";
          util2.addClass(this._styleCommandMap.fullScreen, "active");
        } else {
          _var.isFullScreen = false;
          wysiwygFrame.style.cssText = _var._wysiwygOriginCssText;
          code.style.cssText = _var._codeOriginCssText;
          toolbar.style.cssText = "";
          editorArea.style.cssText = _var._editorAreaOriginCssText;
          topArea.style.cssText = _var._originCssText;
          _d.body.style.overflow = _var._bodyOverflow;
          if (options2.height === "auto" && !options2.codeMirrorEditor) event._codeViewAutoHeight();
          if (!!options2.toolbarContainer) options2.toolbarContainer.appendChild(toolbar);
          if (options2.stickyToolbar > -1) {
            util2.removeClass(toolbar, "se-toolbar-sticky");
          }
          if (_var._fullScreenAttrs.sticky && !options2.toolbarContainer) {
            _var._fullScreenAttrs.sticky = false;
            context.element._stickyDummy.style.display = "block";
            util2.addClass(toolbar, "se-toolbar-sticky");
          }
          this._isInline = _var._fullScreenAttrs.inline;
          this._isBalloon = _var._fullScreenAttrs.balloon;
          if (this._isInline) event._showToolbarInline();
          if (!!options2.toolbarContainer) util2.removeClass(toolbar, "se-toolbar-balloon");
          event.onScroll_window();
          if (element) util2.changeElement(element.firstElementChild, icons.expansion);
          context.element.topArea.style.marginTop = "";
          util2.removeClass(this._styleCommandMap.fullScreen, "active");
        }
        if (wasToolbarHidden) functions.toolbar.hide();
        if (typeof functions.toggleFullScreen === "function") functions.toggleFullScreen(this._variable.isFullScreen, this);
      },
      /**
       * @description Prints the current contents of the editor.
       */
      print: function() {
        const iframe = util2.createElement("IFRAME");
        iframe.style.display = "none";
        _d.body.appendChild(iframe);
        const contentsHTML = options2.printTemplate ? options2.printTemplate.replace(/\{\{\s*contents\s*\}\}/i, this.getContents(true)) : this.getContents(true);
        const printDocument = util2.getIframeDocument(iframe);
        const wDoc = this._wd;
        if (options2.iframe) {
          const arrts = options2._printClass !== null ? 'class="' + options2._printClass + '"' : options2.fullPage ? util2.getAttributesToString(wDoc.body, ["contenteditable"]) : 'class="' + options2._editableClass + '"';
          printDocument.write(
            "<!DOCTYPE html><html><head>" + wDoc.head.innerHTML + "</head><body " + arrts + ">" + contentsHTML + "</body></html>"
          );
        } else {
          const links = _d.head.getElementsByTagName("link");
          const styles = _d.head.getElementsByTagName("style");
          let linkHTML = "";
          for (let i = 0, len = links.length; i < len; i++) {
            linkHTML += links[i].outerHTML;
          }
          for (let i = 0, len = styles.length; i < len; i++) {
            linkHTML += styles[i].outerHTML;
          }
          printDocument.write(
            "<!DOCTYPE html><html><head>" + linkHTML + '</head><body class="' + (options2._printClass !== null ? options2._printClass : options2._editableClass) + '">' + contentsHTML + "</body></html>"
          );
        }
        this.showLoading();
        _w.setTimeout(function() {
          try {
            iframe.focus();
            if (util2.isIE_Edge || util2.isChromium || !!_d.documentMode || !!_w.StyleMedia) {
              try {
                iframe.contentWindow.document.execCommand("print", false, null);
              } catch (e) {
                iframe.contentWindow.print();
              }
            } else {
              iframe.contentWindow.print();
            }
          } catch (error) {
            throw Error("[SUNEDITOR.core.print.fail] error: " + error);
          } finally {
            core.closeLoading();
            util2.removeItem(iframe);
          }
        }, 1e3);
      },
      /**
       * @description Open the preview window.
       */
      preview: function() {
        core.submenuOff();
        core.containerOff();
        core.controllersOff();
        const contentsHTML = options2.previewTemplate ? options2.previewTemplate.replace(/\{\{\s*contents\s*\}\}/i, this.getContents(true)) : this.getContents(true);
        const windowObject = _w.open("", "_blank");
        windowObject.mimeType = "text/html";
        const wDoc = this._wd;
        if (options2.iframe) {
          const arrts = options2._printClass !== null ? 'class="' + options2._printClass + '"' : options2.fullPage ? util2.getAttributesToString(wDoc.body, ["contenteditable"]) : 'class="' + options2._editableClass + '"';
          windowObject.document.write(
            "<!DOCTYPE html><html><head>" + wDoc.head.innerHTML + "<style>body {overflow:auto !important; margin: 10px auto !important; height:auto !important; outline:1px dashed #ccc;}</style></head><body " + arrts + ">" + contentsHTML + "</body></html>"
          );
        } else {
          const links = _d.head.getElementsByTagName("link");
          const styles = _d.head.getElementsByTagName("style");
          let linkHTML = "";
          for (let i = 0, len = links.length; i < len; i++) {
            linkHTML += links[i].outerHTML;
          }
          for (let i = 0, len = styles.length; i < len; i++) {
            linkHTML += styles[i].outerHTML;
          }
          windowObject.document.write(
            '<!DOCTYPE html><html><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>' + lang.toolbar.preview + "</title>" + linkHTML + '</head><body class="' + (options2._printClass !== null ? options2._printClass : options2._editableClass) + '" style="margin:10px auto !important; height:auto !important; outline:1px dashed #ccc;">' + contentsHTML + "</body></html>"
          );
        }
      },
      /**
       * @description Set direction to "rtl" or "ltr".
       * @param {String} dir "rtl" or "ltr"
       */
      setDir: function(dir) {
        const rtl = dir === "rtl";
        const changeDir = this._prevRtl !== rtl;
        this._prevRtl = options2.rtl = rtl;
        if (changeDir) {
          if (this.plugins.align) {
            this.plugins.align.exchangeDir.call(this);
          }
          if (context.tool.indent) util2.changeElement(context.tool.indent.firstElementChild, icons.indent);
          if (context.tool.outdent) util2.changeElement(context.tool.outdent.firstElementChild, icons.outdent);
        }
        const el = context.element;
        if (rtl) {
          util2.addClass(el.topArea, "se-rtl");
          util2.addClass(el.wysiwygFrame, "se-rtl");
        } else {
          util2.removeClass(el.topArea, "se-rtl");
          util2.removeClass(el.wysiwygFrame, "se-rtl");
        }
        const lineNodes = util2.getListChildren(el.wysiwyg, function(current) {
          return util2.isFormatElement(current) && (current.style.marginRight || current.style.marginLeft || current.style.textAlign);
        });
        for (let i = 0, len = lineNodes.length, n, l, r; i < len; i++) {
          n = lineNodes[i];
          r = n.style.marginRight;
          l = n.style.marginLeft;
          if (r || l) {
            n.style.marginRight = l;
            n.style.marginLeft = r;
          }
          r = n.style.textAlign;
          if (r === "left") n.style.textAlign = "right";
          else if (r === "right") n.style.textAlign = "left";
        }
        const tool = context.tool;
        if (tool.dir) {
          util2.changeTxt(tool.dir.querySelector(".se-tooltip-text"), lang.toolbar[options2.rtl ? "dir_ltr" : "dir_rtl"]);
          util2.changeElement(tool.dir.firstElementChild, icons[options2.rtl ? "dir_ltr" : "dir_rtl"]);
        }
        if (tool.dir_ltr) {
          if (rtl) util2.removeClass(tool.dir_ltr, "active");
          else util2.addClass(tool.dir_ltr, "active");
        }
        if (tool.dir_rtl) {
          if (rtl) util2.addClass(tool.dir_rtl, "active");
          else util2.removeClass(tool.dir_rtl, "active");
        }
      },
      /**
       * @description Sets the HTML string
       * @param {String|undefined} html HTML string
       */
      setContents: function(html2) {
        this.removeRange();
        const convertValue = html2 === null || html2 === void 0 ? "" : this.convertContentsForEditor(html2, null, null);
        if (!this._variable.isCodeView) {
          context.element.wysiwyg.innerHTML = convertValue;
          this._resetComponents();
          this.history.push(false);
        } else {
          const value = this.convertHTMLForCodeView(convertValue, false);
          this._setCodeView(value);
        }
      },
      /**
       * @description Sets the contents of the iframe's head tag and body tag when using the "iframe" or "fullPage" option.
       * @param {Object} ctx { head: HTML string, body: HTML string}
       */
      setIframeContents: function(ctx) {
        if (!options2.iframe) return false;
        if (ctx.head) this._wd.head.innerHTML = this.options.__allowedScriptTag ? ctx.head : ctx.head.replace(this.__scriptTagRegExp, "");
        if (ctx.body) this._wd.body.innerHTML = this.convertContentsForEditor(ctx.body);
        this._resetComponents();
      },
      /**
       * @description Gets the current contents
       * @param {Boolean} onlyContents Return only the contents of the body without headers when the "fullPage" option is true
       * @returns {Object}
       */
      getContents: function(onlyContents) {
        const contents = this.cleanHTML(context.element.wysiwyg.innerHTML, null, null);
        const renderHTML = util2.createElement("DIV");
        renderHTML.innerHTML = contents;
        const editableEls = util2.getListChildren(renderHTML, function(current) {
          return current.hasAttribute("contenteditable");
        });
        for (let i = 0, len = editableEls.length; i < len; i++) {
          editableEls[i].removeAttribute("contenteditable");
        }
        if (options2.fullPage && !onlyContents) {
          const attrs = util2.getAttributesToString(this._wd.body, ["contenteditable"]);
          return "<!DOCTYPE html><html>" + this._wd.head.outerHTML + "<body " + attrs + ">" + renderHTML.innerHTML + "</body></html>";
        } else {
          return renderHTML.innerHTML;
        }
      },
      /**
       * @description Gets the current contents with containing parent div(div.sun-editor-editable).
       * <div class="sun-editor-editable">{contents}</div>
       * @param {Boolean} onlyContents Return only the contents of the body without headers when the "fullPage" option is true
       * @returns {String}
       */
      getFullContents: function(onlyContents) {
        return '<div class="sun-editor-editable' + (options2.rtl ? " se-rtl" : "") + '">' + this.getContents(onlyContents) + "</div>";
      },
      /**
       * @description Returns HTML string according to tag type and configuration.
       * Use only "cleanHTML"
       * @param {Node} node Node
       * @param {Boolean} requireFormat If true, text nodes that do not have a format node is wrapped with the format tag.
       * @private
       */
      _makeLine: function(node, requireFormat) {
        const defaultTag = options2.defaultTag;
        if (node.nodeType === 1) {
          if (this.__disallowedTagNameRegExp.test(node.nodeName)) return "";
          if (/__se__tag/.test(node.className)) return node.outerHTML;
          const ch = util2.getListChildNodes(node, function(current) {
            return util2.isSpanWithoutAttr(current) && !util2.getParentElement(current, util2.isNotCheckingNode);
          }) || [];
          for (let i = ch.length - 1; i >= 0; i--) {
            ch[i].outerHTML = ch[i].innerHTML;
          }
          if (!requireFormat || (util2.isFormatElement(node) || util2.isRangeFormatElement(node) || util2.isComponent(node) || util2.isFigures(node) || util2.isAnchor(node) && util2.isMedia(node.firstElementChild))) {
            return util2.isSpanWithoutAttr(node) ? node.innerHTML : node.outerHTML;
          } else {
            return "<" + defaultTag + ">" + (util2.isSpanWithoutAttr(node) ? node.innerHTML : node.outerHTML) + "</" + defaultTag + ">";
          }
        }
        if (node.nodeType === 3) {
          if (!requireFormat) return util2._HTMLConvertor(node.textContent);
          const textArray = node.textContent.split(/\n/g);
          let html2 = "";
          for (let i = 0, tLen = textArray.length, text; i < tLen; i++) {
            text = textArray[i].trim();
            if (text.length > 0) html2 += "<" + defaultTag + ">" + util2._HTMLConvertor(text) + "</" + defaultTag + ">";
          }
          return html2;
        }
        if (node.nodeType === 8 && this._allowHTMLComments) {
          return "<!--" + node.textContent.trim() + "-->";
        }
        return "";
      },
      /**
       * @description Removes attribute values such as style and converts tags that do not conform to the "html5" standard.
       * @param {String} text 
       * @returns {String} HTML string
       * @private
       */
      _tagConvertor: function(text) {
        if (!this._disallowedTextTagsRegExp) return text;
        const ec = options2._textTagsMap;
        return text.replace(this._disallowedTextTagsRegExp, function(m, t, n, p) {
          return t + (typeof ec[n] === "string" ? ec[n] : n) + (p ? " " + p : "");
        });
      },
      /**
       * @description Delete disallowed tags
       * @param {String} html HTML string
       * @returns {String}
       * @private
       */
      _deleteDisallowedTags: function(html2) {
        html2 = html2.replace(this.__disallowedTagsRegExp, "").replace(/<[a-z0-9]+\:[a-z0-9]+[^>^\/]*>[^>]*<\/[a-z0-9]+\:[a-z0-9]+>/gi, "");
        if (!/\bfont\b/i.test(this.options._editorTagsWhitelist)) {
          html2 = html2.replace(/(<\/?)font(\s?)/gi, "$1span$2");
        }
        return html2.replace(this.editorTagsWhitelistRegExp, "").replace(this.editorTagsBlacklistRegExp, "");
      },
      _convertFontSize: function(to, size) {
        const math = this._w.Math;
        const value = size.match(/(\d+(?:\.\d+)?)(.+)/);
        const sizeNum = value ? value[1] * 1 : util2.fontValueMap[size];
        const from = value ? value[2] : "rem";
        let pxSize = sizeNum;
        if (/em/.test(from)) {
          pxSize = math.round(sizeNum / 0.0625);
        } else if (from === "pt") {
          pxSize = math.round(sizeNum * 1.333);
        } else if (from === "%") {
          pxSize = sizeNum / 100;
        }
        switch (to) {
          case "em":
          case "rem":
          case "%":
            return (pxSize * 0.0625).toFixed(2) + to;
          case "pt":
            return math.floor(pxSize / 1.333) + to;
          default:
            return pxSize + to;
        }
      },
      _cleanStyle: function(m, v, name2) {
        let sv = (m.match(/style\s*=\s*(?:"|')[^"']*(?:"|')/) || [])[0];
        if (/span/i.test(name2) && !sv && (m.match(/<[^\s]+\s(.+)/) || [])[1]) {
          const size = (m.match(/\ssize="([^"]+)"/i) || [])[1];
          const face = (m.match(/\sface="([^"]+)"/i) || [])[1];
          const color = (m.match(/\scolor="([^"]+)"/i) || [])[1];
          if (size || face || color) {
            sv = 'style="' + (size ? "font-size:" + this.util.getNumber(size / 3.333, 1) + "rem;" : "") + (face ? "font-family:" + face + ";" : "") + (color ? "color:" + color + ";" : "") + '"';
          }
        }
        if (sv) {
          if (!v) v = [];
          const style = sv.replace(/&quot;/g, "").match(this._cleanStyleRegExp[name2]);
          if (style) {
            const allowedStyle = [];
            for (let i = 0, len = style.length, r; i < len; i++) {
              r = style[i].match(/([a-zA-Z0-9-]+)(:)([^"']+)/);
              if (r && !/inherit|initial|revert|unset/i.test(r[3])) {
                const k = util2.kebabToCamelCase(r[1].trim());
                const v2 = this.wwComputedStyle[k] ? this.wwComputedStyle[k].replace(/"/g, "") : "";
                const c = r[3].trim();
                switch (k) {
                  case "fontFamily":
                    if (!options2.plugins.font || options2.font.indexOf(c) === -1) continue;
                    break;
                  case "fontSize":
                    if (!options2.plugins.fontSize) continue;
                    if (!this._cleanStyleRegExp.fontSizeUnit.test(r[0])) {
                      r[0] = r[0].replace((r[0].match(/:\s*([^;]+)/) || [])[1], this._convertFontSize.bind(this, options2.fontSizeUnit));
                    }
                    break;
                  case "color":
                    if (!options2.plugins.fontColor || /rgba\(([0-9]+\s*,\s*){3}0\)|windowtext/i.test(c)) continue;
                    break;
                  case "backgroundColor":
                    if (!options2.plugins.hiliteColor || /rgba\(([0-9]+\s*,\s*){3}0\)|windowtext/i.test(c)) continue;
                    break;
                }
                if (v2 !== c) {
                  allowedStyle.push(r[0]);
                }
              }
            }
            if (allowedStyle.length > 0) v.push('style="' + allowedStyle.join(";") + '"');
          }
        }
        return v;
      },
      /**
       * @description Tag and tag attribute check RegExp function. (used by "cleanHTML" and "convertContentsForEditor")
       * @param {Boolean} lowLevelCheck Row level check
       * @param {String} m RegExp value
       * @param {String} t RegExp value
       * @returns {String}
       * @private
       */
      _cleanTags: function(lowLevelCheck, m, t) {
        if (/^<[a-z0-9]+\:[a-z0-9]+/i.test(m)) return m;
        let v = null;
        const tagName = t.match(/(?!<)[a-zA-Z0-9\-]+/)[0].toLowerCase();
        const bAttr = this._attributesTagsBlacklist[tagName];
        m = m.replace(/\s(?:on[a-z]+)\s*=\s*(")[^"]*\1/ig, "");
        if (bAttr) m = m.replace(bAttr, "");
        else m = m.replace(this._attributesBlacklistRegExp, "");
        const wAttr = this._attributesTagsWhitelist[tagName];
        if (wAttr) v = m.match(wAttr);
        else v = m.match(lowLevelCheck ? this._attributesWhitelistRegExp : this._attributesWhitelistRegExp_all_data);
        if (lowLevelCheck || tagName === "span" || tagName === "li" || this._cleanStyleRegExp[tagName]) {
          if (tagName === "a") {
            const sv = m.match(/(?:(?:id|name)\s*=\s*(?:"|')[^"']*(?:"|'))/g);
            if (sv) {
              if (!v) v = [];
              v.push(sv[0]);
            }
          } else if (!v || !/style=/i.test(v.toString())) {
            if (tagName === "span" || tagName === "li") {
              v = this._cleanStyle(m, v, "span");
            }
            if (this._cleanStyleRegExp[tagName]) {
              v = this._cleanStyle(m, v, tagName);
            } else if (/^(P|DIV|H[1-6]|PRE)$/i.test(tagName)) {
              v = this._cleanStyle(m, v, "format");
            }
          }
        } else {
          const sv = m.match(/style\s*=\s*(?:"|')[^"']*(?:"|')/);
          if (sv && !v) v = [sv[0]];
          else if (sv && !v.some(function(v2) {
            return /^style/.test(v2.trim());
          })) v.push(sv[0]);
        }
        if (util2.isFigures(tagName)) {
          const sv = m.match(/style\s*=\s*(?:"|')[^"']*(?:"|')/);
          if (!v) v = [];
          if (sv) v.push(sv[0]);
        }
        if (v) {
          for (let i = 0, len = v.length, a; i < len; i++) {
            a = /^(?:href|src)\s*=\s*('|"|\s)*javascript\s*\:/i.test(v[i].trim()) ? "" : v[i];
            t += (/^\s/.test(a) ? "" : " ") + a;
          }
        }
        return t;
      },
      /**
       * @description Determines if formatting is required and returns a domTree
       * @param {Element} dom documentFragment
       * @returns {Element}
       * @private
       */
      _editFormat: function(dom) {
        let value = "", f;
        const tempTree = dom.childNodes;
        for (let i = 0, len = tempTree.length, n; i < len; i++) {
          n = tempTree[i];
          if (n.nodeType === 8) {
            value += "<!-- " + n.textContent + " -->";
          } else if (!util2.isFormatElement(n) && !util2.isRangeFormatElement(n) && !util2.isComponent(n) && !/meta/i.test(n.nodeName)) {
            if (!f) f = util2.createElement(options2.defaultTag);
            f.appendChild(n);
            i--;
            len--;
          } else {
            if (f) {
              value += f.outerHTML;
              f = null;
            }
            value += n.outerHTML;
          }
        }
        if (f) value += f.outerHTML;
        return _d.createRange().createContextualFragment(value);
      },
      _convertListCell: function(domTree) {
        let html2 = "";
        for (let i = 0, len = domTree.length, node; i < len; i++) {
          node = domTree[i];
          if (node.nodeType === 1) {
            if (util2.isList(node)) {
              html2 += node.innerHTML;
            } else if (util2.isListCell(node)) {
              html2 += node.outerHTML;
            } else if (util2.isFormatElement(node)) {
              html2 += "<li>" + (node.innerHTML.trim() || "<br>") + "</li>";
            } else if (util2.isRangeFormatElement(node) && !util2.isTable(node)) {
              html2 += this._convertListCell(node);
            } else {
              html2 += "<li>" + node.outerHTML + "</li>";
            }
          } else {
            html2 += "<li>" + (node.textContent || "<br>") + "</li>";
          }
        }
        return html2;
      },
      _isFormatData: function(domTree) {
        let requireFormat = false;
        for (let i = 0, len = domTree.length, t; i < len; i++) {
          t = domTree[i];
          if (t.nodeType === 1 && !util2.isTextStyleElement(t) && !util2.isBreak(t) && !this.__disallowedTagNameRegExp.test(t.nodeName)) {
            requireFormat = true;
            break;
          }
        }
        return requireFormat;
      },
      /**
       * @description Gets the clean HTML code for editor
       * @param {String} html HTML string
       * @param {String|RegExp|null} whitelist Regular expression of allowed tags.
       * RegExp object is create by util.createTagsWhitelist method. (core.pasteTagsWhitelistRegExp)
       * @param {String|RegExp|null} blacklist Regular expression of disallowed tags.
       * RegExp object is create by util.createTagsBlacklist method. (core.pasteTagsBlacklistRegExp)
       * @returns {String}
       */
      cleanHTML: function(html2, whitelist, blacklist) {
        if (!options2.strictMode) return html2;
        html2 = this._deleteDisallowedTags(this._parser.parseFromString(util2.htmlCompress(html2), "text/html").body.innerHTML).replace(/(<[a-zA-Z0-9\-]+)[^>]*(?=>)/g, this._cleanTags.bind(this, true)).replace(/<br\/?>$/i, "");
        const dom = _d.createRange().createContextualFragment(html2);
        try {
          util2._consistencyCheckOfHTML(dom, this._htmlCheckWhitelistRegExp, this._htmlCheckBlacklistRegExp, this._classNameFilter);
        } catch (error) {
          console.warn("[SUNEDITOR.cleanHTML.consistencyCheck.fail] " + error);
        }
        if (this.managedTagsInfo && this.managedTagsInfo.query) {
          const textCompList = dom.querySelectorAll(this.managedTagsInfo.query);
          for (let i = 0, len = textCompList.length, initMethod, classList; i < len; i++) {
            classList = [].slice.call(textCompList[i].classList);
            for (let c = 0, cLen = classList.length; c < cLen; c++) {
              initMethod = this.managedTagsInfo.map[classList[c]];
              if (initMethod) {
                initMethod(textCompList[i]);
                break;
              }
            }
          }
        }
        let domTree = dom.childNodes;
        let cleanHTML = "";
        const requireFormat = this._isFormatData(domTree);
        if (requireFormat) {
          domTree = this._editFormat(dom).childNodes;
        }
        for (let i = 0, len = domTree.length, t; i < len; i++) {
          t = domTree[i];
          if (this.__allowedScriptRegExp.test(t.nodeName)) {
            cleanHTML += t.outerHTML;
            continue;
          }
          cleanHTML += this._makeLine(t, requireFormat);
        }
        cleanHTML = util2.htmlRemoveWhiteSpace(cleanHTML);
        if (!cleanHTML) {
          cleanHTML = html2;
        } else {
          if (whitelist) cleanHTML = cleanHTML.replace(typeof whitelist === "string" ? util2.createTagsWhitelist(whitelist) : whitelist, "");
          if (blacklist) cleanHTML = cleanHTML.replace(typeof blacklist === "string" ? util2.createTagsBlacklist(blacklist) : blacklist, "");
        }
        return this._tagConvertor(cleanHTML);
      },
      /**
       * @description Converts contents into a format that can be placed in an editor
       * @param {String} contents contents
       * @returns {String}
       */
      convertContentsForEditor: function(contents) {
        if (!options2.strictMode) return contents;
        contents = this._deleteDisallowedTags(this._parser.parseFromString(util2.htmlCompress(contents), "text/html").body.innerHTML).replace(/(<[a-zA-Z0-9\-]+)[^>]*(?=>)/g, this._cleanTags.bind(this, true));
        const dom = _d.createRange().createContextualFragment(contents);
        try {
          util2._consistencyCheckOfHTML(dom, this._htmlCheckWhitelistRegExp, this._htmlCheckBlacklistRegExp, this._classNameFilter);
        } catch (error) {
          console.warn("[SUNEDITOR.convertContentsForEditor.consistencyCheck.fail] " + error);
        }
        if (this.managedTagsInfo && this.managedTagsInfo.query) {
          const textCompList = dom.querySelectorAll(this.managedTagsInfo.query);
          for (let i = 0, len = textCompList.length, initMethod, classList; i < len; i++) {
            classList = [].slice.call(textCompList[i].classList);
            for (let c = 0, cLen = classList.length; c < cLen; c++) {
              initMethod = this.managedTagsInfo.map[classList[c]];
              if (initMethod) {
                initMethod(textCompList[i]);
                break;
              }
            }
          }
        }
        const domTree = dom.childNodes;
        let cleanHTML = "", p = null;
        for (let i = 0, t; i < domTree.length; i++) {
          t = domTree[i];
          if (this.__allowedScriptRegExp.test(t.nodeName)) {
            cleanHTML += t.outerHTML;
            continue;
          }
          if (!util2.isFormatElement(t) && !util2.isRangeFormatElement(t) && !util2.isComponent(t) && !util2.isFigures(t) && t.nodeType !== 8 && !/__se__tag/.test(t.className)) {
            if (!p) p = util2.createElement(options2.defaultTag);
            p.appendChild(t);
            i--;
            if (domTree[i + 1] && !util2.isFormatElement(domTree[i + 1])) {
              continue;
            } else {
              t = p;
              p = null;
            }
          }
          if (p) {
            cleanHTML += this._makeLine(p, true);
            p = null;
          }
          cleanHTML += this._makeLine(t, true);
        }
        if (p) cleanHTML += this._makeLine(p, true);
        if (cleanHTML.length === 0) return "<" + options2.defaultTag + "><br></" + options2.defaultTag + ">";
        cleanHTML = util2.htmlRemoveWhiteSpace(cleanHTML);
        return this._tagConvertor(cleanHTML);
      },
      /**
       * @description Converts wysiwyg area element into a format that can be placed in an editor of code view mode
       * @param {Element|String} html WYSIWYG element (context.element.wysiwyg) or HTML string.
       * @param {Boolean} comp If true, does not line break and indentation of tags.
       * @returns {String}
       */
      convertHTMLForCodeView: function(html2, comp) {
        let returnHTML = "";
        const wRegExp = _w.RegExp;
        const brReg = new wRegExp("^(BLOCKQUOTE|PRE|TABLE|THEAD|TBODY|TR|TH|TD|OL|UL|IMG|IFRAME|VIDEO|AUDIO|FIGURE|FIGCAPTION|HR|BR|CANVAS|SELECT)$", "i");
        const wDoc = typeof html2 === "string" ? _d.createRange().createContextualFragment(html2) : html2;
        const isFormat = function(current) {
          return this.isFormatElement(current) || this.isComponent(current);
        }.bind(util2);
        const brChar = comp ? "" : "\n";
        let indentSize = comp ? 0 : this._variable.codeIndent * 1;
        indentSize = indentSize > 0 ? new _w.Array(indentSize + 1).join(" ") : "";
        (function recursionFunc(element, indent) {
          const children2 = element.childNodes;
          const elementRegTest = brReg.test(element.nodeName);
          const elementIndent = elementRegTest ? indent : "";
          for (let i = 0, len = children2.length, node, br2, lineBR, nodeRegTest, tag2, tagIndent; i < len; i++) {
            node = children2[i];
            nodeRegTest = brReg.test(node.nodeName);
            br2 = nodeRegTest ? brChar : "";
            lineBR = isFormat(node) && !elementRegTest && !/^(TH|TD)$/i.test(element.nodeName) ? brChar : "";
            if (node.nodeType === 8) {
              returnHTML += "\n<!-- " + node.textContent.trim() + " -->" + br2;
              continue;
            }
            if (node.nodeType === 3) {
              if (!util2.isList(node.parentElement)) returnHTML += util2._HTMLConvertor(/^\n+$/.test(node.data) ? "" : node.data);
              continue;
            }
            if (node.childNodes.length === 0) {
              returnHTML += (/^HR$/i.test(node.nodeName) ? brChar : "") + (/^PRE$/i.test(node.parentElement.nodeName) && /^BR$/i.test(node.nodeName) ? "" : elementIndent) + node.outerHTML + br2;
              continue;
            }
            if (!node.outerHTML) {
              returnHTML += new _w.XMLSerializer().serializeToString(node);
            } else {
              tag2 = node.nodeName.toLowerCase();
              tagIndent = elementIndent || nodeRegTest ? indent : "";
              returnHTML += (lineBR || (elementRegTest ? "" : br2)) + tagIndent + node.outerHTML.match(wRegExp("<" + tag2 + "[^>]*>", "i"))[0] + br2;
              recursionFunc(node, indent + indentSize, "");
              returnHTML += (/\n$/.test(returnHTML) ? tagIndent : "") + "</" + tag2 + ">" + (lineBR || br2 || elementRegTest ? brChar : /^(TH|TD)$/i.test(node.nodeName) ? brChar : "");
            }
          }
        })(wDoc, "");
        return returnHTML.trim() + brChar;
      },
      /**
       * @description Add an event to document.
       * When created as an Iframe, the same event is added to the document in the Iframe.
       * @param {String} type Event type
       * @param {Function} listener Event listener
       * @param {Boolean} useCapture Use event capture
       */
      addDocEvent: function(type, listener, useCapture) {
        _d.addEventListener(type, listener, useCapture);
        if (options2.iframe) {
          this._wd.addEventListener(type, listener);
        }
      },
      /**
       * @description Remove events from document.
       * When created as an Iframe, the event of the document inside the Iframe is also removed.
       * @param {String} type Event type
       * @param {Function} listener Event listener
       */
      removeDocEvent: function(type, listener) {
        _d.removeEventListener(type, listener);
        if (options2.iframe) {
          this._wd.removeEventListener(type, listener);
        }
      },
      /**
       * @description The current number of characters is counted and displayed.
       * @param {String} inputText Text added.
       * @returns {Boolean}
       * @private
       */
      _charCount: function(inputText) {
        const maxCharCount = options2.maxCharCount;
        const countType = options2.charCounterType;
        let nextCharCount = 0;
        if (!!inputText) nextCharCount = this.getCharLength(inputText, countType);
        this._setCharCount();
        if (maxCharCount > 0) {
          let over = false;
          const count = functions.getCharCount(countType);
          if (count > maxCharCount) {
            over = true;
            if (nextCharCount > 0) {
              this._editorRange();
              const range = this.getRange();
              const endOff = range.endOffset - 1;
              const text = this.getSelectionNode().textContent;
              const slicePosition = range.endOffset - (count - maxCharCount);
              this.getSelectionNode().textContent = text.slice(0, slicePosition < 0 ? 0 : slicePosition) + text.slice(range.endOffset, text.length);
              this.setRange(range.endContainer, endOff, range.endContainer, endOff);
            }
          } else if (count + nextCharCount > maxCharCount) {
            over = true;
          }
          if (over) {
            this._callCounterBlink();
            if (nextCharCount > 0) return false;
          }
        }
        return true;
      },
      /**
       * @description When "element" is added, if it is greater than "options.maxCharCount", false is returned.
       * @param {Node|String} element Element node or String.
       * @param {String|null} charCounterType charCounterType. If it is null, the options.charCounterType
       * @returns {Boolean}
       */
      checkCharCount: function(element, charCounterType) {
        if (options2.maxCharCount) {
          const countType = charCounterType || options2.charCounterType;
          const length = this.getCharLength(typeof element === "string" ? element : this._charTypeHTML && element.nodeType === 1 ? element.outerHTML : element.textContent, countType);
          if (length > 0 && length + functions.getCharCount(countType) > options2.maxCharCount) {
            this._callCounterBlink();
            return false;
          }
        }
        return true;
      },
      /**
       * @description Get the length of the content.
       * Depending on the option, the length of the character is taken. (charCounterType)
       * @param {String} content Content to count
       * @param {String} charCounterType options.charCounterType
       * @returns {Number}
       */
      getCharLength: function(content, charCounterType) {
        return /byte/.test(charCounterType) ? util2.getByteLength(content) : content.length;
      },
      /**
       * @description Reset buttons of the responsive toolbar.
       */
      resetResponsiveToolbar: function() {
        core.controllersOff();
        const responsiveSize = event._responsiveButtonSize;
        if (responsiveSize) {
          let w = 0;
          if ((core._isBalloon || core._isInline) && options2.toolbarWidth === "auto") {
            w = context.element.topArea.offsetWidth;
          } else {
            w = context.element.toolbar.offsetWidth;
          }
          let responsiveWidth = "default";
          for (let i = 1, len = responsiveSize.length; i < len; i++) {
            if (w < responsiveSize[i]) {
              responsiveWidth = responsiveSize[i] + "";
              break;
            }
          }
          if (event._responsiveCurrentSize !== responsiveWidth) {
            event._responsiveCurrentSize = responsiveWidth;
            functions.setToolbarButtons(event._responsiveButtons[responsiveWidth]);
          }
        }
      },
      /**
       * @description Set the char count to charCounter element textContent.
       * @private
       */
      _setCharCount: function() {
        if (context.element.charCounter) {
          _w.setTimeout(function(functions2, options3) {
            if (this.textContent && functions2) {
              this.textContent = functions2.getCharCount(options3.charCounterType);
            }
          }.bind(context.element.charCounter, functions, options2), 0);
        }
      },
      /**
       * @description The character counter blinks.
       * @private
       */
      _callCounterBlink: function() {
        const charWrapper = context.element.charWrapper;
        if (charWrapper && !util2.hasClass(charWrapper, "se-blink")) {
          util2.addClass(charWrapper, "se-blink");
          _w.setTimeout(function() {
            util2.removeClass(charWrapper, "se-blink");
          }, 600);
        }
      },
      /**
       * @description Check the components such as image and video and modify them according to the format.
       * @private
       */
      _checkComponents: function() {
        for (let i = 0, len = this._fileInfoPluginsCheck.length; i < len; i++) {
          this._fileInfoPluginsCheck[i]();
        }
      },
      /**
       * @description Initialize the information of the components.
       * @private
       */
      _resetComponents: function() {
        for (let i = 0, len = this._fileInfoPluginsReset.length; i < len; i++) {
          this._fileInfoPluginsReset[i]();
        }
      },
      /**
       * @description Set method in the code view area
       * @param {String} value HTML string
       * @private
       */
      _setCodeView: function(value) {
        if (options2.codeMirrorEditor) {
          options2.codeMirrorEditor.getDoc().setValue(value);
        } else {
          context.element.code.value = value;
        }
      },
      /**
       * @description Get method in the code view area
       * @private
       */
      _getCodeView: function() {
        return options2.codeMirrorEditor ? options2.codeMirrorEditor.getDoc().getValue() : context.element.code.value;
      },
      /**
       * @description remove class, display text.
       * @param {Array|null} ignoredList Igonred button list
       */
      _setKeyEffect: function(ignoredList) {
        const commandMap = this.commandMap;
        const activePlugins = this.activePlugins;
        for (let key in commandMap) {
          if (ignoredList.indexOf(key) > -1 || !util2.hasOwn(commandMap, key)) continue;
          if (activePlugins.indexOf(key) > -1) {
            plugins[key].active.call(this, null);
          } else if (commandMap.OUTDENT && /^OUTDENT$/i.test(key)) {
            if (!util2.isImportantDisabled(commandMap.OUTDENT)) commandMap.OUTDENT.setAttribute("disabled", true);
          } else if (commandMap.INDENT && /^INDENT$/i.test(key)) {
            if (!util2.isImportantDisabled(commandMap.INDENT)) commandMap.INDENT.removeAttribute("disabled");
          } else {
            util2.removeClass(commandMap[key], "active");
          }
        }
      },
      /**
       * @description Initializ core variable
       * @param {Boolean} reload Is relooad?
       * @param {String} _initHTML initial html string
       * @private
       */
      _init: function(reload, _initHTML) {
        const wRegExp = _w.RegExp;
        this._ww = options2.iframe ? context.element.wysiwygFrame.contentWindow : _w;
        this._wd = _d;
        this._charTypeHTML = options2.charCounterType === "byte-html";
        this.wwComputedStyle = _w.getComputedStyle(context.element.wysiwyg);
        this._editorHeight = context.element.wysiwygFrame.offsetHeight;
        this._editorHeightPadding = util2.getNumber(this.wwComputedStyle.getPropertyValue("padding-top")) + util2.getNumber(this.wwComputedStyle.getPropertyValue("padding-bottom"));
        this._classNameFilter = function(v) {
          return this.test(v) ? v : "";
        }.bind(options2.allowedClassNames);
        const sPrefix = options2.__allowedScriptTag ? "" : "script|";
        this.__scriptTagRegExp = new wRegExp("<(script)[^>]*>([\\s\\S]*?)<\\/\\1>|<script[^>]*\\/?>", "gi");
        this.__disallowedTagsRegExp = new wRegExp("<(" + sPrefix + "style)[^>]*>([\\s\\S]*?)<\\/\\1>|<(" + sPrefix + "style)[^>]*\\/?>", "gi");
        this.__disallowedTagNameRegExp = new wRegExp("^(" + sPrefix + "meta|link|style|[a-z]+:[a-z]+)$", "i");
        this.__allowedScriptRegExp = new wRegExp("^" + (options2.__allowedScriptTag ? "script" : "") + "$", "i");
        if (!options2.iframe && typeof _w.ShadowRoot === "function") {
          let child = context.element.wysiwygFrame;
          while (child) {
            if (child.shadowRoot) {
              this._shadowRoot = child.shadowRoot;
              break;
            } else if (child instanceof _w.ShadowRoot) {
              this._shadowRoot = child;
              break;
            }
            child = child.parentNode;
          }
          if (this._shadowRoot) this._shadowRootControllerEventTarget = [];
        }
        const disallowTextTags = _w.Object.keys(options2._textTagsMap);
        const allowTextTags = !options2.addTagsWhitelist ? [] : options2.addTagsWhitelist.split("|").filter(function(v) {
          return /b|i|ins|s|strike/i.test(v);
        });
        for (let i = 0; i < allowTextTags.length; i++) {
          disallowTextTags.splice(disallowTextTags.indexOf(allowTextTags[i].toLowerCase()), 1);
        }
        this._disallowedTextTagsRegExp = disallowTextTags.length === 0 ? null : new wRegExp("(<\\/?)(" + disallowTextTags.join("|") + ")\\b\\s*([^>^<]+)?\\s*(?=>)", "gi");
        const getRegList = function(str, str2) {
          return !str ? "^" : str === "*" ? "[a-z-]+" : !str2 ? str : str + "|" + str2;
        };
        const videoAttr = "|controls|autoplay|loop|muted|poster|preload|playsinline";
        const iframeAttr = "|allowfullscreen|sandbox|loading|allow|referrerpolicy|frameborder|scrolling";
        const defaultAttr = "contenteditable|colspan|rowspan|target|href|download|rel|src|alt|class|type|origin-size" + videoAttr + iframeAttr;
        const dataAttr = "data-format|data-size|data-file-size|data-file-name|data-origin|data-align|data-image-link|data-rotate|data-proportion|data-percentage|data-exp|data-font-size";
        this._allowHTMLComments = options2._editorTagsWhitelist.indexOf("//") > -1 || options2._editorTagsWhitelist === "*";
        this._htmlCheckWhitelistRegExp = new wRegExp("^(" + getRegList(options2._editorTagsWhitelist.replace("|//", ""), "") + ")$", "i");
        this._htmlCheckBlacklistRegExp = new wRegExp("^(" + (options2.tagsBlacklist || "^") + ")$", "i");
        this.editorTagsWhitelistRegExp = util2.createTagsWhitelist(getRegList(options2._editorTagsWhitelist.replace("|//", "|<!--|-->"), ""));
        this.editorTagsBlacklistRegExp = util2.createTagsBlacklist(options2.tagsBlacklist.replace("|//", "|<!--|-->"));
        this.pasteTagsWhitelistRegExp = util2.createTagsWhitelist(getRegList(options2.pasteTagsWhitelist, ""));
        this.pasteTagsBlacklistRegExp = util2.createTagsBlacklist(options2.pasteTagsBlacklist);
        const regEndStr = '\\s*=\\s*(")[^"]*\\1';
        const _wAttr = options2.attributesWhitelist;
        let tagsAttr = {};
        let allAttr = "";
        if (!!_wAttr) {
          for (let k in _wAttr) {
            if (!util2.hasOwn(_wAttr, k) || /^on[a-z]+$/i.test(_wAttr[k])) continue;
            if (k === "all") {
              allAttr = getRegList(_wAttr[k], defaultAttr);
            } else {
              tagsAttr[k] = new wRegExp("\\s(?:" + getRegList(_wAttr[k], "") + ")" + regEndStr, "ig");
            }
          }
        }
        this._attributesWhitelistRegExp = new wRegExp("\\s(?:" + (allAttr || defaultAttr + "|" + dataAttr) + ")" + regEndStr, "ig");
        this._attributesWhitelistRegExp_all_data = new wRegExp("\\s(?:" + ((allAttr || defaultAttr) + "|data-[a-z0-9\\-]+") + ")" + regEndStr, "ig");
        this._attributesTagsWhitelist = tagsAttr;
        const _bAttr = options2.attributesBlacklist;
        tagsAttr = {};
        allAttr = "";
        if (!!_bAttr) {
          for (let k in _bAttr) {
            if (!util2.hasOwn(_bAttr, k)) continue;
            if (k === "all") {
              allAttr = getRegList(_bAttr[k], "");
            } else {
              tagsAttr[k] = new wRegExp("\\s(?:" + getRegList(_bAttr[k], "") + ")" + regEndStr, "ig");
            }
          }
        }
        this._attributesBlacklistRegExp = new wRegExp("\\s(?:" + (allAttr || "^") + ")" + regEndStr, "ig");
        this._attributesTagsBlacklist = tagsAttr;
        this._isInline = /inline/i.test(options2.mode);
        this._isBalloon = /balloon|balloon-always/i.test(options2.mode);
        this._isBalloonAlways = /balloon-always/i.test(options2.mode);
        this._cachingButtons();
        this._fileInfoPluginsCheck = [];
        this._fileInfoPluginsReset = [];
        this.managedTagsInfo = { query: "", map: {} };
        const managedClass = [];
        this.activePlugins = [];
        this._fileManager.tags = [];
        this._fileManager.pluginMap = {};
        let filePluginRegExp = [];
        let plugin, button;
        for (let key in plugins) {
          if (!util2.hasOwn(plugins, key)) continue;
          plugin = plugins[key];
          button = pluginCallButtons[key];
          if ((plugin.active || plugin.action) && button) {
            this.callPlugin(key, null, button);
          }
          if (typeof plugin.checkFileInfo === "function" && typeof plugin.resetFileInfo === "function") {
            this.callPlugin(key, null, button);
            this._fileInfoPluginsCheck.push(plugin.checkFileInfo.bind(this));
            this._fileInfoPluginsReset.push(plugin.resetFileInfo.bind(this));
          }
          if (_w.Array.isArray(plugin.fileTags)) {
            const fileTags = plugin.fileTags;
            this.callPlugin(key, null, button);
            this._fileManager.tags = this._fileManager.tags.concat(fileTags);
            filePluginRegExp.push(key);
            for (let tag2 = 0, tLen = fileTags.length; tag2 < tLen; tag2++) {
              this._fileManager.pluginMap[fileTags[tag2].toLowerCase()] = key;
            }
          }
          if (plugin.managedTags) {
            const info = plugin.managedTags();
            managedClass.push("." + info.className);
            this.managedTagsInfo.map[info.className] = info.method.bind(this);
          }
        }
        this.managedTagsInfo.query = managedClass.toString();
        this._fileManager.queryString = this._fileManager.tags.join(",");
        this._fileManager.regExp = new wRegExp("^(" + (this._fileManager.tags.join("|") || "^") + ")$", "i");
        this._fileManager.pluginRegExp = new wRegExp("^(" + (filePluginRegExp.length === 0 ? "^" : filePluginRegExp.join("|")) + ")$", "i");
        this._variable._originCssText = context.element.topArea.style.cssText;
        this._placeholder = context.element.placeholder;
        this._lineBreaker = context.element.lineBreaker;
        this._lineBreakerButton = this._lineBreaker.querySelector("button");
        this.history = history_default(this, this._onChange_historyStack.bind(this));
        this.addModule([notice_default]);
        if (options2.iframe) {
          this._wd = context.element.wysiwygFrame.contentDocument;
          context.element.wysiwyg = this._wd.body;
          if (options2._editorStyles.editor) context.element.wysiwyg.style.cssText = options2._editorStyles.editor;
          if (options2.height === "auto") this._iframeAuto = this._wd.body;
        }
        this._initWysiwygArea(reload, _initHTML);
      },
      /**
       * @description Caching basic buttons to use
       * @private
       */
      _cachingButtons: function() {
        this.codeViewDisabledButtons = context.element._buttonTray.querySelectorAll('.se-menu-list button[data-display]:not([class~="se-code-view-enabled"]):not([data-display="MORE"])');
        this.resizingDisabledButtons = context.element._buttonTray.querySelectorAll('.se-menu-list button[data-display]:not([class~="se-resizing-enabled"]):not([data-display="MORE"])');
        const tool = context.tool;
        const commandMap = this.commandMap;
        commandMap.INDENT = tool.indent;
        commandMap.OUTDENT = tool.outdent;
        commandMap[options2.textTags.bold.toUpperCase()] = tool.bold;
        commandMap[options2.textTags.underline.toUpperCase()] = tool.underline;
        commandMap[options2.textTags.italic.toUpperCase()] = tool.italic;
        commandMap[options2.textTags.strike.toUpperCase()] = tool.strike;
        commandMap[options2.textTags.sub.toUpperCase()] = tool.subscript;
        commandMap[options2.textTags.sup.toUpperCase()] = tool.superscript;
        this._styleCommandMap = {
          fullScreen: tool.fullScreen,
          showBlocks: tool.showBlocks,
          codeView: tool.codeView
        };
        this._saveButtonStates();
      },
      /**
       * @description Initializ wysiwyg area (Only called from core._init)
       * @param {Boolean} reload Is relooad?
       * @param {String} _initHTML initial html string
       * @private
       */
      _initWysiwygArea: function(reload, _initHTML) {
        context.element.wysiwyg.innerHTML = reload ? _initHTML : this.convertContentsForEditor((typeof _initHTML === "string" ? _initHTML : /^TEXTAREA$/i.test(context.element.originElement.nodeName) ? context.element.originElement.value : context.element.originElement.innerHTML) || "");
      },
      /**
       * @description Called when there are changes to tags in the wysiwyg region.
       * @private
       */
      _resourcesStateChange: function() {
        this._iframeAutoHeight();
        this._checkPlaceholder();
      },
      /**
       * @description Called when after execute "history.push"
       * @private
       */
      _onChange_historyStack: function() {
        if (this.hasFocus) event._applyTagEffects();
        this._variable.isChanged = true;
        if (context.tool.save) context.tool.save.removeAttribute("disabled");
        if (functions.onChange) functions.onChange(this.getContents(true), this);
        if (context.element.toolbar.style.display === "block") event._showToolbarBalloon();
      },
      /**
       * @description Modify the height value of the iframe when the height of the iframe is automatic.
       * @private
       */
      _iframeAutoHeight: function() {
        if (this._iframeAuto) {
          _w.setTimeout(function() {
            const h = core._iframeAuto.offsetHeight;
            context.element.wysiwygFrame.style.height = h + "px";
            if (!util2.isResizeObserverSupported) core.__callResizeFunction(h, null);
          });
        } else if (!util2.isResizeObserverSupported) {
          core.__callResizeFunction(context.element.wysiwygFrame.offsetHeight, null);
        }
      },
      __callResizeFunction: function(h, resizeObserverEntry) {
        h = h === -1 ? resizeObserverEntry.borderBoxSize && resizeObserverEntry.borderBoxSize[0] ? resizeObserverEntry.borderBoxSize[0].blockSize : resizeObserverEntry.contentRect.height + this._editorHeightPadding : h;
        if (this._editorHeight !== h) {
          if (typeof functions.onResizeEditor === "function") functions.onResizeEditor(h, this._editorHeight, core, resizeObserverEntry);
          this._editorHeight = h;
        }
      },
      /**
       * @description Set display property when there is placeholder.
       * @private
       */
      _checkPlaceholder: function() {
        if (this._placeholder) {
          if (this._variable.isCodeView) {
            this._placeholder.style.display = "none";
            return;
          }
          const wysiwyg = context.element.wysiwyg;
          if (!util2.onlyZeroWidthSpace(wysiwyg.textContent) || wysiwyg.querySelector(util2._allowedEmptyNodeList) || (wysiwyg.innerText.match(/\n/g) || "").length > 1) {
            this._placeholder.style.display = "none";
          } else {
            this._placeholder.style.display = "block";
          }
        }
      },
      /**
       * @description If there is no default format, add a format and move "selection".
       * @param {String|null} formatName Format tag name (default: 'P')
       * @returns {undefined|null}
       * @private
       */
      _setDefaultFormat: function(formatName) {
        if (this._fileManager.pluginRegExp.test(this.currentControllerName)) return;
        const range = this.getRange();
        const commonCon = range.commonAncestorContainer;
        const startCon = range.startContainer;
        const rangeEl = util2.getRangeFormatElement(commonCon, null);
        let focusNode, offset, format;
        const fileComponent = util2.getParentElement(commonCon, util2.isComponent);
        if (fileComponent && !util2.isTable(fileComponent)) {
          return;
        } else if (commonCon.nodeType === 1 && commonCon.getAttribute("data-se-embed") === "true") {
          let el = commonCon.nextElementSibling;
          if (!util2.isFormatElement(el)) el = this.appendFormatTag(commonCon, options2.defaultTag);
          this.setRange(el.firstChild, 0, el.firstChild, 0);
          return;
        }
        if ((util2.isRangeFormatElement(startCon) || util2.isWysiwygDiv(startCon)) && (util2.isComponent(startCon.children[range.startOffset]) || util2.isComponent(startCon.children[range.startOffset - 1]))) return;
        if (util2.getParentElement(commonCon, util2.isNotCheckingNode)) return null;
        if (rangeEl) {
          format = util2.createElement(formatName || options2.defaultTag);
          format.innerHTML = rangeEl.innerHTML;
          if (format.childNodes.length === 0) format.innerHTML = util2.zeroWidthSpace;
          rangeEl.innerHTML = format.outerHTML;
          format = rangeEl.firstChild;
          focusNode = util2.getEdgeChildNodes(format, null).sc;
          if (!focusNode) {
            focusNode = util2.createTextNode(util2.zeroWidthSpace);
            format.insertBefore(focusNode, format.firstChild);
          }
          offset = focusNode.textContent.length;
          this.setRange(focusNode, offset, focusNode, offset);
          return;
        }
        if (util2.isRangeFormatElement(commonCon) && commonCon.childNodes.length <= 1) {
          let br2 = null;
          if (commonCon.childNodes.length === 1 && util2.isBreak(commonCon.firstChild)) {
            br2 = commonCon.firstChild;
          } else {
            br2 = util2.createTextNode(util2.zeroWidthSpace);
            commonCon.appendChild(br2);
          }
          this.setRange(br2, 1, br2, 1);
          return;
        }
        try {
          if (commonCon.nodeType === 3) {
            format = util2.createElement(formatName || options2.defaultTag);
            commonCon.parentNode.insertBefore(format, commonCon);
            format.appendChild(commonCon);
          }
          if (util2.isBreak(format.nextSibling)) util2.removeItem(format.nextSibling);
          if (util2.isBreak(format.previousSibling)) util2.removeItem(format.previousSibling);
          if (util2.isBreak(focusNode)) {
            const zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
            focusNode.parentNode.insertBefore(zeroWidth, focusNode);
            focusNode = zeroWidth;
          }
        } catch (e) {
          this.execCommand("formatBlock", false, formatName || options2.defaultTag);
          this.removeRange();
          this._editorRange();
        }
        if (format) {
          if (util2.isBreak(format.nextSibling)) util2.removeItem(format.nextSibling);
          if (util2.isBreak(format.previousSibling)) util2.removeItem(format.previousSibling);
          if (util2.isBreak(focusNode)) {
            const zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
            focusNode.parentNode.insertBefore(zeroWidth, focusNode);
            focusNode = zeroWidth;
          }
        }
        this.effectNode = null;
        this.nativeFocus();
      },
      /**
       * @description Initialization after "setOptions"
       * @param {Object} el context.element
       * @param {String} _initHTML Initial html string
       * @private
       */
      _setOptionsInit: function(el, _initHTML) {
        this.context = context = context_default(el.originElement, this._getConstructed(el), options2);
        this._componentsInfoReset = true;
        this._editorInit(true, _initHTML);
      },
      /**
       * @description Initializ editor
       * @param {Boolean} reload Is relooad?
       * @param {String} _initHTML initial html string
       * @private
       */
      _editorInit: function(reload, _initHTML) {
        this._init(reload, _initHTML);
        event._addEvent();
        this._setCharCount();
        event._offStickyToolbar();
        event.onResize_window();
        context.element.toolbar.style.visibility = "";
        const attr = options2.frameAttrbutes;
        for (let k in attr) {
          context.element.wysiwyg.setAttribute(k, attr[k]);
        }
        this._checkComponents();
        this._componentsInfoInit = false;
        this._componentsInfoReset = false;
        this.history.reset(true);
        _w.setTimeout(function() {
          if (typeof core._resourcesStateChange !== "function") return;
          if (event._resizeObserver) event._resizeObserver.observe(context.element.wysiwygFrame);
          if (event._toolbarObserver) event._toolbarObserver.observe(context.element._toolbarShadow);
          core._resourcesStateChange();
          if (typeof functions.onload === "function") functions.onload(core, reload);
        });
      },
      /**
       * @description Create and return an object to cache the new context.
       * @param {Element} contextEl context.element
       * @returns {Object}
       * @private
       */
      _getConstructed: function(contextEl2) {
        return {
          _top: contextEl2.topArea,
          _relative: contextEl2.relative,
          _toolBar: contextEl2.toolbar,
          _toolbarShadow: contextEl2._toolbarShadow,
          _menuTray: contextEl2._menuTray,
          _editorArea: contextEl2.editorArea,
          _wysiwygArea: contextEl2.wysiwygFrame,
          _codeArea: contextEl2.code,
          _placeholder: contextEl2.placeholder,
          _resizingBar: contextEl2.resizingBar,
          _navigation: contextEl2.navigation,
          _charCounter: contextEl2.charCounter,
          _charWrapper: contextEl2.charWrapper,
          _loading: contextEl2.loading,
          _lineBreaker: contextEl2.lineBreaker,
          _lineBreaker_t: contextEl2.lineBreaker_t,
          _lineBreaker_b: contextEl2.lineBreaker_b,
          _resizeBack: contextEl2.resizeBackground,
          _stickyDummy: contextEl2._stickyDummy,
          _arrow: contextEl2._arrow
        };
      }
    };
    const event = {
      _IEisComposing: false,
      // In IE, there is no "e.isComposing" in the key-up event.
      _lineBreakerBind: null,
      _responsiveCurrentSize: "default",
      _responsiveButtonSize: null,
      _responsiveButtons: null,
      _cursorMoveKeyCode: new _w.RegExp("^(8|3[2-9]|40|46)$"),
      _directionKeyCode: new _w.RegExp("^(8|13|3[2-9]|40|46)$"),
      _nonTextKeyCode: new _w.RegExp("^(8|13|1[6-9]|20|27|3[3-9]|40|45|46|11[2-9]|12[0-3]|144|145)$"),
      _historyIgnoreKeyCode: new _w.RegExp("^(1[6-9]|20|27|3[3-9]|40|45|11[2-9]|12[0-3]|144|145)$"),
      _onButtonsCheck: new _w.RegExp("^(" + _w.Object.keys(options2._textTagsMap).join("|") + ")$", "i"),
      _frontZeroWidthReg: new _w.RegExp(util2.zeroWidthSpace + "+", ""),
      _keyCodeShortcut: {
        65: "A",
        66: "B",
        83: "S",
        85: "U",
        73: "I",
        89: "Y",
        90: "Z",
        219: "[",
        221: "]"
      },
      _shortcutCommand: function(keyCode, shift) {
        let command = null;
        const keyStr = event._keyCodeShortcut[keyCode];
        switch (keyStr) {
          case "A":
            command = "selectAll";
            break;
          case "B":
            if (options2.shortcutsDisable.indexOf("bold") === -1) {
              command = "bold";
            }
            break;
          case "S":
            if (shift && options2.shortcutsDisable.indexOf("strike") === -1) {
              command = "strike";
            } else if (!shift && options2.shortcutsDisable.indexOf("save") === -1) {
              command = "save";
            }
            break;
          case "U":
            if (options2.shortcutsDisable.indexOf("underline") === -1) {
              command = "underline";
            }
            break;
          case "I":
            if (options2.shortcutsDisable.indexOf("italic") === -1) {
              command = "italic";
            }
            break;
          case "Z":
            if (options2.shortcutsDisable.indexOf("undo") === -1) {
              if (shift) {
                command = "redo";
              } else {
                command = "undo";
              }
            }
            break;
          case "Y":
            if (options2.shortcutsDisable.indexOf("undo") === -1) {
              command = "redo";
            }
            break;
          case "[":
            if (options2.shortcutsDisable.indexOf("indent") === -1) {
              command = options2.rtl ? "indent" : "outdent";
            }
            break;
          case "]":
            if (options2.shortcutsDisable.indexOf("indent") === -1) {
              command = options2.rtl ? "outdent" : "indent";
            }
            break;
        }
        if (!command) return !!keyStr;
        core.commandHandler(core.commandMap[command], command);
        return true;
      },
      _applyTagEffects: function() {
        if (util2.hasClass(context.element.wysiwyg, "se-read-only")) {
          return false;
        }
        let selectionNode = core.getSelectionNode();
        if (selectionNode === core.effectNode) return;
        core.effectNode = selectionNode;
        const marginDir = options2.rtl ? "marginRight" : "marginLeft";
        const commandMap = core.commandMap;
        const classOnCheck = event._onButtonsCheck;
        const commandMapNodes = [];
        const currentNodes = [];
        const activePlugins = core.activePlugins;
        const cLen = activePlugins.length;
        let nodeName = "";
        while (selectionNode.firstChild) {
          selectionNode = selectionNode.firstChild;
        }
        for (let element = selectionNode; !util2.isWysiwygDiv(element); element = element.parentNode) {
          if (!element) break;
          if (element.nodeType !== 1 || util2.isBreak(element)) continue;
          nodeName = element.nodeName.toUpperCase();
          currentNodes.push(nodeName);
          if (!core.isReadOnly) {
            for (let c = 0, name2; c < cLen; c++) {
              name2 = activePlugins[c];
              if (commandMapNodes.indexOf(name2) === -1 && plugins[name2].active.call(core, element)) {
                commandMapNodes.push(name2);
              }
            }
          }
          if (util2.isFormatElement(element)) {
            if (commandMapNodes.indexOf("OUTDENT") === -1 && commandMap.OUTDENT && !util2.isImportantDisabled(commandMap.OUTDENT)) {
              if (util2.isListCell(element) || element.style[marginDir] && util2.getNumber(element.style[marginDir], 0) > 0) {
                commandMapNodes.push("OUTDENT");
                commandMap.OUTDENT.removeAttribute("disabled");
              }
            }
            if (commandMapNodes.indexOf("INDENT") === -1 && commandMap.INDENT && !util2.isImportantDisabled(commandMap.INDENT)) {
              commandMapNodes.push("INDENT");
              if (util2.isListCell(element) && !element.previousElementSibling) {
                commandMap.INDENT.setAttribute("disabled", true);
              } else {
                commandMap.INDENT.removeAttribute("disabled");
              }
            }
            continue;
          }
          if (classOnCheck && classOnCheck.test(nodeName)) {
            commandMapNodes.push(nodeName);
            util2.addClass(commandMap[nodeName], "active");
          }
        }
        core._setKeyEffect(commandMapNodes);
        core._variable.currentNodes = currentNodes.reverse();
        core._variable.currentNodesMap = commandMapNodes;
        if (options2.showPathLabel) context.element.navigation.textContent = core._variable.currentNodes.join(" > ");
      },
      _buttonsEventHandler: function(e) {
        let target = e.target;
        if (core._bindControllersOff) e.stopPropagation();
        if (/^(input|textarea|select|option)$/i.test(target.nodeName)) {
          core._antiBlur = false;
        } else {
          e.preventDefault();
        }
        if (util2.getParentElement(target, ".se-submenu")) {
          e.stopPropagation();
          core._notHideToolbar = true;
        } else {
          let command = target.getAttribute("data-command");
          let className = target.className;
          while (!command && !/se-menu-list/.test(className) && !/sun-editor-common/.test(className)) {
            target = target.parentNode;
            command = target.getAttribute("data-command");
            className = target.className;
          }
          if (command === core._submenuName || command === core._containerName) {
            e.stopPropagation();
          }
        }
      },
      addGlobalEvent(type, listener, useCapture) {
        if (options2.iframe) {
          core._ww.addEventListener(type, listener, useCapture);
        }
        core._w.addEventListener(type, listener, useCapture);
        return {
          type,
          listener,
          useCapture
        };
      },
      removeGlobalEvent(type, listener, useCapture) {
        if (!type) return;
        if (typeof type === "object") {
          listener = type.listener;
          useCapture = type.useCapture;
          type = type.type;
        }
        if (options2.iframe) {
          core._ww.removeEventListener(type, listener, useCapture);
        }
        core._w.removeEventListener(type, listener, useCapture);
      },
      onClick_toolbar: function(e) {
        let target = e.target;
        let display = target.getAttribute("data-display");
        let command = target.getAttribute("data-command");
        let className = target.className;
        core.controllersOff();
        while (target.parentNode && !command && !/se-menu-list/.test(className) && !/se-toolbar/.test(className)) {
          target = target.parentNode;
          command = target.getAttribute("data-command");
          display = target.getAttribute("data-display");
          className = target.className;
        }
        if (!command && !display) return;
        if (target.disabled) return;
        core.actionCall(command, display, target);
      },
      __selectionSyncEvent: null,
      onMouseDown_wysiwyg: function(e) {
        if (core.isReadOnly || util2.isNonEditable(context.element.wysiwyg)) return;
        if (util2._isExcludeSelectionElement(e.target)) {
          e.preventDefault();
          return;
        }
        event.removeGlobalEvent(event.__selectionSyncEvent);
        event.__selectionSyncEvent = event.addGlobalEvent("mouseup", function() {
          core._editorRange();
          event.removeGlobalEvent(event.__selectionSyncEvent);
        });
        if (typeof functions.onMouseDown === "function" && functions.onMouseDown(e, core) === false) return;
        const tableCell = util2.getParentElement(e.target, util2.isCell);
        if (tableCell) {
          const tablePlugin = core.plugins.table;
          if (tablePlugin && tableCell !== tablePlugin._fixedCell && !tablePlugin._shift) {
            core.callPlugin("table", function() {
              tablePlugin.onTableCellMultiSelect.call(core, tableCell, false);
            }, null);
          }
        }
        if (core._isBalloon) {
          event._hideToolbar();
        }
      },
      onClick_wysiwyg: function(e) {
        const targetElement = e.target;
        if (core.isReadOnly) {
          e.preventDefault();
          if (util2.isAnchor(targetElement)) {
            _w.open(targetElement.href, targetElement.target);
          }
          return false;
        }
        if (util2.isNonEditable(context.element.wysiwyg)) return;
        if (typeof functions.onClick === "function" && functions.onClick(e, core) === false) return;
        const fileComponentInfo = core.getFileComponent(targetElement);
        if (fileComponentInfo) {
          e.preventDefault();
          core.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName);
          return;
        }
        const figcaption = util2.getParentElement(targetElement, "FIGCAPTION");
        if (figcaption && util2.isNonEditable(figcaption)) {
          e.preventDefault();
          figcaption.focus();
          if (core._isInline && !core._inlineToolbarAttr.isShow) {
            event._showToolbarInline();
            const hideToolbar = function() {
              event._hideToolbar();
              figcaption.removeEventListener("blur", hideToolbar);
            };
            figcaption.addEventListener("blur", hideToolbar);
          }
        }
        core._editorRange();
        if (e.detail === 3) {
          let range = core.getRange();
          if (util2.isFormatElement(range.endContainer) && range.endOffset === 0) {
            range = core.setRange(range.startContainer, range.startOffset, range.startContainer, range.startContainer.length);
            core._rangeInfo(range, core.getSelection());
          }
        }
        const selectionNode = core.getSelectionNode();
        const formatEl = util2.getFormatElement(selectionNode, null);
        const rangeEl = util2.getRangeFormatElement(selectionNode, null);
        let selectionNodeDeepestFirstChild = selectionNode;
        while (selectionNodeDeepestFirstChild.firstChild) selectionNodeDeepestFirstChild = selectionNodeDeepestFirstChild.firstChild;
        const selectedComponentInfo = core.getFileComponent(selectionNodeDeepestFirstChild);
        if (selectedComponentInfo) {
          const range = core.getRange();
          if (!rangeEl && range.startContainer === range.endContainer) core.selectComponent(selectedComponentInfo.target, selectedComponentInfo.pluginName);
        } else if (core.currentFileComponentInfo) core.controllersOff();
        if (!formatEl && !util2.isNonEditable(targetElement) && !util2.isList(rangeEl)) {
          const range = core.getRange();
          if (util2.getFormatElement(range.startContainer) === util2.getFormatElement(range.endContainer)) {
            if (util2.isList(rangeEl)) {
              e.preventDefault();
              const oLi = util2.createElement("LI");
              const prevLi = selectionNode.nextElementSibling;
              oLi.appendChild(selectionNode);
              rangeEl.insertBefore(oLi, prevLi);
              core.focus();
            } else if (!util2.isWysiwygDiv(selectionNode) && !util2.isComponent(selectionNode) && (!util2.isTable(selectionNode) || util2.isCell(selectionNode)) && core._setDefaultFormat(util2.isRangeFormatElement(rangeEl) ? "DIV" : options2.defaultTag) !== null) {
              e.preventDefault();
              core.focus();
            } else {
              event._applyTagEffects();
            }
          }
        } else {
          event._applyTagEffects();
        }
        if (core._isBalloon) _w.setTimeout(event._toggleToolbarBalloon);
      },
      _balloonDelay: null,
      _showToolbarBalloonDelay: function() {
        if (event._balloonDelay) {
          _w.clearTimeout(event._balloonDelay);
        }
        event._balloonDelay = _w.setTimeout(function() {
          _w.clearTimeout(this._balloonDelay);
          this._balloonDelay = null;
          this._showToolbarBalloon();
        }.bind(event), 350);
      },
      _toggleToolbarBalloon: function() {
        core._editorRange();
        const range = core.getRange();
        if (core._bindControllersOff || !core._isBalloonAlways && range.collapsed) event._hideToolbar();
        else event._showToolbarBalloon(range);
      },
      _showToolbarBalloon: function(rangeObj) {
        if (!core._isBalloon) return;
        const range = rangeObj || core.getRange();
        const toolbar = context.element.toolbar;
        const topArea = context.element.topArea;
        const selection = core.getSelection();
        let isDirTop;
        if (core._isBalloonAlways && range.collapsed) {
          isDirTop = true;
        } else if (selection.focusNode === selection.anchorNode) {
          isDirTop = selection.focusOffset < selection.anchorOffset;
        } else {
          const childNodes = util2.getListChildNodes(range.commonAncestorContainer, null);
          isDirTop = util2.getArrayIndex(childNodes, selection.focusNode) < util2.getArrayIndex(childNodes, selection.anchorNode);
        }
        let rects = range.getClientRects();
        rects = rects[isDirTop ? 0 : rects.length - 1];
        const globalScroll = core.getGlobalScrollOffset();
        let scrollLeft = globalScroll.left;
        let scrollTop = globalScroll.top;
        const editorWidth = topArea.offsetWidth;
        const offsets = event._getEditorOffsets(null);
        const stickyTop = offsets.top;
        const editorLeft = offsets.left;
        toolbar.style.top = "-10000px";
        toolbar.style.visibility = "hidden";
        toolbar.style.display = "block";
        if (!rects) {
          const node = core.getSelectionNode();
          if (util2.isFormatElement(node)) {
            const zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
            core.insertNode(zeroWidth, null, false);
            core.setRange(zeroWidth, 1, zeroWidth, 1);
            core._editorRange();
            rects = core.getRange().getClientRects();
            rects = rects[isDirTop ? 0 : rects.length - 1];
          }
          if (!rects) {
            const nodeOffset = util2.getOffset(node, context.element.wysiwygFrame);
            rects = {
              left: nodeOffset.left,
              top: nodeOffset.top,
              right: nodeOffset.left,
              bottom: nodeOffset.top + node.offsetHeight,
              noText: true
            };
            scrollLeft = 0;
            scrollTop = 0;
          }
          isDirTop = true;
        }
        const arrowMargin = _w.Math.round(context.element._arrow.offsetWidth / 2);
        const toolbarWidth = toolbar.offsetWidth;
        const toolbarHeight = toolbar.offsetHeight;
        const iframeRects = /iframe/i.test(context.element.wysiwygFrame.nodeName) ? context.element.wysiwygFrame.getClientRects()[0] : null;
        if (iframeRects) {
          rects = {
            left: rects.left + iframeRects.left,
            top: rects.top + iframeRects.top,
            right: rects.right + iframeRects.right - iframeRects.width,
            bottom: rects.bottom + iframeRects.bottom - iframeRects.height
          };
        }
        event._setToolbarOffset(isDirTop, rects, toolbar, editorLeft, editorWidth, scrollLeft, scrollTop, stickyTop, arrowMargin);
        if (toolbarWidth !== toolbar.offsetWidth || toolbarHeight !== toolbar.offsetHeight) {
          event._setToolbarOffset(isDirTop, rects, toolbar, editorLeft, editorWidth, scrollLeft, scrollTop, stickyTop, arrowMargin);
        }
        if (options2.toolbarContainer) {
          const editorParent = topArea.parentElement;
          let container = options2.toolbarContainer;
          let left = container.offsetLeft;
          let top = container.offsetTop;
          while (!container.parentElement.contains(editorParent) || !/^(BODY|HTML)$/i.test(container.parentElement.nodeName)) {
            container = container.offsetParent;
            left += container.offsetLeft;
            top += container.offsetTop;
          }
          toolbar.style.left = toolbar.offsetLeft - left + topArea.offsetLeft + "px";
          toolbar.style.top = toolbar.offsetTop - top + topArea.offsetTop + "px";
        }
        toolbar.style.visibility = "";
      },
      _setToolbarOffset: function(isDirTop, rects, toolbar, editorLeft, editorWidth, scrollLeft, scrollTop, stickyTop, arrowMargin) {
        const padding = 1;
        const toolbarWidth = toolbar.offsetWidth;
        const toolbarHeight = rects.noText && !isDirTop ? 0 : toolbar.offsetHeight;
        const absoluteLeft = (isDirTop ? rects.left : rects.right) - editorLeft - toolbarWidth / 2 + scrollLeft;
        const overRight = absoluteLeft + toolbarWidth - editorWidth;
        let t = (isDirTop ? rects.top - toolbarHeight - arrowMargin : rects.bottom + arrowMargin) - (rects.noText ? 0 : stickyTop) + scrollTop;
        let l = absoluteLeft < 0 ? padding : overRight < 0 ? absoluteLeft : absoluteLeft - overRight - padding - 1;
        let resetTop = false;
        const space = t + (isDirTop ? event._getEditorOffsets(null).top : toolbar.offsetHeight - context.element.wysiwyg.offsetHeight);
        if (!isDirTop && space > 0 && event._getPageBottomSpace() < space) {
          isDirTop = true;
          resetTop = true;
        } else if (isDirTop && _d.documentElement.offsetTop > space) {
          isDirTop = false;
          resetTop = true;
        }
        if (resetTop) t = (isDirTop ? rects.top - toolbarHeight - arrowMargin : rects.bottom + arrowMargin) - (rects.noText ? 0 : stickyTop) + scrollTop;
        toolbar.style.left = _w.Math.floor(l) + "px";
        toolbar.style.top = _w.Math.floor(t) + "px";
        if (isDirTop) {
          util2.removeClass(context.element._arrow, "se-arrow-up");
          util2.addClass(context.element._arrow, "se-arrow-down");
          context.element._arrow.style.top = toolbarHeight + "px";
        } else {
          util2.removeClass(context.element._arrow, "se-arrow-down");
          util2.addClass(context.element._arrow, "se-arrow-up");
          context.element._arrow.style.top = -arrowMargin + "px";
        }
        const arrow_left = _w.Math.floor(toolbarWidth / 2 + (absoluteLeft - l));
        context.element._arrow.style.left = (arrow_left + arrowMargin > toolbar.offsetWidth ? toolbar.offsetWidth - arrowMargin : arrow_left < arrowMargin ? arrowMargin : arrow_left) + "px";
      },
      _showToolbarInline: function() {
        if (!core._isInline) return;
        const toolbar = context.element.toolbar;
        if (options2.toolbarContainer) toolbar.style.position = "relative";
        else toolbar.style.position = "absolute";
        toolbar.style.visibility = "hidden";
        toolbar.style.display = "block";
        core._inlineToolbarAttr.width = toolbar.style.width = options2.toolbarWidth;
        core._inlineToolbarAttr.top = toolbar.style.top = (options2.toolbarContainer ? 0 : -1 - toolbar.offsetHeight) + "px";
        if (typeof functions.showInline === "function") functions.showInline(toolbar, context, core);
        event.onScroll_window();
        core._inlineToolbarAttr.isShow = true;
        toolbar.style.visibility = "";
      },
      _hideToolbar: function() {
        if (!core._notHideToolbar && !core._variable.isFullScreen) {
          context.element.toolbar.style.display = "none";
          core._inlineToolbarAttr.isShow = false;
        }
      },
      onInput_wysiwyg: function(e) {
        if (/AUDIO/.test(e.target.nodeName)) return false;
        if (core.isReadOnly || core.isDisabled) {
          e.preventDefault();
          e.stopPropagation();
          core.history.go(core.history.getCurrentIndex());
          return false;
        }
        core._editorRange();
        const data2 = (e.data === null ? "" : e.data === void 0 ? " " : e.data) || "";
        if (!core._charCount(data2)) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        if (typeof functions.onInput === "function" && functions.onInput(e, core) === false) return;
        core.history.push(true);
      },
      _isUneditableNode: function(range, isFront) {
        const container = isFront ? range.startContainer : range.endContainer;
        const offset = isFront ? range.startOffset : range.endOffset;
        const siblingKey = isFront ? "previousSibling" : "nextSibling";
        const isElement = container.nodeType === 1;
        let siblingNode;
        if (isElement) {
          siblingNode = event._isUneditableNode_getSibling(container.childNodes[offset], siblingKey, container);
          return siblingNode && siblingNode.nodeType === 1 && siblingNode.getAttribute("contenteditable") === "false";
        } else {
          siblingNode = event._isUneditableNode_getSibling(container, siblingKey, container);
          return core.isEdgePoint(container, offset, isFront ? "front" : "end") && (siblingNode && siblingNode.nodeType === 1 && siblingNode.getAttribute("contenteditable") === "false");
        }
      },
      _isUneditableNode_getSibling: function(selectNode, siblingKey, container) {
        if (!selectNode) return null;
        let siblingNode = selectNode[siblingKey];
        if (!siblingNode) {
          siblingNode = util2.getFormatElement(container);
          siblingNode = siblingNode ? siblingNode[siblingKey] : null;
          if (siblingNode && !util2.isComponent(siblingNode)) siblingNode = siblingKey === "previousSibling" ? siblingNode.firstChild : siblingNode.lastChild;
          else return null;
        }
        return siblingNode;
      },
      _onShortcutKey: false,
      onKeyDown_wysiwyg: function(e) {
        let selectionNode = core.getSelectionNode();
        if (util2.isInputElement(selectionNode)) return;
        const keyCode = e.keyCode;
        const shift = e.shiftKey;
        const ctrl = e.ctrlKey || e.metaKey || keyCode === 91 || keyCode === 92 || keyCode === 224;
        const alt = e.altKey;
        event._IEisComposing = keyCode === 229;
        if (!ctrl && core.isReadOnly && !event._cursorMoveKeyCode.test(keyCode)) {
          e.preventDefault();
          return false;
        }
        core.submenuOff();
        if (core._isBalloon) {
          event._hideToolbar();
        }
        if (typeof functions.onKeyDown === "function" && functions.onKeyDown(e, core) === false) return;
        if (ctrl && event._shortcutCommand(keyCode, shift)) {
          event._onShortcutKey = true;
          e.preventDefault();
          e.stopPropagation();
          return false;
        } else if (event._onShortcutKey) {
          event._onShortcutKey = false;
        }
        const range = core.getRange();
        const selectRange = !range.collapsed || range.startContainer !== range.endContainer;
        const fileComponentName = core._fileManager.pluginRegExp.test(core.currentControllerName) ? core.currentControllerName : "";
        let formatEl = util2.getFormatElement(selectionNode, null) || selectionNode;
        let rangeEl = util2.getRangeFormatElement(formatEl, null);
        const isArrowKey = /37|38|39|40/.test(e.keyCode);
        if (isArrowKey && event._onKeyDown_wysiwyg_arrowKey(e) === false) return;
        switch (keyCode) {
          case 8:
            if (!selectRange) {
              if (fileComponentName) {
                e.preventDefault();
                e.stopPropagation();
                core.plugins[fileComponentName].destroy.call(core);
                break;
              }
            }
            if (selectRange && event._hardDelete()) {
              e.preventDefault();
              e.stopPropagation();
              break;
            }
            if (!util2.isFormatElement(formatEl) && !context.element.wysiwyg.firstElementChild && !util2.isComponent(selectionNode) && core._setDefaultFormat(options2.defaultTag) !== null) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }
            if (!selectRange && !formatEl.previousElementSibling && (range.startOffset === 0 && !selectionNode.previousSibling && !util2.isListCell(formatEl) && (util2.isFormatElement(formatEl) && (!util2.isFreeFormatElement(formatEl) || util2.isClosureFreeFormatElement(formatEl))))) {
              if (util2.isClosureRangeFormatElement(formatEl.parentNode)) {
                e.preventDefault();
                e.stopPropagation();
                return false;
              }
              if (util2.isWysiwygDiv(formatEl.parentNode) && formatEl.childNodes.length <= 1 && (!formatEl.firstChild || util2.onlyZeroWidthSpace(formatEl.textContent))) {
                e.preventDefault();
                e.stopPropagation();
                if (formatEl.nodeName.toUpperCase() === options2.defaultTag.toUpperCase()) {
                  formatEl.innerHTML = "<br>";
                  const attrs = formatEl.attributes;
                  while (attrs[0]) {
                    formatEl.removeAttribute(attrs[0].name);
                  }
                } else {
                  const defaultFormat = util2.createElement(options2.defaultTag);
                  defaultFormat.innerHTML = "<br>";
                  formatEl.parentElement.replaceChild(defaultFormat, formatEl);
                }
                core.nativeFocus();
                return false;
              }
            }
            const startCon = range.startContainer;
            if (formatEl && !formatEl.previousElementSibling && range.startOffset === 0 && startCon.nodeType === 3 && !util2.isFormatElement(startCon.parentNode)) {
              let prev = startCon.parentNode.previousSibling;
              const next = startCon.parentNode.nextSibling;
              if (!prev) {
                if (!next) {
                  prev = util2.createElement("BR");
                  formatEl.appendChild(prev);
                } else {
                  prev = next;
                }
              }
              let con = startCon;
              while (formatEl.contains(con) && !con.previousSibling) {
                con = con.parentNode;
              }
              if (!formatEl.contains(con)) {
                startCon.textContent = "";
                util2.removeItemAllParents(startCon, null, formatEl);
                break;
              }
            }
            if (event._isUneditableNode(range, true)) {
              e.preventDefault();
              e.stopPropagation();
              break;
            }
            if (!selectRange && core._isEdgeFormat(range.startContainer, range.startOffset, "start")) {
              if (util2.isFormatElement(formatEl.previousElementSibling)) {
                core._formatAttrsTemp = formatEl.previousElementSibling.attributes;
              }
            }
            const commonCon = range.commonAncestorContainer;
            formatEl = util2.getFormatElement(range.startContainer, null);
            rangeEl = util2.getRangeFormatElement(formatEl, null);
            if (rangeEl && formatEl && !util2.isCell(rangeEl) && !/^FIGCAPTION$/i.test(rangeEl.nodeName)) {
              if (util2.isListCell(formatEl) && util2.isList(rangeEl) && (util2.isListCell(rangeEl.parentNode) || formatEl.previousElementSibling) && (selectionNode === formatEl || selectionNode.nodeType === 3 && (!selectionNode.previousSibling || util2.isList(selectionNode.previousSibling))) && (util2.getFormatElement(range.startContainer, null) !== util2.getFormatElement(range.endContainer, null) ? rangeEl.contains(range.startContainer) : range.startOffset === 0 && range.collapsed)) {
                if (range.startContainer !== range.endContainer) {
                  e.preventDefault();
                  core.removeNode();
                  if (range.startContainer.nodeType === 3) {
                    core.setRange(range.startContainer, range.startContainer.textContent.length, range.startContainer, range.startContainer.textContent.length);
                  }
                  core.history.push(true);
                } else {
                  let prev = formatEl.previousElementSibling || rangeEl.parentNode;
                  if (util2.isListCell(prev)) {
                    e.preventDefault();
                    let prevLast = prev;
                    if (!prev.contains(formatEl) && util2.isListCell(prevLast) && util2.isList(prevLast.lastElementChild)) {
                      prevLast = prevLast.lastElementChild.lastElementChild;
                      while (util2.isListCell(prevLast) && util2.isList(prevLast.lastElementChild)) {
                        prevLast = prevLast.lastElementChild && prevLast.lastElementChild.lastElementChild;
                      }
                      prev = prevLast;
                    }
                    let con = prev === rangeEl.parentNode ? rangeEl.previousSibling : prev.lastChild;
                    if (!con) {
                      con = util2.createTextNode(util2.zeroWidthSpace);
                      rangeEl.parentNode.insertBefore(con, rangeEl.parentNode.firstChild);
                    }
                    const offset = con.nodeType === 3 ? con.textContent.length : 1;
                    const children2 = formatEl.childNodes;
                    let after = con;
                    let child = children2[0];
                    while (child = children2[0]) {
                      prev.insertBefore(child, after.nextSibling);
                      after = child;
                    }
                    util2.removeItem(formatEl);
                    if (rangeEl.children.length === 0) util2.removeItem(rangeEl);
                    core.setRange(con, offset, con, offset);
                    core.history.push(true);
                  }
                }
                break;
              }
              if (!selectRange && range.startOffset === 0) {
                let detach = true;
                let comm = commonCon;
                while (comm && comm !== rangeEl && !util2.isWysiwygDiv(comm)) {
                  if (comm.previousSibling) {
                    if (comm.previousSibling.nodeType === 1 || !util2.onlyZeroWidthSpace(comm.previousSibling.textContent.trim())) {
                      detach = false;
                      break;
                    }
                  }
                  comm = comm.parentNode;
                }
                if (detach && rangeEl.parentNode) {
                  e.preventDefault();
                  core.detachRangeFormatElement(rangeEl, util2.isListCell(formatEl) ? [formatEl] : null, null, false, false);
                  core.history.push(true);
                  break;
                }
              }
            }
            if (!selectRange && formatEl && (range.startOffset === 0 || (selectionNode === formatEl ? !!formatEl.childNodes[range.startOffset] : false))) {
              const sel = selectionNode === formatEl ? formatEl.childNodes[range.startOffset] : selectionNode;
              const prev = formatEl.previousSibling;
              const ignoreZWS = (commonCon.nodeType === 3 || util2.isBreak(commonCon)) && !commonCon.previousSibling && range.startOffset === 0;
              if (sel && !sel.previousSibling && (commonCon && util2.isComponent(commonCon.previousSibling) || ignoreZWS && util2.isComponent(prev))) {
                const fileComponentInfo = core.getFileComponent(prev);
                if (fileComponentInfo) {
                  e.preventDefault();
                  e.stopPropagation();
                  if (formatEl.textContent.length === 0) util2.removeItem(formatEl);
                  if (core.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName) === false) core.blur();
                } else if (util2.isComponent(prev)) {
                  e.preventDefault();
                  e.stopPropagation();
                  util2.removeItem(prev);
                }
                break;
              }
              if (sel && util2.isNonEditable(sel.previousSibling)) {
                e.preventDefault();
                e.stopPropagation();
                util2.removeItem(sel.previousSibling);
                break;
              }
            }
            break;
          case 46:
            if (fileComponentName) {
              e.preventDefault();
              e.stopPropagation();
              core.plugins[fileComponentName].destroy.call(core);
              break;
            }
            if (selectRange && event._hardDelete()) {
              e.preventDefault();
              e.stopPropagation();
              break;
            }
            if (event._isUneditableNode(range, false)) {
              e.preventDefault();
              e.stopPropagation();
              break;
            }
            if ((util2.isFormatElement(selectionNode) || selectionNode.nextSibling === null || util2.onlyZeroWidthSpace(selectionNode.nextSibling) && selectionNode.nextSibling.nextSibling === null) && range.startOffset === selectionNode.textContent.length) {
              const nextEl = formatEl.nextElementSibling;
              if (!nextEl) break;
              if (util2.isComponent(nextEl)) {
                e.preventDefault();
                if (util2.onlyZeroWidthSpace(formatEl)) {
                  util2.removeItem(formatEl);
                  if (util2.isTable(nextEl)) {
                    let cell = util2.getChildElement(nextEl, util2.isCell, false);
                    cell = cell.firstElementChild || cell;
                    core.setRange(cell, 0, cell, 0);
                    break;
                  }
                }
                const fileComponentInfo = core.getFileComponent(nextEl);
                if (fileComponentInfo) {
                  e.stopPropagation();
                  if (core.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName) === false) core.blur();
                } else if (util2.isComponent(nextEl)) {
                  e.stopPropagation();
                  util2.removeItem(nextEl);
                }
                break;
              }
            }
            if (!selectRange && (core.isEdgePoint(range.endContainer, range.endOffset) || (selectionNode === formatEl ? !!formatEl.childNodes[range.startOffset] : false))) {
              const sel = selectionNode === formatEl ? formatEl.childNodes[range.startOffset] || selectionNode : selectionNode;
              if (sel && util2.isNonEditable(sel.nextSibling)) {
                e.preventDefault();
                e.stopPropagation();
                util2.removeItem(sel.nextSibling);
                break;
              } else if (util2.isComponent(sel)) {
                e.preventDefault();
                e.stopPropagation();
                util2.removeItem(sel);
                break;
              }
            }
            if (!selectRange && core._isEdgeFormat(range.endContainer, range.endOffset, "end")) {
              if (util2.isFormatElement(formatEl.nextElementSibling)) {
                core._formatAttrsTemp = formatEl.attributes;
              }
            }
            formatEl = util2.getFormatElement(range.startContainer, null);
            rangeEl = util2.getRangeFormatElement(formatEl, null);
            if (util2.isListCell(formatEl) && util2.isList(rangeEl) && (selectionNode === formatEl || selectionNode.nodeType === 3 && (!selectionNode.nextSibling || util2.isList(selectionNode.nextSibling)) && (util2.getFormatElement(range.startContainer, null) !== util2.getFormatElement(range.endContainer, null) ? rangeEl.contains(range.endContainer) : range.endOffset === selectionNode.textContent.length && range.collapsed))) {
              if (range.startContainer !== range.endContainer) core.removeNode();
              let next = util2.getArrayItem(formatEl.children, util2.isList, false);
              next = next || formatEl.nextElementSibling || rangeEl.parentNode.nextElementSibling;
              if (next && (util2.isList(next) || util2.getArrayItem(next.children, util2.isList, false))) {
                e.preventDefault();
                let con, children2;
                if (util2.isList(next)) {
                  const child = next.firstElementChild;
                  children2 = child.childNodes;
                  con = children2[0];
                  while (children2[0]) {
                    formatEl.insertBefore(children2[0], next);
                  }
                  util2.removeItem(child);
                } else {
                  con = next.firstChild;
                  children2 = next.childNodes;
                  while (children2[0]) {
                    formatEl.appendChild(children2[0]);
                  }
                  util2.removeItem(next);
                }
                core.setRange(con, 0, con, 0);
                core.history.push(true);
              }
              break;
            }
            break;
          case 9:
            if (fileComponentName || options2.tabDisable) break;
            e.preventDefault();
            if (ctrl || alt || util2.isWysiwygDiv(selectionNode)) break;
            const isEdge = !range.collapsed || core.isEdgePoint(range.startContainer, range.startOffset);
            const selectedFormats = core.getSelectedElements(null);
            selectionNode = core.getSelectionNode();
            const cells = [];
            let lines = [];
            let fc = util2.isListCell(selectedFormats[0]), lc = util2.isListCell(selectedFormats[selectedFormats.length - 1]);
            let r = { sc: range.startContainer, so: range.startOffset, ec: range.endContainer, eo: range.endOffset };
            for (let i = 0, len = selectedFormats.length, f; i < len; i++) {
              f = selectedFormats[i];
              if (util2.isListCell(f)) {
                if (!f.previousElementSibling && !shift) {
                  continue;
                } else {
                  cells.push(f);
                }
              } else {
                lines.push(f);
              }
            }
            if (cells.length > 0 && isEdge && core.plugins.list) {
              r = core.plugins.list.editInsideList.call(core, shift, cells);
            } else {
              const tableCell = util2.getParentElement(selectionNode, util2.isCell);
              if (tableCell && isEdge) {
                const table = util2.getParentElement(tableCell, "table");
                const cells2 = util2.getListChildren(table, util2.isCell);
                let idx = shift ? util2.prevIdx(cells2, tableCell) : util2.nextIdx(cells2, tableCell);
                if (idx === cells2.length && !shift) idx = 0;
                if (idx === -1 && shift) idx = cells2.length - 1;
                let moveCell = cells2[idx];
                if (!moveCell) break;
                moveCell = moveCell.firstElementChild || moveCell;
                core.setRange(moveCell, 0, moveCell, 0);
                break;
              }
              lines = lines.concat(cells);
              fc = lc = null;
            }
            if (lines.length > 0) {
              if (!shift) {
                const tabText = util2.createTextNode(new _w.Array(core._variable.tabSize + 1).join("\xA0"));
                if (lines.length === 1) {
                  const textRange = core.insertNode(tabText, null, true);
                  if (!textRange) return false;
                  if (!fc) {
                    r.sc = tabText;
                    r.so = textRange.endOffset;
                  }
                  if (!lc) {
                    r.ec = tabText;
                    r.eo = textRange.endOffset;
                  }
                } else {
                  const len = lines.length - 1;
                  for (let i = 0, child; i <= len; i++) {
                    child = lines[i].firstChild;
                    if (!child) continue;
                    if (util2.isBreak(child)) {
                      lines[i].insertBefore(tabText.cloneNode(false), child);
                    } else {
                      child.textContent = tabText.textContent + child.textContent;
                    }
                  }
                  const firstChild = util2.getChildElement(lines[0], "text", false);
                  const endChild = util2.getChildElement(lines[len], "text", true);
                  if (!fc && firstChild) {
                    r.sc = firstChild;
                    r.so = 0;
                  }
                  if (!lc && endChild) {
                    r.ec = endChild;
                    r.eo = endChild.textContent.length;
                  }
                }
              } else {
                const len = lines.length - 1;
                for (let i = 0, line; i <= len; i++) {
                  line = lines[i].childNodes;
                  for (let c = 0, cLen = line.length, child; c < cLen; c++) {
                    child = line[c];
                    if (!child) break;
                    if (util2.onlyZeroWidthSpace(child)) continue;
                    if (/^\s{1,4}$/.test(child.textContent)) {
                      util2.removeItem(child);
                    } else if (/^\s{1,4}/.test(child.textContent)) {
                      child.textContent = child.textContent.replace(/^\s{1,4}/, "");
                    }
                    break;
                  }
                }
                const firstChild = util2.getChildElement(lines[0], "text", false);
                const endChild = util2.getChildElement(lines[len], "text", true);
                if (!fc && firstChild) {
                  r.sc = firstChild;
                  r.so = 0;
                }
                if (!lc && endChild) {
                  r.ec = endChild;
                  r.eo = endChild.textContent.length;
                }
              }
            }
            core.setRange(r.sc, r.so, r.ec, r.eo);
            core.history.push(false);
            break;
          case 13:
            const freeFormatEl = util2.getFreeFormatElement(selectionNode, null);
            if (core._charTypeHTML) {
              let enterHTML = "";
              if (!shift && freeFormatEl || shift) {
                enterHTML = "<br>";
              } else {
                enterHTML = "<" + formatEl.nodeName + "><br></" + formatEl.nodeName + ">";
              }
              if (!core.checkCharCount(enterHTML, "byte-html")) {
                e.preventDefault();
                return false;
              }
            }
            if (!shift && !fileComponentName) {
              const formatEndEdge = core._isEdgeFormat(range.endContainer, range.endOffset, "end");
              const formatStartEdge = core._isEdgeFormat(range.startContainer, range.startOffset, "start");
              if (formatEndEdge && (/^H[1-6]$/i.test(formatEl.nodeName) || /^HR$/i.test(formatEl.nodeName))) {
                event._enterPrevent(e);
                let temp = null;
                const newFormat = core.appendFormatTag(formatEl, options2.defaultTag);
                if (formatEndEdge && formatEndEdge.length > 0) {
                  temp = formatEndEdge.pop();
                  const innerNode = temp;
                  while (formatEndEdge.length > 0) {
                    temp = temp.appendChild(formatEndEdge.pop());
                  }
                  newFormat.appendChild(innerNode);
                }
                temp = !temp ? newFormat.firstChild : temp.appendChild(newFormat.firstChild);
                if (util2.isBreak(temp)) {
                  const zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
                  temp.parentNode.insertBefore(zeroWidth, temp);
                  core.setRange(zeroWidth, 1, zeroWidth, 1);
                } else {
                  core.setRange(temp, 0, temp, 0);
                }
                break;
              } else if (rangeEl && formatEl && !util2.isCell(rangeEl) && !/^FIGCAPTION$/i.test(rangeEl.nodeName)) {
                const range2 = core.getRange();
                if (core.isEdgePoint(range2.endContainer, range2.endOffset) && util2.isList(selectionNode.nextSibling)) {
                  event._enterPrevent(e);
                  const newEl = util2.createElement("LI");
                  const br2 = util2.createElement("BR");
                  newEl.appendChild(br2);
                  formatEl.parentNode.insertBefore(newEl, formatEl.nextElementSibling);
                  newEl.appendChild(selectionNode.nextSibling);
                  core.setRange(br2, 1, br2, 1);
                  break;
                }
                if ((range2.commonAncestorContainer.nodeType === 3 ? !range2.commonAncestorContainer.nextElementSibling : true) && util2.onlyZeroWidthSpace(formatEl.innerText.trim()) && !util2.isListCell(formatEl.nextElementSibling)) {
                  event._enterPrevent(e);
                  let newEl = null;
                  if (util2.isListCell(rangeEl.parentNode)) {
                    const parentLi = formatEl.parentNode.parentNode;
                    rangeEl = parentLi.parentNode;
                    const newListCell = util2.createElement("LI");
                    newListCell.innerHTML = "<br>";
                    util2.copyTagAttributes(newListCell, formatEl, options2.lineAttrReset);
                    newEl = newListCell;
                    rangeEl.insertBefore(newEl, parentLi.nextElementSibling);
                  } else {
                    const newFormat = util2.isCell(rangeEl.parentNode) ? "DIV" : util2.isList(rangeEl.parentNode) ? "LI" : util2.isFormatElement(rangeEl.nextElementSibling) && !util2.isRangeFormatElement(rangeEl.nextElementSibling) ? rangeEl.nextElementSibling.nodeName : util2.isFormatElement(rangeEl.previousElementSibling) && !util2.isRangeFormatElement(rangeEl.previousElementSibling) ? rangeEl.previousElementSibling.nodeName : options2.defaultTag;
                    newEl = util2.createElement(newFormat);
                    util2.copyTagAttributes(newEl, formatEl, options2.lineAttrReset);
                    const edge = core.detachRangeFormatElement(rangeEl, [formatEl], null, true, true);
                    edge.cc.insertBefore(newEl, edge.ec);
                  }
                  newEl.innerHTML = "<br>";
                  util2.removeItemAllParents(formatEl, null, null);
                  core.setRange(newEl, 1, newEl, 1);
                  break;
                }
              }
              if (freeFormatEl) {
                event._enterPrevent(e);
                const selectionFormat = selectionNode === freeFormatEl;
                const wSelection = core.getSelection();
                const children2 = selectionNode.childNodes, offset = wSelection.focusOffset, prev = selectionNode.previousElementSibling, next = selectionNode.nextSibling;
                if (!util2.isClosureFreeFormatElement(freeFormatEl) && !!children2 && (selectionFormat && range.collapsed && children2.length - 1 <= offset + 1 && util2.isBreak(children2[offset]) && (!children2[offset + 1] || (!children2[offset + 2] || util2.onlyZeroWidthSpace(children2[offset + 2].textContent)) && children2[offset + 1].nodeType === 3 && util2.onlyZeroWidthSpace(children2[offset + 1].textContent)) && offset > 0 && util2.isBreak(children2[offset - 1]) || !selectionFormat && util2.onlyZeroWidthSpace(selectionNode.textContent) && util2.isBreak(prev) && (util2.isBreak(prev.previousSibling) || !util2.onlyZeroWidthSpace(prev.previousSibling.textContent)) && (!next || !util2.isBreak(next) && util2.onlyZeroWidthSpace(next.textContent)))) {
                  if (selectionFormat) util2.removeItem(children2[offset - 1]);
                  else util2.removeItem(selectionNode);
                  const newEl = core.appendFormatTag(freeFormatEl, util2.isFormatElement(freeFormatEl.nextElementSibling) && !util2.isRangeFormatElement(freeFormatEl.nextElementSibling) ? freeFormatEl.nextElementSibling : null);
                  util2.copyFormatAttributes(newEl, freeFormatEl);
                  core.setRange(newEl, 1, newEl, 1);
                  break;
                }
                if (selectionFormat) {
                  functions.insertHTML(range.collapsed && util2.isBreak(range.startContainer.childNodes[range.startOffset - 1]) ? "<br>" : "<br><br>", true, false);
                  let focusNode = wSelection.focusNode;
                  const wOffset = wSelection.focusOffset;
                  if (freeFormatEl === focusNode) {
                    focusNode = focusNode.childNodes[wOffset - offset > 1 ? wOffset - 1 : wOffset];
                  }
                  core.setRange(focusNode, 1, focusNode, 1);
                } else {
                  const focusNext = wSelection.focusNode.nextSibling;
                  const br2 = util2.createElement("BR");
                  core.insertNode(br2, null, false);
                  const brPrev = br2.previousSibling, brNext = br2.nextSibling;
                  if (!util2.isBreak(focusNext) && !util2.isBreak(brPrev) && (!brNext || util2.onlyZeroWidthSpace(brNext))) {
                    br2.parentNode.insertBefore(br2.cloneNode(false), br2);
                    core.setRange(br2, 1, br2, 1);
                  } else {
                    core.setRange(brNext, 0, brNext, 0);
                  }
                }
                event._onShortcutKey = true;
                break;
              }
              if (range.collapsed && (formatStartEdge || formatEndEdge)) {
                event._enterPrevent(e);
                const focusBR = util2.createElement("BR");
                const newFormat = util2.createElement(formatEl.nodeName);
                util2.copyTagAttributes(newFormat, formatEl, options2.lineAttrReset);
                let child = focusBR;
                do {
                  if (!util2.isBreak(selectionNode) && selectionNode.nodeType === 1) {
                    const f = selectionNode.cloneNode(false);
                    f.appendChild(child);
                    child = f;
                  }
                  selectionNode = selectionNode.parentNode;
                } while (formatEl !== selectionNode && formatEl.contains(selectionNode));
                newFormat.appendChild(child);
                formatEl.parentNode.insertBefore(newFormat, formatStartEdge && !formatEndEdge ? formatEl : formatEl.nextElementSibling);
                if (formatEndEdge) {
                  core.setRange(focusBR, 1, focusBR, 1);
                }
                break;
              }
              if (formatEl) {
                e.stopPropagation();
                let newEl;
                let offset = 0;
                if (!range.collapsed) {
                  const isMultiLine = util2.getFormatElement(range.startContainer, null) !== util2.getFormatElement(range.endContainer, null);
                  const newFormat = formatEl.cloneNode(false);
                  newFormat.innerHTML = "<br>";
                  const r2 = core.removeNode();
                  newEl = util2.getFormatElement(r2.container, null);
                  if (!newEl) {
                    if (util2.isWysiwygDiv(r2.container)) {
                      event._enterPrevent(e);
                      context.element.wysiwyg.appendChild(newFormat);
                      newEl = newFormat;
                      util2.copyTagAttributes(newEl, formatEl, options2.lineAttrReset);
                      core.setRange(newEl, offset, newEl, offset);
                    }
                    break;
                  }
                  const innerRange = util2.getRangeFormatElement(r2.container);
                  newEl = newEl.contains(innerRange) ? util2.getChildElement(innerRange, util2.getFormatElement.bind(util2)) : newEl;
                  if (isMultiLine) {
                    if (formatEndEdge && !formatStartEdge) {
                      newEl.parentNode.insertBefore(newFormat, !r2.prevContainer || r2.container === r2.prevContainer ? newEl.nextElementSibling : newEl);
                      newEl = newFormat;
                      offset = 0;
                    } else {
                      offset = r2.offset;
                      if (formatStartEdge) {
                        const tempEl = newEl.parentNode.insertBefore(newFormat, newEl);
                        if (formatEndEdge) {
                          newEl = tempEl;
                          offset = 0;
                        }
                      }
                    }
                  } else {
                    if (formatEndEdge && formatStartEdge) {
                      newEl.parentNode.insertBefore(newFormat, r2.prevContainer && r2.container === r2.prevContainer ? newEl.nextElementSibling : newEl);
                      newEl = newFormat;
                      offset = 0;
                    } else {
                      newEl = util2.splitElement(r2.container, r2.offset, util2.getElementDepth(formatEl));
                    }
                  }
                } else {
                  if (util2.onlyZeroWidthSpace(formatEl)) {
                    newEl = core.appendFormatTag(formatEl, formatEl.cloneNode(false));
                  } else {
                    newEl = util2.splitElement(range.endContainer, range.endOffset, util2.getElementDepth(formatEl));
                  }
                }
                event._enterPrevent(e);
                util2.copyTagAttributes(newEl, formatEl, options2.lineAttrReset);
                core.setRange(newEl, offset, newEl, offset);
                break;
              }
            }
            if (selectRange) break;
            if (rangeEl && util2.getParentElement(rangeEl, "FIGCAPTION") && util2.getParentElement(rangeEl, util2.isList)) {
              event._enterPrevent(e);
              formatEl = core.appendFormatTag(formatEl, null);
              core.setRange(formatEl, 0, formatEl, 0);
            }
            if (fileComponentName) {
              e.preventDefault();
              e.stopPropagation();
              core.containerOff();
              core.controllersOff();
              const compContext = context[fileComponentName];
              const container = compContext._container;
              const sibling = container.previousElementSibling || container.nextElementSibling;
              let newEl = null;
              if (util2.isListCell(container.parentNode)) {
                newEl = util2.createElement("BR");
              } else {
                newEl = util2.createElement(util2.isFormatElement(sibling) && !util2.isRangeFormatElement(sibling) ? sibling.nodeName : options2.defaultTag);
                newEl.innerHTML = "<br>";
              }
              if (shift) container.parentNode.insertBefore(newEl, container);
              else container.parentNode.insertBefore(newEl, container.nextElementSibling);
              core.callPlugin(fileComponentName, function() {
                if (core.selectComponent(compContext._element, fileComponentName) === false) core.blur();
              }, null);
            }
            break;
          case 27:
            if (fileComponentName) {
              e.preventDefault();
              e.stopPropagation();
              core.controllersOff();
              return false;
            }
            break;
        }
        if (shift && keyCode === 16) {
          e.preventDefault();
          e.stopPropagation();
          const tablePlugin = core.plugins.table;
          if (tablePlugin && !tablePlugin._shift && !tablePlugin._ref) {
            const cell = util2.getParentElement(formatEl, util2.isCell);
            if (cell) {
              tablePlugin.onTableCellMultiSelect.call(core, cell, true);
              return;
            }
          }
        } else if (shift && (util2.isOSX_IOS ? alt : ctrl) && keyCode === 32) {
          e.preventDefault();
          e.stopPropagation();
          const nbsp = core.insertNode(util2.createTextNode("\xA0"));
          if (nbsp && nbsp.container) {
            core.setRange(nbsp.container, nbsp.endOffset, nbsp.container, nbsp.endOffset);
            return;
          }
        }
        if (util2.isIE && !ctrl && !alt && !selectRange && !event._nonTextKeyCode.test(keyCode) && util2.isBreak(range.commonAncestorContainer)) {
          const zeroWidth = util2.createTextNode(util2.zeroWidthSpace);
          core.insertNode(zeroWidth, null, false);
          core.setRange(zeroWidth, 1, zeroWidth, 1);
        }
        if (event._directionKeyCode.test(keyCode)) {
          core._editorRange();
          event._applyTagEffects();
        }
      },
      _onKeyDown_wysiwyg_arrowKey: function(e) {
        if (e.shiftKey) return;
        let selectionNode = core.getSelectionNode();
        const selectNode = function(node, offset = 0) {
          e.preventDefault();
          e.stopPropagation();
          if (!node) return;
          let componentInfo2 = core.getFileComponent(node);
          if (componentInfo2) {
            core.selectComponent(componentInfo2.target, componentInfo2.pluginName);
          } else {
            core.setRange(node, offset, node, offset);
            core.controllersOff();
          }
        };
        const table = util2.getParentElement(selectionNode, "table");
        if (table) {
          const currentRow = util2.getParentElement(selectionNode, "tr");
          const currentCell = util2.getParentElement(selectionNode, "td");
          let currentCellFirstNode = currentCell;
          let currentCellLastNode = currentCell;
          if (currentCell) {
            while (currentCellFirstNode.firstChild) currentCellFirstNode = currentCellFirstNode.firstChild;
            while (currentCellLastNode.lastChild) currentCellLastNode = currentCellLastNode.lastChild;
          }
          let selectionNodeDeepestFirstChild = selectionNode;
          while (selectionNodeDeepestFirstChild.firstChild) selectionNodeDeepestFirstChild = selectionNodeDeepestFirstChild.firstChild;
          const isCellFirstNode = selectionNodeDeepestFirstChild === currentCellFirstNode;
          const isCellLastNode = selectionNodeDeepestFirstChild === currentCellLastNode;
          let siblingToSet = null;
          let offset = 0;
          if (e.keyCode === 38 && isCellFirstNode) {
            const previousRow = currentRow && currentRow.previousElementSibling;
            if (previousRow) siblingToSet = previousRow.children[currentCell.cellIndex];
            else siblingToSet = util2.getPreviousDeepestNode(table, core.context.element.wysiwyg);
            while (siblingToSet.lastChild) siblingToSet = siblingToSet.lastChild;
            if (siblingToSet) offset = siblingToSet.textContent.length;
          } else if (e.keyCode === 40 && isCellLastNode) {
            const nextRow = currentRow && currentRow.nextElementSibling;
            if (nextRow) siblingToSet = nextRow.children[currentCell.cellIndex];
            else siblingToSet = util2.getNextDeepestNode(table, core.context.element.wysiwyg);
            while (siblingToSet.firstChild) siblingToSet = siblingToSet.firstChild;
          }
          if (siblingToSet) {
            selectNode(siblingToSet, offset);
            return false;
          }
        }
        const componentInfo = core.getFileComponent(selectionNode);
        if (componentInfo) {
          const selectPrevious = /37|38/.test(e.keyCode);
          const selectNext = /39|40/.test(e.keyCode);
          if (selectPrevious) {
            const previousDeepestNode = util2.getPreviousDeepestNode(componentInfo.target, core.context.element.wysiwyg);
            selectNode(previousDeepestNode, previousDeepestNode && previousDeepestNode.textContent.length);
          } else if (selectNext) {
            const nextDeepestNode = util2.getNextDeepestNode(componentInfo.target, core.context.element.wysiwyg);
            selectNode(nextDeepestNode);
          }
        }
      },
      onKeyUp_wysiwyg: function(e) {
        if (event._onShortcutKey) return;
        core._editorRange();
        const keyCode = e.keyCode;
        const ctrl = e.ctrlKey || e.metaKey || keyCode === 91 || keyCode === 92 || keyCode === 224;
        const alt = e.altKey;
        if (core.isReadOnly) {
          if (!ctrl && event._cursorMoveKeyCode.test(keyCode)) event._applyTagEffects();
          return;
        }
        const range = core.getRange();
        let selectionNode = core.getSelectionNode();
        if (core._isBalloon && (core._isBalloonAlways && keyCode !== 27 || !range.collapsed)) {
          if (core._isBalloonAlways) {
            if (keyCode !== 27) event._showToolbarBalloonDelay();
          } else {
            event._showToolbarBalloon();
            return;
          }
        }
        let selectionNodeDeepestFirstChild = selectionNode;
        while (selectionNodeDeepestFirstChild.firstChild) selectionNodeDeepestFirstChild = selectionNodeDeepestFirstChild.firstChild;
        const selectedComponentInfo = core.getFileComponent(selectionNodeDeepestFirstChild);
        if (!(e.keyCode === 16 || e.shiftKey) && selectedComponentInfo) core.selectComponent(selectedComponentInfo.target, selectedComponentInfo.pluginName);
        else if (core.currentFileComponentInfo) core.controllersOff();
        if (keyCode === 8 && util2.isWysiwygDiv(selectionNode) && selectionNode.textContent === "" && selectionNode.children.length === 0) {
          e.preventDefault();
          e.stopPropagation();
          selectionNode.innerHTML = "";
          const oFormatTag = util2.createElement(util2.isFormatElement(core._variable.currentNodes[0]) ? core._variable.currentNodes[0] : options2.defaultTag);
          oFormatTag.innerHTML = "<br>";
          selectionNode.appendChild(oFormatTag);
          core.setRange(oFormatTag, 0, oFormatTag, 0);
          event._applyTagEffects();
          core.history.push(false);
          return;
        }
        const formatEl = util2.getFormatElement(selectionNode, null);
        const rangeEl = util2.getRangeFormatElement(selectionNode, null);
        const attrs = core._formatAttrsTemp;
        if (attrs) {
          for (let i = 0, len = attrs.length; i < len; i++) {
            if (keyCode === 13 && /^id$/i.test(attrs[i].name)) {
              formatEl.removeAttribute("id");
              continue;
            }
            formatEl.setAttribute(attrs[i].name, attrs[i].value);
          }
          core._formatAttrsTemp = null;
        }
        if (!formatEl && range.collapsed && !util2.isComponent(selectionNode) && !util2.isList(selectionNode) && core._setDefaultFormat(util2.isRangeFormatElement(rangeEl) ? "DIV" : options2.defaultTag) !== null) {
          selectionNode = core.getSelectionNode();
        }
        const textKey = !ctrl && !alt && !event._nonTextKeyCode.test(keyCode);
        if (textKey && selectionNode.nodeType === 3 && util2.zeroWidthRegExp.test(selectionNode.textContent) && !(e.isComposing !== void 0 ? e.isComposing : event._IEisComposing)) {
          let so = range.startOffset, eo = range.endOffset;
          const frontZeroWidthCnt = (selectionNode.textContent.substring(0, eo).match(event._frontZeroWidthReg) || "").length;
          so = range.startOffset - frontZeroWidthCnt;
          eo = range.endOffset - frontZeroWidthCnt;
          selectionNode.textContent = selectionNode.textContent.replace(util2.zeroWidthRegExp, "");
          core.setRange(selectionNode, so < 0 ? 0 : so, selectionNode, eo < 0 ? 0 : eo);
        }
        core._charCount("");
        if (typeof functions.onKeyUp === "function" && functions.onKeyUp(e, core) === false) return;
        if (!ctrl && !alt && !event._historyIgnoreKeyCode.test(keyCode)) {
          core.history.push(true);
        }
      },
      onScroll_wysiwyg: function(e) {
        core.controllersOff();
        if (core._isBalloon) event._hideToolbar();
        if (typeof functions.onScroll === "function") functions.onScroll(e, core);
      },
      onFocus_wysiwyg: function(e) {
        if (core._antiBlur) return;
        core.hasFocus = true;
        _w.setTimeout(event._applyTagEffects);
        if (core._isInline) event._showToolbarInline();
        if (typeof functions.onFocus === "function") functions.onFocus(e, core);
      },
      onBlur_wysiwyg: function(e) {
        if (core._antiBlur || core._variable.isCodeView) return;
        core.hasFocus = false;
        core.effectNode = null;
        core.controllersOff();
        if (core._isInline || core._isBalloon) event._hideToolbar();
        core._setKeyEffect([]);
        core._variable.currentNodes = [];
        core._variable.currentNodesMap = [];
        if (options2.showPathLabel) context.element.navigation.textContent = "";
        if (typeof functions.onBlur === "function") functions.onBlur(e, core, this);
      },
      onMouseDown_resizingBar: function(e) {
        e.stopPropagation();
        core.submenuOff();
        core.controllersOff();
        core._variable.resizeClientY = e.clientY;
        context.element.resizeBackground.style.display = "block";
        function closureFunc() {
          context.element.resizeBackground.style.display = "none";
          _d.removeEventListener("mousemove", event._resize_editor);
          _d.removeEventListener("mouseup", closureFunc);
        }
        _d.addEventListener("mousemove", event._resize_editor);
        _d.addEventListener("mouseup", closureFunc);
      },
      _resize_editor: function(e) {
        const resizeInterval = context.element.editorArea.offsetHeight + (e.clientY - core._variable.resizeClientY);
        const h = resizeInterval < core._variable.minResizingSize ? core._variable.minResizingSize : resizeInterval;
        context.element.wysiwygFrame.style.height = context.element.code.style.height = h + "px";
        core._variable.resizeClientY = e.clientY;
        if (!util2.isResizeObserverSupported) core.__callResizeFunction(h, null);
      },
      onResize_window: function() {
        if (!util2.isResizeObserverSupported) core.resetResponsiveToolbar();
        const toolbar = context.element.toolbar;
        const isToolbarHidden = toolbar.style.display === "none" || core._isInline && !core._inlineToolbarAttr.isShow;
        if (toolbar.offsetWidth === 0 && !isToolbarHidden) return;
        if (context.fileBrowser && context.fileBrowser.area.style.display === "block") {
          context.fileBrowser.body.style.maxHeight = _w.innerHeight - context.fileBrowser.header.offsetHeight - 50 + "px";
        }
        if (core.submenuActiveButton && core.submenu) {
          core._setMenuPosition(core.submenuActiveButton, core.submenu);
        }
        if (core._variable.isFullScreen) {
          core._variable.innerHeight_fullScreen += _w.innerHeight - toolbar.offsetHeight - core._variable.innerHeight_fullScreen;
          context.element.editorArea.style.height = core._variable.innerHeight_fullScreen + "px";
          return;
        }
        if (core._variable.isCodeView && core._isInline) {
          event._showToolbarInline();
          return;
        }
        core._iframeAutoHeight();
        if (core._sticky) {
          toolbar.style.width = context.element.topArea.offsetWidth - 2 + "px";
          event.onScroll_window();
        }
      },
      onScroll_window: function() {
        if (core._variable.isFullScreen || context.element.toolbar.offsetWidth === 0 || options2.stickyToolbar < 0) return;
        const element = context.element;
        const editorHeight = element.editorArea.offsetHeight;
        const y = (this.scrollY || _d.documentElement.scrollTop) + options2.stickyToolbar;
        const editorTop = event._getEditorOffsets(options2.toolbarContainer).top - (core._isInline ? element.toolbar.offsetHeight : 0);
        const inlineOffset = core._isInline && y - editorTop > 0 ? y - editorTop - context.element.toolbar.offsetHeight : 0;
        if (y < editorTop) {
          event._offStickyToolbar();
        } else if (y + core._variable.minResizingSize >= editorHeight + editorTop) {
          if (!core._sticky) event._onStickyToolbar(inlineOffset);
          element.toolbar.style.top = inlineOffset + editorHeight + editorTop + options2.stickyToolbar - y - core._variable.minResizingSize + "px";
        } else if (y >= editorTop) {
          event._onStickyToolbar(inlineOffset);
        }
      },
      _getEditorOffsets: function(container) {
        let offsetEl = container || context.element.topArea;
        let t = 0, l = 0, s = 0;
        while (offsetEl) {
          t += offsetEl.offsetTop;
          l += offsetEl.offsetLeft;
          s += offsetEl.scrollTop;
          offsetEl = offsetEl.offsetParent;
        }
        return {
          top: t,
          left: l,
          scroll: s
        };
      },
      _getPageBottomSpace: function() {
        return _d.documentElement.scrollHeight - (event._getEditorOffsets(null).top + context.element.topArea.offsetHeight);
      },
      _onStickyToolbar: function(inlineOffset) {
        const element = context.element;
        if (!core._isInline && !options2.toolbarContainer) {
          element._stickyDummy.style.height = element.toolbar.offsetHeight + "px";
          element._stickyDummy.style.display = "block";
        }
        element.toolbar.style.top = options2.stickyToolbar + inlineOffset + "px";
        element.toolbar.style.width = core._isInline ? core._inlineToolbarAttr.width : element.toolbar.offsetWidth + "px";
        util2.addClass(element.toolbar, "se-toolbar-sticky");
        core._sticky = true;
      },
      _offStickyToolbar: function() {
        const element = context.element;
        element._stickyDummy.style.display = "none";
        element.toolbar.style.top = core._isInline ? core._inlineToolbarAttr.top : "";
        element.toolbar.style.width = core._isInline ? core._inlineToolbarAttr.width : "";
        element.editorArea.style.marginTop = "";
        util2.removeClass(element.toolbar, "se-toolbar-sticky");
        core._sticky = false;
      },
      _codeViewAutoHeight: function() {
        if (core._variable.isFullScreen) return;
        context.element.code.style.height = context.element.code.scrollHeight + "px";
      },
      // FireFox - table delete, Chrome - image, video, audio
      _hardDelete: function() {
        const range = core.getRange();
        const sc = range.startContainer;
        const ec = range.endContainer;
        const sCell = util2.getRangeFormatElement(sc);
        const eCell = util2.getRangeFormatElement(ec);
        const sIsCell = util2.isCell(sCell);
        const eIsCell = util2.isCell(eCell);
        const ancestor = range.commonAncestorContainer;
        if ((sIsCell && !sCell.previousElementSibling && !sCell.parentElement.previousElementSibling || eIsCell && !eCell.nextElementSibling && !eCell.parentElement.nextElementSibling) && sCell !== eCell) {
          if (!sIsCell) {
            util2.removeItem(util2.getParentElement(eCell, function(current) {
              return ancestor === current.parentNode;
            }));
          } else if (!eIsCell) {
            util2.removeItem(util2.getParentElement(sCell, function(current) {
              return ancestor === current.parentNode;
            }));
          } else {
            util2.removeItem(util2.getParentElement(sCell, function(current) {
              return ancestor === current.parentNode;
            }));
            core.nativeFocus();
            return true;
          }
        }
        const sComp = sc.nodeType === 1 ? util2.getParentElement(sc, ".se-component") : null;
        const eComp = ec.nodeType === 1 ? util2.getParentElement(ec, ".se-component") : null;
        if (sComp) util2.removeItem(sComp);
        if (eComp) util2.removeItem(eComp);
        return false;
      },
      onPaste_wysiwyg: function(e) {
        const clipboardData = util2.isIE ? _w.clipboardData : e.clipboardData;
        if (!clipboardData) return true;
        return event._dataTransferAction("paste", e, clipboardData);
      },
      _setClipboardComponent: function(e, info, clipboardData) {
        e.preventDefault();
        e.stopPropagation();
        clipboardData.setData("text/html", info.component.outerHTML);
      },
      onCopy_wysiwyg: function(e) {
        const clipboardData = util2.isIE ? _w.clipboardData : e.clipboardData;
        if (typeof functions.onCopy === "function" && functions.onCopy(e, clipboardData, core) === false) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        const info = core.currentFileComponentInfo;
        if (info && !util2.isIE) {
          event._setClipboardComponent(e, info, clipboardData);
          util2.addClass(info.component, "se-component-copy");
          _w.setTimeout(function() {
            util2.removeClass(info.component, "se-component-copy");
          }, 150);
        }
      },
      onSave_wysiwyg: function(content) {
        if (typeof functions.onSave === "function") {
          functions.onSave(content, core);
          return;
        }
      },
      onCut_wysiwyg: function(e) {
        const clipboardData = util2.isIE ? _w.clipboardData : e.clipboardData;
        if (typeof functions.onCut === "function" && functions.onCut(e, clipboardData, core) === false) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        const info = core.currentFileComponentInfo;
        if (info && !util2.isIE) {
          event._setClipboardComponent(e, info, clipboardData);
          util2.removeItem(info.component);
          core.controllersOff();
        }
        _w.setTimeout(function() {
          core.history.push(false);
        });
      },
      onDrop_wysiwyg: function(e) {
        if (core.isReadOnly || util2.isIE) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        const dataTransfer = e.dataTransfer;
        if (!dataTransfer) return true;
        event._setDropLocationSelection(e);
        core.removeNode();
        if (!document.body.contains(core.currentControllerTarget)) core.controllersOff();
        return event._dataTransferAction("drop", e, dataTransfer);
      },
      _setDropLocationSelection: function(e) {
        const range = { startContainer: null, startOffset: null, endContainer: null, endOffset: null };
        let r = null;
        if (e.rangeParent) {
          range.startContainer = e.rangeParent;
          range.startOffset = e.rangeOffset;
          range.endContainer = e.rangeParent;
          range.endOffset = e.rangeOffset;
        } else if (core._wd.caretRangeFromPoint) {
          r = core._wd.caretRangeFromPoint(e.clientX, e.clientY);
        } else {
          r = core.getRange();
        }
        if (r) {
          range.startContainer = r.startContainer;
          range.startOffset = r.startOffset;
          range.endContainer = r.endContainer;
          range.endOffset = r.endOffset;
        }
        if (range.startContainer === range.endContainer) {
          const component4 = util2.getParentElement(range.startContainer, util2.isComponent);
          if (component4) {
            range.startContainer = component4;
            range.startOffset = 0;
            range.endContainer = component4;
            range.endOffset = 0;
          }
        }
        core.setRange(range.startContainer, range.startOffset, range.endContainer, range.endOffset);
      },
      _dataTransferAction: function(type, e, data2) {
        let plainText, cleanData;
        if (util2.isIE) {
          plainText = data2.getData("Text");
          const range = core.getRange();
          const tempDiv = util2.createElement("DIV");
          const tempRange = {
            sc: range.startContainer,
            so: range.startOffset,
            ec: range.endContainer,
            eo: range.endOffset
          };
          tempDiv.setAttribute("contenteditable", true);
          tempDiv.style.cssText = "position:absolute; top:0; left:0; width:1px; height:1px; overflow:hidden;";
          context.element.relative.appendChild(tempDiv);
          tempDiv.focus();
          _w.setTimeout(function() {
            cleanData = tempDiv.innerHTML;
            util2.removeItem(tempDiv);
            core.setRange(tempRange.sc, tempRange.so, tempRange.ec, tempRange.eo);
            event._setClipboardData(type, e, plainText, cleanData, data2);
          });
          return true;
        } else {
          plainText = data2.getData("text/plain");
          cleanData = data2.getData("text/html");
          if (event._setClipboardData(type, e, plainText, cleanData, data2) === false) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        }
      },
      _setClipboardData: function(type, e, plainText, cleanData, data2) {
        const MSData = /class=["']*Mso(Normal|List)/i.test(cleanData) || /content=["']*Word.Document/i.test(cleanData) || /content=["']*OneNote.File/i.test(cleanData) || /content=["']*Excel.Sheet/i.test(cleanData);
        const onlyText = !cleanData;
        if (!onlyText) {
          cleanData = cleanData.replace(/^<html>\r?\n?<body>\r?\n?\x3C!--StartFragment--\>|\x3C!--EndFragment-->\r?\n?<\/body\>\r?\n?<\/html>$/g, "");
          if (MSData) {
            cleanData = cleanData.replace(/\n/g, " ");
            plainText = plainText.replace(/\n/g, " ");
          }
          cleanData = core.cleanHTML(cleanData, core.pasteTagsWhitelistRegExp, core.pasteTagsBlacklistRegExp);
        } else {
          cleanData = util2._HTMLConvertor(plainText).replace(/\n/g, "<br>");
        }
        const maxCharCount = core._charCount(core._charTypeHTML ? cleanData : plainText);
        if (type === "paste" && typeof functions.onPaste === "function") {
          const value = functions.onPaste(e, cleanData, maxCharCount, core);
          if (value === false) {
            return false;
          } else if (typeof value === "string") {
            if (!value) return false;
            cleanData = value;
          }
        }
        if (type === "drop" && typeof functions.onDrop === "function") {
          const value = functions.onDrop(e, cleanData, maxCharCount, core);
          if (value === false) {
            return false;
          } else if (typeof value === "string") {
            if (!value) return false;
            cleanData = value;
          }
        }
        const files = data2.files;
        if (files.length > 0 && !MSData) {
          if (/^image/.test(files[0].type) && core.plugins.image) {
            functions.insertImage(files);
          }
          return false;
        }
        if (!maxCharCount) {
          return false;
        }
        if (cleanData) {
          functions.insertHTML(cleanData, true, false);
          return false;
        }
      },
      onMouseMove_wysiwyg: function(e) {
        if (core.isDisabled || core.isReadOnly) return false;
        const component4 = util2.getParentElement(e.target, util2.isComponent);
        const lineBreakerStyle = core._lineBreaker.style;
        if (component4 && !core.currentControllerName) {
          const ctxEl = context.element;
          let scrollTop = 0;
          let el = ctxEl.wysiwyg;
          do {
            scrollTop += el.scrollTop;
            el = el.parentElement;
          } while (el && !/^(BODY|HTML)$/i.test(el.nodeName));
          const wScroll = ctxEl.wysiwyg.scrollTop;
          const offsets = event._getEditorOffsets(null);
          const componentTop = util2.getOffset(component4, ctxEl.wysiwygFrame).top + wScroll;
          const y = e.pageY + scrollTop + (options2.iframe && !options2.toolbarContainer ? ctxEl.toolbar.offsetHeight : 0);
          const c = componentTop + (options2.iframe ? scrollTop : offsets.top);
          const isList = util2.isListCell(component4.parentNode);
          let dir = "", top = "";
          if ((isList ? !component4.previousSibling : !util2.isFormatElement(component4.previousElementSibling)) && y < c + 20) {
            top = componentTop;
            dir = "t";
          } else if ((isList ? !component4.nextSibling : !util2.isFormatElement(component4.nextElementSibling)) && y > c + component4.offsetHeight - 20) {
            top = componentTop + component4.offsetHeight;
            dir = "b";
          } else {
            lineBreakerStyle.display = "none";
            return;
          }
          core._variable._lineBreakComp = component4;
          core._variable._lineBreakDir = dir;
          lineBreakerStyle.top = top - wScroll + "px";
          core._lineBreakerButton.style.left = util2.getOffset(component4).left + component4.offsetWidth / 2 - 15 + "px";
          lineBreakerStyle.display = "block";
        } else if (lineBreakerStyle.display !== "none") {
          lineBreakerStyle.display = "none";
        }
      },
      _enterPrevent(e) {
        e.preventDefault();
        if (!util2.isMobile) return;
        core.__focusTemp.focus();
      },
      _onMouseDown_lineBreak: function(e) {
        e.preventDefault();
      },
      _onLineBreak: function(e) {
        e.preventDefault();
        const component4 = core._variable._lineBreakComp;
        const dir = !this ? core._variable._lineBreakDir : this;
        const isList = util2.isListCell(component4.parentNode);
        const format = util2.createElement(isList ? "BR" : util2.isCell(component4.parentNode) ? "DIV" : options2.defaultTag);
        if (!isList) format.innerHTML = "<br>";
        if (core._charTypeHTML && !core.checkCharCount(format.outerHTML, "byte-html")) return;
        component4.parentNode.insertBefore(format, dir === "t" ? component4 : component4.nextSibling);
        core._lineBreaker.style.display = "none";
        core._variable._lineBreakComp = null;
        const focusEl = isList ? format : format.firstChild;
        core.setRange(focusEl, 1, focusEl, 1);
        core.history.push(false);
      },
      _resizeObserver: null,
      _toolbarObserver: null,
      _addEvent: function() {
        const eventWysiwyg = options2.iframe ? core._ww : context.element.wysiwyg;
        if (util2.isResizeObserverSupported) {
          this._resizeObserver = new _w.ResizeObserver(function(entries) {
            core.__callResizeFunction(-1, entries[0]);
          });
        }
        context.element.toolbar.addEventListener("mousedown", event._buttonsEventHandler, false);
        context.element._menuTray.addEventListener("mousedown", event._buttonsEventHandler, false);
        context.element.toolbar.addEventListener("click", event.onClick_toolbar, false);
        eventWysiwyg.addEventListener("mousedown", event.onMouseDown_wysiwyg, false);
        eventWysiwyg.addEventListener("click", event.onClick_wysiwyg, false);
        eventWysiwyg.addEventListener(util2.isIE ? "textinput" : "input", event.onInput_wysiwyg, false);
        eventWysiwyg.addEventListener("keydown", event.onKeyDown_wysiwyg, false);
        eventWysiwyg.addEventListener("keyup", event.onKeyUp_wysiwyg, false);
        eventWysiwyg.addEventListener("paste", event.onPaste_wysiwyg, false);
        eventWysiwyg.addEventListener("copy", event.onCopy_wysiwyg, false);
        eventWysiwyg.addEventListener("cut", event.onCut_wysiwyg, false);
        eventWysiwyg.addEventListener("drop", event.onDrop_wysiwyg, false);
        eventWysiwyg.addEventListener("scroll", event.onScroll_wysiwyg, false);
        eventWysiwyg.addEventListener("focus", event.onFocus_wysiwyg, false);
        eventWysiwyg.addEventListener("blur", event.onBlur_wysiwyg, false);
        event._lineBreakerBind = { a: event._onLineBreak.bind(""), t: event._onLineBreak.bind("t"), b: event._onLineBreak.bind("b") };
        eventWysiwyg.addEventListener("mousemove", event.onMouseMove_wysiwyg, false);
        core._lineBreakerButton.addEventListener("mousedown", event._onMouseDown_lineBreak, false);
        core._lineBreakerButton.addEventListener("click", event._lineBreakerBind.a, false);
        context.element.lineBreaker_t.addEventListener("mousedown", event._lineBreakerBind.t, false);
        context.element.lineBreaker_b.addEventListener("mousedown", event._lineBreakerBind.b, false);
        eventWysiwyg.addEventListener("touchstart", event.onMouseDown_wysiwyg, { passive: true, useCapture: false });
        eventWysiwyg.addEventListener("touchend", event.onClick_wysiwyg, { passive: true, useCapture: false });
        if (options2.height === "auto" && !options2.codeMirrorEditor) {
          context.element.code.addEventListener("keydown", event._codeViewAutoHeight, false);
          context.element.code.addEventListener("keyup", event._codeViewAutoHeight, false);
          context.element.code.addEventListener("paste", event._codeViewAutoHeight, false);
        }
        if (context.element.resizingBar) {
          if (/\d+/.test(options2.height) && options2.resizeEnable) {
            context.element.resizingBar.addEventListener("mousedown", event.onMouseDown_resizingBar, false);
          } else {
            util2.addClass(context.element.resizingBar, "se-resizing-none");
          }
        }
        event._setResponsiveToolbar();
        if (util2.isResizeObserverSupported) this._toolbarObserver = new _w.ResizeObserver(core.resetResponsiveToolbar);
        _w.addEventListener("resize", event.onResize_window, false);
        if (options2.stickyToolbar > -1) {
          _w.addEventListener("scroll", event.onScroll_window, false);
        }
      },
      _removeEvent: function() {
        const eventWysiwyg = options2.iframe ? core._ww : context.element.wysiwyg;
        context.element.toolbar.removeEventListener("mousedown", event._buttonsEventHandler);
        context.element._menuTray.removeEventListener("mousedown", event._buttonsEventHandler);
        context.element.toolbar.removeEventListener("click", event.onClick_toolbar);
        eventWysiwyg.removeEventListener("mousedown", event.onMouseDown_wysiwyg);
        eventWysiwyg.removeEventListener("click", event.onClick_wysiwyg);
        eventWysiwyg.removeEventListener(util2.isIE ? "textinput" : "input", event.onInput_wysiwyg);
        eventWysiwyg.removeEventListener("keydown", event.onKeyDown_wysiwyg);
        eventWysiwyg.removeEventListener("keyup", event.onKeyUp_wysiwyg);
        eventWysiwyg.removeEventListener("paste", event.onPaste_wysiwyg);
        eventWysiwyg.removeEventListener("copy", event.onCopy_wysiwyg);
        eventWysiwyg.removeEventListener("cut", event.onCut_wysiwyg);
        eventWysiwyg.removeEventListener("drop", event.onDrop_wysiwyg);
        eventWysiwyg.removeEventListener("scroll", event.onScroll_wysiwyg);
        eventWysiwyg.removeEventListener("mousemove", event.onMouseMove_wysiwyg);
        core._lineBreakerButton.removeEventListener("mousedown", event._onMouseDown_lineBreak);
        core._lineBreakerButton.removeEventListener("click", event._lineBreakerBind.a);
        context.element.lineBreaker_t.removeEventListener("mousedown", event._lineBreakerBind.t);
        context.element.lineBreaker_b.removeEventListener("mousedown", event._lineBreakerBind.b);
        event._lineBreakerBind = null;
        eventWysiwyg.removeEventListener("touchstart", event.onMouseDown_wysiwyg, { passive: true, useCapture: false });
        eventWysiwyg.removeEventListener("touchend", event.onClick_wysiwyg, { passive: true, useCapture: false });
        eventWysiwyg.removeEventListener("focus", event.onFocus_wysiwyg);
        eventWysiwyg.removeEventListener("blur", event.onBlur_wysiwyg);
        context.element.code.removeEventListener("keydown", event._codeViewAutoHeight);
        context.element.code.removeEventListener("keyup", event._codeViewAutoHeight);
        context.element.code.removeEventListener("paste", event._codeViewAutoHeight);
        if (context.element.resizingBar) {
          context.element.resizingBar.removeEventListener("mousedown", event.onMouseDown_resizingBar);
        }
        if (event._resizeObserver) {
          event._resizeObserver.unobserve(context.element.wysiwygFrame);
          event._resizeObserver = null;
        }
        if (event._toolbarObserver) {
          event._toolbarObserver.unobserve(context.element._toolbarShadow);
          event._toolbarObserver = null;
        }
        _w.removeEventListener("resize", event.onResize_window);
        _w.removeEventListener("scroll", event.onScroll_window);
      },
      _setResponsiveToolbar: function() {
        if (_responsiveButtons.length === 0) {
          _responsiveButtons = null;
          return;
        }
        event._responsiveCurrentSize = "default";
        const sizeArray = event._responsiveButtonSize = [];
        const buttonsObj = event._responsiveButtons = { default: _responsiveButtons[0] };
        for (let i = 1, len = _responsiveButtons.length, size, buttonGroup; i < len; i++) {
          buttonGroup = _responsiveButtons[i];
          size = buttonGroup[0] * 1;
          sizeArray.push(size);
          buttonsObj[size] = buttonGroup[1];
        }
        sizeArray.sort(function(a, b) {
          return a - b;
        }).unshift("default");
      }
    };
    const functions = {
      /**
       * @description Core, Util object
       */
      core,
      util: util2,
      /**
       * @description Event functions
       * @param {Object} e Event Object
       * @param {Object} core Core object
       */
      onload: null,
      onScroll: null,
      onMouseDown: null,
      onClick: null,
      onInput: null,
      onKeyDown: null,
      onKeyUp: null,
      onCopy: null,
      onCut: null,
      onFocus: null,
      /**
       * @description Event functions
       * @param {Object} e Event Object
       * @param {Object} core Core object
       * @param {String} contents Current contents
       */
      onBlur: null,
      /**
       * @description Event functions
       * @param {String} contents Current contents
       * @param {Object} core Core object
       */
      onChange: null,
      /**
       * @description Event functions
       * @param {String} contents Current contents
       * @param {Object} core Core object
       */
      onSave: null,
      /**
       * @description Event functions (drop, paste)
       * When false is returned, the default behavior is stopped.
       * If the string is returned, the cleanData value is modified to the return value.
       * @param {Object} e Event object.
       * @param {String} cleanData HTML string modified for editor format.
       * @param {Boolean} maxChartCount option (true if max character is exceeded)
       * @param {Object} core Core object
       * @returns {Boolean|String}
       */
      onDrop: null,
      onPaste: null,
      /**
       * @description Called just before the inline toolbar is positioned and displayed on the screen.
       * @param {Element} toolbar Toolbar Element
       * @param {Object} context The editor's context object (editor.getContext())
       * @param {Object} core Core object
       */
      showInline: null,
      /**
       * @description Called just after the controller is positioned and displayed on the screen.
       * controller - editing elements displayed on the screen [image resizing, table editor, link editor..]]
       * @param {String} name The name of the plugin that called the controller
       * @param {Array} controllers Array of Controller elements
       * @param {Object} core Core object
       */
      showController: null,
      /**
       * @description An event when toggling between code view and wysiwyg view.
       * @param {Boolean} isCodeView Whether the current code view mode
       * @param {Object} core Core object
       */
      toggleCodeView: null,
      /**
       * @description An event when toggling full screen.
       * @param {Boolean} isFullScreen Whether the current full screen mode
       * @param {Object} core Core object
       */
      toggleFullScreen: null,
      /**
       * @description It replaces the default callback function of the image upload
       * @param {Object} response Response object
       * @param {Object} info Input information
       * - linkValue: Link url value
       * - linkNewWindow: Open in new window Check Value
       * - inputWidth: Value of width input
       * - inputHeight: Value of height input
       * - align: Align Check Value
       * - isUpdate: Update image if true, create image if false
       * - element: If isUpdate is true, the currently selected image.
       * @param {Object} core Core object
       */
      imageUploadHandler: null,
      /**
       * @description It replaces the default callback function of the video upload
       * @param xmlHttp xmlHttpRequest object
       * @param info Input information
       * - inputWidth: Value of width input
       * - inputHeight: Value of height input
       * - align: Align Check Value
       * - isUpdate: Update video if true, create video if false
       * - element: If isUpdate is true, the currently selected video.
       * @param core Core object
       */
      videoUploadHandler: null,
      /**
       * @description It replaces the default callback function of the audio upload
       * @param xmlHttp xmlHttpRequest object
       * @param info Input information
       * - isUpdate: Update audio if true, create audio if false
       * - element: If isUpdate is true, the currently selected audio.
       * @param core Core object
       */
      audioUploadHandler: null,
      /**
       * @description Called before the image is uploaded
       * If true is returned, the internal upload process runs normally.
       * If false is returned, no image upload is performed.
       * If new fileList are returned,  replaced the previous fileList
       * If undefined is returned, it waits until "uploadHandler" is executed.
       * @param {Array} files Files array
       * @param {Object} info info: {
       * - linkValue: Link url value
       * - linkNewWindow: Open in new window Check Value
       * - inputWidth: Value of width input
       * - inputHeight: Value of height input
       * - align: Align Check Value
       * - isUpdate: Update image if true, create image if false
       * - element: If isUpdate is true, the currently selected image.
       * }
       * @param {Object} core Core object
       * @param {Function} uploadHandler If undefined is returned, it waits until "uploadHandler" is executed.
       *                "uploadHandler" is an upload function with "core" and "info" bound.
       *                [upload files] : uploadHandler(files or [new File(...),])
       *                [error]        : uploadHandler("Error message")
       *                [Just finish]  : uploadHandler()
       *                [directly register] : uploadHandler(response) // Same format as "imageUploadUrl" response
       *                                   ex) {
       *                                      // "errorMessage": "insert error message",
       *                                      "result": [ { "url": "...", "name": "...", "size": "999" }, ]
       *                                   }
       * @returns {Boolean|Array|undefined}
       */
      onImageUploadBefore: null,
      /**
       * @description Called before the video is uploaded
       * If true is returned, the internal upload process runs normally.
       * If false is returned, no video(iframe, video) upload is performed.
       * If new fileList are returned,  replaced the previous fileList
       * If undefined is returned, it waits until "uploadHandler" is executed.
       * @param {Array} files Files array
       * @param {Object} info info: {
       * - inputWidth: Value of width input
       * - inputHeight: Value of height input
       * - align: Align Check Value
       * - isUpdate: Update video if true, create video if false
       * - element: If isUpdate is true, the currently selected video.
       * }
       * @param {Object} core Core object
       * @param {Function} uploadHandler If undefined is returned, it waits until "uploadHandler" is executed.
       *                "uploadHandler" is an upload function with "core" and "info" bound.
       *                [upload files] : uploadHandler(files or [new File(...),])
       *                [error]        : uploadHandler("Error message")
       *                [Just finish]  : uploadHandler()
       *                [directly register] : uploadHandler(response) // Same format as "videoUploadUrl" response
       *                                   ex) {
       *                                      // "errorMessage": "insert error message",
       *                                      "result": [ { "url": "...", "name": "...", "size": "999" }, ]
       *                                   }
       * @returns {Boolean|Array|undefined}
       */
      onVideoUploadBefore: null,
      /**
       * @description Called before the audio is uploaded
       * If true is returned, the internal upload process runs normally.
       * If false is returned, no audio upload is performed.
       * If new fileList are returned,  replaced the previous fileList
       * If undefined is returned, it waits until "uploadHandler" is executed.
       * @param {Array} files Files array
       * @param {Object} info info: {
       * - isUpdate: Update audio if true, create audio if false
       * - element: If isUpdate is true, the currently selected audio.
       * }
       * @param {Object} core Core object
       * @param {Function} uploadHandler If undefined is returned, it waits until "uploadHandler" is executed.
       *                "uploadHandler" is an upload function with "core" and "info" bound.
       *                [upload files] : uploadHandler(files or [new File(...),])
       *                [error]        : uploadHandler("Error message")
       *                [Just finish]  : uploadHandler()
       *                [directly register] : uploadHandler(response) // Same format as "audioUploadUrl" response
       *                                   ex) {
       *                                      // "errorMessage": "insert error message",
       *                                      "result": [ { "url": "...", "name": "...", "size": "999" }, ]
       *                                   }
       * @returns {Boolean|Array|undefined}
       */
      onAudioUploadBefore: null,
      /**
       * @description Called when the image is uploaded, updated, deleted
       * @param {Element} targetElement Target element
       * @param {Number} index Uploaded index
       * @param {String} state Upload status ('create', 'update', 'delete')
       * @param {Object} info Image info object
       * - index: data index
       * - name: file name
       * - size: file size
       * - select: select function
       * - delete: delete function
       * - element: target element
       * - src: src attribute of tag
       * @param {Number} remainingFilesCount Count of remaining files to upload (0 when added as a url)
       * @param {Object} core Core object
       */
      onImageUpload: null,
      /**
      * @description Called when the video(iframe, video) is is uploaded, updated, deleted
      * -- arguments is same "onImageUpload" --
      */
      onVideoUpload: null,
      /**
      * @description Called when the audio is is uploaded, updated, deleted
      * -- arguments is same "onImageUpload" --
      */
      onAudioUpload: null,
      /**
       * @description Called when the image is upload failed
       * @param {String} errorMessage Error message
       * @param {Object} result Response Object
       * @param {Object} core Core object
       * @returns {Boolean}
       */
      onImageUploadError: null,
      /**
       * @description Called when the video(iframe, video) upload failed
       * -- arguments is same "onImageUploadError" --
       */
      onVideoUploadError: null,
      /**
       * @description Called when the audio upload failed
       * -- arguments is same "onImageUploadError" --
       */
      onAudioUploadError: null,
      /**
       * @description Called when the editor is resized using the bottom bar
       */
      onResizeEditor: null,
      /**
       * @description Called after the "setToolbarButtons" invocation.
       * Can be used to tweak buttons properties (useful for custom buttons)
       * @param {Array} buttonList Button list 
       * @param {Object} core Core object
       */
      onSetToolbarButtons: null,
      /**
       * @description Reset the buttons on the toolbar. (Editor is not reloaded)
       * You cannot set a new plugin for the button.
       * @param {Array} buttonList Button list 
       */
      setToolbarButtons: function(buttonList) {
        core.submenuOff();
        core.containerOff();
        core.moreLayerOff();
        const newToolbar = constructor_default._createToolBar(_d, buttonList, core.plugins, options2);
        _responsiveButtons = newToolbar.responsiveButtons;
        event._setResponsiveToolbar();
        context.element.toolbar.replaceChild(newToolbar._buttonTray, context.element._buttonTray);
        const newContext = context_default(context.element.originElement, core._getConstructed(context.element), options2);
        context.element = newContext.element;
        context.tool = newContext.tool;
        if (options2.iframe) context.element.wysiwyg = core._wd.body;
        core._recoverButtonStates();
        core._cachingButtons();
        core.history._resetCachingButton();
        core.effectNode = null;
        if (core.hasFocus) event._applyTagEffects();
        if (core.isReadOnly) util2.setDisabledButtons(true, core.resizingDisabledButtons);
        if (typeof functions.onSetToolbarButtons === "function") functions.onSetToolbarButtons(newToolbar._buttonTray.querySelectorAll("button"), core);
      },
      /**
       * @description Add or reset option property (Editor is reloaded)
       * @param {Object} _options Options
       */
      setOptions: function(_options) {
        event._removeEvent();
        core._resetComponents();
        util2.removeClass(core._styleCommandMap.showBlocks, "active");
        util2.removeClass(core._styleCommandMap.codeView, "active");
        core._variable.isCodeView = false;
        core._iframeAuto = null;
        core.plugins = _options.plugins || core.plugins;
        const mergeOptions = [options2, _options].reduce(function(init, option) {
          for (let key in option) {
            if (!util2.hasOwn(option, key)) continue;
            if (key === "plugins" && option[key] && init[key]) {
              let i = init[key], o = option[key];
              i = i.length ? i : _w.Object.keys(i).map(function(name2) {
                return i[name2];
              });
              o = o.length ? o : _w.Object.keys(o).map(function(name2) {
                return o[name2];
              });
              init[key] = o.filter(function(val) {
                return i.indexOf(val) === -1;
              }).concat(i);
            } else {
              init[key] = option[key];
            }
          }
          return init;
        }, {});
        const el = context.element;
        const _initHTML = el.wysiwyg.innerHTML;
        const cons = constructor_default._setOptions(mergeOptions, context, options2);
        if (cons.callButtons) {
          pluginCallButtons = cons.callButtons;
          core.initPlugins = {};
        }
        if (cons.plugins) {
          core.plugins = plugins = cons.plugins;
        }
        if (el._menuTray.children.length === 0) this._menuTray = {};
        _responsiveButtons = cons.toolbar.responsiveButtons;
        core.options = options2 = mergeOptions;
        core.lang = lang = options2.lang;
        if (options2.iframe) {
          el.wysiwygFrame.addEventListener("load", function() {
            util2._setIframeDocument(this, options2);
            core._setOptionsInit(el, _initHTML);
          });
        }
        el.editorArea.appendChild(el.wysiwygFrame);
        if (!options2.iframe) {
          core._setOptionsInit(el, _initHTML);
        }
      },
      /**
       * @description Set "options.defaultStyle" style.
       * Define the style of the edit area
       * It can also be defined with the "setOptions" method, but the "setDefaultStyle" method does not render the editor again.
       * @param {String} style Style string
       */
      setDefaultStyle: function(style) {
        const newStyles = options2._editorStyles = util2._setDefaultOptionStyle(options2, style);
        const el = context.element;
        el.topArea.style.cssText = newStyles.top;
        el.code.style.cssText = options2._editorStyles.frame;
        el.code.style.display = "none";
        if (options2.height === "auto") {
          el.code.style.overflow = "hidden";
        } else {
          el.code.style.overflow = "";
        }
        if (!options2.iframe) {
          el.wysiwygFrame.style.cssText = newStyles.frame + newStyles.editor;
        } else {
          el.wysiwygFrame.style.cssText = newStyles.frame;
          el.wysiwyg.style.cssText = newStyles.editor;
        }
      },
      /**
       * @description Open a notice area
       * @param {String} message Notice message
       */
      noticeOpen: function(message) {
        core.notice.open.call(core, message);
      },
      /**
       * @description Close a notice area
       */
      noticeClose: function() {
        core.notice.close.call(core);
      },
      /**
       * @description Copying the contents of the editor to the original textarea and execute onSave callback
       * * not working during enabled codeView mode
       */
      save: function() {
        const contents = core.getContents(false);
        context.element.originElement.value = contents;
        event.onSave_wysiwyg(contents, core);
      },
      /**
       * @description Gets the suneditor's context object. Contains settings, plugins, and cached element objects
       * @returns {Object}
       */
      getContext: function() {
        return context;
      },
      /**
       * @description Gets the contents of the suneditor
       * * not working during enabled codeView mode
       * @param {Boolean} onlyContents - Return only the contents of the body without headers when the "fullPage" option is true
       * @returns {String}
       */
      getContents: function(onlyContents) {
        return core.getContents(onlyContents);
      },
      /**
       * @description Gets only the text of the suneditor contents
       * * not working during enabled codeView mode
       * @returns {String}
       */
      getText: function() {
        return context.element.wysiwyg.textContent;
      },
      /**
       * @description Get the editor's number of characters or binary data size.
       * You can use the "charCounterType" option format.
       * @param {String|null} charCounterType options - charCounterType ('char', 'byte', 'byte-html')
       * If argument is no value, the currently set "charCounterType" option is used.
       * @returns {Number}
       */
      getCharCount: function(charCounterType) {
        charCounterType = typeof charCounterType === "string" ? charCounterType : options2.charCounterType;
        return core.getCharLength(core._charTypeHTML ? context.element.wysiwyg.innerHTML : context.element.wysiwyg.textContent, charCounterType);
      },
      /**
       * @description Gets uploaded images informations
       * - index: data index
       * - name: file name
       * - size: file size
       * - select: select function
       * - delete: delete function
       * - element: target element
       * - src: src attribute of tag
       * @returns {Array}
       */
      getImagesInfo: function() {
        return context.image ? context.image._infoList : [];
      },
      /**
       * @description Gets uploaded files(plugin using fileManager) information list.
       * image: [img], video: [video, iframe], audio: [audio]
       * When the argument value is 'image', it is the same function as "getImagesInfo".
       * - index: data index
       * - name: file name
       * - size: file size
       * - select: select function
       * - delete: delete function
       * - element: target element
       * - src: src attribute of tag
       * @param {String} pluginName Plugin name (image, video, audio)
       * @returns {Array}
       */
      getFilesInfo: function(pluginName) {
        return context[pluginName] ? context[pluginName]._infoList : [];
      },
      /**
       * @description Upload images using image plugin
       * @param {FileList} files FileList
       */
      insertImage: function(files) {
        if (!core.plugins.image || !files) return;
        if (!core.initPlugins.image) core.callPlugin("image", core.plugins.image.submitAction.bind(core, files), null);
        else core.plugins.image.submitAction.call(core, files);
        core.focus();
      },
      /**
       * @description Inserts an HTML element or HTML string or plain string at the current cursor position
       * @param {Element|String} html HTML Element or HTML string or plain string
       * @param {Boolean} notCleaningData If true, inserts the HTML string without refining it with core.cleanHTML.
       * @param {Boolean} checkCharCount If true, if "options.maxCharCount" is exceeded when "element" is added, null is returned without addition.
       * @param {Boolean} rangeSelection If true, range select the inserted node.
       */
      insertHTML: function(html2, notCleaningData, checkCharCount, rangeSelection) {
        if (!context.element.wysiwygFrame.contains(core.getSelection().focusNode)) core.focus();
        if (typeof html2 === "string") {
          if (!notCleaningData) html2 = core.cleanHTML(html2, null, null);
          try {
            if (util2.isListCell(util2.getFormatElement(core.getSelectionNode(), null))) {
              const dom2 = _d.createRange().createContextualFragment(html2);
              const domTree2 = dom2.childNodes;
              if (core._isFormatData(domTree2)) html2 = core._convertListCell(domTree2);
            }
            const dom = _d.createRange().createContextualFragment(html2);
            const domTree = dom.childNodes;
            if (checkCharCount) {
              const type = core._charTypeHTML ? "outerHTML" : "textContent";
              let checkHTML = "";
              for (let i = 0, len = domTree.length; i < len; i++) {
                checkHTML += domTree[i][type];
              }
              if (!core.checkCharCount(checkHTML, null)) return;
            }
            let c, a, t, prev, firstCon;
            while (c = domTree[0]) {
              if (prev && prev.nodeType === 3 && a && a.nodeType === 1 && util2.isBreak(c)) {
                prev = c;
                util2.removeItem(c);
                continue;
              }
              t = core.insertNode(c, a, false);
              a = t.container || t;
              if (!firstCon) firstCon = t;
              prev = c;
            }
            if (prev.nodeType === 3 && a.nodeType === 1) a = prev;
            const offset = a.nodeType === 3 ? t.endOffset || a.textContent.length : a.childNodes.length;
            if (rangeSelection) core.setRange(firstCon.container || firstCon, firstCon.startOffset || 0, a, offset);
            else core.setRange(a, offset, a, offset);
          } catch (error) {
            if (core.isDisabled || core.isReadOnly) return;
            console.warn("[SUNEDITOR.insertHTML.fail] " + error);
            core.execCommand("insertHTML", false, html2);
          }
        } else {
          if (util2.isComponent(html2)) {
            core.insertComponent(html2, false, checkCharCount, false);
          } else {
            let afterNode = null;
            if (util2.isFormatElement(html2) || util2.isMedia(html2)) {
              afterNode = util2.getFormatElement(core.getSelectionNode(), null);
            }
            core.insertNode(html2, afterNode, checkCharCount);
          }
        }
        core.effectNode = null;
        core.focus();
        core.history.push(false);
      },
      /**
       * @description Change the contents of the suneditor
       * @param {String|undefined} contents Contents to Input
       */
      setContents: function(contents) {
        core.setContents(contents);
      },
      /**
       * @description Add contents to the suneditor
       * @param {String} contents Contents to Input
       */
      appendContents: function(contents) {
        const convertValue = core.convertContentsForEditor(contents);
        if (!core._variable.isCodeView) {
          const temp = util2.createElement("DIV");
          temp.innerHTML = convertValue;
          const wysiwyg = context.element.wysiwyg;
          const children2 = temp.children;
          for (let i = 0, len = children2.length; i < len; i++) {
            if (children2[i]) {
              wysiwyg.appendChild(children2[i]);
            }
          }
        } else {
          core._setCodeView(core._getCodeView() + "\n" + core.convertHTMLForCodeView(convertValue, false));
        }
        core.history.push(false);
      },
      /**
       * @description Switch to or off "ReadOnly" mode.
       * @param {Boolean} value "readOnly" boolean value.
       */
      readOnly: function(value) {
        core.isReadOnly = value;
        util2.setDisabledButtons(!!value, core.resizingDisabledButtons);
        if (value) {
          core.controllersOff();
          if (core.submenuActiveButton && core.submenuActiveButton.disabled) core.submenuOff();
          if (core._moreLayerActiveButton && core._moreLayerActiveButton.disabled) core.moreLayerOff();
          if (core.containerActiveButton && core.containerActiveButton.disabled) core.containerOff();
          if (core.modalForm) core.plugins.dialog.close.call(core);
          context.element.code.setAttribute("readOnly", "true");
          util2.addClass(context.element.wysiwygFrame, "se-read-only");
        } else {
          context.element.code.removeAttribute("readOnly");
          util2.removeClass(context.element.wysiwygFrame, "se-read-only");
        }
        if (options2.codeMirrorEditor) options2.codeMirrorEditor.setOption("readOnly", !!value);
      },
      /**
       * @description Disable the suneditor
       */
      disable: function() {
        this.toolbar.disable();
        this.wysiwyg.disable();
      },
      /**
       * @description Provided for backward compatibility and will be removed in 3.0.0 version
       */
      disabled: function() {
        this.disable();
      },
      /**
       * @description Enable the suneditor
       */
      enable: function() {
        this.toolbar.enable();
        this.wysiwyg.enable();
      },
      /**
       * @description Provided for backward compatibility and will be removed in 3.0.0 version
       */
      enabled: function() {
        this.enable();
      },
      /**
       * @description Show the suneditor
       */
      show: function() {
        const topAreaStyle = context.element.topArea.style;
        if (topAreaStyle.display === "none") topAreaStyle.display = options2.display;
      },
      /**
       * @description Hide the suneditor
       */
      hide: function() {
        context.element.topArea.style.display = "none";
      },
      /**
       * @description Destroy the suneditor
       */
      destroy: function() {
        core.submenuOff();
        core.containerOff();
        core.controllersOff();
        if (core.notice) core.notice.close.call(core);
        if (core.modalForm) core.plugins.dialog.close.call(core);
        core.history._destroy();
        event._removeEvent();
        util2.removeItem(context.element.toolbar);
        util2.removeItem(context.element.topArea);
        for (let k in core.functions) {
          if (util2.hasOwn(core, k)) delete core.functions[k];
        }
        for (let k in core) {
          if (util2.hasOwn(core, k)) delete core[k];
        }
        for (let k in event) {
          if (util2.hasOwn(event, k)) delete event[k];
        }
        for (let k in context) {
          if (util2.hasOwn(context, k)) delete context[k];
        }
        for (let k in pluginCallButtons) {
          if (util2.hasOwn(pluginCallButtons, k)) delete pluginCallButtons[k];
        }
        for (let k in this) {
          if (util2.hasOwn(this, k)) delete this[k];
        }
      },
      /**
       * @description Toolbar methods
       */
      toolbar: {
        /**
         * @description Disable the toolbar
         */
        disable: function() {
          core.submenuOff();
          core.moreLayerOff();
          core.containerOff();
          context.tool.cover.style.display = "block";
        },
        /**
         * @description Provided for backward compatibility and will be removed in 3.0.0 version
         */
        disabled: function() {
          this.disable();
        },
        /**
         * @description Enable the toolbar
         */
        enable: function() {
          context.tool.cover.style.display = "none";
        },
        /**
         * @description Provided for backward compatibility and will be removed in 3.0.0 version
         */
        enabled: function() {
          this.enable();
        },
        /**
         * @description Show the toolbar
         */
        show: function() {
          if (core._isInline) {
            event._showToolbarInline();
          } else {
            context.element.toolbar.style.display = "";
            context.element._stickyDummy.style.display = "";
          }
          event.onResize_window();
        },
        /**
         * @description Hide the toolbar
         */
        hide: function() {
          if (core._isInline) {
            event._hideToolbar();
          } else {
            context.element.toolbar.style.display = "none";
            context.element._stickyDummy.style.display = "none";
          }
          event.onResize_window();
        }
      },
      /**
       * @description Wysiwyg methods
       */
      wysiwyg: {
        /**
         * @description Disable the wysiwyg area
         */
        disable: function() {
          core.controllersOff();
          if (core.modalForm) core.plugins.dialog.close.call(core);
          context.element.wysiwyg.setAttribute("contenteditable", false);
          core.isDisabled = true;
          if (options2.codeMirrorEditor) {
            options2.codeMirrorEditor.setOption("readOnly", true);
          } else {
            context.element.code.setAttribute("disabled", "disabled");
          }
        },
        /**
         * @description Enable the wysiwyg area
         */
        enable: function() {
          context.element.wysiwyg.setAttribute("contenteditable", true);
          core.isDisabled = false;
          if (options2.codeMirrorEditor) {
            options2.codeMirrorEditor.setOption("readOnly", false);
          } else {
            context.element.code.removeAttribute("disabled");
          }
        }
      }
    };
    core.functions = functions;
    core.options = options2;
    let contextEl = context.element;
    let originEl = contextEl.originElement;
    let topEl = contextEl.topArea;
    originEl.style.display = "none";
    topEl.style.display = "block";
    if (options2.iframe) {
      contextEl.wysiwygFrame.addEventListener("load", function() {
        util2._setIframeDocument(this, options2);
        core._editorInit(false, options2.value);
        options2.value = null;
      });
    }
    if (typeof originEl.nextElementSibling === "object") {
      originEl.parentNode.insertBefore(topEl, originEl.nextElementSibling);
    } else {
      originEl.parentNode.appendChild(topEl);
    }
    contextEl.editorArea.appendChild(contextEl.wysiwygFrame);
    contextEl = originEl = topEl = null;
    if (!options2.iframe) {
      core._editorInit(false, options2.value);
      options2.value = null;
    }
    return functions;
  }

  // ../../node_modules/suneditor/src/suneditor.js
  var suneditor_default = {
    /**
     * @description Returns the create function with preset options.
     * If the options overlap, the options of the 'create' function take precedence.
     * @param {Json} options Initialization options
     * @returns {Object}
     */
    init: function(init_options) {
      return {
        create: function(idOrElement, options2) {
          return this.create(idOrElement, options2, init_options);
        }.bind(this)
      };
    },
    /**
     * @description Create the suneditor
     * @param {String|Element} idOrElement textarea Id or textarea element
     * @param {JSON|Object} options user options
     * @returns {Object}
     */
    create: function(idOrElement, options2, _init_options) {
      util_default._propertiesInit();
      if (typeof options2 !== "object") options2 = {};
      if (_init_options) {
        options2 = [_init_options, options2].reduce(function(init, option) {
          for (let key in option) {
            if (!util_default.hasOwn(option, key)) continue;
            if (key === "plugins" && option[key] && init[key]) {
              let i = init[key], o = option[key];
              i = i.length ? i : Object.keys(i).map(function(name2) {
                return i[name2];
              });
              o = o.length ? o : Object.keys(o).map(function(name2) {
                return o[name2];
              });
              init[key] = o.filter(function(val) {
                return i.indexOf(val) === -1;
              }).concat(i);
            } else {
              init[key] = option[key];
            }
          }
          return init;
        }, {});
      }
      const element = typeof idOrElement === "string" ? document.getElementById(idOrElement) : idOrElement;
      if (!element) {
        if (typeof idOrElement === "string") {
          throw Error('[SUNEDITOR.create.fail] The element for that id was not found (ID:"' + idOrElement + '")');
        }
        throw Error("[SUNEDITOR.create.fail] suneditor requires textarea's element or id value");
      }
      const cons = constructor_default.init(element, options2);
      if (cons.constructed._top.id && document.getElementById(cons.constructed._top.id)) {
        throw Error('[SUNEDITOR.create.fail] The ID of the suneditor you are trying to create already exists (ID:"' + cons.constructed._top.id + '")');
      }
      return core_default(context_default(element, cons.constructed, cons.options), cons.pluginCallButtons, cons.plugins, cons.options.lang, options2, cons._responsiveButtons);
    }
  };

  // ../../node_modules/suneditor/src/plugins/command/blockquote.js
  var blockquote_default = {
    name: "blockquote",
    display: "command",
    add: function(core, targetElement) {
      const context = core.context;
      context.blockquote = {
        targetButton: targetElement,
        tag: core.util.createElement("BLOCKQUOTE")
      };
    },
    /**
     * @Override core
     */
    active: function(element) {
      if (!element) {
        this.util.removeClass(this.context.blockquote.targetButton, "active");
      } else if (/blockquote/i.test(element.nodeName)) {
        this.util.addClass(this.context.blockquote.targetButton, "active");
        return true;
      }
      return false;
    },
    /**
     * @Override core
     */
    action: function() {
      const currentBlockquote = this.util.getParentElement(this.getSelectionNode(), "blockquote");
      if (currentBlockquote) {
        this.detachRangeFormatElement(currentBlockquote, null, null, false, false);
      } else {
        this.applyRangeFormatElement(this.context.blockquote.tag.cloneNode(false));
      }
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/align.js
  var align_default = {
    name: "align",
    display: "submenu",
    add: function(core, targetElement) {
      const icons = core.icons;
      const context = core.context;
      context.align = {
        targetButton: targetElement,
        _itemMenu: null,
        _alignList: null,
        currentAlign: "",
        defaultDir: core.options.rtl ? "right" : "left",
        icons: {
          justify: icons.align_justify,
          left: icons.align_left,
          right: icons.align_right,
          center: icons.align_center
        }
      };
      let listDiv = this.setSubmenu(core);
      let listUl = context.align._itemMenu = listDiv.querySelector("ul");
      listUl.addEventListener("click", this.pickup.bind(core));
      context.align._alignList = listUl.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null, listUl = null;
    },
    setSubmenu: function(core) {
      const lang = core.lang;
      const icons = core.icons;
      const listDiv = core.util.createElement("DIV");
      const alignItems = core.options.alignItems;
      let html2 = "";
      for (let i = 0, item, text; i < alignItems.length; i++) {
        item = alignItems[i];
        text = lang.toolbar["align" + item.charAt(0).toUpperCase() + item.slice(1)];
        html2 += '<li><button type="button" class="se-btn-list se-btn-align" data-value="' + item + '" title="' + text + '" aria-label="' + text + '"><span class="se-list-icon">' + icons["align_" + item] + "</span>" + text + "</button></li>";
      }
      listDiv.className = "se-submenu se-list-layer se-list-align";
      listDiv.innerHTML = '<div class="se-list-inner"><ul class="se-list-basic">' + html2 + "</ul></div>";
      return listDiv;
    },
    /**
     * @Override core
     */
    active: function(element) {
      const alignContext = this.context.align;
      const targetButton = alignContext.targetButton;
      const target = targetButton.firstElementChild;
      if (!element) {
        this.util.changeElement(target, alignContext.icons[alignContext.defaultDir]);
        targetButton.removeAttribute("data-focus");
      } else if (this.util.isFormatElement(element)) {
        const textAlign = element.style.textAlign;
        if (textAlign) {
          this.util.changeElement(target, alignContext.icons[textAlign] || alignContext.icons[alignContext.defaultDir]);
          targetButton.setAttribute("data-focus", textAlign);
          return true;
        }
      }
      return false;
    },
    /**
     * @Override submenu
     */
    on: function() {
      const alignContext = this.context.align;
      const alignList = alignContext._alignList;
      const currentAlign = alignContext.targetButton.getAttribute("data-focus") || alignContext.defaultDir;
      if (currentAlign !== alignContext.currentAlign) {
        for (let i = 0, len = alignList.length; i < len; i++) {
          if (currentAlign === alignList[i].getAttribute("data-value")) {
            this.util.addClass(alignList[i], "active");
          } else {
            this.util.removeClass(alignList[i], "active");
          }
        }
        alignContext.currentAlign = currentAlign;
      }
    },
    exchangeDir: function() {
      const dir = this.options.rtl ? "right" : "left";
      if (!this.context.align || this.context.align.defaultDir === dir) return;
      this.context.align.defaultDir = dir;
      let menu = this.context.align._itemMenu;
      let leftBtn = menu.querySelector('[data-value="left"]');
      let rightBtn = menu.querySelector('[data-value="right"]');
      if (leftBtn && rightBtn) {
        const lp = leftBtn.parentElement;
        const rp = rightBtn.parentElement;
        lp.appendChild(rightBtn);
        rp.appendChild(leftBtn);
      }
    },
    pickup: function(e) {
      e.preventDefault();
      e.stopPropagation();
      let target = e.target;
      let value = null;
      while (!value && !/UL/i.test(target.tagName)) {
        value = target.getAttribute("data-value");
        target = target.parentNode;
      }
      if (!value) return;
      const defaultDir = this.context.align.defaultDir;
      const selectedFormsts = this.getSelectedElements();
      for (let i = 0, len = selectedFormsts.length; i < len; i++) {
        this.util.setStyle(selectedFormsts[i], "textAlign", value === defaultDir ? "" : value);
      }
      this.effectNode = null;
      this.submenuOff();
      this.focus();
      this.history.push(false);
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/font.js
  var font_default = {
    name: "font",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.font = {
        targetText: targetElement.querySelector(".txt"),
        targetTooltip: targetElement.parentNode.querySelector(".se-tooltip-text"),
        _fontList: null,
        currentFont: ""
      };
      let listDiv = this.setSubmenu(core);
      listDiv.querySelector(".se-list-inner").addEventListener("click", this.pickup.bind(core));
      context.font._fontList = listDiv.querySelectorAll("ul li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null;
    },
    setSubmenu: function(core) {
      const lang = core.lang;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer se-list-font-family";
      let font, text, i, len;
      let fontList = core.options.font;
      let list2 = '<div class="se-list-inner"><ul class="se-list-basic"><li><button type="button" class="default_value se-btn-list" title="' + lang.toolbar.default + '" aria-label="' + lang.toolbar.default + '">(' + lang.toolbar.default + ")</button></li>";
      for (i = 0, len = fontList.length; i < len; i++) {
        font = fontList[i];
        text = font.split(",")[0];
        list2 += '<li><button type="button" class="se-btn-list" data-value="' + font + '" data-txt="' + text + '" title="' + text + '" aria-label="' + text + '" style="font-family:' + font + ';">' + text + "</button></li>";
      }
      list2 += "</ul></div>";
      listDiv.innerHTML = list2;
      return listDiv;
    },
    /**
    * @Override core
    */
    active: function(element) {
      const target = this.context.font.targetText;
      const tooltip = this.context.font.targetTooltip;
      if (!element) {
        const font = this.hasFocus ? this.wwComputedStyle.fontFamily : this.lang.toolbar.font;
        this.util.changeTxt(target, font);
        this.util.changeTxt(tooltip, this.hasFocus ? this.lang.toolbar.font + (font ? " (" + font + ")" : "") : font);
      } else if (element.style && element.style.fontFamily.length > 0) {
        const selectFont = element.style.fontFamily.replace(/["']/g, "");
        this.util.changeTxt(target, selectFont);
        this.util.changeTxt(tooltip, this.lang.toolbar.font + " (" + selectFont + ")");
        return true;
      }
      return false;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const fontContext = this.context.font;
      const fontList = fontContext._fontList;
      const currentFont = fontContext.targetText.textContent;
      if (currentFont !== fontContext.currentFont) {
        for (let i = 0, len = fontList.length; i < len; i++) {
          if (currentFont === (fontList[i].getAttribute("data-value") || "").replace(/'|"/g, "")) {
            this.util.addClass(fontList[i], "active");
          } else {
            this.util.removeClass(fontList[i], "active");
          }
        }
        fontContext.currentFont = currentFont;
      }
    },
    pickup: function(e) {
      if (!/^BUTTON$/i.test(e.target.tagName)) return false;
      e.preventDefault();
      e.stopPropagation();
      let value = e.target.getAttribute("data-value");
      if (value) {
        const newNode = this.util.createElement("SPAN");
        if (/[\s\d\W]/.test(value) && !/^['"].*['"]$/.test(value)) {
          value = '"' + value + '"';
        }
        newNode.style.fontFamily = value;
        this.nodeChange(newNode, ["font-family"], null, null);
      } else {
        this.nodeChange(null, ["font-family"], ["span"], true);
      }
      this.submenuOff();
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/fontSize.js
  var fontSize_default = {
    name: "fontSize",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.fontSize = {
        targetText: targetElement.querySelector(".txt"),
        _sizeList: null,
        currentSize: ""
      };
      let listDiv = this.setSubmenu(core);
      let listUl = listDiv.querySelector("ul");
      listUl.addEventListener("click", this.pickup.bind(core));
      context.fontSize._sizeList = listUl.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null, listUl = null;
    },
    setSubmenu: function(core) {
      const option = core.options;
      const lang = core.lang;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer se-list-font-size";
      const sizeList = !option.fontSize ? [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72] : option.fontSize;
      let list2 = '<div class="se-list-inner"><ul class="se-list-basic"><li><button type="button" class="default_value se-btn-list" title="' + lang.toolbar.default + '" aria-label="' + lang.toolbar.default + '">(' + lang.toolbar.default + ")</button></li>";
      for (let i = 0, unit = option.fontSizeUnit, len = sizeList.length, size; i < len; i++) {
        size = sizeList[i];
        list2 += '<li><button type="button" class="se-btn-list" data-value="' + size + unit + '" title="' + size + unit + '" aria-label="' + size + unit + '" style="font-size:' + size + unit + ';">' + size + "</button></li>";
      }
      list2 += "</ul></div>";
      listDiv.innerHTML = list2;
      return listDiv;
    },
    /**
    * @Override core
    */
    active: function(element) {
      if (!element) {
        this.util.changeTxt(this.context.fontSize.targetText, this.hasFocus ? this._convertFontSize.call(this, this.options.fontSizeUnit, this.wwComputedStyle.fontSize) : this.lang.toolbar.fontSize);
      } else if (element.style && element.style.fontSize.length > 0) {
        this.util.changeTxt(this.context.fontSize.targetText, this._convertFontSize.call(this, this.options.fontSizeUnit, element.style.fontSize));
        return true;
      }
      return false;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const fontSizeContext = this.context.fontSize;
      const sizeList = fontSizeContext._sizeList;
      const currentSize = fontSizeContext.targetText.textContent;
      if (currentSize !== fontSizeContext.currentSize) {
        for (let i = 0, len = sizeList.length; i < len; i++) {
          if (currentSize === sizeList[i].getAttribute("data-value")) {
            this.util.addClass(sizeList[i], "active");
          } else {
            this.util.removeClass(sizeList[i], "active");
          }
        }
        fontSizeContext.currentSize = currentSize;
      }
    },
    pickup: function(e) {
      if (!/^BUTTON$/i.test(e.target.tagName)) return false;
      e.preventDefault();
      e.stopPropagation();
      const value = e.target.getAttribute("data-value");
      if (value) {
        const newNode = this.util.createElement("SPAN");
        newNode.style.fontSize = value;
        this.nodeChange(newNode, ["font-size"], null, null);
      } else {
        this.nodeChange(null, ["font-size"], ["span"], true);
      }
      this.submenuOff();
    }
  };

  // ../../node_modules/suneditor/src/plugins/modules/_colorPicker.js
  var colorPicker_default = {
    name: "colorPicker",
    /**
     * @description Constructor
     * @param {Object} core Core object 
     */
    add: function(core) {
      const context = core.context;
      context.colorPicker = {
        colorListHTML: "",
        _colorInput: "",
        _defaultColor: "#000",
        _styleProperty: "color",
        _currentColor: "",
        _colorList: []
      };
      context.colorPicker.colorListHTML = this.createColorList(core, this._makeColorList);
    },
    /**
     * @description Create color list
     * @param {Object} core Core object 
     * @param {Function} makeColor this._makeColorList
     * @returns {String} HTML string
     */
    createColorList: function(core, makeColor) {
      const option = core.options;
      const lang = core.lang;
      const colorList = !option.colorList || option.colorList.length === 0 ? [
        "#ff0000",
        "#ff5e00",
        "#ffe400",
        "#abf200",
        "#00d8ff",
        "#0055ff",
        "#6600ff",
        "#ff00dd",
        "#000000",
        "#ffd8d8",
        "#fae0d4",
        "#faf4c0",
        "#e4f7ba",
        "#d4f4fa",
        "#d9e5ff",
        "#e8d9ff",
        "#ffd9fa",
        "#f1f1f1",
        "#ffa7a7",
        "#ffc19e",
        "#faed7d",
        "#cef279",
        "#b2ebf4",
        "#b2ccff",
        "#d1b2ff",
        "#ffb2f5",
        "#bdbdbd",
        "#f15f5f",
        "#f29661",
        "#e5d85c",
        "#bce55c",
        "#5cd1e5",
        "#6699ff",
        "#a366ff",
        "#f261df",
        "#8c8c8c",
        "#980000",
        "#993800",
        "#998a00",
        "#6b9900",
        "#008299",
        "#003399",
        "#3d0099",
        "#990085",
        "#353535",
        "#670000",
        "#662500",
        "#665c00",
        "#476600",
        "#005766",
        "#002266",
        "#290066",
        "#660058",
        "#222222"
      ] : option.colorList;
      let colorArr = [];
      let list2 = '<div class="se-list-inner">';
      for (let i = 0, len = colorList.length, color; i < len; i++) {
        color = colorList[i];
        if (!color) continue;
        if (typeof color === "string") {
          colorArr.push(color);
          if (i < len - 1) continue;
        }
        if (colorArr.length > 0) {
          list2 += '<div class="se-selector-color">' + makeColor(colorArr) + "</div>";
          colorArr = [];
        }
        if (typeof color === "object") {
          list2 += '<div class="se-selector-color">' + makeColor(color) + "</div>";
        }
      }
      list2 += '<form class="se-form-group"><input type="text" maxlength="9" class="_se_color_picker_input se-color-input"/><button type="submit" class="se-btn-primary _se_color_picker_submit" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '">' + core.icons.checked + '</button><button type="button" class="se-btn _se_color_picker_remove" title="' + lang.toolbar.removeFormat + '" aria-label="' + lang.toolbar.removeFormat + '">' + core.icons.erase + "</button></form></div>";
      return list2;
    },
    /**
     * @description Internal function used by this.createColorList
     * @param {Array} colorList Color list
     * @private
     */
    _makeColorList: function(colorList) {
      let list2 = "";
      list2 += '<ul class="se-color-pallet">';
      for (let i = 0, len = colorList.length, color; i < len; i++) {
        color = colorList[i];
        if (typeof color === "string") {
          list2 += '<li><button type="button" data-value="' + color + '" title="' + color + '" aria-label="' + color + '" style="background-color:' + color + ';"></button></li>';
        }
      }
      list2 += "</ul>";
      return list2;
    },
    /**
     * @description Displays or resets the currently selected color at color list.
     * @param {Node} node Current Selected node
     * @param {String|null} color Color value
     */
    init: function(node, color) {
      const colorPicker = this.plugins.colorPicker;
      let fillColor = color ? color : colorPicker.getColorInNode.call(this, node) || this.context.colorPicker._defaultColor;
      fillColor = colorPicker.isHexColor(fillColor) ? fillColor : colorPicker.rgb2hex(fillColor) || fillColor;
      const colorList = this.context.colorPicker._colorList;
      if (colorList) {
        for (let i = 0, len = colorList.length; i < len; i++) {
          if (fillColor.toLowerCase() === colorList[i].getAttribute("data-value").toLowerCase()) {
            this.util.addClass(colorList[i], "active");
          } else {
            this.util.removeClass(colorList[i], "active");
          }
        }
      }
      colorPicker.setInputText.call(this, colorPicker.colorName2hex.call(this, fillColor));
    },
    /**
     * @description Store color values
     * @param {String} hexColorStr Hax color value
     */
    setCurrentColor: function(hexColorStr) {
      this.context.colorPicker._currentColor = hexColorStr;
      this.context.colorPicker._colorInput.style.borderColor = hexColorStr;
    },
    /**
     * @description Set color at input element
     * @param {String} hexColorStr Hax color value
     */
    setInputText: function(hexColorStr) {
      hexColorStr = /^#/.test(hexColorStr) ? hexColorStr : "#" + hexColorStr;
      this.context.colorPicker._colorInput.value = hexColorStr;
      this.plugins.colorPicker.setCurrentColor.call(this, hexColorStr);
    },
    /**
     * @description Gets color value at color property of node
     * @param {Node} node Selected node 
     * @returns {String}
     */
    getColorInNode: function(node) {
      let findColor = "";
      const styleProperty = this.context.colorPicker._styleProperty;
      while (node && !this.util.isWysiwygDiv(node) && findColor.length === 0) {
        if (node.nodeType === 1 && node.style[styleProperty]) findColor = node.style[styleProperty];
        node = node.parentNode;
      }
      return findColor;
    },
    /**
     * @description Function to check hex format color
     * @param {String} str Color value
     */
    isHexColor: function(str) {
      return /^#[0-9a-f]{3}(?:[0-9a-f]{3})?$/i.test(str);
    },
    /**
     * @description Function to convert hex format to a rgb color
     * @param {String} rgb RGB color format
     * @returns {String}
     */
    rgb2hex: function(rgb) {
      const rgbMatch = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
      return rgbMatch && rgbMatch.length === 4 ? "#" + ("0" + parseInt(rgbMatch[1], 10).toString(16)).slice(-2) + ("0" + parseInt(rgbMatch[2], 10).toString(16)).slice(-2) + ("0" + parseInt(rgbMatch[3], 10).toString(16)).slice(-2) : "";
    },
    /**
     * @description Converts color values of other formats to hex color values and returns.
     * @param {String} colorName Color value
     * @returns {String}
     */
    colorName2hex: function(colorName) {
      if (/^#/.test(colorName)) return colorName;
      var temp = this.util.createElement("div");
      temp.style.display = "none";
      temp.style.color = colorName;
      var colors = this._w.getComputedStyle(this._d.body.appendChild(temp)).color.match(/\d+/g).map(function(a) {
        return parseInt(a, 10);
      });
      this.util.removeItem(temp);
      return colors.length >= 3 ? "#" + ((1 << 24) + (colors[0] << 16) + (colors[1] << 8) + colors[2]).toString(16).substr(1) : false;
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/fontColor.js
  var fontColor_default = {
    name: "fontColor",
    display: "submenu",
    add: function(core, targetElement) {
      core.addModule([colorPicker_default]);
      const context = core.context;
      context.fontColor = {
        previewEl: null,
        colorInput: null,
        colorList: null
      };
      let listDiv = this.setSubmenu(core);
      context.fontColor.colorInput = listDiv.querySelector("._se_color_picker_input");
      context.fontColor.colorInput.addEventListener("keyup", this.onChangeInput.bind(core));
      listDiv.querySelector("._se_color_picker_submit").addEventListener("click", this.submit.bind(core));
      listDiv.querySelector("._se_color_picker_remove").addEventListener("click", this.remove.bind(core));
      listDiv.addEventListener("click", this.pickup.bind(core));
      context.fontColor.colorList = listDiv.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null;
    },
    setSubmenu: function(core) {
      const colorArea = core.context.colorPicker.colorListHTML;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer";
      listDiv.innerHTML = colorArea;
      return listDiv;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const contextPicker = this.context.colorPicker;
      const contextFontColor = this.context.fontColor;
      contextPicker._colorInput = contextFontColor.colorInput;
      const color = this.wwComputedStyle.color;
      contextPicker._defaultColor = color ? this.plugins.colorPicker.isHexColor(color) ? color : this.plugins.colorPicker.rgb2hex(color) : "#333333";
      contextPicker._styleProperty = "color";
      contextPicker._colorList = contextFontColor.colorList;
      this.plugins.colorPicker.init.call(this, this.getSelectionNode(), null);
    },
    /**
    * @Override _colorPicker
    */
    onChangeInput: function(e) {
      this.plugins.colorPicker.setCurrentColor.call(this, e.target.value);
    },
    submit: function() {
      this.plugins.fontColor.applyColor.call(this, this.context.colorPicker._currentColor);
    },
    pickup: function(e) {
      e.preventDefault();
      e.stopPropagation();
      this.plugins.fontColor.applyColor.call(this, e.target.getAttribute("data-value"));
    },
    remove: function() {
      this.nodeChange(null, ["color"], ["span"], true);
      this.submenuOff();
    },
    applyColor: function(color) {
      if (!color) return;
      const newNode = this.util.createElement("SPAN");
      newNode.style.color = color;
      this.nodeChange(newNode, ["color"], null, null);
      this.submenuOff();
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/hiliteColor.js
  var hiliteColor_default = {
    name: "hiliteColor",
    display: "submenu",
    add: function(core, targetElement) {
      core.addModule([colorPicker_default]);
      const context = core.context;
      context.hiliteColor = {
        previewEl: null,
        colorInput: null,
        colorList: null
      };
      let listDiv = this.setSubmenu(core);
      context.hiliteColor.colorInput = listDiv.querySelector("._se_color_picker_input");
      context.hiliteColor.colorInput.addEventListener("keyup", this.onChangeInput.bind(core));
      listDiv.querySelector("._se_color_picker_submit").addEventListener("click", this.submit.bind(core));
      listDiv.querySelector("._se_color_picker_remove").addEventListener("click", this.remove.bind(core));
      listDiv.addEventListener("click", this.pickup.bind(core));
      context.hiliteColor.colorList = listDiv.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null;
    },
    setSubmenu: function(core) {
      const colorArea = core.context.colorPicker.colorListHTML;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer";
      listDiv.innerHTML = colorArea;
      return listDiv;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const contextPicker = this.context.colorPicker;
      const contextHiliteColor = this.context.hiliteColor;
      contextPicker._colorInput = contextHiliteColor.colorInput;
      const color = this.wwComputedStyle.backgroundColor;
      contextPicker._defaultColor = color ? this.plugins.colorPicker.isHexColor(color) ? color : this.plugins.colorPicker.rgb2hex(color) : "#ffffff";
      contextPicker._styleProperty = "backgroundColor";
      contextPicker._colorList = contextHiliteColor.colorList;
      this.plugins.colorPicker.init.call(this, this.getSelectionNode(), null);
    },
    /**
    * @Override _colorPicker
    */
    onChangeInput: function(e) {
      this.plugins.colorPicker.setCurrentColor.call(this, e.target.value);
    },
    submit: function() {
      this.plugins.hiliteColor.applyColor.call(this, this.context.colorPicker._currentColor);
    },
    pickup: function(e) {
      e.preventDefault();
      e.stopPropagation();
      this.plugins.hiliteColor.applyColor.call(this, e.target.getAttribute("data-value"));
    },
    remove: function() {
      this.nodeChange(null, ["background-color"], ["span"], true);
      this.submenuOff();
    },
    applyColor: function(color) {
      if (!color) return;
      const newNode = this.util.createElement("SPAN");
      newNode.style.backgroundColor = color;
      this.nodeChange(newNode, ["background-color"], null, null);
      this.submenuOff();
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/horizontalRule.js
  var horizontalRule_default = {
    name: "horizontalRule",
    display: "submenu",
    add: function(core, targetElement) {
      core.context.horizontalRule = {
        currentHR: null
      };
      let listDiv = this.setSubmenu(core);
      listDiv.querySelector("ul").addEventListener("click", this.horizontalRulePick.bind(core));
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null;
    },
    setSubmenu: function(core) {
      const lang = core.lang;
      const listDiv = core.util.createElement("DIV");
      const items = core.options.hrItems || [{ name: lang.toolbar.hr_solid, class: "__se__solid" }, { name: lang.toolbar.hr_dashed, class: "__se__dashed" }, { name: lang.toolbar.hr_dotted, class: "__se__dotted" }];
      let list2 = "";
      for (let i = 0, len = items.length; i < len; i++) {
        list2 += '<li><button type="button" class="se-btn-list btn_line" data-command="horizontalRule" data-value="' + items[i].class + '" title="' + items[i].name + '" aria-label="' + items[i].name + '"><hr' + (items[i].class ? ' class="' + items[i].class + '"' : "") + (items[i].style ? ' style="' + items[i].style + '"' : "") + "/></button></li>";
      }
      listDiv.className = "se-submenu se-list-layer se-list-line";
      listDiv.innerHTML = '<div class="se-list-inner"><ul class="se-list-basic">' + list2 + "</ul></div>";
      return listDiv;
    },
    active: function(element) {
      if (!element) {
        if (this.util.hasClass(this.context.horizontalRule.currentHR, "on")) {
          this.controllersOff();
        }
      } else if (/HR/i.test(element.nodeName)) {
        this.context.horizontalRule.currentHR = element;
        if (!this.util.hasClass(element, "on")) {
          this.util.addClass(element, "on");
          this.controllersOn("hr", this.util.removeClass.bind(this.util, element, "on"));
        }
        return true;
      }
      return false;
    },
    appendHr: function(hrTemp) {
      this.focus();
      return this.insertComponent(hrTemp.cloneNode(false), false, true, false);
    },
    horizontalRulePick: function(e) {
      e.preventDefault();
      e.stopPropagation();
      let target = e.target;
      let command = target.getAttribute("data-command");
      while (!command && !/UL/i.test(target.tagName)) {
        target = target.parentNode;
        command = target.getAttribute("data-command");
      }
      if (!command) return;
      const oNode = this.plugins.horizontalRule.appendHr.call(this, target.firstElementChild);
      if (oNode) {
        this.setRange(oNode, 0, oNode, 0);
        this.submenuOff();
      }
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/list.js
  var list_default = {
    name: "list",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.list = {
        targetButton: targetElement,
        _list: null,
        currentList: "",
        icons: {
          bullets: core.icons.list_bullets,
          number: core.icons.list_number
        }
      };
      let listDiv = this.setSubmenu(core);
      let listUl = listDiv.querySelector("ul");
      listUl.addEventListener("click", this.pickup.bind(core));
      context.list._list = listUl.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null, listUl = null;
    },
    setSubmenu: function(core) {
      const lang = core.lang;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer";
      listDiv.innerHTML = '<div class="se-list-inner"><ul class="se-list-basic"><li><button type="button" class="se-btn-list se-tooltip" data-command="OL" title="' + lang.toolbar.orderList + '" aria-label="' + lang.toolbar.orderList + '">' + core.icons.list_number + '</button></li><li><button type="button" class="se-btn-list se-tooltip" data-command="UL" title="' + lang.toolbar.unorderList + '" aria-label="' + lang.toolbar.unorderList + '">' + core.icons.list_bullets + "</button></li></ul></div>";
      return listDiv;
    },
    /**
    * @Override core
    */
    active: function(element) {
      const button = this.context.list.targetButton;
      const icon = button.firstElementChild;
      const util2 = this.util;
      if (util2.isList(element)) {
        const nodeName = element.nodeName;
        button.setAttribute("data-focus", nodeName);
        util2.addClass(button, "active");
        if (/UL/i.test(nodeName)) {
          util2.changeElement(icon, this.context.list.icons.bullets);
        } else {
          util2.changeElement(icon, this.context.list.icons.number);
        }
        return true;
      } else {
        button.removeAttribute("data-focus");
        util2.changeElement(icon, this.context.list.icons.number);
        util2.removeClass(button, "active");
      }
      return false;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const listContext = this.context.list;
      const list2 = listContext._list;
      const currentList = listContext.targetButton.getAttribute("data-focus") || "";
      if (currentList !== listContext.currentList) {
        for (let i = 0, len = list2.length; i < len; i++) {
          if (currentList === list2[i].getAttribute("data-command")) {
            this.util.addClass(list2[i], "active");
          } else {
            this.util.removeClass(list2[i], "active");
          }
        }
        listContext.currentList = currentList;
      }
    },
    editList: function(command, selectedCells, detach) {
      let range = this.getRange();
      let selectedFormats = !selectedCells ? this.getSelectedElementsAndComponents(false) : selectedCells;
      if (selectedFormats.length === 0) {
        if (selectedCells) return;
        range = this.getRange_addLine(range, null);
        selectedFormats = this.getSelectedElementsAndComponents(false);
        if (selectedFormats.length === 0) return;
      }
      const util2 = this.util;
      util2.sortByDepth(selectedFormats, true);
      let firstSel = selectedFormats[0];
      let lastSel = selectedFormats[selectedFormats.length - 1];
      let topEl = (util2.isListCell(firstSel) || util2.isComponent(firstSel)) && !firstSel.previousElementSibling ? firstSel.parentNode.previousElementSibling : firstSel.previousElementSibling;
      let bottomEl = (util2.isListCell(lastSel) || util2.isComponent(lastSel)) && !lastSel.nextElementSibling ? lastSel.parentNode.nextElementSibling : lastSel.nextElementSibling;
      const isCollapsed = range.collapsed;
      const originRange = {
        sc: range.startContainer,
        so: range.startContainer === range.endContainer && util2.onlyZeroWidthSpace(range.startContainer) && range.startOffset === 0 && range.endOffset === 1 ? range.endOffset : range.startOffset,
        ec: range.endContainer,
        eo: range.endOffset
      };
      let afterRange = null;
      let isRemove = true;
      for (let i = 0, len = selectedFormats.length; i < len; i++) {
        if (!util2.isList(util2.getRangeFormatElement(selectedFormats[i], function(current) {
          return this.getRangeFormatElement(current) && current !== selectedFormats[i];
        }.bind(util2)))) {
          isRemove = false;
          break;
        }
      }
      if (isRemove && (!topEl || (firstSel.tagName !== topEl.tagName || command !== topEl.tagName.toUpperCase())) && (!bottomEl || (lastSel.tagName !== bottomEl.tagName || command !== bottomEl.tagName.toUpperCase()))) {
        if (detach) {
          for (let i = 0, len = selectedFormats.length; i < len; i++) {
            for (let j = i - 1; j >= 0; j--) {
              if (selectedFormats[j].contains(selectedFormats[i])) {
                selectedFormats.splice(i, 1);
                i--;
                len--;
                break;
              }
            }
          }
        }
        const currentFormat = util2.getRangeFormatElement(firstSel);
        const cancel = currentFormat && currentFormat.tagName === command;
        let rangeArr, tempList;
        const passComponent = function(current) {
          return !this.isComponent(current);
        }.bind(util2);
        if (!cancel) tempList = util2.createElement(command);
        for (let i = 0, len = selectedFormats.length, r, o; i < len; i++) {
          o = util2.getRangeFormatElement(selectedFormats[i], passComponent);
          if (!o || !util2.isList(o)) continue;
          if (!r) {
            r = o;
            rangeArr = { r, f: [util2.getParentElement(selectedFormats[i], "LI")] };
          } else {
            if (r !== o) {
              if (detach && util2.isListCell(o.parentNode)) {
                this.plugins.list._detachNested.call(this, rangeArr.f);
              } else {
                afterRange = this.detachRangeFormatElement(rangeArr.f[0].parentNode, rangeArr.f, tempList, false, true);
              }
              o = selectedFormats[i].parentNode;
              if (!cancel) tempList = util2.createElement(command);
              r = o;
              rangeArr = { r, f: [util2.getParentElement(selectedFormats[i], "LI")] };
            } else {
              rangeArr.f.push(util2.getParentElement(selectedFormats[i], "LI"));
            }
          }
          if (i === len - 1) {
            if (detach && util2.isListCell(o.parentNode)) {
              this.plugins.list._detachNested.call(this, rangeArr.f);
            } else {
              afterRange = this.detachRangeFormatElement(rangeArr.f[0].parentNode, rangeArr.f, tempList, false, true);
            }
          }
        }
      } else {
        const topElParent = topEl ? topEl.parentNode : topEl;
        const bottomElParent = bottomEl ? bottomEl.parentNode : bottomEl;
        topEl = topElParent && !util2.isWysiwygDiv(topElParent) && topElParent.nodeName === command ? topElParent : topEl;
        bottomEl = bottomElParent && !util2.isWysiwygDiv(bottomElParent) && bottomElParent.nodeName === command ? bottomElParent : bottomEl;
        const mergeTop = topEl && topEl.tagName === command;
        const mergeBottom = bottomEl && bottomEl.tagName === command;
        let list2 = mergeTop ? topEl : util2.createElement(command);
        let firstList = null;
        let lastList = null;
        let topNumber = null;
        let bottomNumber = null;
        const passComponent = function(current) {
          return !this.isComponent(current) && !this.isList(current);
        }.bind(util2);
        for (let i = 0, len = selectedFormats.length, newCell, fTag, isCell, next, originParent, nextParent, parentTag, siblingTag, rangeTag; i < len; i++) {
          fTag = selectedFormats[i];
          if (fTag.childNodes.length === 0 && !util2._isIgnoreNodeChange(fTag)) {
            util2.removeItem(fTag);
            continue;
          }
          next = selectedFormats[i + 1];
          originParent = fTag.parentNode;
          nextParent = next ? next.parentNode : null;
          isCell = util2.isListCell(fTag);
          rangeTag = util2.isRangeFormatElement(originParent) ? originParent : null;
          parentTag = isCell && !util2.isWysiwygDiv(originParent) ? originParent.parentNode : originParent;
          siblingTag = isCell && !util2.isWysiwygDiv(originParent) ? !next || util2.isListCell(parentTag) ? originParent : originParent.nextSibling : fTag.nextSibling;
          newCell = util2.createElement("LI");
          util2.copyFormatAttributes(newCell, fTag);
          if (i === 0 && originRange.sc === fTag) {
            originRange.sc = newCell;
          }
          if (i === len - 1 && originRange.ec === fTag) {
            originRange.ec = newCell;
          }
          if (util2.isComponent(fTag)) {
            const isHR = /^HR$/i.test(fTag.nodeName);
            if (!isHR) newCell.innerHTML = "<br>";
            newCell.innerHTML += fTag.outerHTML;
            if (isHR) newCell.innerHTML += "<br>";
          } else {
            const fChildren = fTag.childNodes;
            while (fChildren[0]) {
              newCell.appendChild(fChildren[0]);
            }
          }
          list2.appendChild(newCell);
          if (!next) lastList = list2;
          if (!next || parentTag !== nextParent || util2.isRangeFormatElement(siblingTag)) {
            if (!firstList) firstList = list2;
            if ((!mergeTop || !next || parentTag !== nextParent) && !(next && util2.isList(nextParent) && nextParent === originParent)) {
              if (list2.parentNode !== parentTag) parentTag.insertBefore(list2, siblingTag);
            }
          }
          util2.removeItem(fTag);
          if (mergeTop && topNumber === null) topNumber = list2.children.length - 1;
          if (next && (util2.getRangeFormatElement(nextParent, passComponent) !== util2.getRangeFormatElement(originParent, passComponent) || util2.isList(nextParent) && util2.isList(originParent) && util2.getElementDepth(nextParent) !== util2.getElementDepth(originParent))) {
            list2 = util2.createElement(command);
          }
          if (rangeTag && rangeTag.children.length === 0) util2.removeItem(rangeTag);
        }
        if (topNumber) {
          firstList = firstList.children[topNumber];
        }
        if (mergeBottom) {
          bottomNumber = list2.children.length - 1;
          list2.innerHTML += bottomEl.innerHTML;
          lastList = list2.children[bottomNumber];
          util2.removeItem(bottomEl);
        }
      }
      this.effectNode = null;
      return !isCollapsed ? originRange : afterRange;
    },
    _detachNested: function(cells) {
      const first = cells[0];
      const last = cells[cells.length - 1];
      const next = last.nextElementSibling;
      const originList = first.parentNode;
      const sibling = originList.parentNode.nextElementSibling;
      const parentNode = originList.parentNode.parentNode;
      for (let c = 0, cLen = cells.length; c < cLen; c++) {
        parentNode.insertBefore(cells[c], sibling);
      }
      if (next && originList.children.length > 0) {
        const newList = originList.cloneNode(false);
        const children2 = originList.childNodes;
        const index = this.util.getPositionIndex(next);
        while (children2[index]) {
          newList.appendChild(children2[index]);
        }
        last.appendChild(newList);
      }
      if (originList.children.length === 0) this.util.removeItem(originList);
      this.util.mergeSameTags(parentNode);
      const edge = this.util.getEdgeChildNodes(first, last);
      return {
        cc: first.parentNode,
        sc: edge.sc,
        ec: edge.ec
      };
    },
    editInsideList: function(remove, selectedCells) {
      selectedCells = !selectedCells ? this.getSelectedElements().filter(function(el) {
        return this.isListCell(el);
      }.bind(this.util)) : selectedCells;
      const cellsLen = selectedCells.length;
      if (cellsLen === 0 || !remove && (!this.util.isListCell(selectedCells[0].previousElementSibling) && !this.util.isListCell(selectedCells[cellsLen - 1].nextElementSibling))) {
        return {
          sc: selectedCells[0],
          so: 0,
          ec: selectedCells[cellsLen - 1],
          eo: 1
        };
      }
      let originList = selectedCells[0].parentNode;
      let lastCell = selectedCells[cellsLen - 1];
      let range = null;
      if (remove) {
        if (originList !== lastCell.parentNode && this.util.isList(lastCell.parentNode.parentNode) && lastCell.nextElementSibling) {
          lastCell = lastCell.nextElementSibling;
          while (lastCell) {
            selectedCells.push(lastCell);
            lastCell = lastCell.nextElementSibling;
          }
        }
        range = this.plugins.list.editList.call(this, originList.nodeName.toUpperCase(), selectedCells, true);
      } else {
        let innerList = this.util.createElement(originList.nodeName);
        let prev = selectedCells[0].previousElementSibling;
        let next = lastCell.nextElementSibling;
        const nodePath = { s: null, e: null, sl: originList, el: originList };
        for (let i = 0, len = cellsLen, c; i < len; i++) {
          c = selectedCells[i];
          if (c.parentNode !== originList) {
            this.plugins.list._insiedList.call(this, originList, innerList, prev, next, nodePath);
            originList = c.parentNode;
            innerList = this.util.createElement(originList.nodeName);
          }
          prev = c.previousElementSibling;
          next = c.nextElementSibling;
          innerList.appendChild(c);
        }
        this.plugins.list._insiedList.call(this, originList, innerList, prev, next, nodePath);
        const sc = this.util.getNodeFromPath(nodePath.s, nodePath.sl);
        const ec = this.util.getNodeFromPath(nodePath.e, nodePath.el);
        range = {
          sc,
          so: 0,
          ec,
          eo: ec.textContent.length
        };
      }
      return range;
    },
    _insiedList: function(originList, innerList, prev, next, nodePath) {
      let insertPrev = false;
      if (prev && innerList.tagName === prev.tagName) {
        const children2 = innerList.children;
        while (children2[0]) {
          prev.appendChild(children2[0]);
        }
        innerList = prev;
        insertPrev = true;
      }
      if (next && innerList.tagName === next.tagName) {
        const children2 = next.children;
        while (children2[0]) {
          innerList.appendChild(children2[0]);
        }
        const temp = next.nextElementSibling;
        next.parentNode.removeChild(next);
        next = temp;
      }
      if (!insertPrev) {
        if (this.util.isListCell(prev)) {
          originList = prev;
          next = null;
        }
        originList.insertBefore(innerList, next);
        if (!nodePath.s) {
          nodePath.s = this.util.getNodePath(innerList.firstElementChild.firstChild, originList, null);
          nodePath.sl = originList;
        }
        const slPath = originList.contains(nodePath.sl) ? this.util.getNodePath(nodePath.sl, originList) : null;
        nodePath.e = this.util.getNodePath(innerList.lastElementChild.firstChild, originList, null);
        nodePath.el = originList;
        this.util.mergeSameTags(originList, [nodePath.s, nodePath.e, slPath], false);
        this.util.mergeNestedTags(originList);
        if (slPath) nodePath.sl = this.util.getNodeFromPath(slPath, originList);
      }
      return innerList;
    },
    pickup: function(e) {
      e.preventDefault();
      e.stopPropagation();
      let target = e.target;
      let command = "";
      while (!command && !/^UL$/i.test(target.tagName)) {
        command = target.getAttribute("data-command");
        target = target.parentNode;
      }
      if (!command) return;
      const range = this.plugins.list.editList.call(this, command, null, false);
      if (range) this.setRange(range.sc, range.so, range.ec, range.eo);
      this.submenuOff();
      this.history.push(false);
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/table.js
  var table_default = {
    name: "table",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      let contextTable = context.table = {
        _element: null,
        _tdElement: null,
        _trElement: null,
        _trElements: null,
        _tableXY: [],
        _maxWidth: true,
        _fixedColumn: false,
        _rtl: core.options.rtl,
        cellControllerTop: core.options.tableCellControllerPosition === "top",
        resizeText: null,
        headerButton: null,
        mergeButton: null,
        splitButton: null,
        splitMenu: null,
        maxText: core.lang.controller.maxSize,
        minText: core.lang.controller.minSize,
        _physical_cellCnt: 0,
        _logical_cellCnt: 0,
        _rowCnt: 0,
        _rowIndex: 0,
        _physical_cellIndex: 0,
        _logical_cellIndex: 0,
        _current_colSpan: 0,
        _current_rowSpan: 0,
        icons: {
          expansion: core.icons.expansion,
          reduction: core.icons.reduction
        }
      };
      let listDiv = this.setSubmenu(core);
      let tablePicker = listDiv.querySelector(".se-controller-table-picker");
      contextTable.tableHighlight = listDiv.querySelector(".se-table-size-highlighted");
      contextTable.tableUnHighlight = listDiv.querySelector(".se-table-size-unhighlighted");
      contextTable.tableDisplay = listDiv.querySelector(".se-table-size-display");
      if (core.options.rtl) contextTable.tableHighlight.style.left = 10 * 18 - 13 + "px";
      let tableController = this.setController_table(core);
      contextTable.tableController = tableController;
      contextTable.resizeButton = tableController.querySelector("._se_table_resize");
      contextTable.resizeText = tableController.querySelector("._se_table_resize > span > span");
      contextTable.columnFixedButton = tableController.querySelector("._se_table_fixed_column");
      contextTable.headerButton = tableController.querySelector("._se_table_header");
      let resizeDiv = this.setController_tableEditor(core, contextTable.cellControllerTop);
      contextTable.resizeDiv = resizeDiv;
      contextTable.splitMenu = resizeDiv.querySelector(".se-btn-group-sub");
      contextTable.mergeButton = resizeDiv.querySelector("._se_table_merge_button");
      contextTable.splitButton = resizeDiv.querySelector("._se_table_split_button");
      contextTable.insertRowAboveButton = resizeDiv.querySelector("._se_table_insert_row_a");
      contextTable.insertRowBelowButton = resizeDiv.querySelector("._se_table_insert_row_b");
      tablePicker.addEventListener("mousemove", this.onMouseMove_tablePicker.bind(core, contextTable));
      tablePicker.addEventListener("click", this.appendTable.bind(core));
      resizeDiv.addEventListener("click", this.onClick_tableController.bind(core));
      tableController.addEventListener("click", this.onClick_tableController.bind(core));
      core.initMenuTarget(this.name, targetElement, listDiv);
      context.element.relative.appendChild(resizeDiv);
      context.element.relative.appendChild(tableController);
      listDiv = null, tablePicker = null, resizeDiv = null, tableController = null, contextTable = null;
    },
    setSubmenu: function(core) {
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-selector-table";
      listDiv.innerHTML = '<div class="se-table-size"><div class="se-table-size-picker se-controller-table-picker"></div><div class="se-table-size-highlighted"></div><div class="se-table-size-unhighlighted"></div></div><div class="se-table-size-display">1 x 1</div>';
      return listDiv;
    },
    setController_table: function(core) {
      const lang = core.lang;
      const icons = core.icons;
      const tableResize = core.util.createElement("DIV");
      tableResize.className = "se-controller se-controller-table";
      tableResize.innerHTML = '<div><div class="se-btn-group"><button type="button" data-command="resize" class="se-btn se-tooltip _se_table_resize">' + icons.expansion + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.maxSize + '</span></span></button><button type="button" data-command="layout" class="se-btn se-tooltip _se_table_fixed_column">' + icons.fixed_column_width + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.fixedColumnWidth + '</span></span></button><button type="button" data-command="header" class="se-btn se-tooltip _se_table_header">' + icons.table_header + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.tableHeader + '</span></span></button><button type="button" data-command="remove" class="se-btn se-tooltip">' + icons.delete + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.remove + "</span></span></button></div></div>";
      return tableResize;
    },
    setController_tableEditor: function(core, cellControllerTop) {
      const lang = core.lang;
      const icons = core.icons;
      const tableResize = core.util.createElement("DIV");
      tableResize.className = "se-controller se-controller-table-cell";
      tableResize.innerHTML = (cellControllerTop ? "" : '<div class="se-arrow se-arrow-up"></div>') + '<div class="se-btn-group"><button type="button" data-command="insert" data-value="row" data-option="up" class="se-btn se-tooltip _se_table_insert_row_a">' + icons.insert_row_above + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.insertRowAbove + '</span></span></button><button type="button" data-command="insert" data-value="row" data-option="down" class="se-btn se-tooltip _se_table_insert_row_b">' + icons.insert_row_below + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.insertRowBelow + '</span></span></button><button type="button" data-command="delete" data-value="row" class="se-btn se-tooltip">' + icons.delete_row + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.deleteRow + '</span></span></button><button type="button" data-command="merge" class="_se_table_merge_button se-btn se-tooltip" disabled>' + icons.merge_cell + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.mergeCells + '</span></span></button></div><div class="se-btn-group" style="padding-top: 0;"><button type="button" data-command="insert" data-value="cell" data-option="left" class="se-btn se-tooltip">' + icons.insert_column_left + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.insertColumnBefore + '</span></span></button><button type="button" data-command="insert" data-value="cell" data-option="right" class="se-btn se-tooltip">' + icons.insert_column_right + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.insertColumnAfter + '</span></span></button><button type="button" data-command="delete" data-value="cell" class="se-btn se-tooltip">' + icons.delete_column + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.deleteColumn + '</span></span></button><button type="button" data-command="onsplit" class="_se_table_split_button se-btn se-tooltip">' + icons.split_cell + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.splitCells + '</span></span></button><div class="se-btn-group-sub sun-editor-common se-list-layer se-table-split"><div class="se-list-inner"><ul class="se-list-basic"><li class="se-btn-list" data-command="split" data-value="vertical" style="line-height:32px;" title="' + lang.controller.VerticalSplit + '" aria-label="' + lang.controller.VerticalSplit + '">' + lang.controller.VerticalSplit + '</li><li class="se-btn-list" data-command="split" data-value="horizontal" style="line-height:32px;" title="' + lang.controller.HorizontalSplit + '" aria-label="' + lang.controller.HorizontalSplit + '">' + lang.controller.HorizontalSplit + "</li></ul></div></div></div>";
      return tableResize;
    },
    appendTable: function() {
      const oTable = this.util.createElement("TABLE");
      const createCells = this.plugins.table.createCells;
      const x = this.context.table._tableXY[0];
      let y = this.context.table._tableXY[1];
      let tableHTML = "<tbody>";
      while (y > 0) {
        tableHTML += "<tr>" + createCells.call(this, "td", x) + "</tr>";
        --y;
      }
      tableHTML += "</tbody>";
      oTable.innerHTML = tableHTML;
      const changed = this.insertComponent(oTable, false, true, false);
      if (changed) {
        const firstTd = oTable.querySelector("td div");
        this.setRange(firstTd, 0, firstTd, 0);
        this.plugins.table.reset_table_picker.call(this);
      }
    },
    createCells: function(nodeName, cnt, returnElement) {
      nodeName = nodeName.toLowerCase();
      if (!returnElement) {
        let cellsHTML = "";
        while (cnt > 0) {
          cellsHTML += "<" + nodeName + "><div><br></div></" + nodeName + ">";
          cnt--;
        }
        return cellsHTML;
      } else {
        const cell = this.util.createElement(nodeName);
        cell.innerHTML = "<div><br></div>";
        return cell;
      }
    },
    onMouseMove_tablePicker: function(contextTable, e) {
      e.stopPropagation();
      let x = this._w.Math.ceil(e.offsetX / 18);
      let y = this._w.Math.ceil(e.offsetY / 18);
      x = x < 1 ? 1 : x;
      y = y < 1 ? 1 : y;
      if (contextTable._rtl) {
        contextTable.tableHighlight.style.left = x * 18 - 13 + "px";
        x = 11 - x;
      }
      contextTable.tableHighlight.style.width = x + "em";
      contextTable.tableHighlight.style.height = y + "em";
      this.util.changeTxt(contextTable.tableDisplay, x + " x " + y);
      contextTable._tableXY = [x, y];
    },
    reset_table_picker: function() {
      if (!this.context.table.tableHighlight) return;
      const highlight = this.context.table.tableHighlight.style;
      const unHighlight = this.context.table.tableUnHighlight.style;
      highlight.width = "1em";
      highlight.height = "1em";
      unHighlight.width = "10em";
      unHighlight.height = "10em";
      this.util.changeTxt(this.context.table.tableDisplay, "1 x 1");
      this.submenuOff();
    },
    init: function() {
      const contextTable = this.context.table;
      const tablePlugin = this.plugins.table;
      tablePlugin._removeEvents.call(this);
      if (tablePlugin._selectedTable) {
        const selectedCells = tablePlugin._selectedTable.querySelectorAll(".se-table-selected-cell");
        for (let i = 0, len = selectedCells.length; i < len; i++) {
          this.util.removeClass(selectedCells[i], "se-table-selected-cell");
        }
      }
      tablePlugin._toggleEditor.call(this, true);
      contextTable._element = null;
      contextTable._tdElement = null;
      contextTable._trElement = null;
      contextTable._trElements = null;
      contextTable._tableXY = [];
      contextTable._maxWidth = true;
      contextTable._fixedColumn = false;
      contextTable._physical_cellCnt = 0;
      contextTable._logical_cellCnt = 0;
      contextTable._rowCnt = 0;
      contextTable._rowIndex = 0;
      contextTable._physical_cellIndex = 0;
      contextTable._logical_cellIndex = 0;
      contextTable._current_colSpan = 0;
      contextTable._current_rowSpan = 0;
      tablePlugin._shift = false;
      tablePlugin._selectedCells = null;
      tablePlugin._selectedTable = null;
      tablePlugin._ref = null;
      tablePlugin._fixedCell = null;
      tablePlugin._selectedCell = null;
      tablePlugin._fixedCellName = null;
    },
    /** table edit controller */
    call_controller_tableEdit: function(tdElement) {
      const tablePlugin = this.plugins.table;
      const contextTable = this.context.table;
      if (!this.getSelection().isCollapsed && !tablePlugin._selectedCell) {
        this.controllersOff();
        this.util.removeClass(tdElement, "se-table-selected-cell");
        return;
      }
      const tableElement = contextTable._element || this.plugins.table._selectedTable || this.util.getParentElement(tdElement, "TABLE");
      contextTable._maxWidth = this.util.hasClass(tableElement, "se-table-size-100") || tableElement.style.width === "100%" || !tableElement.style.width && !this.util.hasClass(tableElement, "se-table-size-auto");
      contextTable._fixedColumn = this.util.hasClass(tableElement, "se-table-layout-fixed") || tableElement.style.tableLayout === "fixed";
      tablePlugin.setTableStyle.call(this, contextTable._maxWidth ? "width|column" : "width");
      tablePlugin.setPositionControllerTop.call(this, tableElement);
      tablePlugin.setPositionControllerDiv.call(this, tdElement, tablePlugin._shift);
      if (!tablePlugin._shift) this.controllersOn(contextTable.resizeDiv, contextTable.tableController, tablePlugin.init.bind(this), tdElement, "table");
    },
    setPositionControllerTop: function(tableElement) {
      this.setControllerPosition(this.context.table.tableController, tableElement, "top", { left: 0, top: 0 });
    },
    setPositionControllerDiv: function(tdElement, reset) {
      const contextTable = this.context.table;
      const resizeDiv = contextTable.resizeDiv;
      this.plugins.table.setCellInfo.call(this, tdElement, reset);
      if (contextTable.cellControllerTop) {
        this.setControllerPosition(resizeDiv, contextTable._element, "top", { left: contextTable.tableController.offsetWidth, top: 0 });
      } else {
        this.setControllerPosition(resizeDiv, tdElement, "bottom", { left: 0, top: 0 });
      }
    },
    setCellInfo: function(tdElement, reset) {
      const contextTable = this.context.table;
      const table = contextTable._element = this.plugins.table._selectedTable || this.util.getParentElement(tdElement, "TABLE");
      if (/THEAD/i.test(table.firstElementChild.nodeName)) {
        this.util.addClass(contextTable.headerButton, "active");
      } else {
        this.util.removeClass(contextTable.headerButton, "active");
      }
      if (reset || contextTable._physical_cellCnt === 0) {
        if (contextTable._tdElement !== tdElement) {
          contextTable._tdElement = tdElement;
          contextTable._trElement = tdElement.parentNode;
        }
        const rows = contextTable._trElements = table.rows;
        const cellIndex = tdElement.cellIndex;
        let cellCnt = 0;
        for (let i = 0, cells = rows[0].cells, len = rows[0].cells.length; i < len; i++) {
          cellCnt += cells[i].colSpan;
        }
        const rowIndex = contextTable._rowIndex = contextTable._trElement.rowIndex;
        contextTable._rowCnt = rows.length;
        contextTable._physical_cellCnt = contextTable._trElement.cells.length;
        contextTable._logical_cellCnt = cellCnt;
        contextTable._physical_cellIndex = cellIndex;
        contextTable._current_colSpan = contextTable._tdElement.colSpan - 1;
        contextTable._current_rowSpan - contextTable._trElement.cells[cellIndex].rowSpan - 1;
        let rowSpanArr = [];
        let spanIndex = [];
        for (let i = 0, cells, colSpan; i <= rowIndex; i++) {
          cells = rows[i].cells;
          colSpan = 0;
          for (let c = 0, cLen = cells.length, cell, cs, rs, logcalIndex; c < cLen; c++) {
            cell = cells[c];
            cs = cell.colSpan - 1;
            rs = cell.rowSpan - 1;
            logcalIndex = c + colSpan;
            if (spanIndex.length > 0) {
              for (let r = 0, arr; r < spanIndex.length; r++) {
                arr = spanIndex[r];
                if (arr.row > i) continue;
                if (logcalIndex >= arr.index) {
                  colSpan += arr.cs;
                  logcalIndex += arr.cs;
                  arr.rs -= 1;
                  arr.row = i + 1;
                  if (arr.rs < 1) {
                    spanIndex.splice(r, 1);
                    r--;
                  }
                } else if (c === cLen - 1) {
                  arr.rs -= 1;
                  arr.row = i + 1;
                  if (arr.rs < 1) {
                    spanIndex.splice(r, 1);
                    r--;
                  }
                }
              }
            }
            if (i === rowIndex && c === cellIndex) {
              contextTable._logical_cellIndex = logcalIndex;
              break;
            }
            if (rs > 0) {
              rowSpanArr.push({
                index: logcalIndex,
                cs: cs + 1,
                rs,
                row: -1
              });
            }
            colSpan += cs;
          }
          spanIndex = spanIndex.concat(rowSpanArr).sort(function(a, b) {
            return a.index - b.index;
          });
          rowSpanArr = [];
        }
        rowSpanArr = null;
        spanIndex = null;
      }
    },
    editTable: function(type, option) {
      const tablePlugin = this.plugins.table;
      const contextTable = this.context.table;
      const table = contextTable._element;
      const isRow = type === "row";
      if (isRow) {
        const tableAttr = contextTable._trElement.parentNode;
        if (/^THEAD$/i.test(tableAttr.nodeName)) {
          if (option === "up") {
            return;
          } else if (!tableAttr.nextElementSibling || !/^TBODY$/i.test(tableAttr.nextElementSibling.nodeName)) {
            table.innerHTML += "<tbody><tr>" + tablePlugin.createCells.call(this, "td", contextTable._logical_cellCnt, false) + "</tr></tbody>";
            return;
          }
        }
      }
      if (tablePlugin._ref) {
        const positionCell = contextTable._tdElement;
        const selectedCells = tablePlugin._selectedCells;
        if (isRow) {
          if (!option) {
            let row = selectedCells[0].parentNode;
            const removeCells = [selectedCells[0]];
            for (let i = 1, len = selectedCells.length, cell; i < len; i++) {
              cell = selectedCells[i];
              if (row !== cell.parentNode) {
                removeCells.push(cell);
                row = cell.parentNode;
              }
            }
            for (let i = 0, len = removeCells.length; i < len; i++) {
              tablePlugin.setCellInfo.call(this, removeCells[i], true);
              tablePlugin.editRow.call(this, option);
            }
          } else {
            tablePlugin.setCellInfo.call(this, option === "up" ? selectedCells[0] : selectedCells[selectedCells.length - 1], true);
            tablePlugin.editRow.call(this, option, positionCell);
          }
        } else {
          const firstRow = selectedCells[0].parentNode;
          if (!option) {
            const removeCells = [selectedCells[0]];
            for (let i = 1, len = selectedCells.length, cell; i < len; i++) {
              cell = selectedCells[i];
              if (firstRow === cell.parentNode) {
                removeCells.push(cell);
              } else {
                break;
              }
            }
            for (let i = 0, len = removeCells.length; i < len; i++) {
              tablePlugin.setCellInfo.call(this, removeCells[i], true);
              tablePlugin.editCell.call(this, option);
            }
          } else {
            let rightCell = null;
            for (let i = 0, len = selectedCells.length - 1; i < len; i++) {
              if (firstRow !== selectedCells[i + 1].parentNode) {
                rightCell = selectedCells[i];
                break;
              }
            }
            tablePlugin.setCellInfo.call(this, option === "left" ? selectedCells[0] : rightCell || selectedCells[0], true);
            tablePlugin.editCell.call(this, option, positionCell);
          }
        }
        if (!option) tablePlugin.init.call(this);
      } else {
        tablePlugin[isRow ? "editRow" : "editCell"].call(this, option);
      }
      if (!option) {
        const children2 = table.children;
        for (let i = 0; i < children2.length; i++) {
          if (children2[i].children.length === 0) {
            this.util.removeItem(children2[i]);
            i--;
          }
        }
        if (table.children.length === 0) this.util.removeItem(table);
      }
    },
    editRow: function(option, positionResetElement) {
      const contextTable = this.context.table;
      const remove = !option;
      const up = option === "up";
      const originRowIndex = contextTable._rowIndex;
      const rowIndex = remove || up ? originRowIndex : originRowIndex + contextTable._current_rowSpan + 1;
      const sign = remove ? -1 : 1;
      const rows = contextTable._trElements;
      let cellCnt = contextTable._logical_cellCnt;
      for (let i = 0, len = originRowIndex + (remove ? -1 : 0), cell; i <= len; i++) {
        cell = rows[i].cells;
        if (cell.length === 0) return;
        for (let c = 0, cLen = cell.length, rs, cs; c < cLen; c++) {
          rs = cell[c].rowSpan;
          cs = cell[c].colSpan;
          if (rs < 2 && cs < 2) continue;
          if (rs + i > rowIndex && rowIndex > i) {
            cell[c].rowSpan = rs + sign;
            cellCnt -= cs;
          }
        }
      }
      if (remove) {
        const next = rows[originRowIndex + 1];
        if (next) {
          const spanCells = [];
          let cells = rows[originRowIndex].cells;
          let colSpan = 0;
          for (let i = 0, len = cells.length, cell, logcalIndex; i < len; i++) {
            cell = cells[i];
            logcalIndex = i + colSpan;
            colSpan += cell.colSpan - 1;
            if (cell.rowSpan > 1) {
              cell.rowSpan -= 1;
              spanCells.push({ cell: cell.cloneNode(false), index: logcalIndex });
            }
          }
          if (spanCells.length > 0) {
            let spanCell = spanCells.shift();
            cells = next.cells;
            colSpan = 0;
            for (let i = 0, len = cells.length, cell, logcalIndex; i < len; i++) {
              cell = cells[i];
              logcalIndex = i + colSpan;
              colSpan += cell.colSpan - 1;
              if (logcalIndex >= spanCell.index) {
                i--, colSpan--;
                colSpan += spanCell.cell.colSpan - 1;
                next.insertBefore(spanCell.cell, cell);
                spanCell = spanCells.shift();
                if (!spanCell) break;
              }
            }
            if (spanCell) {
              next.appendChild(spanCell.cell);
              for (let i = 0, len = spanCells.length; i < len; i++) {
                next.appendChild(spanCells[i].cell);
              }
            }
          }
        }
        contextTable._element.deleteRow(rowIndex);
      } else {
        const newRow = contextTable._element.insertRow(rowIndex);
        newRow.innerHTML = this.plugins.table.createCells.call(this, "td", cellCnt, false);
      }
      if (!remove) {
        this.plugins.table.setPositionControllerDiv.call(this, positionResetElement || contextTable._tdElement, true);
      } else {
        this.controllersOff();
      }
    },
    editCell: function(option, positionResetElement) {
      const contextTable = this.context.table;
      const util2 = this.util;
      const remove = !option;
      const left = option === "left";
      const colSpan = contextTable._current_colSpan;
      const cellIndex = remove || left ? contextTable._logical_cellIndex : contextTable._logical_cellIndex + colSpan + 1;
      const rows = contextTable._trElements;
      let rowSpanArr = [];
      let spanIndex = [];
      let passCell = 0;
      const removeCell = [];
      const removeSpanArr = [];
      for (let i = 0, len = contextTable._rowCnt, row, insertIndex, cells, newCell, applySpan, cellColSpan; i < len; i++) {
        row = rows[i];
        insertIndex = cellIndex;
        applySpan = false;
        cells = row.cells;
        cellColSpan = 0;
        for (let c = 0, cell, cLen = cells.length, rs, cs, removeIndex; c < cLen; c++) {
          cell = cells[c];
          if (!cell) break;
          rs = cell.rowSpan - 1;
          cs = cell.colSpan - 1;
          if (!remove) {
            if (c >= insertIndex) break;
            if (cs > 0) {
              if (passCell < 1 && cs + c >= insertIndex) {
                cell.colSpan += 1;
                insertIndex = null;
                passCell = rs + 1;
                break;
              }
              insertIndex -= cs;
            }
            if (!applySpan) {
              for (let r = 0, arr; r < spanIndex.length; r++) {
                arr = spanIndex[r];
                insertIndex -= arr.cs;
                arr.rs -= 1;
                if (arr.rs < 1) {
                  spanIndex.splice(r, 1);
                  r--;
                }
              }
              applySpan = true;
            }
          } else {
            removeIndex = c + cellColSpan;
            if (spanIndex.length > 0) {
              const lastCell = !cells[c + 1];
              for (let r = 0, arr; r < spanIndex.length; r++) {
                arr = spanIndex[r];
                if (arr.row > i) continue;
                if (removeIndex >= arr.index) {
                  cellColSpan += arr.cs;
                  removeIndex = c + cellColSpan;
                  arr.rs -= 1;
                  arr.row = i + 1;
                  if (arr.rs < 1) {
                    spanIndex.splice(r, 1);
                    r--;
                  }
                } else if (lastCell) {
                  arr.rs -= 1;
                  arr.row = i + 1;
                  if (arr.rs < 1) {
                    spanIndex.splice(r, 1);
                    r--;
                  }
                }
              }
            }
            if (rs > 0) {
              rowSpanArr.push({
                rs,
                cs: cs + 1,
                index: removeIndex,
                row: -1
              });
            }
            if (removeIndex >= insertIndex && removeIndex + cs <= insertIndex + colSpan) {
              removeCell.push(cell);
            } else if (removeIndex <= insertIndex + colSpan && removeIndex + cs >= insertIndex) {
              cell.colSpan -= util2.getOverlapRangeAtIndex(cellIndex, cellIndex + colSpan, removeIndex, removeIndex + cs);
            } else if (rs > 0 && (removeIndex < insertIndex || removeIndex + cs > insertIndex + colSpan)) {
              removeSpanArr.push({
                cell,
                i,
                rs: i + rs
              });
            }
            cellColSpan += cs;
          }
        }
        spanIndex = spanIndex.concat(rowSpanArr).sort(function(a, b) {
          return a.index - b.index;
        });
        rowSpanArr = [];
        if (!remove) {
          if (passCell > 0) {
            passCell -= 1;
            continue;
          }
          if (insertIndex !== null && cells.length > 0) {
            newCell = this.plugins.table.createCells.call(this, cells[0].nodeName, 0, true);
            newCell = row.insertBefore(newCell, cells[insertIndex]);
          }
        }
      }
      if (remove) {
        let removeFirst, removeEnd;
        for (let r = 0, rLen = removeCell.length, row; r < rLen; r++) {
          row = removeCell[r].parentNode;
          util2.removeItem(removeCell[r]);
          if (row.cells.length === 0) {
            if (!removeFirst) removeFirst = util2.getArrayIndex(rows, row);
            removeEnd = util2.getArrayIndex(rows, row);
            util2.removeItem(row);
          }
        }
        for (let c = 0, cLen = removeSpanArr.length, rowSpanCell; c < cLen; c++) {
          rowSpanCell = removeSpanArr[c];
          rowSpanCell.cell.rowSpan = util2.getOverlapRangeAtIndex(removeFirst, removeEnd, rowSpanCell.i, rowSpanCell.rs);
        }
        this.controllersOff();
      } else {
        this.plugins.table.setPositionControllerDiv.call(this, positionResetElement || contextTable._tdElement, true);
      }
    },
    _closeSplitMenu: null,
    openSplitMenu: function() {
      this.util.addClass(this.context.table.splitButton, "on");
      this.context.table.splitMenu.style.display = "inline-table";
      this.plugins.table._closeSplitMenu = function() {
        this.util.removeClass(this.context.table.splitButton, "on");
        this.context.table.splitMenu.style.display = "none";
        this.removeDocEvent("click", this.plugins.table._closeSplitMenu);
        this.plugins.table._closeSplitMenu = null;
      }.bind(this);
      this.addDocEvent("click", this.plugins.table._closeSplitMenu);
    },
    splitCells: function(direction) {
      const util2 = this.util;
      const vertical = direction === "vertical";
      const contextTable = this.context.table;
      const currentCell = contextTable._tdElement;
      const rows = contextTable._trElements;
      const currentRow = contextTable._trElement;
      const index = contextTable._logical_cellIndex;
      const rowIndex = contextTable._rowIndex;
      const newCell = this.plugins.table.createCells.call(this, currentCell.nodeName, 0, true);
      if (vertical) {
        const currentColSpan = currentCell.colSpan;
        newCell.rowSpan = currentCell.rowSpan;
        if (currentColSpan > 1) {
          newCell.colSpan = this._w.Math.floor(currentColSpan / 2);
          currentCell.colSpan = currentColSpan - newCell.colSpan;
          currentRow.insertBefore(newCell, currentCell.nextElementSibling);
        } else {
          let rowSpanArr = [];
          let spanIndex = [];
          for (let i = 0, len = contextTable._rowCnt, cells, colSpan; i < len; i++) {
            cells = rows[i].cells;
            colSpan = 0;
            for (let c = 0, cLen = cells.length, cell, cs, rs, logcalIndex; c < cLen; c++) {
              cell = cells[c];
              cs = cell.colSpan - 1;
              rs = cell.rowSpan - 1;
              logcalIndex = c + colSpan;
              if (spanIndex.length > 0) {
                for (let r = 0, arr; r < spanIndex.length; r++) {
                  arr = spanIndex[r];
                  if (arr.row > i) continue;
                  if (logcalIndex >= arr.index) {
                    colSpan += arr.cs;
                    logcalIndex += arr.cs;
                    arr.rs -= 1;
                    arr.row = i + 1;
                    if (arr.rs < 1) {
                      spanIndex.splice(r, 1);
                      r--;
                    }
                  } else if (c === cLen - 1) {
                    arr.rs -= 1;
                    arr.row = i + 1;
                    if (arr.rs < 1) {
                      spanIndex.splice(r, 1);
                      r--;
                    }
                  }
                }
              }
              if (logcalIndex <= index && rs > 0) {
                rowSpanArr.push({
                  index: logcalIndex,
                  cs: cs + 1,
                  rs,
                  row: -1
                });
              }
              if (cell !== currentCell && logcalIndex <= index && logcalIndex + cs >= index + currentColSpan - 1) {
                cell.colSpan += 1;
                break;
              }
              if (logcalIndex > index) break;
              colSpan += cs;
            }
            spanIndex = spanIndex.concat(rowSpanArr).sort(function(a, b) {
              return a.index - b.index;
            });
            rowSpanArr = [];
          }
          currentRow.insertBefore(newCell, currentCell.nextElementSibling);
        }
      } else {
        const currentRowSpan = currentCell.rowSpan;
        newCell.colSpan = currentCell.colSpan;
        if (currentRowSpan > 1) {
          newCell.rowSpan = this._w.Math.floor(currentRowSpan / 2);
          const newRowSpan = currentRowSpan - newCell.rowSpan;
          const rowSpanArr = [];
          const nextRowIndex = util2.getArrayIndex(rows, currentRow) + newRowSpan;
          for (let i = 0, cells, colSpan; i < nextRowIndex; i++) {
            cells = rows[i].cells;
            colSpan = 0;
            for (let c = 0, cLen = cells.length, cell, cs, logcalIndex; c < cLen; c++) {
              logcalIndex = c + colSpan;
              if (logcalIndex >= index) break;
              cell = cells[c];
              cs = cell.rowSpan - 1;
              if (cs > 0 && cs + i >= nextRowIndex && logcalIndex < index) {
                rowSpanArr.push({
                  index: logcalIndex,
                  cs: cell.colSpan
                });
              }
              colSpan += cell.colSpan - 1;
            }
          }
          const nextRow = rows[nextRowIndex];
          const nextCells = nextRow.cells;
          let rs = rowSpanArr.shift();
          for (let c = 0, cLen = nextCells.length, colSpan = 0, cell, cs, logcalIndex, insertIndex; c < cLen; c++) {
            logcalIndex = c + colSpan;
            cell = nextCells[c];
            cs = cell.colSpan - 1;
            insertIndex = logcalIndex + cs + 1;
            if (rs && insertIndex >= rs.index) {
              colSpan += rs.cs;
              insertIndex += rs.cs;
              rs = rowSpanArr.shift();
            }
            if (insertIndex >= index || c === cLen - 1) {
              nextRow.insertBefore(newCell, cell.nextElementSibling);
              break;
            }
            colSpan += cs;
          }
          currentCell.rowSpan = newRowSpan;
        } else {
          newCell.rowSpan = currentCell.rowSpan;
          const newRow = util2.createElement("TR");
          newRow.appendChild(newCell);
          for (let i = 0, cells2; i < rowIndex; i++) {
            cells2 = rows[i].cells;
            if (cells2.length === 0) return;
            for (let c = 0, cLen = cells2.length; c < cLen; c++) {
              if (i + cells2[c].rowSpan - 1 >= rowIndex) {
                cells2[c].rowSpan += 1;
              }
            }
          }
          const physicalIndex = contextTable._physical_cellIndex;
          const cells = currentRow.cells;
          for (let c = 0, cLen = cells.length; c < cLen; c++) {
            if (c === physicalIndex) continue;
            cells[c].rowSpan += 1;
          }
          currentRow.parentNode.insertBefore(newRow, currentRow.nextElementSibling);
        }
      }
      this.focusEdge(currentCell);
      this.plugins.table.setPositionControllerDiv.call(this, currentCell, true);
    },
    mergeCells: function() {
      const tablePlugin = this.plugins.table;
      const contextTable = this.context.table;
      const util2 = this.util;
      const ref = tablePlugin._ref;
      const selectedCells = tablePlugin._selectedCells;
      const mergeCell = selectedCells[0];
      let emptyRowFirst = null;
      let emptyRowLast = null;
      let cs = ref.ce - ref.cs + 1;
      let rs = ref.re - ref.rs + 1;
      let mergeHTML = "";
      let row = null;
      for (let i = 1, len = selectedCells.length, cell, ch; i < len; i++) {
        cell = selectedCells[i];
        if (row !== cell.parentNode) row = cell.parentNode;
        ch = cell.children;
        for (let c = 0, cLen = ch.length; c < cLen; c++) {
          if (util2.isFormatElement(ch[c]) && util2.onlyZeroWidthSpace(ch[c].textContent)) {
            util2.removeItem(ch[c]);
          }
        }
        mergeHTML += cell.innerHTML;
        util2.removeItem(cell);
        if (row.cells.length === 0) {
          if (!emptyRowFirst) emptyRowFirst = row;
          else emptyRowLast = row;
          rs -= 1;
        }
      }
      if (emptyRowFirst) {
        const rows = contextTable._trElements;
        const rowIndexFirst = util2.getArrayIndex(rows, emptyRowFirst);
        const rowIndexLast = util2.getArrayIndex(rows, emptyRowLast || emptyRowFirst);
        const removeRows = [];
        for (let i = 0, cells; i <= rowIndexLast; i++) {
          cells = rows[i].cells;
          if (cells.length === 0) {
            removeRows.push(rows[i]);
            continue;
          }
          for (let c = 0, cLen = cells.length, cell, rs2; c < cLen; c++) {
            cell = cells[c];
            rs2 = cell.rowSpan - 1;
            if (rs2 > 0 && i + rs2 >= rowIndexFirst) {
              cell.rowSpan -= util2.getOverlapRangeAtIndex(rowIndexFirst, rowIndexLast, i, i + rs2);
            }
          }
        }
        for (let i = 0, len = removeRows.length; i < len; i++) {
          util2.removeItem(removeRows[i]);
        }
      }
      mergeCell.innerHTML += mergeHTML;
      mergeCell.colSpan = cs;
      mergeCell.rowSpan = rs;
      this.controllersOff();
      tablePlugin.setActiveButton.call(this, true, false);
      tablePlugin.call_controller_tableEdit.call(this, mergeCell);
      util2.addClass(mergeCell, "se-table-selected-cell");
      this.focusEdge(mergeCell);
    },
    toggleHeader: function() {
      const util2 = this.util;
      const headerButton = this.context.table.headerButton;
      const active = util2.hasClass(headerButton, "active");
      const table = this.context.table._element;
      if (!active) {
        const header = util2.createElement("THEAD");
        header.innerHTML = "<tr>" + this.plugins.table.createCells.call(this, "th", this.context.table._logical_cellCnt, false) + "</tr>";
        table.insertBefore(header, table.firstElementChild);
      } else {
        util2.removeItem(table.querySelector("thead"));
      }
      util2.toggleClass(headerButton, "active");
      if (/TH/i.test(this.context.table._tdElement.nodeName)) {
        this.controllersOff();
      } else {
        this.plugins.table.setPositionControllerDiv.call(this, this.context.table._tdElement, false);
      }
    },
    setTableStyle: function(styles) {
      const contextTable = this.context.table;
      const tableElement = contextTable._element;
      let icon, span, sizeIcon, text;
      if (styles.indexOf("width") > -1) {
        icon = contextTable.resizeButton.firstElementChild;
        span = contextTable.resizeText;
        if (!contextTable._maxWidth) {
          sizeIcon = contextTable.icons.expansion;
          text = contextTable.maxText;
          contextTable.columnFixedButton.style.display = "none";
          this.util.removeClass(tableElement, "se-table-size-100");
          this.util.addClass(tableElement, "se-table-size-auto");
        } else {
          sizeIcon = contextTable.icons.reduction;
          text = contextTable.minText;
          contextTable.columnFixedButton.style.display = "block";
          this.util.removeClass(tableElement, "se-table-size-auto");
          this.util.addClass(tableElement, "se-table-size-100");
        }
        this.util.changeElement(icon, sizeIcon);
        this.util.changeTxt(span, text);
      }
      if (styles.indexOf("column") > -1) {
        if (!contextTable._fixedColumn) {
          this.util.removeClass(tableElement, "se-table-layout-fixed");
          this.util.addClass(tableElement, "se-table-layout-auto");
          this.util.removeClass(contextTable.columnFixedButton, "active");
        } else {
          this.util.removeClass(tableElement, "se-table-layout-auto");
          this.util.addClass(tableElement, "se-table-layout-fixed");
          this.util.addClass(contextTable.columnFixedButton, "active");
        }
      }
    },
    setActiveButton: function(fixedCell, selectedCell) {
      const contextTable = this.context.table;
      if (/^TH$/i.test(fixedCell.nodeName)) {
        contextTable.insertRowAboveButton.setAttribute("disabled", true);
        contextTable.insertRowBelowButton.setAttribute("disabled", true);
      } else {
        contextTable.insertRowAboveButton.removeAttribute("disabled");
        contextTable.insertRowBelowButton.removeAttribute("disabled");
      }
      if (!selectedCell || fixedCell === selectedCell) {
        contextTable.splitButton.removeAttribute("disabled");
        contextTable.mergeButton.setAttribute("disabled", true);
      } else {
        contextTable.splitButton.setAttribute("disabled", true);
        contextTable.mergeButton.removeAttribute("disabled");
      }
    },
    // multi selecte
    _bindOnSelect: null,
    _bindOffSelect: null,
    _bindOffShift: null,
    _selectedCells: null,
    _shift: false,
    _fixedCell: null,
    _fixedCellName: null,
    _selectedCell: null,
    _selectedTable: null,
    _ref: null,
    _toggleEditor: function(enabled) {
      this.context.element.wysiwyg.setAttribute("contenteditable", enabled);
      if (enabled) this.util.removeClass(this.context.element.wysiwyg, "se-disabled");
      else this.util.addClass(this.context.element.wysiwyg, "se-disabled");
    },
    _offCellMultiSelect: function(e) {
      e.stopPropagation();
      const tablePlugin = this.plugins.table;
      if (!tablePlugin._shift) {
        tablePlugin._removeEvents.call(this);
        tablePlugin._toggleEditor.call(this, true);
      } else if (tablePlugin._initBind) {
        this._wd.removeEventListener("touchmove", tablePlugin._initBind);
        tablePlugin._initBind = null;
      }
      if (!tablePlugin._fixedCell || !tablePlugin._selectedTable) return;
      tablePlugin.setActiveButton.call(this, tablePlugin._fixedCell, tablePlugin._selectedCell);
      tablePlugin.call_controller_tableEdit.call(this, tablePlugin._selectedCell || tablePlugin._fixedCell);
      tablePlugin._selectedCells = tablePlugin._selectedTable.querySelectorAll(".se-table-selected-cell");
      if (tablePlugin._selectedCell && tablePlugin._fixedCell) this.focusEdge(tablePlugin._selectedCell);
      if (!tablePlugin._shift) {
        tablePlugin._fixedCell = null;
        tablePlugin._selectedCell = null;
        tablePlugin._fixedCellName = null;
      }
    },
    _onCellMultiSelect: function(e) {
      this._antiBlur = true;
      const tablePlugin = this.plugins.table;
      const target = this.util.getParentElement(e.target, this.util.isCell);
      if (tablePlugin._shift) {
        if (target === tablePlugin._fixedCell) tablePlugin._toggleEditor.call(this, true);
        else tablePlugin._toggleEditor.call(this, false);
      } else if (!tablePlugin._ref) {
        if (target === tablePlugin._fixedCell) return;
        else tablePlugin._toggleEditor.call(this, false);
      }
      if (!target || target === tablePlugin._selectedCell || tablePlugin._fixedCellName !== target.nodeName || tablePlugin._selectedTable !== this.util.getParentElement(target, "TABLE")) {
        return;
      }
      tablePlugin._selectedCell = target;
      tablePlugin._setMultiCells.call(this, tablePlugin._fixedCell, target);
    },
    _setMultiCells: function(startCell, endCell) {
      const tablePlugin = this.plugins.table;
      const rows = tablePlugin._selectedTable.rows;
      const util2 = this.util;
      const selectedCells = tablePlugin._selectedTable.querySelectorAll(".se-table-selected-cell");
      for (let i = 0, len = selectedCells.length; i < len; i++) {
        util2.removeClass(selectedCells[i], "se-table-selected-cell");
      }
      if (startCell === endCell) {
        util2.addClass(startCell, "se-table-selected-cell");
        if (!tablePlugin._shift) return;
      }
      let findSelectedCell = true;
      let spanIndex = [];
      let rowSpanArr = [];
      const ref = tablePlugin._ref = { _i: 0, cs: null, ce: null, rs: null, re: null };
      for (let i = 0, len = rows.length, cells, colSpan; i < len; i++) {
        cells = rows[i].cells;
        colSpan = 0;
        for (let c = 0, cLen = cells.length, cell, logcalIndex, cs, rs; c < cLen; c++) {
          cell = cells[c];
          cs = cell.colSpan - 1;
          rs = cell.rowSpan - 1;
          logcalIndex = c + colSpan;
          if (spanIndex.length > 0) {
            for (let r = 0, arr; r < spanIndex.length; r++) {
              arr = spanIndex[r];
              if (arr.row > i) continue;
              if (logcalIndex >= arr.index) {
                colSpan += arr.cs;
                logcalIndex += arr.cs;
                arr.rs -= 1;
                arr.row = i + 1;
                if (arr.rs < 1) {
                  spanIndex.splice(r, 1);
                  r--;
                }
              } else if (c === cLen - 1) {
                arr.rs -= 1;
                arr.row = i + 1;
                if (arr.rs < 1) {
                  spanIndex.splice(r, 1);
                  r--;
                }
              }
            }
          }
          if (findSelectedCell) {
            if (cell === startCell || cell === endCell) {
              ref.cs = ref.cs !== null && ref.cs < logcalIndex ? ref.cs : logcalIndex;
              ref.ce = ref.ce !== null && ref.ce > logcalIndex + cs ? ref.ce : logcalIndex + cs;
              ref.rs = ref.rs !== null && ref.rs < i ? ref.rs : i;
              ref.re = ref.re !== null && ref.re > i + rs ? ref.re : i + rs;
              ref._i += 1;
            }
            if (ref._i === 2) {
              findSelectedCell = false;
              spanIndex = [];
              rowSpanArr = [];
              i = -1;
              break;
            }
          } else if (util2.getOverlapRangeAtIndex(ref.cs, ref.ce, logcalIndex, logcalIndex + cs) && util2.getOverlapRangeAtIndex(ref.rs, ref.re, i, i + rs)) {
            const newCs = ref.cs < logcalIndex ? ref.cs : logcalIndex;
            const newCe = ref.ce > logcalIndex + cs ? ref.ce : logcalIndex + cs;
            const newRs = ref.rs < i ? ref.rs : i;
            const newRe = ref.re > i + rs ? ref.re : i + rs;
            if (ref.cs !== newCs || ref.ce !== newCe || ref.rs !== newRs || ref.re !== newRe) {
              ref.cs = newCs;
              ref.ce = newCe;
              ref.rs = newRs;
              ref.re = newRe;
              i = -1;
              spanIndex = [];
              rowSpanArr = [];
              break;
            }
            util2.addClass(cell, "se-table-selected-cell");
          }
          if (rs > 0) {
            rowSpanArr.push({
              index: logcalIndex,
              cs: cs + 1,
              rs,
              row: -1
            });
          }
          colSpan += cell.colSpan - 1;
        }
        spanIndex = spanIndex.concat(rowSpanArr).sort(function(a, b) {
          return a.index - b.index;
        });
        rowSpanArr = [];
      }
    },
    _removeEvents: function() {
      const tablePlugin = this.plugins.table;
      if (tablePlugin._initBind) {
        this._wd.removeEventListener("touchmove", tablePlugin._initBind);
        tablePlugin._initBind = null;
      }
      if (tablePlugin._bindOnSelect) {
        this._wd.removeEventListener("mousedown", tablePlugin._bindOnSelect);
        this._wd.removeEventListener("mousemove", tablePlugin._bindOnSelect);
        tablePlugin._bindOnSelect = null;
      }
      if (tablePlugin._bindOffSelect) {
        this._wd.removeEventListener("mouseup", tablePlugin._bindOffSelect);
        tablePlugin._bindOffSelect = null;
      }
      if (tablePlugin._bindOffShift) {
        this._wd.removeEventListener("keyup", tablePlugin._bindOffShift);
        tablePlugin._bindOffShift = null;
      }
    },
    _initBind: null,
    onTableCellMultiSelect: function(tdElement, shift) {
      const tablePlugin = this.plugins.table;
      tablePlugin._removeEvents.call(this);
      this.controllersOff();
      tablePlugin._shift = shift;
      tablePlugin._fixedCell = tdElement;
      tablePlugin._fixedCellName = tdElement.nodeName;
      tablePlugin._selectedTable = this.util.getParentElement(tdElement, "TABLE");
      const selectedCells = tablePlugin._selectedTable.querySelectorAll(".se-table-selected-cell");
      for (let i = 0, len = selectedCells.length; i < len; i++) {
        this.util.removeClass(selectedCells[i], "se-table-selected-cell");
      }
      this.util.addClass(tdElement, "se-table-selected-cell");
      tablePlugin._bindOnSelect = tablePlugin._onCellMultiSelect.bind(this);
      tablePlugin._bindOffSelect = tablePlugin._offCellMultiSelect.bind(this);
      if (!shift) {
        this._wd.addEventListener("mousemove", tablePlugin._bindOnSelect, false);
      } else {
        tablePlugin._bindOffShift = function() {
          this.controllersOn(this.context.table.resizeDiv, this.context.table.tableController, this.plugins.table.init.bind(this), tdElement, "table");
          if (!tablePlugin._ref) this.controllersOff();
        }.bind(this);
        this._wd.addEventListener("keyup", tablePlugin._bindOffShift, false);
        this._wd.addEventListener("mousedown", tablePlugin._bindOnSelect, false);
      }
      this._wd.addEventListener("mouseup", tablePlugin._bindOffSelect, false);
      tablePlugin._initBind = tablePlugin.init.bind(this);
      this._wd.addEventListener("touchmove", tablePlugin._initBind, false);
    },
    onClick_tableController: function(e) {
      e.stopPropagation();
      const target = e.target.getAttribute("data-command") ? e.target : e.target.parentNode;
      if (target.getAttribute("disabled")) return;
      const command = target.getAttribute("data-command");
      const value = target.getAttribute("data-value");
      const option = target.getAttribute("data-option");
      const tablePlugin = this.plugins.table;
      if (typeof tablePlugin._closeSplitMenu === "function") {
        tablePlugin._closeSplitMenu();
        if (command === "onsplit") return;
      }
      if (!command) return;
      e.preventDefault();
      const contextTable = this.context.table;
      switch (command) {
        case "insert":
        case "delete":
          tablePlugin.editTable.call(this, value, option);
          break;
        case "header":
          tablePlugin.toggleHeader.call(this);
          break;
        case "onsplit":
          tablePlugin.openSplitMenu.call(this);
          break;
        case "split":
          tablePlugin.splitCells.call(this, value);
          break;
        case "merge":
          tablePlugin.mergeCells.call(this);
          break;
        case "resize":
          contextTable._maxWidth = !contextTable._maxWidth;
          tablePlugin.setTableStyle.call(this, "width");
          tablePlugin.setPositionControllerTop.call(this, contextTable._element);
          tablePlugin.setPositionControllerDiv.call(this, contextTable._tdElement, tablePlugin._shift);
          break;
        case "layout":
          contextTable._fixedColumn = !contextTable._fixedColumn;
          tablePlugin.setTableStyle.call(this, "column");
          tablePlugin.setPositionControllerTop.call(this, contextTable._element);
          tablePlugin.setPositionControllerDiv.call(this, contextTable._tdElement, tablePlugin._shift);
          break;
        case "remove":
          const emptyDiv = contextTable._element.parentNode;
          this.util.removeItem(contextTable._element);
          this.controllersOff();
          if (emptyDiv !== this.context.element.wysiwyg) this.util.removeItemAllParents(emptyDiv, function(current) {
            return current.childNodes.length === 0;
          }, null);
          this.focus();
      }
      this.history.push(false);
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/formatBlock.js
  var formatBlock_default = {
    name: "formatBlock",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.formatBlock = {
        targetText: targetElement.querySelector(".txt"),
        targetTooltip: targetElement.parentNode.querySelector(".se-tooltip-text"),
        _formatList: null,
        currentFormat: ""
      };
      let listDiv = this.setSubmenu(core);
      listDiv.querySelector("ul").addEventListener("click", this.pickUp.bind(core));
      context.formatBlock._formatList = listDiv.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null;
    },
    setSubmenu: function(core) {
      const option = core.options;
      const lang_toolbar = core.lang.toolbar;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer se-list-format";
      const defaultFormats = ["p", "div", "blockquote", "pre", "h1", "h2", "h3", "h4", "h5", "h6"];
      const formatList = !option.formats || option.formats.length === 0 ? defaultFormats : option.formats;
      let list2 = '<div class="se-list-inner"><ul class="se-list-basic">';
      for (let i = 0, len = formatList.length, format, tagName, command, name2, h, attrs, className; i < len; i++) {
        format = formatList[i];
        if (typeof format === "string" && defaultFormats.indexOf(format) > -1) {
          tagName = format.toLowerCase();
          command = tagName === "blockquote" ? "range" : tagName === "pre" ? "free" : "replace";
          h = /^h/.test(tagName) ? tagName.match(/\d+/)[0] : "";
          name2 = lang_toolbar["tag_" + (h ? "h" : tagName)] + h;
          className = "";
          attrs = "";
        } else {
          tagName = format.tag.toLowerCase();
          command = format.command;
          name2 = format.name || tagName;
          className = format.class;
          attrs = className ? ' class="' + className + '"' : "";
        }
        list2 += '<li><button type="button" class="se-btn-list" data-command="' + command + '" data-value="' + tagName + '" data-class="' + className + '" title="' + name2 + '" aria-label="' + name2 + '"><' + tagName + attrs + ">" + name2 + "</" + tagName + "></button></li>";
      }
      list2 += "</ul></div>";
      listDiv.innerHTML = list2;
      return listDiv;
    },
    /**
    * @Override core
    */
    active: function(element) {
      let formatTitle = this.lang.toolbar.formats;
      const target = this.context.formatBlock.targetText;
      if (!element) {
        this.util.changeTxt(target, formatTitle);
      } else if (this.util.isFormatElement(element)) {
        const formatContext = this.context.formatBlock;
        const formatList = formatContext._formatList;
        const nodeName = element.nodeName.toLowerCase();
        const className = (element.className.match(/(\s|^)__se__format__[^\s]+/) || [""])[0].trim();
        for (let i = 0, len = formatList.length, f; i < len; i++) {
          f = formatList[i];
          if (nodeName === f.getAttribute("data-value") && className === f.getAttribute("data-class")) {
            formatTitle = f.title;
            break;
          }
        }
        this.util.changeTxt(target, formatTitle);
        target.setAttribute("data-value", nodeName);
        target.setAttribute("data-class", className);
        return true;
      }
      return false;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const formatContext = this.context.formatBlock;
      const formatList = formatContext._formatList;
      const target = formatContext.targetText;
      const currentFormat = (target.getAttribute("data-value") || "") + (target.getAttribute("data-class") || "");
      if (currentFormat !== formatContext.currentFormat) {
        for (let i = 0, len = formatList.length, f; i < len; i++) {
          f = formatList[i];
          if (currentFormat === f.getAttribute("data-value") + f.getAttribute("data-class")) {
            this.util.addClass(f, "active");
          } else {
            this.util.removeClass(f, "active");
          }
        }
        formatContext.currentFormat = currentFormat;
      }
    },
    pickUp: function(e) {
      e.preventDefault();
      e.stopPropagation();
      let target = e.target;
      let command = null, value = null, tag2 = null, className = "";
      while (!command && !/UL/i.test(target.tagName)) {
        command = target.getAttribute("data-command");
        value = target.getAttribute("data-value");
        className = target.getAttribute("data-class");
        if (command) {
          tag2 = target.firstChild;
          break;
        }
        target = target.parentNode;
      }
      if (!command) return;
      if (command === "range") {
        const rangeElement = tag2.cloneNode(false);
        this.applyRangeFormatElement(rangeElement);
      } else {
        let range = this.getRange();
        let selectedFormsts = this.getSelectedElementsAndComponents(false);
        if (selectedFormsts.length === 0) {
          range = this.getRange_addLine(range, null);
          selectedFormsts = this.getSelectedElementsAndComponents(false);
          if (selectedFormsts.length === 0) return;
        }
        const startOffset = range.startOffset;
        const endOffset = range.endOffset;
        const util2 = this.util;
        let first = selectedFormsts[0];
        let last = selectedFormsts[selectedFormsts.length - 1];
        const firstPath = util2.getNodePath(range.startContainer, first, null, null);
        const lastPath = util2.getNodePath(range.endContainer, last, null, null);
        const rlist = this.detachList(selectedFormsts, false);
        if (rlist.sc) first = rlist.sc;
        if (rlist.ec) last = rlist.ec;
        this.setRange(util2.getNodeFromPath(firstPath, first), startOffset, util2.getNodeFromPath(lastPath, last), endOffset);
        const modifiedFormsts = this.getSelectedElementsAndComponents(false);
        if (command === "free") {
          const len = modifiedFormsts.length - 1;
          let parentNode = modifiedFormsts[len].parentNode;
          let freeElement = tag2.cloneNode(false);
          const focusElement = freeElement;
          for (let i = len, f, html2, before, next, inner, isComp, first2 = true; i >= 0; i--) {
            f = modifiedFormsts[i];
            if (f === (!modifiedFormsts[i + 1] ? null : modifiedFormsts[i + 1].parentNode)) continue;
            isComp = util2.isComponent(f);
            html2 = isComp ? "" : f.innerHTML.replace(/(?!>)\s+(?=<)|\n/g, " ");
            before = util2.getParentElement(f, function(current) {
              return current.parentNode === parentNode;
            });
            if (parentNode !== f.parentNode || isComp) {
              if (util2.isFormatElement(parentNode)) {
                parentNode.parentNode.insertBefore(freeElement, parentNode.nextSibling);
                parentNode = parentNode.parentNode;
              } else {
                parentNode.insertBefore(freeElement, before ? before.nextSibling : null);
                parentNode = f.parentNode;
              }
              next = freeElement.nextSibling;
              if (next && freeElement.nodeName === next.nodeName && util2.isSameAttributes(freeElement, next)) {
                freeElement.innerHTML += "<BR>" + next.innerHTML;
                util2.removeItem(next);
              }
              freeElement = tag2.cloneNode(false);
              first2 = true;
            }
            inner = freeElement.innerHTML;
            freeElement.innerHTML = (first2 || !html2 || !inner || /<br>$/i.test(html2) ? html2 : html2 + "<BR>") + inner;
            if (i === 0) {
              parentNode.insertBefore(freeElement, f);
              next = f.nextSibling;
              if (next && freeElement.nodeName === next.nodeName && util2.isSameAttributes(freeElement, next)) {
                freeElement.innerHTML += "<BR>" + next.innerHTML;
                util2.removeItem(next);
              }
              const prev = freeElement.previousSibling;
              if (prev && freeElement.nodeName === prev.nodeName && util2.isSameAttributes(freeElement, prev)) {
                prev.innerHTML += "<BR>" + freeElement.innerHTML;
                util2.removeItem(freeElement);
              }
            }
            if (!isComp) util2.removeItem(f);
            if (!!html2) first2 = false;
          }
          this.setRange(focusElement, 0, focusElement, 0);
        } else {
          for (let i = 0, len = modifiedFormsts.length, node, newFormat; i < len; i++) {
            node = modifiedFormsts[i];
            if ((node.nodeName.toLowerCase() !== value.toLowerCase() || (node.className.match(/(\s|^)__se__format__[^\s]+/) || [""])[0].trim() !== className) && !util2.isComponent(node)) {
              newFormat = tag2.cloneNode(false);
              util2.copyFormatAttributes(newFormat, node);
              newFormat.innerHTML = node.innerHTML;
              node.parentNode.replaceChild(newFormat, node);
            }
            if (i === 0) first = newFormat || node;
            if (i === len - 1) last = newFormat || node;
            newFormat = null;
          }
          this.setRange(util2.getNodeFromPath(firstPath, first), startOffset, util2.getNodeFromPath(lastPath, last), endOffset);
        }
        this.history.push(false);
      }
      this.submenuOff();
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/lineHeight.js
  var lineHeight_default = {
    name: "lineHeight",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.lineHeight = {
        _sizeList: null,
        currentSize: -1
      };
      let listDiv = this.setSubmenu(core);
      let listUl = listDiv.querySelector("ul");
      listUl.addEventListener("click", this.pickup.bind(core));
      context.lineHeight._sizeList = listUl.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null, listUl = null;
    },
    setSubmenu: function(core) {
      const option = core.options;
      const lang = core.lang;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer";
      const sizeList = !option.lineHeights ? [
        { text: "1", value: 1 },
        { text: "1.15", value: 1.15 },
        { text: "1.5", value: 1.5 },
        { text: "2", value: 2 }
      ] : option.lineHeights;
      let list2 = '<div class="se-list-inner"><ul class="se-list-basic"><li><button type="button" class="default_value se-btn-list" title="' + lang.toolbar.default + '" aria-label="' + lang.toolbar.default + '">(' + lang.toolbar.default + ")</button></li>";
      for (let i = 0, len = sizeList.length, size; i < len; i++) {
        size = sizeList[i];
        list2 += '<li><button type="button" class="se-btn-list" data-value="' + size.value + '" title="' + size.text + '" aria-label="' + size.text + '">' + size.text + "</button></li>";
      }
      list2 += "</ul></div>";
      listDiv.innerHTML = list2;
      return listDiv;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const lineHeightContext = this.context.lineHeight;
      const sizeList = lineHeightContext._sizeList;
      const format = this.util.getFormatElement(this.getSelectionNode());
      const currentSize = !format ? "" : format.style.lineHeight + "";
      if (currentSize !== lineHeightContext.currentSize) {
        for (let i = 0, len = sizeList.length; i < len; i++) {
          if (currentSize === sizeList[i].getAttribute("data-value")) {
            this.util.addClass(sizeList[i], "active");
          } else {
            this.util.removeClass(sizeList[i], "active");
          }
        }
        lineHeightContext.currentSize = currentSize;
      }
    },
    pickup: function(e) {
      if (!/^BUTTON$/i.test(e.target.tagName)) return false;
      e.preventDefault();
      e.stopPropagation();
      const value = e.target.getAttribute("data-value") || "";
      const formats = this.getSelectedElements();
      for (let i = 0, len = formats.length; i < len; i++) {
        formats[i].style.lineHeight = value;
      }
      this.submenuOff();
      this.history.push(false);
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/template.js
  var template_default = {
    name: "template",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.template = {
        selectedIndex: -1
      };
      let templateDiv = this.setSubmenu(core);
      templateDiv.querySelector("ul").addEventListener("click", this.pickup.bind(core));
      core.initMenuTarget(this.name, targetElement, templateDiv);
      templateDiv = null;
    },
    setSubmenu: function(core) {
      const templateList = core.options.templates;
      if (!templateList || templateList.length === 0) {
        throw Error('[SUNEDITOR.plugins.template.fail] To use the "template" plugin, please define the "templates" option.');
      }
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-list-layer";
      let list2 = '<div class="se-submenu se-list-inner"><ul class="se-list-basic">';
      for (let i = 0, len = templateList.length, t; i < len; i++) {
        t = templateList[i];
        list2 += '<li><button type="button" class="se-btn-list" data-value="' + i + '" title="' + t.name + '" aria-label="' + t.name + '">' + t.name + "</button></li>";
      }
      list2 += "</ul></div>";
      listDiv.innerHTML = list2;
      return listDiv;
    },
    pickup: function(e) {
      if (!/^BUTTON$/i.test(e.target.tagName)) return false;
      e.preventDefault();
      e.stopPropagation();
      this.context.template.selectedIndex = e.target.getAttribute("data-value") * 1;
      const temp = this.options.templates[this.context.template.selectedIndex];
      if (temp.html) {
        this.setContents(temp.html);
      } else {
        this.submenuOff();
        throw Error('[SUNEDITOR.template.fail] cause : "templates[i].html not found"');
      }
      this.submenuOff();
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/paragraphStyle.js
  var paragraphStyle_default = {
    name: "paragraphStyle",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.paragraphStyle = {
        _classList: null
      };
      let listDiv = this.setSubmenu(core);
      listDiv.querySelector("ul").addEventListener("click", this.pickUp.bind(core));
      context.paragraphStyle._classList = listDiv.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null;
    },
    setSubmenu: function(core) {
      const option = core.options;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer se-list-format";
      const menuLang = core.lang.menu;
      const defaultList = {
        spaced: {
          name: menuLang.spaced,
          class: "__se__p-spaced",
          _class: ""
        },
        bordered: {
          name: menuLang.bordered,
          class: "__se__p-bordered",
          _class: ""
        },
        neon: {
          name: menuLang.neon,
          class: "__se__p-neon",
          _class: ""
        }
      };
      const paragraphStyles = !option.paragraphStyles || option.paragraphStyles.length === 0 ? ["spaced", "bordered", "neon"] : option.paragraphStyles;
      let list2 = '<div class="se-list-inner"><ul class="se-list-basic">';
      for (let i = 0, len = paragraphStyles.length, p, name2, attrs, _class; i < len; i++) {
        p = paragraphStyles[i];
        if (typeof p === "string") {
          const defaultStyle = defaultList[p.toLowerCase()];
          if (!defaultStyle) continue;
          p = defaultStyle;
        }
        name2 = p.name;
        attrs = p.class ? ' class="' + p.class + '"' : "";
        _class = p._class;
        list2 += '<li><button type="button" class="se-btn-list' + (_class ? " " + _class : "") + '" data-value="' + p.class + '" title="' + name2 + '" aria-label="' + name2 + '"><div' + attrs + ">" + name2 + "</div></button></li>";
      }
      list2 += "</ul></div>";
      listDiv.innerHTML = list2;
      return listDiv;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const paragraphContext = this.context.paragraphStyle;
      const paragraphList = paragraphContext._classList;
      const currentFormat = this.util.getFormatElement(this.getSelectionNode());
      for (let i = 0, len = paragraphList.length; i < len; i++) {
        if (this.util.hasClass(currentFormat, paragraphList[i].getAttribute("data-value"))) {
          this.util.addClass(paragraphList[i], "active");
        } else {
          this.util.removeClass(paragraphList[i], "active");
        }
      }
    },
    pickUp: function(e) {
      e.preventDefault();
      e.stopPropagation();
      let target = e.target;
      let value = null;
      while (!/^UL$/i.test(target.tagName)) {
        value = target.getAttribute("data-value");
        if (value) break;
        target = target.parentNode;
      }
      if (!value) return;
      let selectedFormsts = this.getSelectedElements();
      if (selectedFormsts.length === 0) {
        this.getRange_addLine(this.getRange(), null);
        selectedFormsts = this.getSelectedElements();
        if (selectedFormsts.length === 0) return;
      }
      const toggleClass = this.util.hasClass(target, "active") ? this.util.removeClass.bind(this.util) : this.util.addClass.bind(this.util);
      for (let i = 0, len = selectedFormsts.length; i < len; i++) {
        toggleClass(selectedFormsts[i], value);
      }
      this.submenuOff();
      this.history.push(false);
    }
  };

  // ../../node_modules/suneditor/src/plugins/submenu/textStyle.js
  var textStyle_default = {
    name: "textStyle",
    display: "submenu",
    add: function(core, targetElement) {
      const context = core.context;
      context.textStyle = {
        _styleList: null
      };
      let listDiv = this.setSubmenu(core);
      let listUl = listDiv.querySelector("ul");
      listUl.addEventListener("click", this.pickup.bind(core));
      context.textStyle._styleList = listDiv.querySelectorAll("li button");
      core.initMenuTarget(this.name, targetElement, listDiv);
      listDiv = null, listUl = null;
    },
    setSubmenu: function(core) {
      const option = core.options;
      const listDiv = core.util.createElement("DIV");
      listDiv.className = "se-submenu se-list-layer se-list-format";
      const defaultList = {
        code: {
          name: core.lang.menu.code,
          class: "__se__t-code",
          tag: "code"
        },
        translucent: {
          name: core.lang.menu.translucent,
          style: "opacity: 0.5;",
          tag: "span"
        },
        shadow: {
          name: core.lang.menu.shadow,
          class: "__se__t-shadow",
          tag: "span"
        }
      };
      const styleList = !option.textStyles ? core._w.Object.keys(defaultList) : option.textStyles;
      let list2 = '<div class="se-list-inner"><ul class="se-list-basic">';
      for (let i = 0, len = styleList.length, t, tag2, name2, attrs, command, value, _class; i < len; i++) {
        t = styleList[i];
        attrs = "", value = "", command = [];
        if (typeof t === "string") {
          const defaultStyle = defaultList[t.toLowerCase()];
          if (!defaultStyle) continue;
          t = defaultStyle;
        }
        name2 = t.name;
        tag2 = t.tag || "span";
        _class = t._class;
        if (t.style) {
          attrs += ' style="' + t.style + '"';
          value += t.style.replace(/:[^;]+(;|$)\s*/g, ",");
          command.push("style");
        }
        if (t.class) {
          attrs += ' class="' + t.class + '"';
          value += "." + t.class.trim().replace(/\s+/g, ",.");
          command.push("class");
        }
        value = value.replace(/,$/, "");
        list2 += '<li><button type="button" class="se-btn-list' + (_class ? " " + _class : "") + '" data-command="' + tag2 + '" data-value="' + value + '" title="' + name2 + '" aria-label="' + name2 + '"><' + tag2 + attrs + ">" + name2 + "</" + tag2 + "></button></li>";
      }
      list2 += "</ul></div>";
      listDiv.innerHTML = list2;
      return listDiv;
    },
    /**
    * @Override submenu
    */
    on: function() {
      const util2 = this.util;
      const textStyleContext = this.context.textStyle;
      const styleButtonList = textStyleContext._styleList;
      const selectionNode = this.getSelectionNode();
      for (let i = 0, len = styleButtonList.length, btn, data2, active; i < len; i++) {
        btn = styleButtonList[i];
        data2 = btn.getAttribute("data-value").split(",");
        for (let v = 0, node, value; v < data2.length; v++) {
          node = selectionNode;
          active = false;
          while (node && !util2.isFormatElement(node) && !util2.isComponent(node)) {
            if (node.nodeName.toLowerCase() === btn.getAttribute("data-command").toLowerCase()) {
              value = data2[v];
              if (/^\./.test(value) ? util2.hasClass(node, value.replace(/^\./, "")) : !!node.style[value]) {
                active = true;
                break;
              }
            }
            node = node.parentNode;
          }
          if (!active) break;
        }
        active ? util2.addClass(btn, "active") : util2.removeClass(btn, "active");
      }
    },
    pickup: function(e) {
      e.preventDefault();
      e.stopPropagation();
      let target = e.target;
      let command = null, tag2 = null;
      while (!command && !/UL/i.test(target.tagName)) {
        command = target.getAttribute("data-command");
        if (command) {
          tag2 = target.firstChild;
          break;
        }
        target = target.parentNode;
      }
      if (!command) return;
      const checkStyles = tag2.style.cssText.replace(/:.+(;|$)/g, ",").split(",");
      checkStyles.pop();
      const classes = tag2.classList;
      for (let i = 0, len = classes.length; i < len; i++) {
        checkStyles.push("." + classes[i]);
      }
      const newNode = this.util.hasClass(target, "active") ? null : tag2.cloneNode(false);
      const removeNodes = newNode ? null : [tag2.nodeName];
      this.nodeChange(newNode, checkStyles, removeNodes, true);
      this.submenuOff();
    }
  };

  // ../../node_modules/suneditor/src/plugins/dialog/link.js
  var import_dialog = __toESM(require_dialog());

  // ../../node_modules/suneditor/src/plugins/modules/_selectMenu.js
  var selectMenu_default = {
    name: "selectMenu",
    add: function(core) {
      core.context.selectMenu = {
        caller: {},
        callerContext: null
      };
    },
    setForm: function() {
      return '<div class="se-select-list"></div>';
    },
    createList: function(listContext, items, html2) {
      listContext.form.innerHTML = "<ul>" + html2 + "</ul>";
      listContext.items = items;
      listContext.menus = listContext.form.querySelectorAll("li");
    },
    initEvent: function(pluginName, forms) {
      const form = forms.querySelector(".se-select-list");
      const context = this.context.selectMenu.caller[pluginName] = {
        form,
        items: [],
        menus: [],
        index: -1,
        item: null,
        clickMethod: null,
        callerName: pluginName
      };
      form.addEventListener("mousedown", this.plugins.selectMenu.onMousedown_list);
      form.addEventListener("mousemove", this.plugins.selectMenu.onMouseMove_list.bind(this, context));
      form.addEventListener("click", this.plugins.selectMenu.onClick_list.bind(this, context));
    },
    onMousedown_list: function(e) {
      e.preventDefault();
      e.stopPropagation();
    },
    onMouseMove_list: function(context, e) {
      this.util.addClass(context.form, "__se_select-menu-mouse-move");
      const index = e.target.getAttribute("data-index");
      if (!index) return;
      context.index = index * 1;
    },
    onClick_list: function(context, e) {
      const index = e.target.getAttribute("data-index");
      if (!index) return;
      context.clickMethod.call(this, context.items[index]);
    },
    moveItem: function(listContext, num) {
      this.util.removeClass(listContext.form, "__se_select-menu-mouse-move");
      num = listContext.index + num;
      const menus = listContext.menus;
      const len = menus.length;
      const selectIndex = listContext.index = num >= len ? 0 : num < 0 ? len - 1 : num;
      for (let i = 0; i < len; i++) {
        if (i === selectIndex) {
          this.util.addClass(menus[i], "active");
        } else {
          this.util.removeClass(menus[i], "active");
        }
      }
      listContext.item = listContext.items[selectIndex];
    },
    getItem: function(listContext, index) {
      index = !index || index < 0 ? listContext.index : index;
      return listContext.items[index];
    },
    on: function(callerName, clickMethod) {
      const listContext = this.context.selectMenu.caller[callerName];
      this.context.selectMenu.callerContext = listContext;
      listContext.clickMethod = clickMethod;
      listContext.callerName = callerName;
    },
    open: function(listContext, positionHandler) {
      const form = listContext.form;
      form.style.visibility = "hidden";
      form.style.display = "block";
      positionHandler(form);
      form.style.visibility = "";
    },
    close: function(listContext) {
      listContext.form.style.display = "none";
      listContext.items = [];
      listContext.menus = [];
      listContext.index = -1;
      listContext.item = null;
    },
    init: function(listContext) {
      if (!listContext) return;
      listContext.items = [];
      listContext.menus = [];
      listContext.index = -1;
      listContext.item = null;
      listContext.callerName = "";
      this.context.selectMenu.callerContext = null;
    }
  };

  // ../../node_modules/suneditor/src/plugins/modules/_anchor.js
  var anchor_default = {
    name: "anchor",
    add: function(core) {
      core.addModule([selectMenu_default]);
      core.context.anchor = {
        caller: {},
        forms: this.setDialogForm(core),
        host: (core._w.location.origin + core._w.location.pathname).replace(/\/$/, ""),
        callerContext: null
      };
    },
    /** dialog */
    setDialogForm: function(core) {
      const lang = core.lang;
      const relList = core.options.linkRel;
      const defaultRel = (core.options.linkRelDefault.default || "").split(" ");
      const icons = core.icons;
      const forms = core.util.createElement("DIV");
      let html2 = '<div class="se-dialog-body"><div class="se-dialog-form"><label>' + lang.dialogBox.linkBox.url + '</label><div class="se-dialog-form-files"><input class="se-input-form se-input-url" type="text" placeholder="' + (core.options.protocol || "") + '" /><button type="button" class="se-btn se-dialog-files-edge-button _se_bookmark_button" title="' + lang.dialogBox.linkBox.bookmark + '" aria-label="' + lang.dialogBox.linkBox.bookmark + '">' + icons.bookmark + "</button>" + core.plugins.selectMenu.setForm() + '</div><div class="se-anchor-preview-form"><span class="se-svg se-anchor-preview-icon _se_anchor_bookmark_icon">' + icons.bookmark + '</span><span class="se-svg se-anchor-preview-icon _se_anchor_download_icon">' + icons.download + '</span><pre class="se-link-preview"></pre></div></div><div class="se-dialog-form"><label>' + lang.dialogBox.linkBox.text + '</label><input class="se-input-form _se_anchor_text" type="text" /></div><div class="se-dialog-form-footer"><label><input type="checkbox" class="se-dialog-btn-check _se_anchor_check" />&nbsp;' + lang.dialogBox.linkBox.newWindowCheck + '</label><label><input type="checkbox" class="se-dialog-btn-check _se_anchor_download" />&nbsp;' + lang.dialogBox.linkBox.downloadLinkCheck + "</label>";
      if (relList.length > 0) {
        html2 += '<div class="se-anchor-rel"><button type="button" class="se-btn se-btn-select se-anchor-rel-btn">&lt;rel&gt;</button><div class="se-anchor-rel-wrapper"><pre class="se-link-preview se-anchor-rel-preview"></pre></div><div class="se-list-layer"><div class="se-list-inner"><ul class="se-list-basic se-list-checked">';
        for (let i = 0, len = relList.length, rel; i < len; i++) {
          rel = relList[i];
          html2 += '<li><button type="button" class="se-btn-list' + (defaultRel.indexOf(rel) > -1 ? " se-checked" : "") + '" data-command="' + rel + '" title="' + rel + '" aria-label="' + rel + '"><span class="se-svg">' + icons.checked + "</span>" + rel + "</button></li>";
        }
        html2 += "</ul></div></div></div>";
      }
      html2 += "</div></div>";
      forms.innerHTML = html2;
      return forms;
    },
    initEvent: function(pluginName, forms) {
      const anchorPlugin = this.plugins.anchor;
      const context = this.context.anchor.caller[pluginName] = {
        modal: forms,
        urlInput: null,
        linkDefaultRel: this.options.linkRelDefault,
        defaultRel: this.options.linkRelDefault.default || "",
        currentRel: [],
        linkAnchor: null,
        linkValue: "",
        _change: false,
        callerName: pluginName
      };
      if (typeof context.linkDefaultRel.default === "string") context.linkDefaultRel.default = context.linkDefaultRel.default.trim();
      if (typeof context.linkDefaultRel.check_new_window === "string") context.linkDefaultRel.check_new_window = context.linkDefaultRel.check_new_window.trim();
      if (typeof context.linkDefaultRel.check_bookmark === "string") context.linkDefaultRel.check_bookmark = context.linkDefaultRel.check_bookmark.trim();
      context.urlInput = forms.querySelector(".se-input-url");
      context.anchorText = forms.querySelector("._se_anchor_text");
      context.newWindowCheck = forms.querySelector("._se_anchor_check");
      context.downloadCheck = forms.querySelector("._se_anchor_download");
      context.download = forms.querySelector("._se_anchor_download_icon");
      context.preview = forms.querySelector(".se-link-preview");
      context.bookmark = forms.querySelector("._se_anchor_bookmark_icon");
      context.bookmarkButton = forms.querySelector("._se_bookmark_button");
      this.plugins.selectMenu.initEvent.call(this, pluginName, forms);
      const listContext = this.context.selectMenu.caller[pluginName];
      if (this.options.linkRel.length > 0) {
        context.relButton = forms.querySelector(".se-anchor-rel-btn");
        context.relList = forms.querySelector(".se-list-layer");
        context.relPreview = forms.querySelector(".se-anchor-rel-preview");
        context.relButton.addEventListener("click", anchorPlugin.onClick_relButton.bind(this, context));
        context.relList.addEventListener("click", anchorPlugin.onClick_relList.bind(this, context));
      }
      context.newWindowCheck.addEventListener("change", anchorPlugin.onChange_newWindowCheck.bind(this, context));
      context.downloadCheck.addEventListener("change", anchorPlugin.onChange_downloadCheck.bind(this, context));
      context.anchorText.addEventListener("input", anchorPlugin.onChangeAnchorText.bind(this, context));
      context.urlInput.addEventListener("input", anchorPlugin.onChangeUrlInput.bind(this, context));
      context.urlInput.addEventListener("keydown", anchorPlugin.onKeyDownUrlInput.bind(this, listContext));
      context.urlInput.addEventListener("focus", anchorPlugin.onFocusUrlInput.bind(this, context, listContext));
      context.urlInput.addEventListener("blur", anchorPlugin.onBlurUrlInput.bind(this, listContext));
      context.bookmarkButton.addEventListener("click", anchorPlugin.onClick_bookmarkButton.bind(this, context));
    },
    on: function(contextAnchor, update) {
      const anchorPlugin = this.plugins.anchor;
      if (!update) {
        anchorPlugin.init.call(this, contextAnchor);
        contextAnchor.anchorText.value = this.getSelection().toString().trim();
        contextAnchor.newWindowCheck.checked = this.options.linkTargetNewWindow;
      } else if (contextAnchor.linkAnchor) {
        this.context.dialog.updateModal = true;
        const href = contextAnchor.linkAnchor.getAttribute("href");
        contextAnchor.linkValue = contextAnchor.preview.textContent = contextAnchor.urlInput.value = anchorPlugin.selfPathBookmark.call(this, href) ? href.substr(href.lastIndexOf("#")) : href;
        contextAnchor.anchorText.value = contextAnchor.linkAnchor.textContent;
        contextAnchor.newWindowCheck.checked = /_blank/i.test(contextAnchor.linkAnchor.target) ? true : false;
        contextAnchor.downloadCheck.checked = contextAnchor.linkAnchor.download;
      }
      this.context.anchor.callerContext = contextAnchor;
      anchorPlugin.setRel.call(this, contextAnchor, update && contextAnchor.linkAnchor ? contextAnchor.linkAnchor.rel : contextAnchor.defaultRel);
      anchorPlugin.setLinkPreview.call(this, contextAnchor, contextAnchor.linkValue);
      this.plugins.selectMenu.on.call(this, contextAnchor.callerName, this.plugins.anchor.setHeaderBookmark);
    },
    selfPathBookmark: function(path) {
      const href = this._w.location.href.replace(/\/$/, "");
      return path.indexOf("#") === 0 || path.indexOf(href) === 0 && path.indexOf("#") === (href.indexOf("#") === -1 ? href.length : href.substr(0, href.indexOf("#")).length);
    },
    _closeRelMenu: null,
    toggleRelList: function(contextAnchor, show) {
      if (!show) {
        if (this.plugins.anchor._closeRelMenu) this.plugins.anchor._closeRelMenu();
      } else {
        const target = contextAnchor.relButton;
        const relList = contextAnchor.relList;
        this.util.addClass(target, "active");
        relList.style.visibility = "hidden";
        relList.style.display = "block";
        if (!this.options.rtl) relList.style.left = target.offsetLeft + target.offsetWidth + 1 + "px";
        else relList.style.left = target.offsetLeft - relList.offsetWidth - 1 + "px";
        relList.style.top = target.offsetTop + target.offsetHeight / 2 - relList.offsetHeight / 2 + "px";
        relList.style.visibility = "";
        this.plugins.anchor._closeRelMenu = function(context, target2, e) {
          if (e && (context.relButton.contains(e.target) || context.relList.contains(e.target))) return;
          this.util.removeClass(target2, "active");
          context.relList.style.display = "none";
          this.modalForm.removeEventListener("click", this.plugins.anchor._closeRelMenu);
          this.plugins.anchor._closeRelMenu = null;
        }.bind(this, contextAnchor, target);
        this.modalForm.addEventListener("click", this.plugins.anchor._closeRelMenu);
      }
    },
    onClick_relButton: function(contextAnchor, e) {
      this.plugins.anchor.toggleRelList.call(this, contextAnchor, !this.util.hasClass(e.target, "active"));
    },
    onClick_relList: function(contextAnchor, e) {
      const target = e.target;
      const cmd = target.getAttribute("data-command");
      if (!cmd) return;
      const current = contextAnchor.currentRel;
      const checked = this.util.toggleClass(target, "se-checked");
      const index = current.indexOf(cmd);
      if (checked) {
        if (index === -1) current.push(cmd);
      } else {
        if (index > -1) current.splice(index, 1);
      }
      contextAnchor.relPreview.title = contextAnchor.relPreview.textContent = current.join(" ");
    },
    setRel: function(contextAnchor, relAttr) {
      const relListEl = contextAnchor.relList;
      const rels = contextAnchor.currentRel = !relAttr ? [] : relAttr.split(" ");
      if (!relListEl) return;
      const checkedRel = relListEl.querySelectorAll("button");
      for (let i = 0, len = checkedRel.length, cmd; i < len; i++) {
        cmd = checkedRel[i].getAttribute("data-command");
        if (rels.indexOf(cmd) > -1) {
          this.util.addClass(checkedRel[i], "se-checked");
        } else {
          this.util.removeClass(checkedRel[i], "se-checked");
        }
      }
      contextAnchor.relPreview.title = contextAnchor.relPreview.textContent = rels.join(" ");
    },
    createHeaderList: function(contextAnchor, contextList, urlValue) {
      const headers = this.util.getListChildren(this.context.element.wysiwyg, function(current) {
        return /h[1-6]/i.test(current.nodeName);
      });
      if (headers.length === 0) return;
      const valueRegExp = new this._w.RegExp("^" + urlValue.replace(/^#/, ""), "i");
      const list2 = [];
      let html2 = "";
      for (let i = 0, len = headers.length, h; i < len; i++) {
        h = headers[i];
        if (!valueRegExp.test(h.textContent)) continue;
        list2.push(h);
        html2 += '<li class="se-select-item" data-index="' + i + '">' + h.textContent + "</li>";
      }
      if (list2.length === 0) {
        this.plugins.selectMenu.close.call(this, contextList);
      } else {
        this.plugins.selectMenu.createList(contextList, list2, html2);
        this.plugins.selectMenu.open.call(this, contextList, this.plugins.anchor._setMenuListPosition.bind(this, contextAnchor));
      }
    },
    _setMenuListPosition: function(contextAnchor, list2) {
      list2.style.top = contextAnchor.urlInput.offsetHeight + 1 + "px";
    },
    onKeyDownUrlInput: function(contextList, e) {
      const keyCode = e.keyCode;
      switch (keyCode) {
        case 38:
          e.preventDefault();
          e.stopPropagation();
          this.plugins.selectMenu.moveItem.call(this, contextList, -1);
          break;
        case 40:
          e.preventDefault();
          e.stopPropagation();
          this.plugins.selectMenu.moveItem.call(this, contextList, 1);
          break;
        case 13:
          if (contextList.index > -1) {
            e.preventDefault();
            e.stopPropagation();
            this.plugins.anchor.setHeaderBookmark.call(this, this.plugins.selectMenu.getItem(contextList, null));
          }
          break;
      }
    },
    setHeaderBookmark: function(header) {
      const contextAnchor = this.context.anchor.callerContext;
      const id = header.id || "h_" + this._w.Math.random().toString().replace(/.+\./, "");
      header.id = id;
      contextAnchor.urlInput.value = "#" + id;
      if (!contextAnchor.anchorText.value.trim() || !contextAnchor._change) {
        contextAnchor.anchorText.value = header.textContent;
      }
      this.plugins.anchor.setLinkPreview.call(this, contextAnchor, contextAnchor.urlInput.value);
      this.plugins.selectMenu.close.call(this, this.context.selectMenu.callerContext);
      this.context.anchor.callerContext.urlInput.focus();
    },
    onChangeAnchorText: function(contextAnchor, e) {
      contextAnchor._change = !!e.target.value.trim();
    },
    onChangeUrlInput: function(contextAnchor, e) {
      const value = e.target.value.trim();
      this.plugins.anchor.setLinkPreview.call(this, contextAnchor, value);
      if (this.plugins.anchor.selfPathBookmark.call(this, value)) this.plugins.anchor.createHeaderList.call(this, contextAnchor, this.context.selectMenu.callerContext, value);
      else this.plugins.selectMenu.close.call(this, this.context.selectMenu.callerContext);
    },
    onFocusUrlInput: function(contextAnchor, contextLink) {
      const value = contextAnchor.urlInput.value;
      if (this.plugins.anchor.selfPathBookmark.call(this, value)) this.plugins.anchor.createHeaderList.call(this, contextAnchor, contextLink, value);
    },
    onBlurUrlInput: function(contextList) {
      this.plugins.selectMenu.close.call(this, contextList);
    },
    setLinkPreview: function(context, value) {
      const preview = context.preview;
      const protocol = this.options.linkProtocol;
      const noPrefix = this.options.linkNoPrefix;
      const reservedProtocol = /^(mailto\:|tel\:|sms\:|https*\:\/\/|#)/.test(value) || value.indexOf(protocol) === 0;
      const sameProtocol = !protocol ? false : this._w.RegExp("^" + this.util.escapeStringRegexp(value.substr(0, protocol.length))).test(protocol);
      value = context.linkValue = preview.textContent = !value ? "" : noPrefix ? value : protocol && !reservedProtocol && !sameProtocol ? protocol + value : reservedProtocol ? value : /^www\./.test(value) ? "http://" + value : this.context.anchor.host + (/^\//.test(value) ? "" : "/") + value;
      if (this.plugins.anchor.selfPathBookmark.call(this, value)) {
        context.bookmark.style.display = "block";
        this.util.addClass(context.bookmarkButton, "active");
      } else {
        context.bookmark.style.display = "none";
        this.util.removeClass(context.bookmarkButton, "active");
      }
      if (!this.plugins.anchor.selfPathBookmark.call(this, value) && context.downloadCheck.checked) {
        context.download.style.display = "block";
      } else {
        context.download.style.display = "none";
      }
    },
    setCtx: function(anchor, contextAnchor) {
      if (!anchor) return;
      contextAnchor.linkAnchor = anchor;
      contextAnchor.linkValue = anchor.href;
      contextAnchor.currentRel = anchor.rel.split(" ");
    },
    updateAnchor: function(anchor, url, displayText, contextAnchor, notText) {
      if (!this.plugins.anchor.selfPathBookmark.call(this, url) && contextAnchor.downloadCheck.checked) {
        anchor.setAttribute("download", displayText || url);
      } else {
        anchor.removeAttribute("download");
      }
      if (contextAnchor.newWindowCheck.checked) anchor.target = "_blank";
      else anchor.removeAttribute("target");
      const rel = contextAnchor.currentRel.join(" ");
      if (!rel) anchor.removeAttribute("rel");
      else anchor.rel = rel;
      anchor.href = url;
      if (notText) {
        if (anchor.children.length === 0) anchor.textContent = "";
      } else {
        anchor.textContent = displayText;
      }
    },
    createAnchor: function(contextAnchor, notText) {
      if (contextAnchor.linkValue.length === 0) return null;
      const url = contextAnchor.linkValue;
      const anchor = contextAnchor.anchorText;
      const displayText = anchor.value.length === 0 ? url : anchor.value;
      const oA = contextAnchor.linkAnchor || this.util.createElement("A");
      this.plugins.anchor.updateAnchor.call(this, oA, url, displayText, contextAnchor, notText);
      contextAnchor.linkValue = contextAnchor.preview.textContent = contextAnchor.urlInput.value = contextAnchor.anchorText.value = "";
      return oA;
    },
    onClick_bookmarkButton: function(contextAnchor) {
      let url = contextAnchor.urlInput.value;
      if (this.plugins.anchor.selfPathBookmark.call(this, url)) {
        url = url.substr(1);
        contextAnchor.bookmark.style.display = "none";
        this.util.removeClass(contextAnchor.bookmarkButton, "active");
        this.plugins.selectMenu.close.call(this, this.context.selectMenu.callerContext);
      } else {
        url = "#" + url;
        contextAnchor.bookmark.style.display = "block";
        this.util.addClass(contextAnchor.bookmarkButton, "active");
        contextAnchor.downloadCheck.checked = false;
        contextAnchor.download.style.display = "none";
        this.plugins.anchor.createHeaderList.call(this, contextAnchor, this.context.selectMenu.callerContext, url);
      }
      contextAnchor.urlInput.value = url;
      this.plugins.anchor.setLinkPreview.call(this, contextAnchor, url);
      contextAnchor.urlInput.focus();
    },
    onChange_newWindowCheck: function(contextAnchor, e) {
      if (typeof contextAnchor.linkDefaultRel.check_new_window !== "string") return;
      if (e.target.checked) {
        this.plugins.anchor.setRel.call(this, contextAnchor, this.plugins.anchor._relMerge.call(this, contextAnchor, contextAnchor.linkDefaultRel.check_new_window));
      } else {
        this.plugins.anchor.setRel.call(this, contextAnchor, this.plugins.anchor._relDelete.call(this, contextAnchor, contextAnchor.linkDefaultRel.check_new_window));
      }
    },
    onChange_downloadCheck: function(contextAnchor, e) {
      if (e.target.checked) {
        contextAnchor.download.style.display = "block";
        contextAnchor.bookmark.style.display = "none";
        this.util.removeClass(contextAnchor.bookmarkButton, "active");
        contextAnchor.linkValue = contextAnchor.preview.textContent = contextAnchor.urlInput.value = contextAnchor.urlInput.value.replace(/^\#+/, "");
        if (typeof contextAnchor.linkDefaultRel.check_bookmark === "string") {
          this.plugins.anchor.setRel.call(this, contextAnchor, this.plugins.anchor._relMerge.call(this, contextAnchor, contextAnchor.linkDefaultRel.check_bookmark));
        }
      } else {
        contextAnchor.download.style.display = "none";
        if (typeof contextAnchor.linkDefaultRel.check_bookmark === "string") {
          this.plugins.anchor.setRel.call(this, contextAnchor, this.plugins.anchor._relDelete.call(this, contextAnchor, contextAnchor.linkDefaultRel.check_bookmark));
        }
      }
    },
    _relMerge: function(contextAnchor, relAttr) {
      const current = contextAnchor.currentRel;
      if (!relAttr) return current.join(" ");
      if (/^only\:/.test(relAttr)) {
        relAttr = relAttr.replace(/^only\:/, "").trim();
        contextAnchor.currentRel = relAttr.split(" ");
        return relAttr;
      }
      const rels = relAttr.split(" ");
      for (let i = 0, len = rels.length, index; i < len; i++) {
        index = current.indexOf(rels[i]);
        if (index === -1) current.push(rels[i]);
      }
      return current.join(" ");
    },
    _relDelete: function(contextAnchor, relAttr) {
      if (!relAttr) return contextAnchor.currentRel.join(" ");
      if (/^only\:/.test(relAttr)) relAttr = relAttr.replace(/^only\:/, "").trim();
      const rels = contextAnchor.currentRel.join(" ").replace(this._w.RegExp(relAttr + "\\s*"), "");
      contextAnchor.currentRel = rels.split(" ");
      return rels;
    },
    init: function(contextAnchor) {
      contextAnchor.linkAnchor = null;
      contextAnchor.linkValue = contextAnchor.preview.textContent = contextAnchor.urlInput.value = "";
      contextAnchor.anchorText.value = "";
      contextAnchor.newWindowCheck.checked = false;
      contextAnchor.downloadCheck.checked = false;
      contextAnchor._change = false;
      this.plugins.anchor.setRel.call(this, contextAnchor, contextAnchor.defaultRel);
      if (contextAnchor.relList) {
        this.plugins.anchor.toggleRelList.call(this, contextAnchor, false);
      }
      this.context.anchor.callerContext = null;
      this.plugins.selectMenu.init.call(this, this.context.selectMenu.callerContext);
    }
  };

  // ../../node_modules/suneditor/src/plugins/dialog/link.js
  var link_default = {
    name: "link",
    display: "dialog",
    add: function(core) {
      core.addModule([import_dialog.default, anchor_default]);
      const context = core.context;
      const contextLink = context.link = {
        focusElement: null,
        // @Override dialog // This element has focus when the dialog is opened.
        _linkAnchor: null,
        anchorCtx: null
      };
      let link_dialog = this.setDialog(core);
      contextLink.modal = link_dialog;
      let link_controller = this.setController_LinkButton(core);
      contextLink.linkController = link_controller;
      link_dialog.querySelector("form").addEventListener("submit", this.submit.bind(core));
      link_controller.addEventListener("click", this.onClick_linkController.bind(core));
      context.dialog.modal.appendChild(link_dialog);
      context.element.relative.appendChild(link_controller);
      core.plugins.anchor.initEvent.call(core, "link", link_dialog);
      contextLink.focusElement = context.anchor.caller.link.urlInput;
      link_dialog = null, link_controller = null;
    },
    /** dialog */
    setDialog: function(core) {
      const lang = core.lang;
      const dialog6 = core.util.createElement("DIV");
      const icons = core.icons;
      dialog6.className = "se-dialog-content";
      dialog6.style.display = "none";
      let html2 = '<form><div class="se-dialog-header"><button type="button" data-command="close" class="se-btn se-dialog-close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + icons.cancel + '</button><span class="se-modal-title">' + lang.dialogBox.linkBox.title + "</span></div>" + core.context.anchor.forms.innerHTML + '<div class="se-dialog-footer"><button type="submit" class="se-btn-primary" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '"><span>' + lang.dialogBox.submitButton + "</span></button></div></form>";
      dialog6.innerHTML = html2;
      return dialog6;
    },
    /** modify controller button */
    setController_LinkButton: function(core) {
      const lang = core.lang;
      const icons = core.icons;
      const link_btn = core.util.createElement("DIV");
      link_btn.className = "se-controller se-controller-link";
      link_btn.innerHTML = '<div class="se-arrow se-arrow-up"></div><div class="link-content"><span><a target="_blank" href=""></a>&nbsp;</span><div class="se-btn-group"><button type="button" data-command="update" tabindex="-1" class="se-btn se-tooltip">' + icons.edit + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.edit + '</span></span></button><button type="button" data-command="unlink" tabindex="-1" class="se-btn se-tooltip">' + icons.unlink + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.unlink + '</span></span></button><button type="button" data-command="delete" tabindex="-1" class="se-btn se-tooltip">' + icons.delete + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.remove + "</span></span></button></div></div>";
      return link_btn;
    },
    /**
     * @Override dialog
     */
    open: function() {
      this.plugins.dialog.open.call(this, "link", "link" === this.currentControllerName);
    },
    submit: function(e) {
      this.showLoading();
      e.preventDefault();
      e.stopPropagation();
      try {
        const oA = this.plugins.anchor.createAnchor.call(this, this.context.anchor.caller.link, false);
        if (oA === null) return;
        if (!this.context.dialog.updateModal) {
          const selectedFormats = this.getSelectedElements();
          if (selectedFormats.length > 1) {
            const oFormat = this.util.createElement(selectedFormats[0].nodeName);
            oFormat.appendChild(oA);
            if (!this.insertNode(oFormat, null, true)) return;
          } else {
            if (!this.insertNode(oA, null, true)) return;
          }
          this.setRange(oA.childNodes[0], 0, oA.childNodes[0], oA.textContent.length);
        } else {
          const textNode = this.context.link._linkAnchor.childNodes[0];
          this.setRange(textNode, 0, textNode, textNode.textContent.length);
        }
      } finally {
        this.plugins.dialog.close.call(this);
        this.closeLoading();
        this.history.push(false);
      }
      return false;
    },
    /**
     * @Override core
     */
    active: function(element) {
      if (!element) {
        if (this.controllerArray.indexOf(this.context.link.linkController) > -1) {
          this.controllersOff();
        }
      } else if (this.util.isAnchor(element) && element.getAttribute("data-image-link") === null) {
        if (this.controllerArray.indexOf(this.context.link.linkController) < 0) {
          this.plugins.link.call_controller.call(this, element);
        }
        return true;
      }
      return false;
    },
    /**
     * @Override dialog
     */
    on: function(update) {
      this.plugins.anchor.on.call(this, this.context.anchor.caller.link, update);
    },
    call_controller: function(selectionATag) {
      this.editLink = this.context.link._linkAnchor = this.context.anchor.caller.link.linkAnchor = selectionATag;
      const linkBtn = this.context.link.linkController;
      const link2 = linkBtn.querySelector("a");
      link2.href = selectionATag.href;
      link2.title = selectionATag.textContent;
      link2.textContent = selectionATag.textContent;
      this.util.addClass(selectionATag, "on");
      this.setControllerPosition(linkBtn, selectionATag, "bottom", { left: 0, top: 0 });
      this.controllersOn(linkBtn, selectionATag, "link", this.util.removeClass.bind(this.util, this.context.link._linkAnchor, "on"));
    },
    onClick_linkController: function(e) {
      e.stopPropagation();
      const command = e.target.getAttribute("data-command") || e.target.parentNode.getAttribute("data-command");
      if (!command) return;
      e.preventDefault();
      if (/update/.test(command)) {
        this.plugins.dialog.open.call(this, "link", true);
      } else if (/unlink/.test(command)) {
        const sc = this.util.getChildElement(this.context.link._linkAnchor, function(current) {
          return current.childNodes.length === 0 || current.nodeType === 3;
        }, false);
        const ec = this.util.getChildElement(this.context.link._linkAnchor, function(current) {
          return current.childNodes.length === 0 || current.nodeType === 3;
        }, true);
        this.setRange(sc, 0, ec, ec.textContent.length);
        this.nodeChange(null, null, ["A"], false);
      } else {
        this.util.removeItem(this.context.link._linkAnchor);
        this.context.anchor.caller.link.linkAnchor = null;
        this.focus();
        this.history.push(false);
      }
      this.controllersOff();
    },
    /**
     * @Override dialog
     */
    init: function() {
      this.context.link.linkController.style.display = "none";
      this.plugins.anchor.init.call(this, this.context.anchor.caller.link);
    }
  };

  // ../../node_modules/suneditor/src/plugins/dialog/image.js
  var import_dialog2 = __toESM(require_dialog());
  var import_component = __toESM(require_component2());
  var import_resizing = __toESM(require_resizing());
  var import_fileManager = __toESM(require_fileManager());
  var image_default = {
    name: "image",
    display: "dialog",
    add: function(core) {
      core.addModule([import_dialog2.default, anchor_default, import_component.default, import_resizing.default, import_fileManager.default]);
      const options2 = core.options;
      const context = core.context;
      const contextImage = context.image = {
        _infoList: [],
        // @Override fileManager
        _infoIndex: 0,
        // @Override fileManager
        _uploadFileLength: 0,
        // @Override fileManager
        focusElement: null,
        // @Override dialog // This element has focus when the dialog is opened.
        sizeUnit: options2._imageSizeUnit,
        _linkElement: "",
        _altText: "",
        _align: "none",
        _floatClassRegExp: "__se__float\\-[a-z]+",
        _v_src: { _linkValue: "" },
        svgDefaultSize: "30%",
        base64RenderIndex: 0,
        // @require @Override component
        _element: null,
        _cover: null,
        _container: null,
        // @Override resizing properties
        inputX: null,
        inputY: null,
        _element_w: 1,
        _element_h: 1,
        _element_l: 0,
        _element_t: 0,
        _defaultSizeX: "auto",
        _defaultSizeY: "auto",
        _origin_w: options2.imageWidth === "auto" ? "" : options2.imageWidth,
        _origin_h: options2.imageHeight === "auto" ? "" : options2.imageHeight,
        _proportionChecked: true,
        _resizing: options2.imageResizing,
        _resizeDotHide: !options2.imageHeightShow,
        _rotation: options2.imageRotation,
        _alignHide: !options2.imageAlignShow,
        _onlyPercentage: options2.imageSizeOnlyPercentage,
        _ratio: false,
        _ratioX: 1,
        _ratioY: 1,
        _captionShow: true,
        _captionChecked: false,
        _caption: null,
        captionCheckEl: null
      };
      let image_dialog = this.setDialog(core);
      contextImage.modal = image_dialog;
      contextImage.imgInputFile = image_dialog.querySelector("._se_image_file");
      contextImage.imgUrlFile = image_dialog.querySelector("._se_image_url");
      contextImage.focusElement = contextImage.imgInputFile || contextImage.imgUrlFile;
      contextImage.altText = image_dialog.querySelector("._se_image_alt");
      contextImage.captionCheckEl = image_dialog.querySelector("._se_image_check_caption");
      contextImage.previewSrc = image_dialog.querySelector("._se_tab_content_image .se-link-preview");
      image_dialog.querySelector(".se-dialog-tabs").addEventListener("click", this.openTab.bind(core));
      image_dialog.querySelector("form").addEventListener("submit", this.submit.bind(core));
      if (contextImage.imgInputFile) image_dialog.querySelector(".se-file-remove").addEventListener("click", this._removeSelectedFiles.bind(contextImage.imgInputFile, contextImage.imgUrlFile, contextImage.previewSrc));
      if (contextImage.imgUrlFile) contextImage.imgUrlFile.addEventListener("input", this._onLinkPreview.bind(contextImage.previewSrc, contextImage._v_src, options2.linkProtocol));
      if (contextImage.imgInputFile && contextImage.imgUrlFile) contextImage.imgInputFile.addEventListener("change", this._fileInputChange.bind(contextImage));
      const imageGalleryButton = image_dialog.querySelector(".__se__gallery");
      if (imageGalleryButton) imageGalleryButton.addEventListener("click", this._openGallery.bind(core));
      contextImage.proportion = {};
      contextImage.inputX = {};
      contextImage.inputY = {};
      if (options2.imageResizing) {
        contextImage.proportion = image_dialog.querySelector("._se_image_check_proportion");
        contextImage.inputX = image_dialog.querySelector("._se_image_size_x");
        contextImage.inputY = image_dialog.querySelector("._se_image_size_y");
        contextImage.inputX.value = options2.imageWidth;
        contextImage.inputY.value = options2.imageHeight;
        contextImage.inputX.addEventListener("keyup", this.setInputSize.bind(core, "x"));
        contextImage.inputY.addEventListener("keyup", this.setInputSize.bind(core, "y"));
        contextImage.inputX.addEventListener("change", this.setRatio.bind(core));
        contextImage.inputY.addEventListener("change", this.setRatio.bind(core));
        contextImage.proportion.addEventListener("change", this.setRatio.bind(core));
        image_dialog.querySelector(".se-dialog-btn-revert").addEventListener("click", this.sizeRevert.bind(core));
      }
      context.dialog.modal.appendChild(image_dialog);
      core.plugins.anchor.initEvent.call(core, "image", image_dialog.querySelector("._se_tab_content_url"));
      contextImage.anchorCtx = core.context.anchor.caller.image;
      image_dialog = null;
    },
    /** dialog */
    setDialog: function(core) {
      const option = core.options;
      const lang = core.lang;
      const dialog6 = core.util.createElement("DIV");
      dialog6.className = "se-dialog-content se-dialog-image";
      dialog6.style.display = "none";
      let html2 = '<div class="se-dialog-header"><button type="button" data-command="close" class="se-btn se-dialog-close" class="close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + core.icons.cancel + '</button><span class="se-modal-title">' + lang.dialogBox.imageBox.title + '</span></div><div class="se-dialog-tabs"><button type="button" class="_se_tab_link active" data-tab-link="image">' + lang.toolbar.image + '</button><button type="button" class="_se_tab_link" data-tab-link="url">' + lang.toolbar.link + '</button></div><form method="post" enctype="multipart/form-data"><div class="_se_tab_content _se_tab_content_image"><div class="se-dialog-body"><div style="border-bottom: 1px dashed #ccc;">';
      if (option.imageFileInput) {
        html2 += '<div class="se-dialog-form"><label>' + lang.dialogBox.imageBox.file + '</label><div class="se-dialog-form-files"><input class="se-input-form _se_image_file" type="file" accept="' + option.imageAccept + '"' + (option.imageMultipleFile ? ' multiple="multiple"' : "") + '/><button type="button" class="se-btn se-dialog-files-edge-button se-file-remove" title="' + lang.controller.remove + '" aria-label="' + lang.controller.remove + '">' + core.icons.cancel + "</button></div></div>";
      }
      if (option.imageUrlInput) {
        html2 += '<div class="se-dialog-form"><label>' + lang.dialogBox.imageBox.url + '</label><div class="se-dialog-form-files"><input class="se-input-form se-input-url _se_image_url" type="text" />' + (option.imageGalleryUrl && core.plugins.imageGallery ? '<button type="button" class="se-btn se-dialog-files-edge-button __se__gallery" title="' + lang.toolbar.imageGallery + '" aria-label="' + lang.toolbar.imageGallery + '">' + core.icons.image_gallery + "</button>" : "") + '</div><pre class="se-link-preview"></pre></div>';
      }
      html2 += '</div><div class="se-dialog-form"><label>' + lang.dialogBox.imageBox.altText + '</label><input class="se-input-form _se_image_alt" type="text" /></div>';
      if (option.imageResizing) {
        const onlyPercentage = option.imageSizeOnlyPercentage;
        const onlyPercentDisplay = onlyPercentage ? ' style="display: none !important;"' : "";
        const heightDisplay = !option.imageHeightShow ? ' style="display: none !important;"' : "";
        html2 += '<div class="se-dialog-form">';
        if (onlyPercentage || !option.imageHeightShow) {
          html2 += '<div class="se-dialog-size-text"><label class="size-w">' + lang.dialogBox.size + "</label></div>";
        } else {
          html2 += '<div class="se-dialog-size-text"><label class="size-w">' + lang.dialogBox.width + '</label><label class="se-dialog-size-x">&nbsp;</label><label class="size-h">' + lang.dialogBox.height + "</label></div>";
        }
        html2 += '<input class="se-input-control _se_image_size_x" placeholder="auto"' + (onlyPercentage ? ' type="number" min="1"' : 'type="text"') + (onlyPercentage ? ' max="100"' : "") + ' /><label class="se-dialog-size-x"' + heightDisplay + ">" + (onlyPercentage ? "%" : "x") + '</label><input type="text" class="se-input-control _se_image_size_y" placeholder="auto"' + onlyPercentDisplay + (onlyPercentage ? ' max="100"' : "") + heightDisplay + "/><label" + onlyPercentDisplay + heightDisplay + '><input type="checkbox" class="se-dialog-btn-check _se_image_check_proportion" checked/>&nbsp;' + lang.dialogBox.proportion + '</label><button type="button" title="' + lang.dialogBox.revertButton + '" aria-label="' + lang.dialogBox.revertButton + '" class="se-btn se-dialog-btn-revert" style="float: right;">' + core.icons.revert + "</button></div>";
      }
      html2 += '<div class="se-dialog-form se-dialog-form-footer"><label><input type="checkbox" class="se-dialog-btn-check _se_image_check_caption" />&nbsp;' + lang.dialogBox.caption + '</label></div></div></div><div class="_se_tab_content _se_tab_content_url" style="display: none">' + core.context.anchor.forms.innerHTML + '</div><div class="se-dialog-footer"><div' + (option.imageAlignShow ? "" : ' style="display: none"') + '><label><input type="radio" name="suneditor_image_radio" class="se-dialog-btn-radio" value="none" checked>' + lang.dialogBox.basic + '</label><label><input type="radio" name="suneditor_image_radio" class="se-dialog-btn-radio" value="left">' + lang.dialogBox.left + '</label><label><input type="radio" name="suneditor_image_radio" class="se-dialog-btn-radio" value="center">' + lang.dialogBox.center + '</label><label><input type="radio" name="suneditor_image_radio" class="se-dialog-btn-radio" value="right">' + lang.dialogBox.right + '</label></div><button type="submit" class="se-btn-primary" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '"><span>' + lang.dialogBox.submitButton + "</span></button></div></form>";
      dialog6.innerHTML = html2;
      return dialog6;
    },
    _fileInputChange: function() {
      if (!this.imgInputFile.value) {
        this.imgUrlFile.removeAttribute("disabled");
        this.previewSrc.style.textDecoration = "";
      } else {
        this.imgUrlFile.setAttribute("disabled", true);
        this.previewSrc.style.textDecoration = "line-through";
      }
    },
    _removeSelectedFiles: function(urlInput, previewSrc) {
      this.value = "";
      if (urlInput) {
        urlInput.removeAttribute("disabled");
        previewSrc.style.textDecoration = "";
      }
    },
    _openGallery: function() {
      this.callPlugin("imageGallery", this.plugins.imageGallery.open.bind(this, this.plugins.image._setUrlInput.bind(this.context.image)), null);
    },
    _setUrlInput: function(target) {
      this.altText.value = target.alt;
      this._v_src._linkValue = this.previewSrc.textContent = this.imgUrlFile.value = target.getAttribute("data-value") || target.src;
      this.imgUrlFile.focus();
    },
    _onLinkPreview: function(context, protocol, e) {
      const value = e.target.value.trim();
      context._linkValue = this.textContent = !value ? "" : protocol && value.indexOf("://") === -1 && value.indexOf("#") !== 0 ? protocol + value : value.indexOf("://") === -1 ? "/" + value : value;
    },
    /**
     * @Override @Required fileManager
     */
    fileTags: ["img"],
    /**
     * @Override core, fileManager, resizing
     * @description It is called from core.selectComponent.
     * @param {Element} element Target element
     */
    select: function(element) {
      this.plugins.image.onModifyMode.call(this, element, this.plugins.resizing.call_controller_resize.call(this, element, "image"));
    },
    /**
     * @Override fileManager, resizing
     */
    destroy: function(element) {
      const imageEl = element || this.context.image._element;
      const imageContainer = this.util.getParentElement(imageEl, this.util.isMediaComponent) || imageEl;
      const dataIndex = imageEl.getAttribute("data-index") * 1;
      if (typeof this.functions.onImageDeleteBefore === "function" && this.functions.onImageDeleteBefore(imageEl, imageContainer, dataIndex, this) === false) return;
      let focusEl = imageContainer.previousElementSibling || imageContainer.nextElementSibling;
      const emptyDiv = imageContainer.parentNode;
      this.util.removeItem(imageContainer);
      this.plugins.image.init.call(this);
      this.controllersOff();
      if (emptyDiv !== this.context.element.wysiwyg) this.util.removeItemAllParents(emptyDiv, function(current) {
        return current.childNodes.length === 0;
      }, null);
      this.focusEdge(focusEl);
      this.plugins.fileManager.deleteInfo.call(this, "image", dataIndex, this.functions.onImageUpload);
      this.history.push(false);
    },
    /**
     * @Required @Override dialog
     */
    on: function(update) {
      const contextImage = this.context.image;
      if (!update) {
        contextImage.inputX.value = contextImage._origin_w = this.options.imageWidth === contextImage._defaultSizeX ? "" : this.options.imageWidth;
        contextImage.inputY.value = contextImage._origin_h = this.options.imageHeight === contextImage._defaultSizeY ? "" : this.options.imageHeight;
        if (contextImage.imgInputFile && this.options.imageMultipleFile) contextImage.imgInputFile.setAttribute("multiple", "multiple");
      } else {
        if (contextImage.imgInputFile && this.options.imageMultipleFile) contextImage.imgInputFile.removeAttribute("multiple");
      }
      this.plugins.anchor.on.call(this, contextImage.anchorCtx, update);
    },
    /**
     * @Required @Override dialog
     */
    open: function() {
      this.plugins.dialog.open.call(this, "image", "image" === this.currentControllerName);
    },
    openTab: function(e) {
      const modal = this.context.image.modal;
      const targetElement = e === "init" ? modal.querySelector("._se_tab_link") : e.target;
      if (!/^BUTTON$/i.test(targetElement.tagName)) {
        return false;
      }
      const tabName = targetElement.getAttribute("data-tab-link");
      const contentClassName = "_se_tab_content";
      let i, tabContent, tabLinks;
      tabContent = modal.getElementsByClassName(contentClassName);
      for (i = 0; i < tabContent.length; i++) {
        tabContent[i].style.display = "none";
      }
      tabLinks = modal.getElementsByClassName("_se_tab_link");
      for (i = 0; i < tabLinks.length; i++) {
        this.util.removeClass(tabLinks[i], "active");
      }
      modal.querySelector("." + contentClassName + "_" + tabName).style.display = "block";
      this.util.addClass(targetElement, "active");
      if (tabName === "image" && this.context.image.focusElement) {
        this.context.image.focusElement.focus();
      } else if (tabName === "url") {
        this.context.anchor.caller.image.urlInput.focus();
      }
      return false;
    },
    submit: function(e) {
      const contextImage = this.context.image;
      const imagePlugin = this.plugins.image;
      e.preventDefault();
      e.stopPropagation();
      contextImage._altText = contextImage.altText.value;
      contextImage._align = contextImage.modal.querySelector('input[name="suneditor_image_radio"]:checked').value;
      contextImage._captionChecked = contextImage.captionCheckEl.checked;
      if (contextImage._resizing) contextImage._proportionChecked = contextImage.proportion.checked;
      try {
        if (this.context.dialog.updateModal) {
          imagePlugin.update_image.call(this, false, true, false);
        }
        if (contextImage.imgInputFile && contextImage.imgInputFile.files.length > 0) {
          this.showLoading();
          imagePlugin.submitAction.call(this, this.context.image.imgInputFile.files);
        } else if (contextImage.imgUrlFile && contextImage._v_src._linkValue.length > 0) {
          this.showLoading();
          imagePlugin.onRender_imgUrl.call(this, contextImage._v_src._linkValue);
        }
      } catch (error) {
        this.closeLoading();
        throw Error('[SUNEDITOR.image.submit.fail] cause : "' + error.message + '"');
      } finally {
        this.plugins.dialog.close.call(this);
      }
      return false;
    },
    submitAction: function(fileList) {
      if (fileList.length === 0) return;
      let fileSize = 0;
      let files = [];
      for (let i = 0, len = fileList.length; i < len; i++) {
        if (/image/i.test(fileList[i].type)) {
          files.push(fileList[i]);
          fileSize += fileList[i].size;
        }
      }
      const limitSize = this.options.imageUploadSizeLimit;
      if (limitSize > 0) {
        let infoSize = 0;
        const imagesInfo = this.context.image._infoList;
        for (let i = 0, len = imagesInfo.length; i < len; i++) {
          infoSize += imagesInfo[i].size * 1;
        }
        if (fileSize + infoSize > limitSize) {
          this.closeLoading();
          const err = "[SUNEDITOR.imageUpload.fail] Size of uploadable total images: " + limitSize / 1e3 + "KB";
          if (typeof this.functions.onImageUploadError !== "function" || this.functions.onImageUploadError(err, { "limitSize": limitSize, "currentSize": infoSize, "uploadSize": fileSize }, this)) {
            this.functions.noticeOpen(err);
          }
          return;
        }
      }
      const contextImage = this.context.image;
      contextImage._uploadFileLength = files.length;
      const anchor = this.plugins.anchor.createAnchor.call(this, contextImage.anchorCtx, true);
      const info = {
        anchor,
        inputWidth: contextImage.inputX.value,
        inputHeight: contextImage.inputY.value,
        align: contextImage._align,
        isUpdate: this.context.dialog.updateModal,
        alt: contextImage._altText,
        element: contextImage._element
      };
      if (typeof this.functions.onImageUploadBefore === "function") {
        const result = this.functions.onImageUploadBefore(files, info, this, function(data2) {
          if (data2 && this._w.Array.isArray(data2.result)) {
            this.plugins.image.register.call(this, info, data2);
          } else {
            this.plugins.image.upload.call(this, info, data2);
          }
        }.bind(this));
        if (typeof result === "undefined") return;
        if (!result) {
          this.closeLoading();
          return;
        }
        if (this._w.Array.isArray(result) && result.length > 0) files = result;
      }
      this.plugins.image.upload.call(this, info, files);
    },
    error: function(message, response) {
      this.closeLoading();
      if (typeof this.functions.onImageUploadError !== "function" || this.functions.onImageUploadError(message, response, this)) {
        this.functions.noticeOpen(message);
        throw Error("[SUNEDITOR.plugin.image.error] response: " + message);
      }
    },
    upload: function(info, files) {
      if (!files) {
        this.closeLoading();
        return;
      }
      if (typeof files === "string") {
        this.plugins.image.error.call(this, files, null);
        return;
      }
      const imageUploadUrl = this.options.imageUploadUrl;
      const filesLen = this.context.dialog.updateModal ? 1 : files.length;
      if (typeof imageUploadUrl === "string" && imageUploadUrl.length > 0) {
        const formData = new FormData();
        for (let i = 0; i < filesLen; i++) {
          formData.append("file-" + i, files[i]);
        }
        this.plugins.fileManager.upload.call(this, imageUploadUrl, this.options.imageUploadHeader, formData, this.plugins.image.callBack_imgUpload.bind(this, info), this.functions.onImageUploadError);
      } else {
        this.plugins.image.setup_reader.call(this, files, info.anchor, info.inputWidth, info.inputHeight, info.align, info.alt, filesLen, info.isUpdate);
      }
    },
    callBack_imgUpload: function(info, xmlHttp) {
      if (typeof this.functions.imageUploadHandler === "function") {
        this.functions.imageUploadHandler(xmlHttp, info, this);
      } else {
        const response = JSON.parse(xmlHttp.responseText);
        if (response.errorMessage) {
          this.plugins.image.error.call(this, response.errorMessage, response);
        } else {
          this.plugins.image.register.call(this, info, response);
        }
      }
    },
    register: function(info, response) {
      const fileList = response.result;
      for (let i = 0, len = fileList.length, file; i < len; i++) {
        file = { name: fileList[i].name, size: fileList[i].size };
        if (info.isUpdate) {
          this.plugins.image.update_src.call(this, fileList[i].url, info.element, file);
          break;
        } else {
          this.plugins.image.create_image.call(this, fileList[i].url, info.anchor, info.inputWidth, info.inputHeight, info.align, file, info.alt);
        }
      }
      this.closeLoading();
    },
    setup_reader: function(files, anchor, width, height, align, alt, filesLen, isUpdate) {
      try {
        if (filesLen === 0) {
          this.closeLoading();
          console.warn("[SUNEDITOR.image.base64.fail] cause : No applicable files");
          return;
        }
        this.context.image.base64RenderIndex = filesLen;
        const wFileReader = this._w.FileReader;
        const filesStack = [filesLen];
        this.context.image.inputX.value = width;
        this.context.image.inputY.value = height;
        for (let i = 0, reader, file; i < filesLen; i++) {
          reader = new wFileReader();
          file = files[i];
          reader.onload = function(reader2, update, updateElement, file2, index) {
            filesStack[index] = { result: reader2.result, file: file2 };
            if (--this.context.image.base64RenderIndex === 0) {
              this.plugins.image.onRender_imgBase64.call(this, update, filesStack, updateElement, anchor, width, height, align, alt);
              this.closeLoading();
            }
          }.bind(this, reader, isUpdate, this.context.image._element, file, i);
          reader.readAsDataURL(file);
        }
      } catch (e) {
        this.closeLoading();
        throw Error('[SUNEDITOR.image.setup_reader.fail] cause : "' + e.message + '"');
      }
    },
    onRender_imgBase64: function(update, filesStack, updateElement, anchor, width, height, align, alt) {
      const updateMethod = this.plugins.image.update_src;
      const createMethod = this.plugins.image.create_image;
      for (let i = 0, len = filesStack.length; i < len; i++) {
        if (update) {
          this.context.image._element.setAttribute("data-file-name", filesStack[i].file.name);
          this.context.image._element.setAttribute("data-file-size", filesStack[i].file.size);
          updateMethod.call(this, filesStack[i].result, updateElement, filesStack[i].file);
        } else {
          createMethod.call(this, filesStack[i].result, anchor, width, height, align, filesStack[i].file, alt);
        }
      }
    },
    onRender_imgUrl: function(url) {
      if (!url) url = this.context.image._v_src._linkValue;
      if (!url) return false;
      const contextImage = this.context.image;
      try {
        const file = { name: url.split("/").pop(), size: 0 };
        if (this.context.dialog.updateModal) this.plugins.image.update_src.call(this, url, contextImage._element, file);
        else this.plugins.image.create_image.call(this, url, this.plugins.anchor.createAnchor.call(this, contextImage.anchorCtx, true), contextImage.inputX.value, contextImage.inputY.value, contextImage._align, file, contextImage._altText);
      } catch (e) {
        throw Error('[SUNEDITOR.image.URLRendering.fail] cause : "' + e.message + '"');
      } finally {
        this.closeLoading();
      }
    },
    onRender_link: function(imgTag, anchor) {
      if (anchor) {
        anchor.setAttribute("data-image-link", "image");
        imgTag.setAttribute("data-image-link", anchor.href);
        anchor.appendChild(imgTag);
        return anchor;
      }
      return imgTag;
    },
    /**
     * @Override resizing
     * @param {String} xy 'x': width, 'y': height
     * @param {KeyboardEvent} e Event object
     */
    setInputSize: function(xy, e) {
      if (e && e.keyCode === 32) {
        e.preventDefault();
        return;
      }
      this.plugins.resizing._module_setInputSize.call(this, this.context.image, xy);
    },
    /**
     * @Override resizing
     */
    setRatio: function() {
      this.plugins.resizing._module_setRatio.call(this, this.context.image);
    },
    /**
     * @Override fileManager
     */
    checkFileInfo: function() {
      const imagePlugin = this.plugins.image;
      const contextImage = this.context.image;
      const modifyHandler = function(tag2) {
        imagePlugin.onModifyMode.call(this, tag2, null);
        imagePlugin.openModify.call(this, true);
        contextImage.inputX.value = contextImage._origin_w;
        contextImage.inputY.value = contextImage._origin_h;
        const format = this.util.getFormatElement(tag2);
        if (format) contextImage._align = format.style.textAlign || format.style.float;
        if (this.util.isAnchor(tag2.parentNode) && !contextImage.anchorCtx.linkValue) contextImage.anchorCtx.linkValue = " ";
        imagePlugin.update_image.call(this, true, false, true);
        imagePlugin.init.call(this);
      }.bind(this);
      this.plugins.fileManager.checkInfo.call(this, "image", ["img"], this.functions.onImageUpload, modifyHandler, true);
    },
    /**
     * @Override fileManager
     */
    resetFileInfo: function() {
      this.plugins.fileManager.resetInfo.call(this, "image", this.functions.onImageUpload);
    },
    create_image: function(src, anchor, width, height, align, file, alt) {
      const imagePlugin = this.plugins.image;
      const contextImage = this.context.image;
      this.context.resizing._resize_plugin = "image";
      let oImg = this.util.createElement("IMG");
      oImg.src = src;
      oImg.alt = alt;
      oImg.setAttribute("data-rotate", "0");
      anchor = imagePlugin.onRender_link.call(this, oImg, anchor ? anchor.cloneNode(false) : null);
      if (contextImage._resizing) {
        oImg.setAttribute("data-proportion", contextImage._proportionChecked);
      }
      const cover = this.plugins.component.set_cover.call(this, anchor);
      const container = this.plugins.component.set_container.call(this, cover, "se-image-container");
      if (contextImage._captionChecked) {
        contextImage._caption = this.plugins.component.create_caption.call(this);
        cover.appendChild(contextImage._caption);
      }
      contextImage._element = oImg;
      contextImage._cover = cover;
      contextImage._container = container;
      imagePlugin.applySize.call(this, width, height);
      imagePlugin.setAlign.call(this, align, oImg, cover, container);
      oImg.onload = imagePlugin._image_create_onload.bind(this, oImg, contextImage.svgDefaultSize, container);
      if (this.insertComponent(container, true, true, true)) this.plugins.fileManager.setInfo.call(this, "image", oImg, this.functions.onImageUpload, file, true);
      this.context.resizing._resize_plugin = "";
    },
    _image_create_onload: function(oImg, svgDefaultSize, container) {
      if (oImg.offsetWidth === 0) this.plugins.image.applySize.call(this, svgDefaultSize, "");
      if (this.options.mediaAutoSelect) {
        this.selectComponent(oImg, "image");
      } else {
        const line = this.appendFormatTag(container, null);
        if (line) this.setRange(line, 0, line, 0);
      }
    },
    update_image: function(init, openController, notHistoryPush) {
      const contextImage = this.context.image;
      let imageEl = contextImage._element;
      let cover = contextImage._cover;
      let container = contextImage._container;
      let isNewContainer = false;
      if (cover === null) {
        isNewContainer = true;
        imageEl = contextImage._element.cloneNode(true);
        cover = this.plugins.component.set_cover.call(this, imageEl);
      }
      if (container === null) {
        cover = cover.cloneNode(true);
        imageEl = cover.querySelector("img");
        isNewContainer = true;
        container = this.plugins.component.set_container.call(this, cover, "se-image-container");
      } else if (isNewContainer) {
        container.innerHTML = "";
        container.appendChild(cover);
        contextImage._cover = cover;
        contextImage._element = imageEl;
        isNewContainer = false;
      }
      let changeSize;
      const x = this.util.isNumber(contextImage.inputX.value) ? contextImage.inputX.value + contextImage.sizeUnit : contextImage.inputX.value;
      const y = this.util.isNumber(contextImage.inputY.value) ? contextImage.inputY.value + contextImage.sizeUnit : contextImage.inputY.value;
      if (/%$/.test(imageEl.style.width)) {
        changeSize = x !== container.style.width || y !== container.style.height;
      } else {
        changeSize = x !== imageEl.style.width || y !== imageEl.style.height;
      }
      imageEl.alt = contextImage._altText;
      let modifiedCaption = false;
      if (contextImage._captionChecked) {
        if (!contextImage._caption) {
          contextImage._caption = this.plugins.component.create_caption.call(this);
          cover.appendChild(contextImage._caption);
          modifiedCaption = true;
        }
      } else {
        if (contextImage._caption) {
          this.util.removeItem(contextImage._caption);
          contextImage._caption = null;
          modifiedCaption = true;
        }
      }
      let isNewAnchor = null;
      const anchor = this.plugins.anchor.createAnchor.call(this, contextImage.anchorCtx, true);
      if (anchor) {
        if (contextImage._linkElement !== anchor || isNewContainer && !container.contains(anchor)) {
          contextImage._linkElement = anchor.cloneNode(false);
          cover.insertBefore(this.plugins.image.onRender_link.call(this, imageEl, contextImage._linkElement), contextImage._caption);
          isNewAnchor = contextImage._element;
        } else {
          contextImage._linkElement.setAttribute("data-image-link", "image");
        }
      } else if (contextImage._linkElement !== null) {
        const imageElement = imageEl;
        imageElement.setAttribute("data-image-link", "");
        if (cover.contains(contextImage._linkElement)) {
          const newEl = imageElement.cloneNode(true);
          cover.removeChild(contextImage._linkElement);
          cover.insertBefore(newEl, contextImage._caption);
          contextImage._element = imageEl = newEl;
        }
      }
      let existElement = null;
      if (isNewContainer) {
        existElement = this.util.isRangeFormatElement(contextImage._element.parentNode) || this.util.isWysiwygDiv(contextImage._element.parentNode) ? contextImage._element : this.util.isAnchor(contextImage._element.parentNode) ? contextImage._element.parentNode : this.util.getFormatElement(contextImage._element) || contextImage._element;
        if (this.util.getParentElement(contextImage._element, this.util.isNotCheckingNode)) {
          existElement = isNewAnchor ? anchor : contextImage._element;
          existElement.parentNode.replaceChild(container, existElement);
        } else if (this.util.isListCell(existElement)) {
          const refer = this.util.getParentElement(contextImage._element, function(current) {
            return current.parentNode === existElement;
          });
          existElement.insertBefore(container, refer);
          this.util.removeItem(contextImage._element);
          this.util.removeEmptyNode(refer, null, true);
        } else if (this.util.isFormatElement(existElement)) {
          const refer = this.util.getParentElement(contextImage._element, function(current) {
            return current.parentNode === existElement;
          });
          existElement = this.util.splitElement(existElement, refer);
          existElement.parentNode.insertBefore(container, existElement);
          this.util.removeItem(contextImage._element);
          this.util.removeEmptyNode(existElement, null, true);
          if (existElement.children.length === 0) existElement.innerHTML = this.util.htmlRemoveWhiteSpace(existElement.innerHTML);
        } else {
          if (this.util.isFormatElement(existElement.parentNode)) {
            const formats = existElement.parentNode;
            formats.parentNode.insertBefore(container, existElement.previousSibling ? formats.nextElementSibling : formats);
            if (contextImage.__updateTags.map(function(current) {
              return existElement.contains(current);
            }).length === 0) this.util.removeItem(existElement);
          } else {
            existElement = this.util.isFigures(existElement.parentNode) ? existElement.parentNode : existElement;
            existElement.parentNode.replaceChild(container, existElement);
          }
        }
        imageEl = container.querySelector("img");
        contextImage._element = imageEl;
        contextImage._cover = cover;
        contextImage._container = container;
      }
      if (isNewAnchor) {
        if (!isNewContainer) {
          this.util.removeItem(anchor);
        } else {
          this.util.removeItem(isNewAnchor);
          if (this.util.getListChildren(anchor, function(current) {
            return /IMG/i.test(current.tagName);
          }).length === 0) {
            this.util.removeItem(anchor);
          }
        }
      }
      if (modifiedCaption || !contextImage._onlyPercentage && changeSize) {
        if (!init && (/\d+/.test(imageEl.style.height) || this.context.resizing._rotateVertical && contextImage._captionChecked)) {
          if (/%$/.test(contextImage.inputX.value) || /%$/.test(contextImage.inputY.value)) {
            this.plugins.resizing.resetTransform.call(this, imageEl);
          } else {
            this.plugins.resizing.setTransformSize.call(this, imageEl, this.util.getNumber(contextImage.inputX.value, 0), this.util.getNumber(contextImage.inputY.value, 0));
          }
        }
      }
      if (contextImage._resizing) {
        imageEl.setAttribute("data-proportion", contextImage._proportionChecked);
        if (changeSize) {
          this.plugins.image.applySize.call(this);
        }
      }
      this.plugins.image.setAlign.call(this, null, imageEl, null, null);
      if (init) {
        this.plugins.fileManager.setInfo.call(this, "image", imageEl, this.functions.onImageUpload, null, true);
      }
      if (openController) {
        this.selectComponent(imageEl, "image");
      }
      if (!notHistoryPush) this.history.push(false);
    },
    update_src: function(src, element, file) {
      element.src = src;
      this._w.setTimeout(this.plugins.fileManager.setInfo.bind(this, "image", element, this.functions.onImageUpload, file, true));
      this.selectComponent(element, "image");
    },
    /**
     * @Required @Override fileManager, resizing
     */
    onModifyMode: function(element, size) {
      if (!element) return;
      const contextImage = this.context.image;
      contextImage._linkElement = contextImage.anchorCtx.linkAnchor = this.util.isAnchor(element.parentNode) ? element.parentNode : null;
      contextImage._element = element;
      contextImage._cover = this.util.getParentElement(element, "FIGURE");
      contextImage._container = this.util.getParentElement(element, this.util.isMediaComponent);
      contextImage._caption = this.util.getChildElement(contextImage._cover, "FIGCAPTION");
      contextImage._align = element.getAttribute("data-align") || element.style.float || "none";
      element.style.float = "";
      this.plugins.anchor.setCtx(contextImage._linkElement, contextImage.anchorCtx);
      if (size) {
        contextImage._element_w = size.w;
        contextImage._element_h = size.h;
        contextImage._element_t = size.t;
        contextImage._element_l = size.l;
      }
      let userSize = contextImage._element.getAttribute("data-size") || contextImage._element.getAttribute("data-origin");
      let w, h;
      if (userSize) {
        userSize = userSize.split(",");
        w = userSize[0];
        h = userSize[1];
      } else if (size) {
        w = size.w;
        h = size.h;
      }
      contextImage._origin_w = w || element.style.width || element.width || "";
      contextImage._origin_h = h || element.style.height || element.height || "";
    },
    /**
     * @Required @Override fileManager, resizing
     */
    openModify: function(notOpen) {
      const contextImage = this.context.image;
      if (contextImage.imgUrlFile) {
        contextImage._v_src._linkValue = contextImage.previewSrc.textContent = contextImage.imgUrlFile.value = contextImage._element.src;
      }
      contextImage._altText = contextImage.altText.value = contextImage._element.alt;
      (contextImage.modal.querySelector('input[name="suneditor_image_radio"][value="' + contextImage._align + '"]') || contextImage.modal.querySelector('input[name="suneditor_image_radio"][value="none"]')).checked = true;
      contextImage._align = contextImage.modal.querySelector('input[name="suneditor_image_radio"]:checked').value;
      contextImage._captionChecked = contextImage.captionCheckEl.checked = !!contextImage._caption;
      if (contextImage._resizing) {
        this.plugins.resizing._module_setModifyInputSize.call(this, contextImage, this.plugins.image);
      }
      if (!notOpen) this.plugins.dialog.open.call(this, "image", true);
    },
    /**
     * @Override fileManager
     */
    applySize: function(w, h) {
      const contextImage = this.context.image;
      if (!w) w = contextImage.inputX.value || this.options.imageWidth;
      if (!h) h = contextImage.inputY.value || this.options.imageHeight;
      if (contextImage._onlyPercentage && !!w || /%$/.test(w)) {
        this.plugins.image.setPercentSize.call(this, w, h);
        return true;
      } else if ((!w || w === "auto") && (!h || h === "auto")) {
        this.plugins.image.setAutoSize.call(this);
      } else {
        this.plugins.image.setSize.call(this, w, h, false);
      }
      return false;
    },
    /**
     * @Override resizing
     */
    sizeRevert: function() {
      this.plugins.resizing._module_sizeRevert.call(this, this.context.image);
    },
    /**
     * @Override resizing
     */
    setSize: function(w, h, notResetPercentage, direction) {
      const contextImage = this.context.image;
      const onlyW = /^(rw|lw)$/.test(direction) && /\d+/.test(contextImage._element.style.height);
      const onlyH = /^(th|bh)$/.test(direction) && /\d+/.test(contextImage._element.style.width);
      if (!onlyH) {
        contextImage._element.style.width = this.util.isNumber(w) ? w + contextImage.sizeUnit : w;
        this.plugins.image.cancelPercentAttr.call(this);
      }
      if (!onlyW) {
        contextImage._element.style.height = this.util.isNumber(h) ? h + contextImage.sizeUnit : /%$/.test(h) ? "" : h;
      }
      if (contextImage._align === "center") this.plugins.image.setAlign.call(this, null, null, null, null);
      if (!notResetPercentage) contextImage._element.removeAttribute("data-percentage");
      this.plugins.resizing._module_saveCurrentSize.call(this, contextImage);
    },
    /**
     * @Override resizing
     */
    setAutoSize: function() {
      const contextImage = this.context.image;
      if (contextImage._caption) contextImage._caption.style.marginTop = "";
      this.plugins.resizing.resetTransform.call(this, contextImage._element);
      this.plugins.image.cancelPercentAttr.call(this);
      contextImage._element.style.maxWidth = "";
      contextImage._element.style.width = "";
      contextImage._element.style.height = "";
      contextImage._cover.style.width = "";
      contextImage._cover.style.height = "";
      this.plugins.image.setAlign.call(this, null, null, null, null);
      contextImage._element.setAttribute("data-percentage", "auto,auto");
      this.plugins.resizing._module_saveCurrentSize.call(this, contextImage);
    },
    /**
     * @Override resizing
     */
    setOriginSize: function() {
      const contextImage = this.context.image;
      contextImage._element.removeAttribute("data-percentage");
      this.plugins.resizing.resetTransform.call(this, contextImage._element);
      this.plugins.image.cancelPercentAttr.call(this);
      const originSize = (contextImage._element.getAttribute("data-origin") || "").split(",");
      const w = originSize[0];
      const h = originSize[1];
      if (originSize) {
        if (contextImage._onlyPercentage || /%$/.test(w) && (/%$/.test(h) || !/\d/.test(h))) {
          this.plugins.image.setPercentSize.call(this, w, h);
        } else {
          this.plugins.image.setSize.call(this, w, h);
        }
        this.plugins.resizing._module_saveCurrentSize.call(this, contextImage);
      }
    },
    /**
     * @Override resizing
     */
    setPercentSize: function(w, h) {
      const contextImage = this.context.image;
      h = !!h && !/%$/.test(h) && !this.util.getNumber(h, 0) ? this.util.isNumber(h) ? h + "%" : h : this.util.isNumber(h) ? h + contextImage.sizeUnit : h || "";
      const heightPercentage = /%$/.test(h);
      contextImage._container.style.width = this.util.isNumber(w) ? w + "%" : w;
      contextImage._container.style.height = "";
      contextImage._cover.style.width = "100%";
      contextImage._cover.style.height = !heightPercentage ? "" : h;
      contextImage._element.style.width = "100%";
      contextImage._element.style.height = heightPercentage ? "" : h;
      contextImage._element.style.maxWidth = "";
      if (contextImage._align === "center") this.plugins.image.setAlign.call(this, null, null, null, null);
      contextImage._element.setAttribute("data-percentage", w + "," + h);
      this.plugins.resizing.setCaptionPosition.call(this, contextImage._element);
      this.plugins.resizing._module_saveCurrentSize.call(this, contextImage);
    },
    /**
     * @Override resizing
     */
    cancelPercentAttr: function() {
      const contextImage = this.context.image;
      contextImage._cover.style.width = "";
      contextImage._cover.style.height = "";
      contextImage._container.style.width = "";
      contextImage._container.style.height = "";
      this.util.removeClass(contextImage._container, this.context.image._floatClassRegExp);
      this.util.addClass(contextImage._container, "__se__float-" + contextImage._align);
      if (contextImage._align === "center") this.plugins.image.setAlign.call(this, null, null, null, null);
    },
    /**
     * @Override resizing
     */
    setAlign: function(align, element, cover, container) {
      const contextImage = this.context.image;
      if (!align) align = contextImage._align;
      if (!element) element = contextImage._element;
      if (!cover) cover = contextImage._cover;
      if (!container) container = contextImage._container;
      if (/%$/.test(element.style.width) && align === "center") {
        container.style.minWidth = "100%";
        cover.style.width = container.style.width;
      } else {
        container.style.minWidth = "";
        cover.style.width = this.context.resizing._rotateVertical ? element.style.height || element.offsetHeight : !element.style.width || element.style.width === "auto" ? "" : element.style.width || "100%";
      }
      if (!this.util.hasClass(container, "__se__float-" + align)) {
        this.util.removeClass(container, contextImage._floatClassRegExp);
        this.util.addClass(container, "__se__float-" + align);
      }
      element.setAttribute("data-align", align);
    },
    /**
     * @Override dialog
     */
    init: function() {
      const contextImage = this.context.image;
      if (contextImage.imgInputFile) contextImage.imgInputFile.value = "";
      if (contextImage.imgUrlFile) contextImage._v_src._linkValue = contextImage.previewSrc.textContent = contextImage.imgUrlFile.value = "";
      if (contextImage.imgInputFile && contextImage.imgUrlFile) {
        contextImage.imgUrlFile.removeAttribute("disabled");
        contextImage.previewSrc.style.textDecoration = "";
      }
      contextImage.altText.value = "";
      contextImage.modal.querySelector('input[name="suneditor_image_radio"][value="none"]').checked = true;
      contextImage.captionCheckEl.checked = false;
      contextImage._element = null;
      this.plugins.image.openTab.call(this, "init");
      if (contextImage._resizing) {
        contextImage.inputX.value = this.options.imageWidth === contextImage._defaultSizeX ? "" : this.options.imageWidth;
        contextImage.inputY.value = this.options.imageHeight === contextImage._defaultSizeY ? "" : this.options.imageHeight;
        contextImage.proportion.checked = true;
        contextImage._ratio = false;
        contextImage._ratioX = 1;
        contextImage._ratioY = 1;
      }
      this.plugins.anchor.init.call(this, contextImage.anchorCtx);
    }
  };

  // ../../node_modules/suneditor/src/plugins/dialog/video.js
  var import_dialog3 = __toESM(require_dialog());
  var import_component2 = __toESM(require_component2());
  var import_resizing2 = __toESM(require_resizing());
  var import_fileManager2 = __toESM(require_fileManager());
  var video_default = {
    name: "video",
    display: "dialog",
    add: function(core) {
      core.addModule([import_dialog3.default, import_component2.default, import_resizing2.default, import_fileManager2.default]);
      const options2 = core.options;
      const context = core.context;
      const contextVideo = context.video = {
        _infoList: [],
        // @Override fileManager
        _infoIndex: 0,
        // @Override fileManager
        _uploadFileLength: 0,
        // @Override fileManager
        focusElement: null,
        // @Override dialog // This element has focus when the dialog is opened.
        sizeUnit: options2._videoSizeUnit,
        _align: "none",
        _floatClassRegExp: "__se__float\\-[a-z]+",
        _youtubeQuery: options2.youtubeQuery,
        _vimeoQuery: options2.vimeoQuery,
        _videoRatio: options2.videoRatio * 100 + "%",
        _defaultRatio: options2.videoRatio * 100 + "%",
        _linkValue: "",
        // @require @Override component
        _element: null,
        _cover: null,
        _container: null,
        // @Override resizing properties
        inputX: null,
        inputY: null,
        _element_w: 1,
        _element_h: 1,
        _element_l: 0,
        _element_t: 0,
        _defaultSizeX: "100%",
        _defaultSizeY: options2.videoRatio * 100 + "%",
        _origin_w: options2.videoWidth === "100%" ? "" : options2.videoWidth,
        _origin_h: options2.videoHeight === "56.25%" ? "" : options2.videoHeight,
        _proportionChecked: true,
        _resizing: options2.videoResizing,
        _resizeDotHide: !options2.videoHeightShow,
        _rotation: options2.videoRotation,
        _alignHide: !options2.videoAlignShow,
        _onlyPercentage: options2.videoSizeOnlyPercentage,
        _ratio: false,
        _ratioX: 1,
        _ratioY: 1,
        _captionShow: false
      };
      let video_dialog = this.setDialog(core);
      contextVideo.modal = video_dialog;
      contextVideo.videoInputFile = video_dialog.querySelector("._se_video_file");
      contextVideo.videoUrlFile = video_dialog.querySelector(".se-input-url");
      contextVideo.focusElement = contextVideo.videoUrlFile || contextVideo.videoInputFile;
      contextVideo.preview = video_dialog.querySelector(".se-link-preview");
      video_dialog.querySelector("form").addEventListener("submit", this.submit.bind(core));
      if (contextVideo.videoInputFile) video_dialog.querySelector(".se-dialog-files-edge-button").addEventListener("click", this._removeSelectedFiles.bind(contextVideo.videoInputFile, contextVideo.videoUrlFile, contextVideo.preview));
      if (contextVideo.videoInputFile && contextVideo.videoUrlFile) contextVideo.videoInputFile.addEventListener("change", this._fileInputChange.bind(contextVideo));
      if (contextVideo.videoUrlFile) contextVideo.videoUrlFile.addEventListener("input", this._onLinkPreview.bind(contextVideo.preview, contextVideo, options2.linkProtocol));
      contextVideo.proportion = {};
      contextVideo.videoRatioOption = {};
      contextVideo.inputX = {};
      contextVideo.inputY = {};
      if (options2.videoResizing) {
        contextVideo.proportion = video_dialog.querySelector("._se_video_check_proportion");
        contextVideo.videoRatioOption = video_dialog.querySelector(".se-video-ratio");
        contextVideo.inputX = video_dialog.querySelector("._se_video_size_x");
        contextVideo.inputY = video_dialog.querySelector("._se_video_size_y");
        contextVideo.inputX.value = options2.videoWidth;
        contextVideo.inputY.value = options2.videoHeight;
        contextVideo.inputX.addEventListener("keyup", this.setInputSize.bind(core, "x"));
        contextVideo.inputY.addEventListener("keyup", this.setInputSize.bind(core, "y"));
        contextVideo.inputX.addEventListener("change", this.setRatio.bind(core));
        contextVideo.inputY.addEventListener("change", this.setRatio.bind(core));
        contextVideo.proportion.addEventListener("change", this.setRatio.bind(core));
        contextVideo.videoRatioOption.addEventListener("change", this.setVideoRatio.bind(core));
        video_dialog.querySelector(".se-dialog-btn-revert").addEventListener("click", this.sizeRevert.bind(core));
      }
      context.dialog.modal.appendChild(video_dialog);
      video_dialog = null;
    },
    /** dialog */
    setDialog: function(core) {
      const option = core.options;
      const lang = core.lang;
      const dialog6 = core.util.createElement("DIV");
      dialog6.className = "se-dialog-content";
      dialog6.style.display = "none";
      let html2 = '<form method="post" enctype="multipart/form-data"><div class="se-dialog-header"><button type="button" data-command="close" class="se-btn se-dialog-close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + core.icons.cancel + '</button><span class="se-modal-title">' + lang.dialogBox.videoBox.title + '</span></div><div class="se-dialog-body">';
      if (option.videoFileInput) {
        html2 += '<div class="se-dialog-form"><label>' + lang.dialogBox.videoBox.file + '</label><div class="se-dialog-form-files"><input class="se-input-form _se_video_file" type="file" accept="' + option.videoAccept + '"' + (option.videoMultipleFile ? ' multiple="multiple"' : "") + '/><button type="button" data-command="filesRemove" class="se-btn se-dialog-files-edge-button se-file-remove" title="' + lang.controller.remove + '" aria-label="' + lang.controller.remove + '">' + core.icons.cancel + "</button></div></div>";
      }
      if (option.videoUrlInput) {
        html2 += '<div class="se-dialog-form"><label>' + lang.dialogBox.videoBox.url + '</label><input class="se-input-form se-input-url" type="text" /><pre class="se-link-preview"></pre></div>';
      }
      if (option.videoResizing) {
        const ratioList = option.videoRatioList || [{ name: "16:9", value: 0.5625 }, { name: "4:3", value: 0.75 }, { name: "21:9", value: 0.4285 }];
        const ratio = option.videoRatio;
        const onlyPercentage = option.videoSizeOnlyPercentage;
        const onlyPercentDisplay = onlyPercentage ? ' style="display: none !important;"' : "";
        const heightDisplay = !option.videoHeightShow ? ' style="display: none !important;"' : "";
        const ratioDisplay = !option.videoRatioShow ? ' style="display: none !important;"' : "";
        const onlyWidthDisplay = !onlyPercentage && !option.videoHeightShow && !option.videoRatioShow ? ' style="display: none !important;"' : "";
        html2 += '<div class="se-dialog-form"><div class="se-dialog-size-text"><label class="size-w">' + lang.dialogBox.width + '</label><label class="se-dialog-size-x">&nbsp;</label><label class="size-h"' + heightDisplay + ">" + lang.dialogBox.height + '</label><label class="size-h"' + ratioDisplay + ">(" + lang.dialogBox.ratio + ')</label></div><input class="se-input-control _se_video_size_x" placeholder="100%"' + (onlyPercentage ? ' type="number" min="1"' : 'type="text"') + (onlyPercentage ? ' max="100"' : "") + '/><label class="se-dialog-size-x"' + onlyWidthDisplay + ">" + (onlyPercentage ? "%" : "x") + '</label><input class="se-input-control _se_video_size_y" placeholder="' + option.videoRatio * 100 + '%"' + (onlyPercentage ? ' type="number" min="1"' : 'type="text"') + (onlyPercentage ? ' max="100"' : "") + heightDisplay + '/><select class="se-input-select se-video-ratio" title="' + lang.dialogBox.ratio + '" aria-label="' + lang.dialogBox.ratio + '"' + ratioDisplay + ">";
        if (!heightDisplay) html2 += '<option value=""> - </option>';
        for (let i = 0, len = ratioList.length; i < len; i++) {
          html2 += '<option value="' + ratioList[i].value + '"' + (ratio.toString() === ratioList[i].value.toString() ? " selected" : "") + ">" + ratioList[i].name + "</option>";
        }
        html2 += '</select><button type="button" title="' + lang.dialogBox.revertButton + '" aria-label="' + lang.dialogBox.revertButton + '" class="se-btn se-dialog-btn-revert" style="float: right;">' + core.icons.revert + '</button></div><div class="se-dialog-form se-dialog-form-footer"' + onlyPercentDisplay + onlyWidthDisplay + '><label><input type="checkbox" class="se-dialog-btn-check _se_video_check_proportion" checked/>&nbsp;' + lang.dialogBox.proportion + "</label></div>";
      }
      html2 += '</div><div class="se-dialog-footer"><div' + (option.videoAlignShow ? "" : ' style="display: none"') + '><label><input type="radio" name="suneditor_video_radio" class="se-dialog-btn-radio" value="none" checked>' + lang.dialogBox.basic + '</label><label><input type="radio" name="suneditor_video_radio" class="se-dialog-btn-radio" value="left">' + lang.dialogBox.left + '</label><label><input type="radio" name="suneditor_video_radio" class="se-dialog-btn-radio" value="center">' + lang.dialogBox.center + '</label><label><input type="radio" name="suneditor_video_radio" class="se-dialog-btn-radio" value="right">' + lang.dialogBox.right + '</label></div><button type="submit" class="se-btn-primary" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '"><span>' + lang.dialogBox.submitButton + "</span></button></div></form>";
      dialog6.innerHTML = html2;
      return dialog6;
    },
    _fileInputChange: function() {
      if (!this.videoInputFile.value) {
        this.videoUrlFile.removeAttribute("disabled");
        this.preview.style.textDecoration = "";
      } else {
        this.videoUrlFile.setAttribute("disabled", true);
        this.preview.style.textDecoration = "line-through";
      }
    },
    _removeSelectedFiles: function(urlInput, preview) {
      this.value = "";
      if (urlInput) {
        urlInput.removeAttribute("disabled");
        preview.style.textDecoration = "";
      }
    },
    _onLinkPreview: function(context, protocol, e) {
      const value = e.target.value.trim();
      if (/^<iframe.*\/iframe>$/.test(value)) {
        context._linkValue = value;
        this.textContent = '<IFrame :src=".."></IFrame>';
      } else {
        context._linkValue = this.textContent = !value ? "" : protocol && value.indexOf("://") === -1 && value.indexOf("#") !== 0 ? protocol + value : value.indexOf("://") === -1 ? "/" + value : value;
      }
    },
    _setTagAttrs: function(element) {
      element.setAttribute("controls", true);
      const attrs = this.options.videoTagAttrs;
      if (!attrs) return;
      for (let key in attrs) {
        if (!this.util.hasOwn(attrs, key)) continue;
        element.setAttribute(key, attrs[key]);
      }
    },
    createVideoTag: function() {
      const videoTag = this.util.createElement("VIDEO");
      this.plugins.video._setTagAttrs.call(this, videoTag);
      return videoTag;
    },
    _setIframeAttrs: function(element) {
      element.frameBorder = "0";
      element.allowFullscreen = true;
      const attrs = this.options.videoIframeAttrs;
      if (!attrs) return;
      for (let key in attrs) {
        if (!this.util.hasOwn(attrs, key)) continue;
        element.setAttribute(key, attrs[key]);
      }
    },
    createIframeTag: function() {
      const iframeTag = this.util.createElement("IFRAME");
      this.plugins.video._setIframeAttrs.call(this, iframeTag);
      return iframeTag;
    },
    /**
     * @Override @Required fileManager
     */
    fileTags: ["iframe", "video"],
    /**
     * @Override core, resizing, fileManager
     * @description It is called from core.selectComponent.
     * @param {Element} element Target element
     */
    select: function(element) {
      this.plugins.video.onModifyMode.call(this, element, this.plugins.resizing.call_controller_resize.call(this, element, "video"));
    },
    /**
     * @Override fileManager, resizing
     */
    destroy: function(element) {
      const frame = element || this.context.video._element;
      const container = this.context.video._container;
      const dataIndex = frame.getAttribute("data-index") * 1;
      if (typeof this.functions.onVideoDeleteBefore === "function" && this.functions.onVideoDeleteBefore(frame, container, dataIndex, this) === false) return;
      let focusEl = container.previousElementSibling || container.nextElementSibling;
      const emptyDiv = container.parentNode;
      this.util.removeItem(container);
      this.plugins.video.init.call(this);
      this.controllersOff();
      if (emptyDiv !== this.context.element.wysiwyg) this.util.removeItemAllParents(emptyDiv, function(current) {
        return current.childNodes.length === 0;
      }, null);
      this.focusEdge(focusEl);
      this.plugins.fileManager.deleteInfo.call(this, "video", dataIndex, this.functions.onVideoUpload);
      this.history.push(false);
    },
    /**
     * @Required @Override dialog
     */
    on: function(update) {
      const contextVideo = this.context.video;
      if (!update) {
        contextVideo.inputX.value = contextVideo._origin_w = this.options.videoWidth === contextVideo._defaultSizeX ? "" : this.options.videoWidth;
        contextVideo.inputY.value = contextVideo._origin_h = this.options.videoHeight === contextVideo._defaultSizeY ? "" : this.options.videoHeight;
        contextVideo.proportion.disabled = true;
        if (contextVideo.videoInputFile && this.options.videoMultipleFile) contextVideo.videoInputFile.setAttribute("multiple", "multiple");
      } else {
        if (contextVideo.videoInputFile && this.options.videoMultipleFile) contextVideo.videoInputFile.removeAttribute("multiple");
      }
      if (contextVideo._resizing) {
        this.plugins.video.setVideoRatioSelect.call(this, contextVideo._origin_h || contextVideo._defaultRatio);
      }
    },
    /**
     * @Required @Override dialog
     */
    open: function() {
      this.plugins.dialog.open.call(this, "video", "video" === this.currentControllerName);
    },
    setVideoRatio: function(e) {
      const contextVideo = this.context.video;
      const value = e.target.options[e.target.selectedIndex].value;
      contextVideo._defaultSizeY = contextVideo._videoRatio = !value ? contextVideo._defaultSizeY : value * 100 + "%";
      contextVideo.inputY.placeholder = !value ? "" : value * 100 + "%";
      contextVideo.inputY.value = "";
    },
    /**
     * @Override resizing
     * @param {String} xy 'x': width, 'y': height
     * @param {KeyboardEvent} e Event object
     */
    setInputSize: function(xy, e) {
      if (e && e.keyCode === 32) {
        e.preventDefault();
        return;
      }
      const contextVideo = this.context.video;
      this.plugins.resizing._module_setInputSize.call(this, contextVideo, xy);
      if (xy === "y") {
        this.plugins.video.setVideoRatioSelect.call(this, e.target.value || contextVideo._defaultRatio);
      }
    },
    /**
     * @Override resizing
     */
    setRatio: function() {
      this.plugins.resizing._module_setRatio.call(this, this.context.video);
    },
    submit: function(e) {
      const contextVideo = this.context.video;
      const videoPlugin = this.plugins.video;
      e.preventDefault();
      e.stopPropagation();
      contextVideo._align = contextVideo.modal.querySelector('input[name="suneditor_video_radio"]:checked').value;
      try {
        if (contextVideo.videoInputFile && contextVideo.videoInputFile.files.length > 0) {
          this.showLoading();
          videoPlugin.submitAction.call(this, this.context.video.videoInputFile.files);
        } else if (contextVideo.videoUrlFile && contextVideo._linkValue.length > 0) {
          this.showLoading();
          videoPlugin.setup_url.call(this, contextVideo._linkValue);
        }
      } catch (error) {
        this.closeLoading();
        throw Error('[SUNEDITOR.video.submit.fail] cause : "' + error.message + '"');
      } finally {
        this.plugins.dialog.close.call(this);
      }
      return false;
    },
    submitAction: function(fileList) {
      if (fileList.length === 0) return;
      let fileSize = 0;
      let files = [];
      for (let i = 0, len = fileList.length; i < len; i++) {
        if (/video/i.test(fileList[i].type)) {
          files.push(fileList[i]);
          fileSize += fileList[i].size;
        }
      }
      const limitSize = this.options.videoUploadSizeLimit;
      if (limitSize > 0) {
        let infoSize = 0;
        const videosInfo = this.context.video._infoList;
        for (let i = 0, len = videosInfo.length; i < len; i++) {
          infoSize += videosInfo[i].size * 1;
        }
        if (fileSize + infoSize > limitSize) {
          this.closeLoading();
          const err = "[SUNEDITOR.videoUpload.fail] Size of uploadable total videos: " + limitSize / 1e3 + "KB";
          if (typeof this.functions.onVideoUploadError !== "function" || this.functions.onVideoUploadError(err, { "limitSize": limitSize, "currentSize": infoSize, "uploadSize": fileSize }, this)) {
            this.functions.noticeOpen(err);
          }
          return;
        }
      }
      const contextVideo = this.context.video;
      contextVideo._uploadFileLength = files.length;
      const info = {
        inputWidth: contextVideo.inputX.value,
        inputHeight: contextVideo.inputY.value,
        align: contextVideo._align,
        isUpdate: this.context.dialog.updateModal,
        element: contextVideo._element
      };
      if (typeof this.functions.onVideoUploadBefore === "function") {
        const result = this.functions.onVideoUploadBefore(files, info, this, function(data2) {
          if (data2 && this._w.Array.isArray(data2.result)) {
            this.plugins.video.register.call(this, info, data2);
          } else {
            this.plugins.video.upload.call(this, info, data2);
          }
        }.bind(this));
        if (typeof result === "undefined") return;
        if (!result) {
          this.closeLoading();
          return;
        }
        if (typeof result === "object" && result.length > 0) files = result;
      }
      this.plugins.video.upload.call(this, info, files);
    },
    error: function(message, response) {
      this.closeLoading();
      if (typeof this.functions.onVideoUploadError !== "function" || this.functions.onVideoUploadError(message, response, this)) {
        this.functions.noticeOpen(message);
        throw Error("[SUNEDITOR.plugin.video.error] response: " + message);
      }
    },
    upload: function(info, files) {
      if (!files) {
        this.closeLoading();
        return;
      }
      if (typeof files === "string") {
        this.plugins.video.error.call(this, files, null);
        return;
      }
      const videoUploadUrl = this.options.videoUploadUrl;
      const filesLen = this.context.dialog.updateModal ? 1 : files.length;
      if (typeof videoUploadUrl === "string" && videoUploadUrl.length > 0) {
        const formData = new FormData();
        for (let i = 0; i < filesLen; i++) {
          formData.append("file-" + i, files[i]);
        }
        this.plugins.fileManager.upload.call(this, videoUploadUrl, this.options.videoUploadHeader, formData, this.plugins.video.callBack_videoUpload.bind(this, info), this.functions.onVideoUploadError);
      } else {
        throw Error('[SUNEDITOR.videoUpload.fail] cause : There is no "videoUploadUrl" option.');
      }
    },
    callBack_videoUpload: function(info, xmlHttp) {
      if (typeof this.functions.videoUploadHandler === "function") {
        this.functions.videoUploadHandler(xmlHttp, info, this);
      } else {
        const response = JSON.parse(xmlHttp.responseText);
        if (response.errorMessage) {
          this.plugins.video.error.call(this, response.errorMessage, response);
        } else {
          this.plugins.video.register.call(this, info, response);
        }
      }
    },
    register: function(info, response) {
      const fileList = response.result;
      const videoTag = this.plugins.video.createVideoTag.call(this);
      for (let i = 0, len = fileList.length, file; i < len; i++) {
        file = { name: fileList[i].name, size: fileList[i].size };
        this.plugins.video.create_video.call(this, info.isUpdate ? info.element : videoTag.cloneNode(false), fileList[i].url, info.inputWidth, info.inputHeight, info.align, file, info.isUpdate);
      }
      this.closeLoading();
    },
    setup_url: function(url) {
      try {
        const contextVideo = this.context.video;
        if (!url) url = contextVideo._linkValue;
        if (!url) return false;
        if (/^<iframe.*\/iframe>$/.test(url)) {
          const oIframe = new this._w.DOMParser().parseFromString(url, "text/html").querySelector("iframe");
          url = oIframe.src;
          if (url.length === 0) return false;
        }
        if (/youtu\.?be/.test(url)) {
          if (!/^http/.test(url)) url = "https://" + url;
          url = url.replace("watch?v=", "");
          if (!/^\/\/.+\/embed\//.test(url)) {
            url = url.replace(url.match(/\/\/.+\//)[0], "//www.youtube.com/embed/").replace("&", "?&");
          }
          if (contextVideo._youtubeQuery.length > 0) {
            if (/\?/.test(url)) {
              const splitUrl = url.split("?");
              url = splitUrl[0] + "?" + contextVideo._youtubeQuery + "&" + splitUrl[1];
            } else {
              url += "?" + contextVideo._youtubeQuery;
            }
          }
        } else if (/vimeo\.com/.test(url)) {
          if (url.endsWith("/")) {
            url = url.slice(0, -1);
          }
          url = "https://player.vimeo.com/video/" + url.slice(url.lastIndexOf("/") + 1);
          if (contextVideo._vimeoQuery.length > 0) {
            if (/\?/.test(url)) {
              const splitUrl = url.split("?");
              url = splitUrl[0] + "?" + contextVideo._vimeoQuery + "&" + splitUrl[1];
            } else {
              url += "?" + contextVideo._vimeoQuery;
            }
          }
        }
        this.plugins.video.create_video.call(this, this.plugins.video[!/embed|iframe|player|\/e\/|\.php|\.html?/.test(url) && !/vimeo\.com/.test(url) ? "createVideoTag" : "createIframeTag"].call(this), url, contextVideo.inputX.value, contextVideo.inputY.value, contextVideo._align, null, this.context.dialog.updateModal);
      } catch (error) {
        throw Error('[SUNEDITOR.video.upload.fail] cause : "' + error.message + '"');
      } finally {
        this.closeLoading();
      }
    },
    create_video: function(oFrame, src, width, height, align, file, isUpdate) {
      this.context.resizing._resize_plugin = "video";
      const contextVideo = this.context.video;
      let cover = null;
      let container = null;
      let init = false;
      if (isUpdate) {
        oFrame = contextVideo._element;
        if (oFrame.src !== src) {
          init = true;
          const isYoutube = /youtu\.?be/.test(src);
          const isVimeo = /vimeo\.com/.test(src);
          if ((isYoutube || isVimeo) && !/^iframe$/i.test(oFrame.nodeName)) {
            const newTag = this.plugins.video.createIframeTag.call(this);
            newTag.src = src;
            oFrame.parentNode.replaceChild(newTag, oFrame);
            contextVideo._element = oFrame = newTag;
          } else if (!isYoutube && !isVimeo && !/^video$/i.test(oFrame.nodeName)) {
            const newTag = this.plugins.video.createVideoTag.call(this);
            newTag.src = src;
            oFrame.parentNode.replaceChild(newTag, oFrame);
            contextVideo._element = oFrame = newTag;
          } else {
            oFrame.src = src;
          }
        }
        container = contextVideo._container;
        cover = this.util.getParentElement(oFrame, "FIGURE");
      } else {
        init = true;
        oFrame.src = src;
        contextVideo._element = oFrame;
        cover = this.plugins.component.set_cover.call(this, oFrame);
        container = this.plugins.component.set_container.call(this, cover, "se-video-container");
      }
      contextVideo._cover = cover;
      contextVideo._container = container;
      const inputUpdate = this.plugins.resizing._module_getSizeX.call(this, contextVideo) !== (width || contextVideo._defaultSizeX) || this.plugins.resizing._module_getSizeY.call(this, contextVideo) !== (height || contextVideo._videoRatio);
      const changeSize = !isUpdate || inputUpdate;
      if (contextVideo._resizing) {
        this.context.video._proportionChecked = contextVideo.proportion.checked;
        oFrame.setAttribute("data-proportion", contextVideo._proportionChecked);
      }
      let isPercent = false;
      if (changeSize) {
        isPercent = this.plugins.video.applySize.call(this);
      }
      if (!(isPercent && align === "center")) {
        this.plugins.video.setAlign.call(this, null, oFrame, cover, container);
      }
      let changed = true;
      if (!isUpdate) {
        changed = this.insertComponent(container, false, true, !this.options.mediaAutoSelect);
        if (!this.options.mediaAutoSelect) {
          const line = this.appendFormatTag(container, null);
          if (line) this.setRange(line, 0, line, 0);
        }
      } else if (contextVideo._resizing && this.context.resizing._rotateVertical && changeSize) {
        this.plugins.resizing.setTransformSize.call(this, oFrame, null, null);
      }
      if (changed) {
        if (init) {
          this.plugins.fileManager.setInfo.call(this, "video", oFrame, this.functions.onVideoUpload, file, true);
        }
        if (isUpdate) {
          this.selectComponent(oFrame, "video");
          this.history.push(false);
        }
      }
      this.context.resizing._resize_plugin = "";
    },
    _update_videoCover: function(oFrame) {
      if (!oFrame) return;
      const contextVideo = this.context.video;
      if (/^video$/i.test(oFrame.nodeName)) this.plugins.video._setTagAttrs.call(this, oFrame);
      else this.plugins.video._setIframeAttrs.call(this, oFrame);
      let existElement = this.util.isRangeFormatElement(oFrame.parentNode) || this.util.isWysiwygDiv(oFrame.parentNode) ? oFrame : this.util.getFormatElement(oFrame) || oFrame;
      const prevFrame = oFrame;
      contextVideo._element = oFrame = oFrame.cloneNode(true);
      const cover = contextVideo._cover = this.plugins.component.set_cover.call(this, oFrame);
      const container = contextVideo._container = this.plugins.component.set_container.call(this, cover, "se-video-container");
      try {
        const figcaption = existElement.querySelector("figcaption");
        let caption = null;
        if (!!figcaption) {
          caption = this.util.createElement("DIV");
          caption.innerHTML = figcaption.innerHTML;
          this.util.removeItem(figcaption);
        }
        const size = (oFrame.getAttribute("data-size") || oFrame.getAttribute("data-origin") || "").split(",");
        this.plugins.video.applySize.call(this, size[0] || prevFrame.style.width || prevFrame.width || "", size[1] || prevFrame.style.height || prevFrame.height || "");
        const format = this.util.getFormatElement(prevFrame);
        if (format) contextVideo._align = format.style.textAlign || format.style.float;
        this.plugins.video.setAlign.call(this, null, oFrame, cover, container);
        if (this.util.getParentElement(prevFrame, this.util.isNotCheckingNode)) {
          prevFrame.parentNode.replaceChild(container, prevFrame);
        } else if (this.util.isListCell(existElement)) {
          const refer = this.util.getParentElement(prevFrame, function(current) {
            return current.parentNode === existElement;
          });
          existElement.insertBefore(container, refer);
          this.util.removeItem(prevFrame);
          this.util.removeEmptyNode(refer, null, true);
        } else if (this.util.isFormatElement(existElement)) {
          const refer = this.util.getParentElement(prevFrame, function(current) {
            return current.parentNode === existElement;
          });
          existElement = this.util.splitElement(existElement, refer);
          existElement.parentNode.insertBefore(container, existElement);
          this.util.removeItem(prevFrame);
          this.util.removeEmptyNode(existElement, null, true);
          if (existElement.children.length === 0) existElement.innerHTML = this.util.htmlRemoveWhiteSpace(existElement.innerHTML);
        } else {
          existElement.parentNode.replaceChild(container, existElement);
        }
        if (!!caption) existElement.parentNode.insertBefore(caption, container.nextElementSibling);
      } catch (error) {
        console.warn("[SUNEDITOR.video.error] Maybe the video tag is nested.", error);
      }
      this.plugins.fileManager.setInfo.call(this, "video", oFrame, this.functions.onVideoUpload, null, true);
      this.plugins.video.init.call(this);
    },
    /**
     * @Required @Override fileManager, resizing
     */
    onModifyMode: function(element, size) {
      const contextVideo = this.context.video;
      contextVideo._element = element;
      contextVideo._cover = this.util.getParentElement(element, "FIGURE");
      contextVideo._container = this.util.getParentElement(element, this.util.isMediaComponent);
      contextVideo._align = element.style.float || element.getAttribute("data-align") || "none";
      element.style.float = "";
      if (size) {
        contextVideo._element_w = size.w;
        contextVideo._element_h = size.h;
        contextVideo._element_t = size.t;
        contextVideo._element_l = size.l;
      }
      let origin = contextVideo._element.getAttribute("data-size") || contextVideo._element.getAttribute("data-origin");
      let w, h;
      if (origin) {
        origin = origin.split(",");
        w = origin[0];
        h = origin[1];
      } else if (size) {
        w = size.w;
        h = size.h;
      }
      contextVideo._origin_w = w || element.style.width || element.width || "";
      contextVideo._origin_h = h || element.style.height || element.height || "";
    },
    /**
     * @Required @Override fileManager, resizing
     */
    openModify: function(notOpen) {
      const contextVideo = this.context.video;
      if (contextVideo.videoUrlFile) contextVideo._linkValue = contextVideo.preview.textContent = contextVideo.videoUrlFile.value = contextVideo._element.src || (contextVideo._element.querySelector("source") || "").src || "";
      (contextVideo.modal.querySelector('input[name="suneditor_video_radio"][value="' + contextVideo._align + '"]') || contextVideo.modal.querySelector('input[name="suneditor_video_radio"][value="none"]')).checked = true;
      if (contextVideo._resizing) {
        this.plugins.resizing._module_setModifyInputSize.call(this, contextVideo, this.plugins.video);
        const y = contextVideo._videoRatio = this.plugins.resizing._module_getSizeY.call(this, contextVideo);
        const ratioSelected = this.plugins.video.setVideoRatioSelect.call(this, y);
        if (!ratioSelected) contextVideo.inputY.value = contextVideo._onlyPercentage ? this.util.getNumber(y, 2) : y;
      }
      if (!notOpen) this.plugins.dialog.open.call(this, "video", true);
    },
    setVideoRatioSelect: function(value) {
      let ratioSelected = false;
      const contextVideo = this.context.video;
      const ratioOptions = contextVideo.videoRatioOption.options;
      if (/%$/.test(value) || contextVideo._onlyPercentage) value = this.util.getNumber(value, 2) / 100 + "";
      else if (!this.util.isNumber(value) || value * 1 >= 1) value = "";
      contextVideo.inputY.placeholder = "";
      for (let i = 0, len = ratioOptions.length; i < len; i++) {
        if (ratioOptions[i].value === value) {
          ratioSelected = ratioOptions[i].selected = true;
          contextVideo.inputY.placeholder = !value ? "" : value * 100 + "%";
        } else ratioOptions[i].selected = false;
      }
      return ratioSelected;
    },
    /**
     * @Override fileManager
     */
    checkFileInfo: function() {
      this.plugins.fileManager.checkInfo.call(this, "video", ["iframe", "video"], this.functions.onVideoUpload, this.plugins.video._update_videoCover.bind(this), true);
    },
    /**
     * @Override fileManager
     */
    resetFileInfo: function() {
      this.plugins.fileManager.resetInfo.call(this, "video", this.functions.onVideoUpload);
    },
    /**
     * @Override fileManager
     */
    applySize: function(w, h) {
      const contextVideo = this.context.video;
      if (!w) w = contextVideo.inputX.value || this.options.videoWidth;
      if (!h) h = contextVideo.inputY.value || this.options.videoHeight;
      if (contextVideo._onlyPercentage || /%$/.test(w) || !w) {
        this.plugins.video.setPercentSize.call(this, w || "100%", h || (/%$/.test(contextVideo._videoRatio) ? contextVideo._videoRatio : contextVideo._defaultRatio));
        return true;
      } else if ((!w || w === "auto") && (!h || h === "auto")) {
        this.plugins.video.setAutoSize.call(this);
      } else {
        this.plugins.video.setSize.call(this, w, h || contextVideo._videoRatio || contextVideo._defaultRatio, false);
      }
      return false;
    },
    /**
     * @Override resizing
     */
    sizeRevert: function() {
      this.plugins.resizing._module_sizeRevert.call(this, this.context.video);
    },
    /**
     * @Override resizing
     */
    setSize: function(w, h, notResetPercentage, direction) {
      const contextVideo = this.context.video;
      const onlyW = /^(rw|lw)$/.test(direction);
      const onlyH = /^(th|bh)$/.test(direction);
      if (!onlyH) w = this.util.getNumber(w, 0);
      if (!onlyW) h = this.util.isNumber(h) ? h + contextVideo.sizeUnit : !h ? "" : h;
      w = w ? w + contextVideo.sizeUnit : "";
      if (!onlyH) contextVideo._element.style.width = w;
      if (!onlyW) contextVideo._cover.style.paddingBottom = contextVideo._cover.style.height = h;
      if (!onlyH && !/%$/.test(w)) {
        contextVideo._cover.style.width = w;
        contextVideo._container.style.width = "";
      }
      if (!onlyW && !/%$/.test(h)) {
        contextVideo._element.style.height = h;
      } else {
        contextVideo._element.style.height = "";
      }
      if (!notResetPercentage) contextVideo._element.removeAttribute("data-percentage");
      this.plugins.resizing._module_saveCurrentSize.call(this, contextVideo);
    },
    /**
     * @Override resizing
     */
    setAutoSize: function() {
      this.plugins.video.setPercentSize.call(this, 100, this.context.video._defaultRatio);
    },
    /**
     * @Override resizing
     */
    setOriginSize: function(dataSize) {
      const contextVideo = this.context.video;
      contextVideo._element.removeAttribute("data-percentage");
      this.plugins.resizing.resetTransform.call(this, contextVideo._element);
      this.plugins.video.cancelPercentAttr.call(this);
      const originSize = ((dataSize ? contextVideo._element.getAttribute("data-size") : "") || contextVideo._element.getAttribute("data-origin") || "").split(",");
      if (originSize) {
        const w = originSize[0];
        const h = originSize[1];
        if (contextVideo._onlyPercentage || /%$/.test(w) && (/%$/.test(h) || !/\d/.test(h))) {
          this.plugins.video.setPercentSize.call(this, w, h);
        } else {
          this.plugins.video.setSize.call(this, w, h);
        }
        this.plugins.resizing._module_saveCurrentSize.call(this, contextVideo);
      }
    },
    /**
     * @Override resizing
     */
    setPercentSize: function(w, h) {
      const contextVideo = this.context.video;
      h = !!h && !/%$/.test(h) && !this.util.getNumber(h, 0) ? this.util.isNumber(h) ? h + "%" : h : this.util.isNumber(h) ? h + contextVideo.sizeUnit : h || contextVideo._defaultRatio;
      contextVideo._container.style.width = this.util.isNumber(w) ? w + "%" : w;
      contextVideo._container.style.height = "";
      contextVideo._cover.style.width = "100%";
      contextVideo._cover.style.height = h;
      contextVideo._cover.style.paddingBottom = h;
      contextVideo._element.style.width = "100%";
      contextVideo._element.style.height = "100%";
      contextVideo._element.style.maxWidth = "";
      if (contextVideo._align === "center") this.plugins.video.setAlign.call(this, null, null, null, null);
      contextVideo._element.setAttribute("data-percentage", w + "," + h);
      this.plugins.resizing._module_saveCurrentSize.call(this, contextVideo);
    },
    /**
     * @Override resizing
     */
    cancelPercentAttr: function() {
      const contextVideo = this.context.video;
      contextVideo._cover.style.width = "";
      contextVideo._cover.style.height = "";
      contextVideo._cover.style.paddingBottom = "";
      contextVideo._container.style.width = "";
      contextVideo._container.style.height = "";
      this.util.removeClass(contextVideo._container, this.context.video._floatClassRegExp);
      this.util.addClass(contextVideo._container, "__se__float-" + contextVideo._align);
      if (contextVideo._align === "center") this.plugins.video.setAlign.call(this, null, null, null, null);
    },
    /**
     * @Override resizing
     */
    setAlign: function(align, element, cover, container) {
      const contextVideo = this.context.video;
      if (!align) align = contextVideo._align;
      if (!element) element = contextVideo._element;
      if (!cover) cover = contextVideo._cover;
      if (!container) container = contextVideo._container;
      if (/%$/.test(element.style.width) && align === "center") {
        container.style.minWidth = "100%";
        cover.style.width = container.style.width;
        cover.style.height = cover.style.height;
        cover.style.paddingBottom = !/%$/.test(cover.style.height) ? cover.style.height : this.util.getNumber(this.util.getNumber(cover.style.height, 2) / 100 * this.util.getNumber(cover.style.width, 2), 2) + "%";
      } else {
        container.style.minWidth = "";
        cover.style.width = this.context.resizing._rotateVertical ? element.style.height || element.offsetHeight : element.style.width || "100%";
        cover.style.paddingBottom = cover.style.height;
      }
      if (!this.util.hasClass(container, "__se__float-" + align)) {
        this.util.removeClass(container, contextVideo._floatClassRegExp);
        this.util.addClass(container, "__se__float-" + align);
      }
      element.setAttribute("data-align", align);
    },
    /**
     * @Override dialog
     */
    init: function() {
      const contextVideo = this.context.video;
      if (contextVideo.videoInputFile) contextVideo.videoInputFile.value = "";
      if (contextVideo.videoUrlFile) contextVideo._linkValue = contextVideo.preview.textContent = contextVideo.videoUrlFile.value = "";
      if (contextVideo.videoInputFile && contextVideo.videoUrlFile) {
        contextVideo.videoUrlFile.removeAttribute("disabled");
        contextVideo.preview.style.textDecoration = "";
      }
      contextVideo._origin_w = this.options.videoWidth;
      contextVideo._origin_h = this.options.videoHeight;
      contextVideo.modal.querySelector('input[name="suneditor_video_radio"][value="none"]').checked = true;
      if (contextVideo._resizing) {
        contextVideo.inputX.value = this.options.videoWidth === contextVideo._defaultSizeX ? "" : this.options.videoWidth;
        contextVideo.inputY.value = this.options.videoHeight === contextVideo._defaultSizeY ? "" : this.options.videoHeight;
        contextVideo.proportion.checked = true;
        contextVideo.proportion.disabled = true;
        this.plugins.video.setVideoRatioSelect.call(this, contextVideo._defaultRatio);
      }
    }
  };

  // ../../node_modules/suneditor/src/plugins/dialog/audio.js
  var import_dialog4 = __toESM(require_dialog());
  var import_component3 = __toESM(require_component2());
  var import_fileManager3 = __toESM(require_fileManager());
  var audio_default = {
    name: "audio",
    display: "dialog",
    add: function(core) {
      core.addModule([import_dialog4.default, import_component3.default, import_fileManager3.default]);
      const context = core.context;
      const contextAudio = context.audio = {
        _infoList: [],
        // @Override fileManager
        _infoIndex: 0,
        // @Override fileManager
        _uploadFileLength: 0,
        // @Override fileManager
        focusElement: null,
        // @Override dialog // This element has focus when the dialog is opened.
        targetSelect: null,
        _origin_w: core.options.audioWidth,
        _origin_h: core.options.audioHeight,
        _linkValue: "",
        // @require @Override component
        _element: null,
        _cover: null,
        _container: null
      };
      let audio_dialog = this.setDialog(core);
      contextAudio.modal = audio_dialog;
      contextAudio.audioInputFile = audio_dialog.querySelector("._se_audio_files");
      contextAudio.audioUrlFile = audio_dialog.querySelector(".se-input-url");
      contextAudio.focusElement = contextAudio.audioInputFile || contextAudio.audioUrlFile;
      contextAudio.preview = audio_dialog.querySelector(".se-link-preview");
      let audio_controller = this.setController(core);
      contextAudio.controller = audio_controller;
      audio_dialog.querySelector("form").addEventListener("submit", this.submit.bind(core));
      if (contextAudio.audioInputFile) audio_dialog.querySelector(".se-dialog-files-edge-button").addEventListener("click", this._removeSelectedFiles.bind(contextAudio.audioInputFile, contextAudio.audioUrlFile, contextAudio.preview));
      if (contextAudio.audioInputFile && contextAudio.audioUrlFile) contextAudio.audioInputFile.addEventListener("change", this._fileInputChange.bind(contextAudio));
      audio_controller.addEventListener("click", this.onClick_controller.bind(core));
      if (contextAudio.audioUrlFile) contextAudio.audioUrlFile.addEventListener("input", this._onLinkPreview.bind(contextAudio.preview, contextAudio, core.options.linkProtocol));
      context.dialog.modal.appendChild(audio_dialog);
      context.element.relative.appendChild(audio_controller);
      audio_dialog = null, audio_controller = null;
    },
    /** HTML - dialog */
    setDialog: function(core) {
      const option = core.options;
      const lang = core.lang;
      const dialog6 = core.util.createElement("DIV");
      dialog6.className = "se-dialog-content";
      dialog6.style.display = "none";
      let html2 = '<form method="post" enctype="multipart/form-data"><div class="se-dialog-header"><button type="button" data-command="close" class="se-btn se-dialog-close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + core.icons.cancel + '</button><span class="se-modal-title">' + lang.dialogBox.audioBox.title + '</span></div><div class="se-dialog-body">';
      if (option.audioFileInput) {
        html2 += '<div class="se-dialog-form"><label>' + lang.dialogBox.audioBox.file + '</label><div class="se-dialog-form-files"><input class="se-input-form _se_audio_files" type="file" accept="' + option.audioAccept + '"' + (option.audioMultipleFile ? ' multiple="multiple"' : "") + '/><button type="button" data-command="filesRemove" class="se-btn se-dialog-files-edge-button se-file-remove" title="' + lang.controller.remove + '" aria-label="' + lang.controller.remove + '">' + core.icons.cancel + "</button></div></div>";
      }
      if (option.audioUrlInput) {
        html2 += '<div class="se-dialog-form"><label>' + lang.dialogBox.audioBox.url + '</label><input class="se-input-form se-input-url" type="text" /><pre class="se-link-preview"></pre></div>';
      }
      html2 += '</div><div class="se-dialog-footer"><button type="submit" class="se-btn-primary" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '"><span>' + lang.dialogBox.submitButton + "</span></button></div></form>";
      dialog6.innerHTML = html2;
      return dialog6;
    },
    /** HTML - controller */
    setController: function(core) {
      const lang = core.lang;
      const icons = core.icons;
      const link_btn = core.util.createElement("DIV");
      link_btn.className = "se-controller se-controller-link";
      link_btn.innerHTML = '<div class="se-arrow se-arrow-up"></div><div class="link-content"><div class="se-btn-group"><button type="button" data-command="update" tabindex="-1" class="se-tooltip">' + icons.edit + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.edit + '</span></span></button><button type="button" data-command="delete" tabindex="-1" class="se-tooltip">' + icons.delete + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.remove + "</span></span></button></div></div>";
      return link_btn;
    },
    // Disable url input when uploading files
    _fileInputChange: function() {
      if (!this.audioInputFile.value) {
        this.audioUrlFile.removeAttribute("disabled");
        this.preview.style.textDecoration = "";
      } else {
        this.audioUrlFile.setAttribute("disabled", true);
        this.preview.style.textDecoration = "line-through";
      }
    },
    // Disable url input when uploading files
    _removeSelectedFiles: function(urlInput, preview) {
      this.value = "";
      if (urlInput) {
        urlInput.removeAttribute("disabled");
        preview.style.textDecoration = "";
      }
    },
    // create new audio tag
    _createAudioTag: function() {
      const oAudio = this.util.createElement("AUDIO");
      this.plugins.audio._setTagAttrs.call(this, oAudio);
      const w = this.context.audio._origin_w;
      const h = this.context.audio._origin_h;
      oAudio.setAttribute("origin-size", w + "," + h);
      oAudio.style.cssText = (w ? "width:" + w + "; " : "") + (h ? "height:" + h + ";" : "");
      return oAudio;
    },
    _setTagAttrs: function(element) {
      element.setAttribute("controls", true);
      const attrs = this.options.audioTagAttrs;
      if (!attrs) return;
      for (let key in attrs) {
        if (!this.util.hasOwn(attrs, key)) continue;
        element.setAttribute(key, attrs[key]);
      }
    },
    _onLinkPreview: function(context, protocol, e) {
      const value = e.target.value.trim();
      context._linkValue = this.textContent = !value ? "" : protocol && value.indexOf("://") === -1 && value.indexOf("#") !== 0 ? protocol + value : value.indexOf("://") === -1 ? "/" + value : value;
    },
    /**
     * @Required @Override fileManager
     */
    fileTags: ["audio"],
    /**
     * @Override core, fileManager, resizing
     * @description It is called from core.selectComponent.
     * @param {Element} element Target element
     */
    select: function(element) {
      this.plugins.audio.onModifyMode.call(this, element);
    },
    /**
     * @Override fileManager, resizing 
     */
    destroy: function(element) {
      element = element || this.context.audio._element;
      const container = this.util.getParentElement(element, this.util.isComponent) || element;
      const dataIndex = element.getAttribute("data-index") * 1;
      if (typeof this.functions.onAudioDeleteBefore === "function" && this.functions.onAudioDeleteBefore(element, container, dataIndex, this) === false) return;
      const focusEl = container.previousElementSibling || container.nextElementSibling;
      const emptyDiv = container.parentNode;
      this.util.removeItem(container);
      this.plugins.audio.init.call(this);
      this.controllersOff();
      if (emptyDiv !== this.context.element.wysiwyg) this.util.removeItemAllParents(emptyDiv, function(current) {
        return current.childNodes.length === 0;
      }, null);
      this.focusEdge(focusEl);
      this.plugins.fileManager.deleteInfo.call(this, "audio", dataIndex, this.functions.onAudioUpload);
      this.history.push(false);
    },
    /**
     * @Override fileManager
     */
    checkFileInfo: function() {
      this.plugins.fileManager.checkInfo.call(this, "audio", ["audio"], this.functions.onAudioUpload, this.plugins.audio.updateCover.bind(this), false);
    },
    /**
     * @Override fileManager
     */
    resetFileInfo: function() {
      this.plugins.fileManager.resetInfo.call(this, "audio", this.functions.onAudioUpload);
    },
    /**
     * @Required @Override dialog
     */
    on: function(update) {
      const contextAudio = this.context.audio;
      if (!update) {
        this.plugins.audio.init.call(this);
        if (contextAudio.audioInputFile && this.options.audioMultipleFile) contextAudio.audioInputFile.setAttribute("multiple", "multiple");
      } else if (contextAudio._element) {
        this.context.dialog.updateModal = true;
        contextAudio._linkValue = contextAudio.preview.textContent = contextAudio.audioUrlFile.value = contextAudio._element.src;
        if (contextAudio.audioInputFile && this.options.audioMultipleFile) contextAudio.audioInputFile.removeAttribute("multiple");
      } else {
        if (contextAudio.audioInputFile && this.options.audioMultipleFile) contextAudio.audioInputFile.removeAttribute("multiple");
      }
    },
    /**
     * @Required @Override dialog
     */
    open: function() {
      this.plugins.dialog.open.call(this, "audio", "audio" === this.currentControllerName);
    },
    submit: function(e) {
      const contextAudio = this.context.audio;
      e.preventDefault();
      e.stopPropagation();
      try {
        if (contextAudio.audioInputFile && contextAudio.audioInputFile.files.length > 0) {
          this.showLoading();
          this.plugins.audio.submitAction.call(this, contextAudio.audioInputFile.files);
        } else if (contextAudio.audioUrlFile && contextAudio._linkValue.length > 0) {
          this.showLoading();
          this.plugins.audio.setupUrl.call(this, contextAudio._linkValue);
        }
      } catch (error) {
        this.closeLoading();
        throw Error('[SUNEDITOR.audio.submit.fail] cause : "' + error.message + '"');
      } finally {
        this.plugins.dialog.close.call(this);
      }
      return false;
    },
    submitAction: function(fileList) {
      if (fileList.length === 0) return;
      let fileSize = 0;
      let files = [];
      for (let i = 0, len = fileList.length; i < len; i++) {
        if (/audio/i.test(fileList[i].type)) {
          files.push(fileList[i]);
          fileSize += fileList[i].size;
        }
      }
      const limitSize = this.options.audioUploadSizeLimit;
      if (limitSize > 0) {
        let infoSize = 0;
        const audiosInfo = this.context.audio._infoList;
        for (let i = 0, len = audiosInfo.length; i < len; i++) {
          infoSize += audiosInfo[i].size * 1;
        }
        if (fileSize + infoSize > limitSize) {
          this.closeLoading();
          const err = "[SUNEDITOR.audioUpload.fail] Size of uploadable total audios: " + limitSize / 1e3 + "KB";
          if (typeof this.functions.onAudioUploadError !== "function" || this.functions.onAudioUploadError(err, { "limitSize": limitSize, "currentSize": infoSize, "uploadSize": fileSize }, this)) {
            this.functions.noticeOpen(err);
          }
          return;
        }
      }
      const contextAudio = this.context.audio;
      contextAudio._uploadFileLength = files.length;
      const info = {
        isUpdate: this.context.dialog.updateModal,
        element: contextAudio._element
      };
      if (typeof this.functions.onAudioUploadBefore === "function") {
        const result = this.functions.onAudioUploadBefore(files, info, this, function(data2) {
          if (data2 && this._w.Array.isArray(data2.result)) {
            this.plugins.audio.register.call(this, info, data2);
          } else {
            this.plugins.audio.upload.call(this, info, data2);
          }
        }.bind(this));
        if (typeof result === "undefined") return;
        if (!result) {
          this.closeLoading();
          return;
        }
        if (typeof result === "object" && result.length > 0) files = result;
      }
      this.plugins.audio.upload.call(this, info, files);
    },
    error: function(message, response) {
      this.closeLoading();
      if (typeof this.functions.onAudioUploadError !== "function" || this.functions.onAudioUploadError(message, response, this)) {
        this.functions.noticeOpen(message);
        throw Error("[SUNEDITOR.plugin.audio.exception] response: " + message);
      }
    },
    upload: function(info, files) {
      if (!files) {
        this.closeLoading();
        return;
      }
      if (typeof files === "string") {
        this.plugins.audio.error.call(this, files, null);
        return;
      }
      const audioUploadUrl = this.options.audioUploadUrl;
      const filesLen = this.context.dialog.updateModal ? 1 : files.length;
      const formData = new FormData();
      for (let i = 0; i < filesLen; i++) {
        formData.append("file-" + i, files[i]);
      }
      this.plugins.fileManager.upload.call(this, audioUploadUrl, this.options.audioUploadHeader, formData, this.plugins.audio.callBack_upload.bind(this, info), this.functions.onAudioUploadError);
    },
    callBack_upload: function(info, xmlHttp) {
      if (typeof this.functions.audioUploadHandler === "function") {
        this.functions.audioUploadHandler(xmlHttp, info, this);
      } else {
        const response = JSON.parse(xmlHttp.responseText);
        if (response.errorMessage) {
          this.plugins.audio.error.call(this, response.errorMessage, response);
        } else {
          this.plugins.audio.register.call(this, info, response);
        }
      }
    },
    register: function(info, response) {
      const fileList = response.result;
      for (let i = 0, len = fileList.length, file, oAudio; i < len; i++) {
        if (info.isUpdate) oAudio = info.element;
        else oAudio = this.plugins.audio._createAudioTag.call(this);
        file = { name: fileList[i].name, size: fileList[i].size };
        this.plugins.audio.create_audio.call(this, oAudio, fileList[i].url, file, info.isUpdate);
      }
      this.closeLoading();
    },
    setupUrl: function(src) {
      try {
        if (src.length === 0) return false;
        this.plugins.audio.create_audio.call(this, this.plugins.audio._createAudioTag.call(this), src, null, this.context.dialog.updateModal);
      } catch (error) {
        throw Error('[SUNEDITOR.audio.audio.fail] cause : "' + error.message + '"');
      } finally {
        this.closeLoading();
      }
    },
    create_audio: function(element, src, file, isUpdate) {
      const contextAudio = this.context.audio;
      if (!isUpdate) {
        element.src = src;
        const cover = this.plugins.component.set_cover.call(this, element);
        const container = this.plugins.component.set_container.call(this, cover, "");
        if (!this.insertComponent(container, false, true, !this.options.mediaAutoSelect)) {
          this.focus();
          return;
        }
        if (!this.options.mediaAutoSelect) {
          const line = this.appendFormatTag(container, null);
          if (line) this.setRange(line, 0, line, 0);
        }
      } else {
        if (contextAudio._element) element = contextAudio._element;
        if (element && element.src !== src) {
          element.src = src;
          this.selectComponent(element, "audio");
        } else {
          this.selectComponent(element, "audio");
          return;
        }
      }
      this.plugins.fileManager.setInfo.call(this, "audio", element, this.functions.onAudioUpload, file, false);
      if (isUpdate) this.history.push(false);
    },
    updateCover: function(element) {
      const contextAudio = this.context.audio;
      this.plugins.audio._setTagAttrs.call(this, element);
      let existElement = this.util.isRangeFormatElement(element.parentNode) || this.util.isWysiwygDiv(element.parentNode) ? element : this.util.getFormatElement(element) || element;
      const prevElement = element;
      contextAudio._element = element = element.cloneNode(false);
      const cover = this.plugins.component.set_cover.call(this, element);
      const container = this.plugins.component.set_container.call(this, cover, "se-audio-container");
      try {
        if (this.util.getParentElement(prevElement, this.util.isNotCheckingNode)) {
          prevElement.parentNode.replaceChild(container, prevElement);
        } else if (this.util.isListCell(existElement)) {
          const refer = this.util.getParentElement(prevElement, function(current) {
            return current.parentNode === existElement;
          });
          existElement.insertBefore(container, refer);
          this.util.removeItem(prevElement);
          this.util.removeEmptyNode(refer, null, true);
        } else if (this.util.isFormatElement(existElement)) {
          const refer = this.util.getParentElement(prevElement, function(current) {
            return current.parentNode === existElement;
          });
          existElement = this.util.splitElement(existElement, refer);
          existElement.parentNode.insertBefore(container, existElement);
          this.util.removeItem(prevElement);
          this.util.removeEmptyNode(existElement, null, true);
          if (existElement.children.length === 0) existElement.innerHTML = this.util.htmlRemoveWhiteSpace(existElement.innerHTML);
        } else {
          existElement.parentNode.replaceChild(container, existElement);
        }
      } catch (error) {
        console.warn("[SUNEDITOR.audio.error] Maybe the audio tag is nested.", error);
      }
      this.plugins.fileManager.setInfo.call(this, "audio", element, this.functions.onAudioUpload, null, false);
      this.plugins.audio.init.call(this);
    },
    /**
     * @Required @Override fileManager, resizing
     */
    onModifyMode: function(selectionTag) {
      const contextAudio = this.context.audio;
      this.setControllerPosition(contextAudio.controller, selectionTag, "bottom", { left: 0, top: 0 });
      this.controllersOn(contextAudio.controller, selectionTag, this.plugins.audio.onControllerOff.bind(this, selectionTag), "audio");
      this.util.addClass(selectionTag, "active");
      contextAudio._element = selectionTag;
      contextAudio._cover = this.util.getParentElement(selectionTag, "FIGURE");
      contextAudio._container = this.util.getParentElement(selectionTag, this.util.isComponent);
    },
    /**
     * @Required @Override fileManager, resizing
     */
    openModify: function(notOpen) {
      if (this.context.audio.audioUrlFile) {
        const contextAudio = this.context.audio;
        contextAudio._linkValue = contextAudio.preview.textContent = contextAudio.audioUrlFile.value = contextAudio._element.src;
      }
      if (!notOpen) this.plugins.dialog.open.call(this, "audio", true);
    },
    onClick_controller: function(e) {
      e.stopPropagation();
      const command = e.target.getAttribute("data-command");
      if (!command) return;
      e.preventDefault();
      if (/update/.test(command)) {
        this.plugins.audio.openModify.call(this, false);
      } else {
        this.plugins.audio.destroy.call(this, this.context.audio._element);
      }
      this.controllersOff();
    },
    onControllerOff: function(selectionTag) {
      this.util.removeClass(selectionTag, "active");
      this.context.audio.controller.style.display = "none";
    },
    /**
     * @Required @Override dialog
     */
    init: function() {
      if (this.context.dialog.updateModal) return;
      const contextAudio = this.context.audio;
      if (contextAudio.audioInputFile) contextAudio.audioInputFile.value = "";
      if (contextAudio.audioUrlFile) contextAudio._linkValue = contextAudio.preview.textContent = contextAudio.audioUrlFile.value = "";
      if (contextAudio.audioInputFile && contextAudio.audioUrlFile) {
        contextAudio.audioUrlFile.removeAttribute("disabled");
        contextAudio.preview.style.textDecoration = "";
      }
      contextAudio._element = null;
    }
  };

  // ../../node_modules/suneditor/src/plugins/dialog/math.js
  var import_dialog5 = __toESM(require_dialog());
  var KATEX_WEBSITE = "https://katex.org/docs/supported.html";
  var math_default = {
    name: "math",
    display: "dialog",
    add: function(core) {
      core.addModule([import_dialog5.default]);
      const context = core.context;
      context.math = {
        focusElement: null,
        // @Override dialog // This element has focus when the dialog is opened.
        previewElement: null,
        fontSizeElement: null,
        defaultFontSize: "",
        _mathExp: null
      };
      let math_dialog = this.setDialog(core);
      context.math.modal = math_dialog;
      context.math.focusElement = math_dialog.querySelector(".se-math-exp");
      context.math.previewElement = math_dialog.querySelector(".se-math-preview");
      context.math.fontSizeElement = math_dialog.querySelector(".se-math-size");
      context.math.focusElement.addEventListener("paste", function(e) {
        if (typeof core.functions.onPasteMath === "function") {
          core.functions.onPasteMath(e, core);
        }
      }, false);
      context.math.focusElement.addEventListener(core.util.isIE ? "textinput" : "input", this._renderMathExp.bind(core, context.math), false);
      context.math.fontSizeElement.addEventListener("change", function(e) {
        this.fontSize = e.target.value;
      }.bind(context.math.previewElement.style), false);
      let math_controller = this.setController_MathButton(core);
      context.math.mathController = math_controller;
      context.math._mathExp = null;
      math_dialog.querySelector("form").addEventListener("submit", this.submit.bind(core), false);
      math_controller.addEventListener("click", this.onClick_mathController.bind(core));
      context.math.previewElement.style.fontSize = context.math.defaultFontSize;
      context.dialog.modal.appendChild(math_dialog);
      context.element.relative.appendChild(math_controller);
      math_dialog = null, math_controller = null;
    },
    /** dialog */
    setDialog: function(core) {
      const lang = core.lang;
      const dialog6 = core.util.createElement("DIV");
      const fontSize = core.options.mathFontSize;
      let defaultFontSize = fontSize[0].value;
      dialog6.className = "se-dialog-content";
      dialog6.style.display = "none";
      let html2 = '<form><div class="se-dialog-header"><button type="button" data-command="close" class="se-btn se-dialog-close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + core.icons.cancel + '</button><span class="se-modal-title">' + lang.dialogBox.mathBox.title + '</span></div><div class="se-dialog-body"><div class="se-dialog-form"><label>' + lang.dialogBox.mathBox.inputLabel + ' (<a href="' + KATEX_WEBSITE + '" target="_blank">KaTeX</a>)</label><textarea class="se-input-form se-math-exp" type="text"></textarea></div><div class="se-dialog-form"><label>' + lang.dialogBox.mathBox.fontSizeLabel + '</label><select class="se-input-select se-math-size">';
      for (let i = 0, len = fontSize.length, f; i < len; i++) {
        f = fontSize[i];
        if (f.default) defaultFontSize = f.value;
        html2 += '<option value="' + f.value + '"' + (f.default ? " selected" : "") + ">" + f.text + "</option>";
      }
      html2 += '</select></div><div class="se-dialog-form"><label>' + lang.dialogBox.mathBox.previewLabel + '</label><p class="se-math-preview"></p></div></div><div class="se-dialog-footer"><button type="submit" class="se-btn-primary" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '"><span>' + lang.dialogBox.submitButton + "</span></button></div></form>";
      core.context.math.defaultFontSize = defaultFontSize;
      dialog6.innerHTML = html2;
      return dialog6;
    },
    /** modify controller button */
    setController_MathButton: function(core) {
      const lang = core.lang;
      const math_btn = core.util.createElement("DIV");
      math_btn.className = "se-controller se-controller-link";
      math_btn.innerHTML = '<div class="se-arrow se-arrow-up"></div><div class="link-content"><div class="se-btn-group"><button type="button" data-command="update" tabindex="-1" class="se-btn se-tooltip">' + core.icons.edit + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.edit + '</span></span></button><button type="button" data-command="delete" tabindex="-1" class="se-btn se-tooltip">' + core.icons.delete + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.remove + "</span></span></button></div></div>";
      return math_btn;
    },
    /**
     * @Required @Override dialog
     */
    open: function() {
      this.plugins.dialog.open.call(this, "math", "math" === this.currentControllerName);
    },
    /**
     * @Override core - managedTagsInfo
     */
    managedTags: function() {
      return {
        className: "katex",
        method: function(element) {
          if (!element.getAttribute("data-exp") || !this.options.katex) return;
          const dom = this._d.createRange().createContextualFragment(this.plugins.math._renderer.call(this, this.util.HTMLDecoder(element.getAttribute("data-exp"))));
          element.innerHTML = dom.querySelector(".katex").innerHTML;
          element.setAttribute("contenteditable", false);
        }
      };
    },
    _renderer: function(exp) {
      let result = "";
      try {
        this.util.removeClass(this.context.math.focusElement, "se-error");
        result = this.options.katex.src.renderToString(exp, { throwOnError: true, displayMode: true });
      } catch (error) {
        this.util.addClass(this.context.math.focusElement, "se-error");
        result = '<span class="se-math-katex-error">Katex syntax error. (Refer <a href="' + KATEX_WEBSITE + '" target="_blank">KaTeX</a>)</span>';
        console.warn("[SUNEDITOR.math.Katex.error] ", error);
      }
      return result;
    },
    _renderMathExp: function(contextMath, e) {
      contextMath.previewElement.innerHTML = this.plugins.math._renderer.call(this, e.target.value);
    },
    submit: function(e) {
      this.showLoading();
      e.preventDefault();
      e.stopPropagation();
      const submitAction = function() {
        if (this.context.math.focusElement.value.trim().length === 0) return false;
        const contextMath = this.context.math;
        const mathExp = contextMath.focusElement.value;
        const katexEl = contextMath.previewElement.querySelector(".katex");
        if (!katexEl) return false;
        katexEl.className = "__se__katex " + katexEl.className;
        katexEl.setAttribute("contenteditable", false);
        katexEl.setAttribute("data-exp", this.util.HTMLEncoder(mathExp));
        katexEl.setAttribute("data-font-size", contextMath.fontSizeElement.value);
        katexEl.style.fontSize = contextMath.fontSizeElement.value;
        if (!this.context.dialog.updateModal) {
          const selectedFormats = this.getSelectedElements();
          if (selectedFormats.length > 1) {
            const oFormat = this.util.createElement(selectedFormats[0].nodeName);
            oFormat.appendChild(katexEl);
            if (!this.insertNode(oFormat, null, true)) return false;
          } else {
            if (!this.insertNode(katexEl, null, true)) return false;
          }
          const empty = this.util.createTextNode(this.util.zeroWidthSpace);
          katexEl.parentNode.insertBefore(empty, katexEl.nextSibling);
          this.setRange(katexEl, 0, katexEl, 1);
        } else {
          const containerEl = this.util.getParentElement(contextMath._mathExp, ".katex");
          containerEl.parentNode.replaceChild(katexEl, containerEl);
          this.setRange(katexEl, 0, katexEl, 1);
        }
        contextMath.focusElement.value = "";
        contextMath.fontSizeElement.value = "1em";
        contextMath.previewElement.style.fontSize = "1em";
        contextMath.previewElement.innerHTML = "";
        return true;
      }.bind(this);
      try {
        if (submitAction()) {
          this.plugins.dialog.close.call(this);
          this.history.push(false);
        }
      } catch (e2) {
        this.plugins.dialog.close.call(this);
      } finally {
        this.closeLoading();
      }
      return false;
    },
    active: function(element) {
      if (!element) {
        if (this.controllerArray.indexOf(this.context.math.mathController) > -1) {
          this.controllersOff();
        }
      } else if (element.getAttribute("data-exp")) {
        if (this.controllerArray.indexOf(this.context.math.mathController) < 0) {
          this.setRange(element, 0, element, 1);
          this.plugins.math.call_controller.call(this, element);
        }
        return true;
      }
      return false;
    },
    on: function(update) {
      if (!update) {
        this.plugins.math.init.call(this);
      } else {
        const contextMath = this.context.math;
        if (contextMath._mathExp) {
          const exp = this.util.HTMLDecoder(contextMath._mathExp.getAttribute("data-exp"));
          const fontSize = contextMath._mathExp.getAttribute("data-font-size") || "1em";
          this.context.dialog.updateModal = true;
          contextMath.focusElement.value = exp;
          contextMath.fontSizeElement.value = fontSize;
          contextMath.previewElement.innerHTML = this.plugins.math._renderer.call(this, exp);
          contextMath.previewElement.style.fontSize = fontSize;
        }
      }
    },
    call_controller: function(mathTag) {
      this.context.math._mathExp = mathTag;
      const mathBtn = this.context.math.mathController;
      this.setControllerPosition(mathBtn, mathTag, "bottom", { left: 0, top: 0 });
      this.controllersOn(mathBtn, mathTag, "math");
    },
    onClick_mathController: function(e) {
      e.stopPropagation();
      const command = e.target.getAttribute("data-command") || e.target.parentNode.getAttribute("data-command");
      if (!command) return;
      e.preventDefault();
      if (/update/.test(command)) {
        this.context.math.focusElement.value = this.util.HTMLDecoder(this.context.math._mathExp.getAttribute("data-exp"));
        this.plugins.dialog.open.call(this, "math", true);
      } else {
        this.util.removeItem(this.context.math._mathExp);
        this.context.math._mathExp = null;
        this.focus();
        this.history.push(false);
      }
      this.controllersOff();
    },
    init: function() {
      const contextMath = this.context.math;
      contextMath.mathController.style.display = "none";
      contextMath._mathExp = null;
      contextMath.focusElement.value = "";
      contextMath.previewElement.innerHTML = "";
    }
  };

  // ../../node_modules/suneditor/src/plugins/fileBrowser/imageGallery.js
  var import_fileBrowser = __toESM(require_fileBrowser());
  var imageGallery_default = {
    name: "imageGallery",
    /**
     * @description Constructor
     * @param {Object} core Core object 
     */
    add: function(core) {
      core.addModule([import_fileBrowser.default]);
      const context = core.context;
      context.imageGallery = {
        title: core.lang.toolbar.imageGallery,
        // @Required @Override fileBrowser - File browser window title.
        url: core.options.imageGalleryUrl,
        // @Required @Override fileBrowser - File server url.
        header: core.options.imageGalleryHeader,
        // @Required @Override fileBrowser - File server http header.
        listClass: "se-image-list",
        // @Required @Override fileBrowser - Class name of list div.
        itemTemplateHandler: this.drawItems,
        // @Required @Override fileBrowser - Function that defines the HTML of an file item.
        selectorHandler: this.setImage.bind(core),
        // @Required @Override fileBrowser - Function that action when item click.
        columnSize: 4
        // @Option @Override fileBrowser - Number of "div.se-file-item-column" to be created (default: 4)
      };
    },
    /**
     * @Required @Override fileBrowser
     * @description Open a file browser.
     * @param {Function|null} selectorHandler When the function comes as an argument value, it substitutes "context.selectorHandler".
     */
    open: function(selectorHandler) {
      this.plugins.fileBrowser.open.call(this, "imageGallery", selectorHandler);
    },
    /**
     * @Required @Override fileBrowser
     * @description Define the HTML of the item to be put in "div.se-file-item-column".
     * Format: [
     *      { src: "image src", name: "name(@option)", alt: "image alt(@option)", tag: "tag name(@option)" }
     * ]
     * @param {Object} item Item of the response data's array
     */
    drawItems: function(item) {
      const srcName = item.src.split("/").pop();
      return '<div class="se-file-item-img"><img src="' + (item.thumbnail || item.src) + '" alt="' + (item.alt || srcName) + '" data-command="pick" data-value="' + (item.src || item.thumbnail) + '"><div class="se-file-img-name se-file-name-back"></div><div class="se-file-img-name __se__img_name">' + (item.name || srcName) + "</div></div>";
    },
    setImage: function(target, fileName) {
      this.callPlugin("image", function() {
        const file = { name: fileName, size: 0 };
        this.plugins.image.create_image.call(this, target.getAttribute("data-value"), null, this.context.image._origin_w, this.context.image._origin_h, "none", file, target.alt);
      }.bind(this), null);
    }
  };

  // ../../node_modules/suneditor/src/plugins/index.js
  var plugins_default = { blockquote: blockquote_default, align: align_default, font: font_default, fontSize: fontSize_default, fontColor: fontColor_default, hiliteColor: hiliteColor_default, horizontalRule: horizontalRule_default, list: list_default, table: table_default, formatBlock: formatBlock_default, lineHeight: lineHeight_default, template: template_default, paragraphStyle: paragraphStyle_default, textStyle: textStyle_default, link: link_default, image: image_default, video: video_default, audio: audio_default, math: math_default, imageGallery: imageGallery_default };

  // ink-component-resolver:C:\Users\Win 10\dev\ink\node_modules\@stackpress\ink-ui\field\wysiwyg.ink
  var import_StyleSet27 = __toESM(require_StyleSet());
  var import_display17 = __toESM(require_display());
  var Wysiwyg_7e3499be9641069413db = class extends import_Component30.default {
    static id = "7e3499be9641069413db";
    static tagname = "wysiwyg";
    static classname = "Wysiwyg_7e3499be9641069413db";
    styles() {
      return `.sun-editor {width:auto; height:auto; box-sizing:border-box; font-family:Helvetica Neue; border:1px solid #dadada; background-color:#FFF; color:#000; user-select:none; -o-user-select:none; -moz-user-select:none; -khtml-user-select:none; -webkit-user-select:none; -ms-user-select:none;}
  .sun-editor * {box-sizing:border-box;  -webkit-user-drag:none; overflow:visible;}
  .sun-editor-common input, .sun-editor-common select, .sun-editor-common textarea, .sun-editor-common button {font-size:14px; line-height:1.5;}
  .sun-editor-common body, .sun-editor-common div, .sun-editor-common dl, .sun-editor-common dt, .sun-editor-common dd, .sun-editor-common ul, .sun-editor-common ol, .sun-editor-common li,
  .sun-editor-common h1, .sun-editor-common h2, .sun-editor-common h3, .sun-editor-common h4, .sun-editor-common h5, .sun-editor-common h6, .sun-editor-common pre, .sun-editor-common code,
  .sun-editor-common form, .sun-editor-common fieldset, .sun-editor-common legend, .sun-editor-common textarea, .sun-editor-common p, .sun-editor-common blockquote, .sun-editor-common th,
  .sun-editor-common td, .sun-editor-common input, .sun-editor-common select, .sun-editor-common textarea, .sun-editor-common button {margin:0; padding:0; border:0;}
  .sun-editor-common dl, .sun-editor-common ul, .sun-editor-common ol, .sun-editor-common menu, .sun-editor-common li {list-style:none !important;}
  .sun-editor-common hr {margin:6px 0 6px 0 !important;}
  .sun-editor textarea {resize:none; border:0; padding:0;}
  .sun-editor button {border:0 none; background-color:transparent; touch-action:manipulation; cursor:pointer; outline:none;}
  .sun-editor input, .sun-editor select, .sun-editor textarea, .sun-editor button {vertical-align:middle;}
  .sun-editor button span {display:block; margin:0; padding:0;}
  .sun-editor button .txt {display:block; margin-top:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  .sun-editor button * {
    pointer-events: none;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
    -moz-backface-visibility: hidden;
  }
  .sun-editor svg {
    fill: currentColor;
  }
  .sun-editor button > svg, .sun-editor .se-svg {
    width: 16px;
    height: 16px;
    margin: auto;
    fill: currentColor;
    display: block;
    text-align: center;
    float: none;
  }
  .sun-editor .close > svg, .sun-editor .se-dialog-close > svg {
    width: 10px;
    height: 10px;
  }
  .sun-editor .se-btn-select > svg {
    float: right;
    width: 10px;
    height: 10px;
  }
  .sun-editor .se-btn-list > .se-list-icon {
    display: inline-block;
    width: 16px;
    height: 16px;
    margin: -1px 10px 0 0;
    vertical-align: middle;
  }
  .sun-editor .se-line-breaker > button > svg {
    width: 24px;
    height: 24px;
  }
  .sun-editor button > i::before {
    -moz-osx-font-smoothing:grayscale;
    -webkit-font-smoothing:antialiased;
    display: inline-block;
    font-style: normal;
    font-variant: normal;
    text-rendering:auto;
    font-size: 15px;
    line-height: 2;
  }
  .sun-editor button > [class="se-icon-text"] {
    font-size: 20px;
    line-height: 1;
  }
  .sun-editor .se-arrow, .sun-editor .se-arrow::after {position:absolute; display:block; width:0; height:0; border:11px solid transparent;}
  .sun-editor .se-arrow.se-arrow-up {top:-11px; left:20px; margin-left:-11px; border-top-width:0; border-bottom-color:#dadada;}
  .sun-editor .se-arrow.se-arrow-up::after {top:1px; margin-left:-11px; content:" "; border-top-width:0; border-bottom-color:#fff;}
  .sun-editor .se-toolbar .se-arrow.se-arrow-up::after {border-bottom-color:#fafafa;}
  .sun-editor .se-arrow.se-arrow-down {top:0px; left:0px; margin-left:-11px; border-bottom-width:0; border-top-color:#dadada;}
  .sun-editor .se-arrow.se-arrow-down::after {top:-12px; margin-left:-11px; content:" "; border-bottom-width:0; border-top-color:#fff;}
  .sun-editor .se-toolbar .se-arrow.se-arrow-down::after {border-top-color:#fafafa;}
  .sun-editor .se-container {position:relative; width:auto; height:auto;}
  .sun-editor button {color:#000;}
  .sun-editor .se-btn {float:left; width:34px; height:34px; border:0; border-radius:4px; margin:1px !important; padding:0; font-size:12px; line-height:27px;}
  .sun-editor .se-btn:enabled:hover, .sun-editor .se-btn:enabled:focus {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-btn:enabled:active {background-color:#d1d1d1; border-color:#c1c1c1; -webkit-box-shadow:inset 0 3px 5px #c1c1c1; box-shadow:inset 0 3px 5px #c1c1c1;}
  .sun-editor .se-btn-primary {color:#000; background-color:#c7deff; border:1px solid #80bdff; border-radius:4px;}
  .sun-editor .se-btn-primary:hover, .sun-editor .se-btn-primary:focus {color:#000; background-color:#80bdff; border-color:#3f9dff; outline:0 none;}
  .sun-editor .se-btn-primary:active {color:#fff; background-color:#3f9dff; border-color:#4592ff; -webkit-box-shadow:inset 0 3px 5px #4592ff; box-shadow:inset 0 3px 5px #4592ff;}
  .sun-editor input, .sun-editor select, .sun-editor textarea {color:#000; border:1px solid #ccc; border-radius:4px;}
  .sun-editor input:focus, .sun-editor select:focus, .sun-editor textarea:focus {border:1px solid #80bdff; outline:0; -webkit-box-shadow:0 0 0 0.2rem #c7deff; box-shadow:0 0 0 0.2rem #c7deff; transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out;}
  .sun-editor .se-btn:enabled.active {color:#4592ff; outline:0 none;}
  .sun-editor .se-btn:enabled.active:hover, .sun-editor .se-btn:enabled.active:focus {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-btn:enabled.active:active {background-color:#d1d1d1; border-color:#c1c1c1; -webkit-box-shadow:inset 0 3px 5px #c1c1c1; box-shadow:inset 0 3px 5px #c1c1c1;}
  .sun-editor .se-btn:enabled.on {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-btn:enabled.on:hover, .sun-editor .se-btn:enabled.on:focus {background-color:#d1d1d1; border-color:#c1c1c1; outline:0 none;}
  .sun-editor .se-btn:enabled.on:active {background-color:#c1c1c1; border-color:#b1b1b1; -webkit-box-shadow:inset 0 3px 5px #b1b1b1; box-shadow:inset 0 3px 5px #b1b1b1;}
  .sun-editor .se-btn:disabled, .sun-editor .se-btn-list:disabled, .sun-editor button:disabled {cursor:not-allowed; background-color:inherit; color:#bdbdbd;}
  .sun-editor .se-loading-box {position:absolute; display:none; width:100%; height:100%; top:0; left:0; background-color:#fff; opacity:.7; filter:alpha(opacity=70); z-index:2147483647;}
  .sun-editor .se-loading-box .se-loading-effect {position:absolute; display:block; top:50%; left:50%; height:25px; width:25px; border-top:2px solid #07d; border-right:2px solid transparent; border-radius:50%; animation:spinner .8s linear infinite; margin:-25px 0 0 -25px;}
  .sun-editor .se-line-breaker {position:absolute; display:none; width:100%; height:1px; cursor:text; border-top:1px solid #3288ff; z-index:7;}
  .sun-editor .se-line-breaker > button.se-btn {position:relative; display:inline-block; width:30px; height:30px; top:-15px; float:none; left:-50%; background-color:#fff; border:1px solid #0c2240; opacity:0.6; cursor:pointer;}
  .sun-editor .se-line-breaker > button.se-btn:hover {opacity:0.9; background-color:#fff; border-color:#041b39;}
  .sun-editor .se-line-breaker-component {position:absolute; display:none; width:24px; height:24px; background-color:#fff; border:1px solid #0c2240; opacity:0.6; border-radius:4px; cursor:pointer; z-index:7;}
  .sun-editor .se-line-breaker-component:hover {opacity:0.9;}
  .sun-editor .se-toolbar {display:block; position:relative; height:auto; width:100%; overflow:visible; padding:0; margin:0; background-color:#fafafa; outline:1px solid #dadada; z-index:5;}
  .sun-editor .se-toolbar-shadow {display:block !important; height:0px !important; padding:0 !important; margin:0 !important; background-color:transparent !important;  outline:none !important; border: none !important; z-index:0 !important;}
  .sun-editor .se-toolbar-cover {position:absolute; display:none; font-size:36px; width:100%; height:100%; top:0; left:0; background-color:#fefefe; opacity:.5; filter:alpha(opacity=50); cursor:not-allowed; z-index:4;}
  .sun-editor .se-toolbar-separator-vertical {display:inline-block; height:0px; width:0px; margin:0px; vertical-align:top;}
  .sun-editor .se-toolbar.se-toolbar-inline {display:none; position:absolute; box-shadow:0 3px 9px rgba(0,0,0,.5); -webkit-box-shadow:0 3px 9px rgba(0,0,0,.5);}
  .sun-editor .se-toolbar.se-toolbar-balloon {display:none; position:absolute; z-index:2147483647; width:auto; box-shadow:0 3px 9px rgba(0,0,0,.5); -webkit-box-shadow:0 3px 9px rgba(0,0,0,.5);}
  .sun-editor .se-toolbar.se-toolbar-sticky {position:fixed; top:0px;}
  .sun-editor .se-toolbar-sticky-dummy {display:none; position:static; z-index:-1;}
  .sun-editor .se-btn-module {display:inline-block;}
  .sun-editor .se-btn-module-border {border:1px solid #dadada; border-radius:4px; margin-left:1px; margin-right:1px;}
  .sun-editor .se-btn-module-enter {display:block; width:100%; height:0px; margin:0; padding:0; background-color:transparent;}
  .sun-editor .se-toolbar-more-layer {margin:0 -3px; background-color:#fafafa;}
  .sun-editor .se-toolbar-more-layer .se-more-layer {display:none;  border-top:1px solid #dadada;}
  .sun-editor .se-toolbar-more-layer .se-more-layer .se-more-form {display:inline-block; width:100%; height:auto; padding:4px 3px 0 3px;}
  .sun-editor .se-btn-module .se-btn-more.se-btn-more-text {width:auto; padding:0 4px;}
  .sun-editor .se-btn-module .se-btn-more:hover, .sun-editor .se-btn-module .se-btn-more:focus {color:#000; background-color:#d1d1d1; border-color:#c1c1c1; outline:0 none;}
  .sun-editor .se-btn-module .se-btn-more.on {color:#333; background-color:#d1d1d1; border-color:#c1c1c1; outline:0 none;}
  .sun-editor .se-btn-module .se-btn-more.on:hover {color:#000; background-color:#c1c1c1; border-color:#b1b1b1; outline:0 none;}
  .sun-editor .se-menu-list {float:left; padding:0; margin:0;}
  .sun-editor .se-menu-list li {position:relative; float:left; padding:0; margin:0;}
  .sun-editor .se-btn-select {width:auto; display:flex; padding:4px 6px;}
  .sun-editor .se-btn-select .txt {flex:auto; text-align:left;}
  .sun-editor .se-btn-select.se-btn-tool-font {width:100px;}
  .sun-editor .se-btn-select.se-btn-tool-format {width:82px;}
  .sun-editor .se-btn-select.se-btn-tool-size {width:78px;}
  .sun-editor .se-btn-tray {position:relative; width:100%; height:auto; padding:4px 3px 0 3px; margin:0;}
  .sun-editor .se-menu-tray {position:absolute; top:0px; left:0px; width:100%; height:0px;}
  .sun-editor .se-submenu {overflow-x:hidden; overflow-y:auto;}
  .sun-editor .se-menu-container {overflow-x:unset; overflow-y:unset;}
  .sun-editor .se-list-layer {display:none; position:absolute; top:0px; left:0px; height:auto; z-index:5; border:1px solid #bababa; border-radius:4px; padding:6px 0; background-color:#fff; -webkit-box-shadow:0 3px 9px rgba(0, 0, 0, .5); box-shadow:0 3px 9px rgba(0, 0, 0, .5); outline:0 none;}
  .sun-editor .se-list-layer .se-list-inner {padding:0; margin:0; overflow-x:initial; overflow-y:initial; overflow:visible;}
  .sun-editor .se-list-layer button {margin:0; width:100%;}
  .sun-editor .se-list-inner ul {width:100%; padding:0;}
  .sun-editor .se-list-inner li > button {min-width:100%; width:max-content;}
  .sun-editor .se-list-inner .se-list-basic li {width:100%;}
  .sun-editor .se-list-inner .se-list-basic li button.active {background-color:#80bdff; border:1px solid #3f9dff; border-left:0; border-right:0;}
  .sun-editor .se-list-inner .se-list-basic li button.active:hover {background-color:#3f9dff; border:1px solid #4592ff; border-left:0; border-right:0;}
  .sun-editor .se-list-inner .se-list-basic li button.active:active {background-color:#4592ff; border:1px solid #407dd1; border-left:0; border-right:0; -webkit-box-shadow:inset 0 3px 5px #407dd1; box-shadow:inset 0 3px 5px #407dd1;}
  .sun-editor .se-list-inner .se-list-checked li button > .se-svg {float:left; padding:6px 6px 0 0;}
  .sun-editor .se-list-inner .se-list-checked li button > .se-svg > svg {display:none;}
  .sun-editor .se-list-inner .se-list-checked li button.se-checked {color:#4592ff;}
  .sun-editor .se-list-inner .se-list-checked li button.se-checked > .se-svg > svg {display:block;}
  .sun-editor .se-btn-list {width:100%; height:auto; min-height:32px; padding:0 14px; cursor:pointer; font-size:12px; line-height:normal; text-indent:0; text-decoration:none; text-align:left;}
  .sun-editor .se-btn-list.default_value {background-color:#f3f3f3; border-top:1px dotted #b1b1b1; border-bottom:1px dotted #b1b1b1;}
  .sun-editor .se-btn-list:hover, .sun-editor .se-btn-list:focus {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-btn-list:active {background-color:#d1d1d1; border-color:#c1c1c1; -webkit-box-shadow:inset 0 3px 5px #c1c1c1; box-shadow:inset 0 3px 5px #c1c1c1;}
  .sun-editor .se-list-layer.se-list-font-size {min-width:140px; max-height:300px;}
  .sun-editor .se-list-layer.se-list-font-family {min-width:156px;}
  .sun-editor .se-list-layer.se-list-font-family .default {border-bottom:1px solid #CCC;}
  .sun-editor .se-list-layer.se-list-line {width:125px;}
  .sun-editor .se-list-layer.se-list-line hr {border-width: 1px 0 0; height: 1px;}
  .sun-editor .se-list-layer.se-list-align .se-list-inner {left:9px;}
  .sun-editor .se-list-layer.se-list-format {min-width:156px;}
  .sun-editor .se-list-layer.se-list-format li {padding:0; width:100%;}
  .sun-editor .se-list-layer.se-list-format ul .se-btn-list {line-height:100%;}
  .sun-editor .se-list-layer.se-list-format ul .se-btn-list[data-value="h1"] {height:40px;}
  .sun-editor .se-list-layer.se-list-format ul .se-btn-list[data-value="h2"] {height:34px;}
  .sun-editor .se-list-layer.se-list-format ul p {font-size:13px;}
  .sun-editor .se-list-layer.se-list-format ul div {font-size:13px; padding:4px 2px;}
  .sun-editor .se-list-layer.se-list-format ul h1 {font-size:2em; font-weight:bold; color:#333;}
  .sun-editor .se-list-layer.se-list-format ul h2 {font-size:1.5em; font-weight:bold; color:#333;}
  .sun-editor .se-list-layer.se-list-format ul h3 {font-size:1.17em; font-weight:bold; color:#333;}
  .sun-editor .se-list-layer.se-list-format ul h4 {font-size:1em; font-weight:bold; color:#333;}
  .sun-editor .se-list-layer.se-list-format ul h5 {font-size:0.83em; font-weight:bold; color:#333;}
  .sun-editor .se-list-layer.se-list-format ul h6 {font-size:0.67em; font-weight:bold; color:#333;}
  .sun-editor .se-list-layer.se-list-format ul blockquote {font-size:13px; color:#999; height:22px; margin:0; background-color:transparent; line-height:1.5; border-style:solid; border-color:#b1b1b1; padding:0 0 0 7px; border-left-width:5px;}
  .sun-editor .se-list-layer.se-list-format ul pre {font-size:13px; color:#666; padding:4px 11px; margin:0; background-color:#f9f9f9; border:1px solid #e1e1e1; border-radius:4px;}
  .sun-editor .se-selector-table {display:none; position:absolute; top:34px; left:1px; z-index:5; padding:5px 0; float:left; margin:2px 0 0; font-size:14px; text-align:left; list-style:none; background-color:#fff; -webkit-background-clip:padding-box; background-clip:padding-box; border:1px solid #ccc; border-radius:4px; -webkit-box-shadow:0 6px 12px rgba(0, 0, 0, .175); box-shadow:0 6px 12px rgba(0, 0, 0, .175);}
  .sun-editor .se-selector-table .se-table-size {font-size:18px; padding:0 5px;}
  .sun-editor .se-selector-table .se-table-size-picker {position:absolute !important; z-index:3; font-size:18px; width:10em; height:10em; cursor:pointer;}
  .sun-editor .se-selector-table .se-table-size-highlighted {position:absolute !important; z-index:2; font-size:18px; width:1em; height:1em; background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAADJmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4QTZCNzMzN0I3RUYxMUU4ODcwQ0QwMjM1NTgzRTJDNyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4QTZCNzMzNkI3RUYxMUU4ODcwQ0QwMjM1NTgzRTJDNyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0MzYyNEUxRUI3RUUxMUU4ODZGQzgwRjNBODgyNTdFOSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MzYyNEUxRkI3RUUxMUU4ODZGQzgwRjNBODgyNTdFOSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pl0yAuwAAABBSURBVDhPY/wPBAxUAGCDGvdBeWSAeicIDTfIXREiQArYeR9hEBOEohyMGkQYjBpEGAxjg6ib+yFMygCVvMbAAABj0hwMTNeKJwAAAABJRU5ErkJggg==') repeat;}
  .sun-editor .se-selector-table .se-table-size-unhighlighted {position:relative !important; z-index:1; font-size:18px; width:10em; height:10em; background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASAgMAAAAroGbEAAAACVBMVEUAAIj4+Pjp6ekKlAqjAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfYAR0BKhmnaJzPAAAAG0lEQVQI12NgAAOtVatWMTCohoaGUY+EmIkEAEruEzK2J7tvAAAAAElFTkSuQmCC') repeat;}
  .sun-editor .se-selector-table .se-table-size-display {padding-left:5px;}
  .sun-editor .se-list-layer.se-table-split {top:36px;}
  .sun-editor .se-list-layer .se-selector-color {display:flex; width:max-content; max-width:270px; height:auto; padding:0; margin:auto;}
  .sun-editor .se-list-layer .se-selector-color .se-color-pallet {width:100%; height:100%; padding:0;}
  .sun-editor .se-list-layer .se-selector-color .se-color-pallet li {display:flex; float:left; position:relative; margin:0;}
  .sun-editor .se-list-layer .se-selector-color .se-color-pallet button {display:block; cursor:default; width:30px; height:30px; text-indent:-9999px;}
  .sun-editor .se-list-layer .se-selector-color .se-color-pallet button.active, 
  .sun-editor .se-list-layer .se-selector-color .se-color-pallet button:hover, 
  .sun-editor .se-list-layer .se-selector-color .se-color-pallet button:focus {border:3px solid #fff;}
  .sun-editor .se-form-group {display:flex; width:100%; min-height:40px; height:auto; padding:4px;}
  .sun-editor .se-form-group input {flex:auto; display:inline-block; width:auto; height:33px; font-size:12px; margin:1px 0 1px 0; padding:0; border-radius:0.25rem; border:1px solid #ccc;}
  .sun-editor .se-form-group button, .sun-editor .se-submenu-form-group button {float:right; width:34px; height:34px; margin:0 2px !important;}
  .sun-editor .se-form-group button.se-btn, .sun-editor .se-form-group button.se-btn {border:1px solid #ccc;}
  .sun-editor .se-form-group > div {position:relative;}
  .sun-editor .se-form-group label {display:inline-block; max-width:100%; margin-bottom:5px; font-weight:bold;}
  .sun-editor .se-form-group-label {width:100%; height:auto; padding:0px 4px;}
  .sun-editor .se-form-group-label label {font-size:13px; font-weight:bold;}
  .sun-editor .se-submenu .se-form-group input {width:auto; height:33px; color:#555;}
  .sun-editor .se-submenu .se-form-group .se-color-input {width:72px; text-transform:uppercase; border:none; border-bottom:2px solid #b1b1b1; outline:none;}
  .sun-editor .se-submenu .se-form-group .se-color-input:focus {border-bottom:3px solid #b1b1b1;}
  .sun-editor .se-wrapper {position:relative !important; width:100%; height:auto; overflow:hidden; z-index:1;}
  .sun-editor .se-wrapper .se-wrapper-inner {width:100%; height:100%; min-height:65px; overflow-y:auto; overflow-x:auto; -webkit-overflow-scrolling:touch; user-select:auto; -o-user-select:auto; -moz-user-select:auto; -khtml-user-select:auto; -webkit-user-select:auto; -ms-user-select:auto;}
  .sun-editor .se-wrapper .se-wrapper-inner:focus {outline:none;}
  .sun-editor .se-wrapper .se-wrapper-code {background-color:#191919; color:#fff; font-size:13px; word-break:break-all; padding:4px; margin:0; resize:none !important;}
  .sun-editor .se-wrapper .se-wrapper-wysiwyg {display:block;}
  .sun-editor .se-wrapper .se-wrapper-code-mirror {font-size:13px;}
  .sun-editor .se-wrapper .se-placeholder {position:absolute; display:none; white-space:nowrap; text-overflow:ellipsis; z-index:1; color:#b1b1b1; font-size:13px; line-height:1.5; top:0; left:0; right:0; overflow:hidden; margin-top:0px; padding-top:16px; padding-left:16px; margin-left:0px; padding-right:16px; margin-right:0px; pointer-events:none; backface-visibility:hidden; -webkit-backface-visibility:hidden; -moz-backface-visibility:hidden;}
  .sun-editor .se-resizing-bar {display:flex; width:auto; height:auto; min-height:16px; border-top:1px solid #dadada; padding:0 4px; background-color:#fafafa; cursor:ns-resize;}
  .sun-editor .se-resizing-bar.se-resizing-none {cursor:default;}
  .sun-editor .se-resizing-back {position:absolute; display:none; cursor:default; top:0; left:0; width:100%; height:100%; z-index:2147483647;}
  .sun-editor .se-resizing-bar .se-navigation {flex:auto; position:relative; width:auto; height:auto; color:#666; margin:0; padding:0; font-size:10px; line-height:1.5; background:transparent;}
  .sun-editor .se-resizing-bar .se-char-counter-wrapper {flex:none; position:relative; display:block; width:auto; height:auto; margin:0; padding:0; color:#999; font-size:13px; background:transparent;}
  .sun-editor .se-resizing-bar .se-char-counter-wrapper.se-blink {color:#b94a48; animation:blinker 0.2s linear infinite;}
  .sun-editor .se-resizing-bar .se-char-counter-wrapper .se-char-label {margin-right:4px;}
  .sun-editor .se-dialog {position:absolute; display:none; top:0; left:0; width:100%; height:100%; z-index:2147483647;}
  .sun-editor .se-dialog label, .sun-editor .se-dialog input, .sun-editor .se-dialog button {font-size:14px; line-height:1.5; color:#111; margin:0;}
  .sun-editor .se-dialog .se-dialog-back {position:absolute; width:100%; height:100%; top:0; left:0; background-color:#222; opacity:0.5;}
  .sun-editor .se-dialog .se-dialog-inner {position:absolute; width:100%; height:100%; top:0; left:0;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-content {position:relative; width:auto; max-width:500px; margin:1.75rem auto; background-color:#fff; -webkit-background-clip:padding-box; background-clip:padding-box; border:1px solid rgba(0, 0, 0, .2); border-radius:4px; outline:0; -webkit-box-shadow:0 3px 9px rgba(0, 0, 0, .5); box-shadow:0 3px 9px rgba(0, 0, 0, .5);}
  @media screen and (max-width:509px) { .sun-editor .se-dialog .se-dialog-inner .se-dialog-content {width:100%;} }
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-content label {display:inline-block; max-width:100%; margin-bottom:5px; font-weight:bold;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-content .se-btn-primary {display:inline-block; padding:6px 12px; margin:0 0 10px 0 !important; font-size:14px; font-weight:normal; line-height:1.42857143; text-align:center; white-space:nowrap; vertical-align:middle; -ms-touch-action:manipulation; touch-action:manipulation; border-radius:4px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-header {height:50px; padding:6px 15px 6px 15px; border-bottom:1px solid #e5e5e5;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-header .se-dialog-close {float:right; font-weight:bold; text-shadow:0 1px 0 #fff; -webkit-appearance:none; filter:alpha(opacity=100); opacity:1;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-header .se-modal-title {float:left; font-size:14px; font-weight:bold; margin:0; padding:0; line-height:2.5;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-body {position:relative; padding:15px 15px 5px 15px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form {margin-bottom:10px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form-footer {margin-top:10px; margin-bottom:0;}
  .sun-editor .se-dialog .se-dialog-inner input:disabled {background-color:#f3f3f3;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-size-text {width:100%;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-size-text .size-w {width:70px; text-align:center;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-size-text .size-h {width:70px; text-align:center;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-size-x {margin:0 8px 0 8px; width:25px; text-align:center;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-footer {height:auto; min-height:55px; padding:10px 15px 0px 15px; text-align:right; border-top:1px solid #e5e5e5;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-footer > div {float:left;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-footer > div > label {margin:0 5px 0 0;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-btn-radio {margin-left:12px; margin-right:6px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-btn-check {margin-left:12px; margin-right:4px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form-footer .se-dialog-btn-check {margin-left:0; margin-right:4px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form-footer label:first-child {margin-right:16px; margin-left:0px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-dialog-form-files {position:relative; display:flex; align-items:center;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-dialog-form-files > input {flex:auto;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-dialog-form-files .se-dialog-files-edge-button {flex:auto; opacity:0.8; border:1px solid #ccc;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-dialog-form-files .se-dialog-files-edge-button.se-file-remove > svg {width:8px; height:8px;} /* custom."remove icon" */
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-dialog-form-files .se-dialog-files-edge-button:hover {background-color:#f0f0f0; outline:0 none;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-dialog-form-files .se-dialog-files-edge-button:active {background-color:#e9e9e9; -webkit-box-shadow:inset 0 3px 5px #d6d6d6; box-shadow:inset 0 3px 5px #d6d6d6;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-input-select {display:inline-block; width:auto; height:34px; font-size:14px; text-align:center; line-height:1.42857143;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-input-control {display:inline-block; width:70px; height:34px; font-size:14px; text-align:center; line-height:1.42857143;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-input-form {display:block; width:100%; height:34px; font-size:14px; line-height:1.42857143; padding:0 4px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-input-form.se-input-url {direction:ltr;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-input-form.se-input-url:disabled {text-decoration:line-through; color:#999;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-video-ratio {width:70px; margin-left:4px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form a {color:#004cff;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-btn-revert {border:1px solid #ccc;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-btn-revert:hover {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-btn-revert:active {background-color:#d1d1d1; border-color:#c1c1c1; -webkit-box-shadow:inset 0 3px 5px #c1c1c1; box-shadow:inset 0 3px 5px #c1c1c1;}
  .sun-editor .se-dialog-tabs {width:100%; height:25px; border-bottom:1px solid #e5e5e5;}
  .sun-editor .se-dialog-tabs button {background-color:#e5e5e5; border-right:1px solid #e5e5e5; float:left; outline:none; padding:2px 13px; transition:0.3s;}
  .sun-editor .se-dialog-tabs button:hover {background-color:#fff;}
  .sun-editor .se-dialog-tabs button.active {background-color:#fff;border-bottom:0;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-input-form.se-math-exp {resize:vertical; height:14em; border:1px solid #ccc; font-size:13px; padding:4px; direction:ltr;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-input-select.se-math-size {width:6em; height:28px; margin-left:1em;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-math-preview {font-size:13px;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-math-preview > span {display:inline-block; -webkit-box-shadow:0 0 0 0.1rem #c7deff; box-shadow:0 0 0 0.1rem #c7deff;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-math-preview > span * {direction:ltr;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-math-preview > .se-math-katex-error {color:#b94a48; -webkit-box-shadow:0 0 0 0.1rem #f2dede; box-shadow:0 0 0 0.1rem #f2dede;}
  .sun-editor .se-dialog .se-dialog-inner .se-dialog-form .se-math-preview > .se-math-katex-error svg {width:auto; height:30px; color:#b94a48;}
  .sun-editor .se-dialog .se-dialog-inner .se-link-preview {display:block; height:auto; max-height:18px; font-size:13px; font-weight:normal; font-family:inherit; color:#666; background-color:transparent; overflow:hidden; text-overflow:ellipsis; word-break:break-all; white-space:pre;}
  .sun-editor .se-dialog .se-dialog-inner .se-anchor-preview-form {width:100%; display:flex; margin-top:4px;}
  .sun-editor .se-dialog .se-dialog-inner .se-anchor-preview-form .se-svg.se-anchor-preview-icon {flex:unset; display:none; line-height:1.5; color:#4592ff;}
  .sun-editor .se-dialog .se-dialog-inner .se-anchor-preview-form .se-link-preview {flex:auto; margin:0; }
  .sun-editor .se-dialog .se-dialog-inner .se-anchor-rel {height:34px;}
  .sun-editor .se-dialog .se-dialog-inner .se-anchor-rel-btn {width:46px; color:#3f9dff;}
  .sun-editor .se-dialog .se-dialog-inner .se-anchor-rel-wrapper {display:flex; line-height:1.5; padding-top:6px;}
  .sun-editor .se-dialog .se-dialog-inner .se-anchor-rel-preview {text-align:left;}
  .sun-editor .se-controller .se-arrow.se-arrow-up {border-bottom-color:rgba(0, 0, 0, .25);}
  .sun-editor .se-controller {position:absolute; display:none; overflow:visible; z-index:6; border:1px solid rgba(0, 0, 0, .25); border-radius:4px; text-align:start; text-decoration:none; text-shadow:none; text-transform:none; letter-spacing:normal; word-break:normal; word-spacing:normal; word-wrap:normal; white-space:normal; background-color:#fff; -webkit-background-clip:padding-box; background-clip:padding-box; -webkit-box-shadow:0 5px 10px rgba(0, 0, 0, .2); box-shadow:0 5px 10px rgba(0, 0, 0, .2); line-break:auto;}
  .sun-editor .se-controller .se-btn-group {position:relative; display:flex; vertical-align:middle; padding:2px; top:0; left:0;}
  .sun-editor .se-controller .se-btn-group .se-btn-group-sub {left:50%; min-width:auto; width:max-content; display:none;/* display: inline-table; */}
  .sun-editor .se-controller .se-btn-group .se-btn-group-sub button {margin:0; min-width:72px;}
  .sun-editor .se-controller .se-btn-group button {position:relative; min-height:34px; height:auto; border:none; border-radius:4px; margin:1px; padding:5px 10px; font-size:12px; line-height:1.5; display:inline-block; font-weight:normal; text-align:center; white-space:nowrap; vertical-align:middle; -ms-touch-action:manipulation; touch-action:manipulation;}
  .sun-editor .se-controller .se-btn-group button:hover:enabled, .sun-editor .se-controller .se-btn-group button:focus:enabled {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-controller .se-btn-group button:active:enabled {background-color:#d1d1d1; border-color:#c1c1c1; -webkit-box-shadow:inset 0 3px 5px #c1c1c1; box-shadow:inset 0 3px 5px #c1c1c1;}
  .sun-editor .se-controller .se-btn-group button span {display:block; padding:0; margin:0;}
  .sun-editor .se-controller .se-btn-group button:enabled.active {color:#4592ff; outline:0 none;}
  .sun-editor .se-controller .se-btn-group button:enabled.active:hover, .sun-editor .se-controller .se-btn-group button:enabled.active:focus {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-controller .se-btn-group button:enabled.active:active {background-color:#d1d1d1; border-color:#c1c1c1; -webkit-box-shadow:inset 0 3px 5px #c1c1c1; box-shadow:inset 0 3px 5px #c1c1c1;}
  .sun-editor .se-controller .se-btn-group button:enabled.on {background-color:#e1e1e1; border-color:#d1d1d1; outline:0 none;}
  .sun-editor .se-controller .se-btn-group button:enabled.on:hover, .sun-editor .se-controller .se-btn-group button:enabled.on:focus {background-color:#d1d1d1; border-color:#c1c1c1; outline:0 none;}
  .sun-editor .se-controller .se-btn-group button:enabled.on:active {background-color:#c1c1c1; border-color:#b1b1b1; -webkit-box-shadow:inset 0 3px 5px #b1b1b1; box-shadow:inset 0 3px 5px #b1b1b1;}
  .sun-editor .se-controller .se-form-group input {min-width:120px;}
  .sun-editor .se-controller-resizing {margin-top:-50px !important; padding:0; font-size:14px; font-style:normal; font-weight:normal; line-height:1.42857143;}
  .sun-editor .se-controller-resizing .se-btn-group .se-btn-group-sub.se-resizing-align-list {width:74px;}
  .sun-editor .se-resizing-container {position:absolute; display:none; outline:1px solid #3f9dff; background-color:transparent;}
  .sun-editor .se-resizing-container .se-modal-resize {position:absolute; display:inline-block; background-color:#3f9dff; opacity:0.3;}
  .sun-editor .se-resizing-container .se-resize-dot {position:absolute; top:0px; left:0px; width:100%; height:100%}
  .sun-editor .se-resizing-container .se-resize-dot > span {position:absolute; width:7px; height:7px; background-color:#3f9dff; border:1px solid #4592ff;}
  .sun-editor .se-resizing-container .se-resize-dot > span.tl {top:-5px; left:-5px; cursor:nw-resize;}
  .sun-editor .se-resizing-container .se-resize-dot > span.tr {top:-5px; right:-5px; cursor:ne-resize;}
  .sun-editor .se-resizing-container .se-resize-dot > span.bl {bottom:-5px; left:-5px; cursor:sw-resize;}
  .sun-editor .se-resizing-container .se-resize-dot > span.br {right:-5px; bottom:-5px; cursor:se-resize;}
  .sun-editor .se-resizing-container .se-resize-dot > span.lw {left:-7px; bottom:50%; cursor:w-resize;}
  .sun-editor .se-resizing-container .se-resize-dot > span.th {left:50%; top:-7px; cursor:n-resize;}
  .sun-editor .se-resizing-container .se-resize-dot > span.rw {right:-7px; bottom:50%; cursor:e-resize;}
  .sun-editor .se-resizing-container .se-resize-dot > span.bh {right:50%; bottom:-7px; cursor:s-resize;}
  .sun-editor .se-resizing-container .se-resize-display {position:absolute; right:0; bottom:0; padding:5px; margin:5px; font-size:12px; color:#fff; background-color:#333; border-radius:4px;}
  .sun-editor .se-controller-table {width:auto; padding:0; font-size:14px; font-style:normal; font-weight:normal; line-height:1.42857143;}
  .sun-editor .se-controller-table-cell {width:auto; padding:0; font-size:14px; font-style:normal; font-weight:normal; line-height:1.42857143;}
  .sun-editor .se-controller-link {padding:0; font-size:14px; font-style:normal; font-weight:normal; line-height:1.42857143;}
  .sun-editor .se-controller-link::before, .sun-editor .se-controller-link::after {-webkit-box-sizing:border-box; -moz-box-sizing:border-box; box-sizing:border-box;}
  .sun-editor .se-controller-link .link-content {padding:0; margin:0;}
  .sun-editor .se-controller-link .link-content a {display:inline-block; color:#4592ff; max-width:200px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; vertical-align:middle; margin-left:5px;}
  .sun-editor .se-select-list {position:absolute; top:0px; left:0px; display:none; width:auto; max-width:100%; background-color:#fff; padding:0; margin:0; border:1px solid #bababa; -webkit-box-shadow:0 3px 9px rgba(0, 0, 0, .5); box-shadow:0 3px 9px rgba(0, 0, 0, .5); outline:0 none;}
  .sun-editor .se-select-list .se-select-item {line-height:28px; min-height:28px; font-size:13px; padding:0 5px; margin:2px 0; cursor:pointer;}
  .sun-editor .se-select-list.__se_select-menu-mouse-move .se-select-item:hover, .sun-editor .se-select-list:not(.__se_select-menu-mouse-move) .se-select-item.active {background-color:#e1e1e1;}
  .sun-editor .se-dialog-form-files .se-select-list {width:100%;}
  .sun-editor .se-file-browser {position:absolute; display:none; top:0; left:0; width:100%; height:100%; z-index:2147483647;}
  .sun-editor .se-file-browser label, .sun-editor .se-file-browser input, .sun-editor .se-file-browser button {font-size:14px; line-height:1.5; color:#111; margin:0;}
  .sun-editor .se-file-browser .se-file-browser-back {position:absolute; display:block; width:100%; height:100%; top:0; left:0; background-color:#222; opacity:0.5;}
  .sun-editor .se-file-browser .se-file-browser-inner {position:absolute; display:block; width:100%; height:100%; top:0; left:0;}
  .sun-editor .se-file-browser .se-file-browser-inner .se-file-browser-content {position:relative; width:960px; max-width:100%; margin:20px auto; background-color:#fff; -webkit-background-clip:padding-box; background-clip:padding-box; border:1px solid rgba(0, 0, 0, .2); border-radius:4px; outline:0; -webkit-box-shadow:0 3px 9px rgba(0, 0, 0, .5); box-shadow:0 3px 9px rgba(0, 0, 0, .5);}
  .sun-editor .se-file-browser .se-file-browser-header {height:auto; min-height:50px; padding:6px 15px 6px 15px; border-bottom:1px solid #e5e5e5;}
  .sun-editor .se-file-browser .se-file-browser-header .se-file-browser-close {float:right; font-weight:bold; text-shadow:0 1px 0 #fff; -webkit-appearance:none; filter:alpha(opacity=100); opacity:1;}
  .sun-editor .se-file-browser .se-file-browser-header .se-file-browser-close > svg {width:12px; height:12px;}
  .sun-editor .se-file-browser .se-file-browser-header .se-file-browser-title {font-size:16px; font-weight:bold; margin:0; padding:0; line-height:2.2;}
  .sun-editor .se-file-browser .se-file-browser-tags {display:block; width:100%; padding:0; text-align:left; margin:0 -15px;}
  .sun-editor .se-file-browser .se-file-browser-tags a {display:inline-block; background-color:#f5f5f5; padding:6px 12px; margin:8px 0 8px 8px; color:#333; text-decoration:none; border-radius:32px; -moz-border-radius:32px; -webkit-border-radius:32px; -moz-background-clip:padding; -webkit-background-clip:padding-box; background-clip:padding-box; cursor:pointer;}
  .sun-editor .se-file-browser .se-file-browser-tags a:hover {background-color:#e1e1e1;}
  .sun-editor .se-file-browser .se-file-browser-tags a:active {background-color:#d1d1d1;}
  .sun-editor .se-file-browser .se-file-browser-tags a.on {background-color:#ebf3fe; color:#4592ff;}
  .sun-editor .se-file-browser .se-file-browser-tags a.on:hover {background-color:#d8e8fe;}
  .sun-editor .se-file-browser .se-file-browser-tags a.on:active {background-color:#c7deff;}
  .sun-editor .se-file-browser .se-file-browser-body {position:relative; height:auto; min-height:350px; padding:20px; overflow-y:auto;}
  .sun-editor .se-file-browser .se-file-browser-body .se-file-browser-list {position:relative; width:100%;}
  @media screen and (max-width:992px) { .sun-editor .se-file-browser .se-file-browser-inner .se-file-browser-content {width:748px;} }
  @media screen and (max-width:768px) { .sun-editor .se-file-browser .se-file-browser-inner .se-file-browser-content {width:600px;} }
  .sun-editor .se-file-browser .se-file-browser-list .se-file-item-column {position:relative; display:block; height:auto; float:left;}
  .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-column {width:calc(25% - 20px); margin:0 10px;}
  @media screen and (max-width:992px) { .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-column {width:calc(33% - 20px);} }
  @media screen and (max-width:768px) { .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-column {width:calc(50% - 20px);} }
  .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-img {position:relative; display:block; cursor: pointer; width:100%; height:auto; border-radius:4px; outline:0; margin:10px 0;}
  .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-img:hover {opacity:0.8; -webkit-box-shadow:0 0 0 0.2rem #3288ff; box-shadow:0 0 0 0.2rem #3288ff;}
  .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-img > img {position:relative; display:block; width:100%; border-radius:4px; outline:0; height:auto;}
  .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-img > .se-file-img-name {position: absolute; z-index:1; font-size:13px; color:#fff; left:0px; bottom:0; padding:5px 10px; background-color:transparent; width:100%; height:30px; border-bottom-right-radius:4px; border-bottom-left-radius:4px;}
  .sun-editor .se-file-browser .se-file-browser-list.se-image-list .se-file-item-img > .se-file-img-name.se-file-name-back {background-color:#333; opacity:0.6;}
  .sun-editor .se-notice {position:absolute; top:0; display:none; z-index:7; width:100%; height:auto; word-break:break-all; font-size:13px; color:#b94a48; background-color:#f2dede; padding:15px; margin:0; border:1px solid #eed3d7; user-select:auto; -o-user-select:auto; -moz-user-select:auto; -khtml-user-select:auto; -webkit-user-select:auto; -ms-user-select:auto;}
  .sun-editor .se-notice button {float:right; padding:7px;}
  .sun-editor .se-tooltip {position:relative; overflow:visible;}
  .sun-editor .se-tooltip .se-tooltip-inner {visibility:hidden; position:absolute; display:block; width:auto; height:auto; top:120%; left:50%; background:transparent; opacity:0; z-index:1; line-height:1.5; transition:opacity 0.5s; margin:0; padding:0; bottom:auto; float:none; pointer-events:none; backface-visibility:hidden; -webkit-backface-visibility:hidden; -moz-backface-visibility:hidden;}
  .sun-editor .se-tooltip .se-tooltip-inner .se-tooltip-text {position:relative; display:inline-block; width:auto; height:auto; left:-50%; font-size:0.9em; margin:0; padding:4px 6px; border-radius:2px; background-color:#333; color:#fff; text-align:center; line-height:unset; white-space:nowrap; cursor:auto;}
  .sun-editor .se-tooltip .se-tooltip-inner .se-tooltip-text::after {content:""; position:absolute; bottom:100%; left:50%; margin-left:-5px; border-width:5px; border-style:solid; border-color:transparent transparent #333 transparent;}
  .sun-editor .se-tooltip:hover .se-tooltip-inner {visibility:visible; opacity:1;}
  .sun-editor .se-tooltip .se-tooltip-inner .se-tooltip-text .se-shortcut {display:block !important;}
  .sun-editor .se-tooltip .se-tooltip-inner .se-tooltip-text .se-shortcut > .se-shortcut-key {display:inline; font-weight:bold;}
  .sun-editor.se-rtl .se-btn-tray {direction:rtl;}
  .sun-editor.se-rtl .se-btn-select svg {margin:auto 1px;}
  .sun-editor.se-rtl .se-btn-select .txt {flex:auto; text-align:right; direction:rtl;}
  .sun-editor.se-rtl .se-btn-list {text-align:right;}
  .sun-editor.se-rtl .se-btn-list > .se-list-icon {margin:-1px 0 0 10px;}
  .sun-editor.se-rtl .se-menu-list:not(.se-menu-dir-fix) {float:right;}
  .sun-editor.se-rtl .se-menu-list:not(.se-menu-dir-fix) li {float:right;}
  .sun-editor.se-rtl .se-list-layer * {direction:rtl;}
  .sun-editor.se-rtl .se-list-layer.se-list-format ul blockquote {padding:0 7px 0 0; border-right-width:5px; border-left-width:0;}
  .sun-editor.se-rtl .se-list-layer .se-selector-color .se-color-pallet li {float:right;}
  .sun-editor.se-rtl .se-list-inner .se-list-checked li button > .se-svg {float:right; padding:6px 0 0 6px;}
  .sun-editor.se-rtl .se-wrapper .se-placeholder {direction:rtl;}
  .sun-editor.se-rtl .se-tooltip .se-tooltip-inner .se-tooltip-text {direction:rtl;}
  .sun-editor.se-rtl .se-tooltip .se-tooltip-inner .se-tooltip-text .se-shortcut {direction:ltr;}
  .sun-editor.se-rtl .se-dialog * {direction:rtl;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-form .se-video-ratio {margin-left:0; margin-right:4px;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-header .se-dialog-close {float:left;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-header .se-modal-title {float:right;}
  .sun-editor.se-rtl .se-dialog-tabs button {float:right;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-size-text {padding-right:34px;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-footer .se-btn-primary {float:left}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-footer > div {float:right;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-footer > div > label {margin:0 0 0 5px;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-dialog-form-footer label:first-child {margin-left:16px; margin-right:0px;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-anchor-rel-preview {margin-left:4px; text-align:right;}
  .sun-editor.se-rtl .se-dialog .se-dialog-inner .se-anchor-rel-btn {float:right;}
  .sun-editor.se-rtl .se-file-browser * {direction:rtl;}
  .sun-editor.se-rtl .se-file-browser .se-file-browser-tags {text-align:right;}
  .sun-editor.se-rtl .se-file-browser .se-file-browser-tags a {margin: 8px 8px 0 8px;}
  .sun-editor.se-rtl .se-file-browser .se-file-browser-header .se-file-browser-close {float:left;}
  .sun-editor.se-rtl .se-controller .se-btn-group {direction:rtl;}
  .sun-editor.se-rtl .se-resizing-container .se-resize-display {direction:rtl;}
  .sun-editor .se-btn-module-border.module-float-left {float:left;}
  .sun-editor .se-btn-module-border.module-float-right {float:right;}
  .sun-editor .se-error {color:#d9534f;}
  .sun-editor input.se-error:focus, select.se-error:focus, textarea.se-error:focus {
    border: 1px solid #f2dede;
    outline: 0;
    -webkit-box-shadow: 0 0 0 0.2rem #eed3d7;
    box-shadow: 0 0 0 0.2rem #eed3d7;
    transition: border-color .15s ease-in-out,box-shadow .15s ease-in-out;
  }
  .sun-editor hr.__se__solid {
    border-style: solid none none;
  }
  .sun-editor hr.__se__dotted {
    border-style: dotted none none;
  }
  .sun-editor hr.__se__dashed {
    border-style: dashed none none;
  }
  @keyframes blinker { 50% {opacity:0;} }
  @keyframes spinner { to {transform:rotate(361deg);} }

  .sun-editor-editable {
    font-family: Helvetica Neue;
    font-size: 13px;
    color: #333;
    background-color: #fff;
    line-height: 1.5;
    word-break: normal;
    word-wrap: break-word;
    padding: 16px;
    margin: 0;
  }
  .sun-editor-editable * {
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    font-family: inherit;
    font-size: inherit;
    color: inherit;
  }
  .sun-editor-editable.se-rtl * {
    direction: rtl;
  }
  .sun-editor-editable .se-component > figure {
    direction: initial;
  }
  .sun-editor-editable td, .sun-editor-editable th, 
  .sun-editor-editable figure, .sun-editor-editable figcaption, .sun-editor-editable img, 
  .sun-editor-editable iframe, .sun-editor-editable video, .sun-editor-editable audio {
    position: relative;
  }
  .sun-editor-editable span {
    display: inline;
    vertical-align: baseline;
    margin: 0;
    padding: 0;
  }
  .sun-editor-editable span.katex {
    display: inline-block;
  }
  .sun-editor-editable span.katex * {
    direction: ltr;
  }
  .sun-editor-editable a {
    color: #004cff;
    text-decoration: none;
  }
  .sun-editor-editable span[style~="color:"] a {
    color: inherit;
  }
  .sun-editor-editable a:hover, .sun-editor-editable a:focus {
    cursor: pointer;
    color: #0093ff;
    text-decoration: underline;
  }
  .sun-editor-editable a.on {
    color: #0093ff;
    background-color: #e8f7ff;
  }
  .sun-editor-editable pre {
    display: block;
    padding: 8px;
    margin: 0 0 10px;
    font-family: monospace;
    color: #666;
    line-height: 1.45;
    background-color: #f9f9f9;
    border: 1px solid #e1e1e1;
    border-radius: 2px;
    white-space: pre-wrap !important;
    word-wrap: break-word;
    overflow: visible;
  }
  .sun-editor-editable ol {
    list-style-position: outside;
    display: block;
    list-style-type: decimal;
    margin-block-start: 1em;
    margin-block-end: 1em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    padding-inline-start: 40px;
  }
  .sun-editor-editable ul {
    list-style-position: outside;
    display: block;
    list-style-type: disc;
    margin-block-start: 1em;
    margin-block-end: 1em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    padding-inline-start: 40px;
  }
  .sun-editor-editable li {
    display: list-item;
    text-align: -webkit-match-parent;
    margin-bottom: 5px;
  }
  .sun-editor-editable ol ol, .sun-editor-editable ol ul, .sun-editor-editable ul ol, .sun-editor-editable ul ul {
    margin: 0;
  }
  .sun-editor-editable ol ol, .sun-editor-editable ul ol {
    list-style-type: lower-alpha;
  }
  .sun-editor-editable ol ol ol, .sun-editor-editable ul ol ol, .sun-editor-editable ul ul ol {
    list-style-type: upper-roman;
  }
  .sun-editor-editable ul ul, .sun-editor-editable ol ul {
    list-style-type: circle;
  }
  .sun-editor-editable ul ul ul, .sun-editor-editable ol ul ul, .sun-editor-editable ol ol ul {
    list-style-type: square;
  }
  .sun-editor-editable sub, .sun-editor-editable sup {
    font-size: 75%;
    line-height: 0;
  }
  .sun-editor-editable sub {
    vertical-align: sub;
  }
  .sun-editor-editable sup {
    vertical-align: super;
  }
  .sun-editor-editable p {
    display: block;
    margin: 0 0 10px;
  }
  .sun-editor-editable div {
    display: block;
    margin: 0;
    padding: 0;
  }
  .sun-editor-editable blockquote {
    display: block;
    font-family: inherit;
    font-size: inherit;
    color: #999;
    margin-block-start: 1em;
    margin-block-end: 1em;
    margin-inline-start: 0;
    margin-inline-end: 0;
    border-style: solid;
    border-width: 0;
    padding-top: 0;
    padding-bottom: 0;
    border-color: #b1b1b1;
    padding-left: 20px;
    padding-right: 5px;
    border-left-width: 5px;
    border-right-width: 0px;
  }
  .sun-editor-editable blockquote blockquote {
    border-color: #c1c1c1;
  }
  .sun-editor-editable blockquote blockquote blockquote {
    border-color: #d1d1d1;
  }
  .sun-editor-editable blockquote blockquote blockquote blockquote {
    border-color: #e1e1e1;
  }
  .sun-editor-editable.se-rtl blockquote {
    padding-left: 5px;
    padding-right: 20px;
    border-left-width: 0px;
    border-right-width: 5px;
  }
  .sun-editor-editable h1 {
    display: block;
    font-size: 2em;
    margin-block-start: 0.67em;
    margin-block-end: 0.67em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    font-weight: bold;
  }
  .sun-editor-editable h2 {
    display: block;
    font-size: 1.5em;
    margin-block-start: 0.83em;
    margin-block-end: 0.83em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    font-weight: bold;
  }
  .sun-editor-editable h3 {
    display: block;
    font-size: 1.17em;
    margin-block-start: 1em;
    margin-block-end: 1em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    font-weight: bold;
  }
  .sun-editor-editable h4 {
    display: block;
    font-size: 1em;
    margin-block-start: 1.33em;
    margin-block-end: 1.33em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    font-weight: bold;
  }
  .sun-editor-editable h5 {
    display: block;
    font-size: 0.83em;
    margin-block-start: 1.67em;
    margin-block-end: 1.67em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    font-weight: bold;
  }
  .sun-editor-editable h6 {
    display: block;
    font-size: 0.67em;
    margin-block-start: 2.33em;
    margin-block-end: 2.33em;
    margin-inline-start: 0px;
    margin-inline-end: 0px;
    font-weight: bold;
  }
  .sun-editor-editable hr {
    display: flex;
    border-width: 1px 0 0;
    border-color: black;
    border-image: initial;
    height: 1px;
  }
  .sun-editor-editable hr.__se__solid {
    border-style: solid none none;
  }
  .sun-editor-editable hr.__se__dotted {
    border-style: dotted none none;
  }
  .sun-editor-editable hr.__se__dashed {
    border-style: dashed none none;
  }
  .sun-editor-editable hr.on {
    border-color: #4592ff;
    -webkit-box-shadow:0 0 0 0.1rem #c7deff;
    box-shadow:0 0 0 0.1rem #c7deff;
  }
  .sun-editor-editable table {
    display: table;
    table-layout: auto !important;
    border: 1px solid rgb(204, 204, 204);
    width: 100%;
    max-width: 100%;
    margin: 0 0 10px;
    background-color: transparent;
    border-spacing: 0;
    border-collapse: collapse;
  }
  .sun-editor-editable.se-rtl table {
    margin: 0 0 10px auto;
  }
  .sun-editor-editable table thead {
    border-bottom: 2px solid #333;
  }
  .sun-editor-editable table tr {
    border: 1px solid #efefef;
  }
  .sun-editor-editable table th {
    background-color: #f3f3f3;
  }
  .sun-editor-editable table th, .sun-editor-editable table td {
    border: 1px solid #e1e1e1;
    padding:0.4em;
    background-clip: padding-box;
  }
  .sun-editor-editable table.se-table-size-auto {
    width: auto !important;
  }
  .sun-editor-editable table.se-table-size-100 {
    width: 100% !important;
  }
  .sun-editor-editable table.se-table-layout-auto {
    table-layout: auto !important;
  }
  .sun-editor-editable table.se-table-layout-fixed {
    table-layout: fixed !important;
  }
  .sun-editor-editable table td.se-table-selected-cell, .sun-editor-editable table th.se-table-selected-cell {
    outline: 1px double #4592ff;
  }
  .sun-editor-editable.se-disabled * {
    user-select: none;
    -o-user-select: none;
    -moz-user-select: none;
    -khtml-user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
  }
  .sun-editor-editable .se-component {
    display: flex;
    padding: 1px;
    margin: 0 0 10px;
  }
  .sun-editor-editable[contenteditable=true] .se-component {
    outline: 1px dashed #e1e1e1;
  }
  .sun-editor-editable[contenteditable=true] .se-component.se-component-copy {
    -webkit-box-shadow:0 0 0 0.2rem #80bdff; box-shadow:0 0 0 0.2rem #3f9dff; transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out;
  }
  .sun-editor-editable .__se__float-left {
    float: left;
    margin-right: 4px;
  }
  .sun-editor-editable .__se__float-right {
    float: right;
    margin-left: 4px;
  }
  .sun-editor-editable .__se__float-center {
    float: center;
  }
  .sun-editor-editable .__se__float-none {
    float: none;
  }
  .sun-editor-editable img, .sun-editor-editable iframe, .sun-editor-editable video, .sun-editor-editable audio {
    display: block;
    margin: 0;
    padding: 0;
    width: auto;
    height: auto;
    max-width: 100%;
  }
  .sun-editor-editable[contenteditable="true"]:not(.se-read-only) figure::after {
    position: absolute;
    content: '';
    z-index: 1;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    cursor: default;
    display: block;
    background: rgba(0,0,0,0);
  }
  .sun-editor-editable[contenteditable="true"] figure a, .sun-editor-editable[contenteditable="true"] figure img, .sun-editor-editable[contenteditable="true"] figure iframe, .sun-editor-editable[contenteditable="true"] figure video {
    z-index: 0;
  }
  .sun-editor-editable[contenteditable="true"] figure figcaption {
    display: block;
    z-index: 2;
  }
  .sun-editor-editable[contenteditable="true"] figure figcaption:focus {
    border-color: #80bdff;
    outline: 0;
    -webkit-box-shadow: 0 0 0 0.2rem #c7deff;
    box-shadow: 0 0 0 0.2rem #c7deff;
  }
  .sun-editor-editable .se-image-container, .sun-editor-editable .se-video-container {
    width: auto;
    height: auto;
    max-width: 100%;
  }
  .sun-editor-editable figure {
    display: block;
    outline: none;
    padding: 0;
    margin: 0;
  }
  .sun-editor-editable .__se__float-left figure,
  .sun-editor-editable .__se__float-right figure,
  .sun-editor-editable .__se__float-center figure {
    margin: auto !important;
  }
  .sun-editor-editable figure figcaption {
    padding: 1em .5em;
    margin: 0;
    background-color: #f9f9f9;
    outline: none;
  }
  .sun-editor-editable figure figcaption p{
    line-height: 2;
    margin: 0;
  }
  .sun-editor-editable .se-image-container a img {
    padding: 1px;
    margin: 1px;
    outline: 1px solid #4592ff;
  }
  .sun-editor-editable .se-video-container iframe, .sun-editor-editable .se-video-container video {
    outline: 1px solid #9e9e9e;
    position: absolute;
    top: 0;
    left: 0;
    border: 0;
    width: 100%;
    height: 100%;
  }
  .sun-editor-editable .se-video-container figure {
    left: 0px;
    width: 100%;
    max-width: 100%;
  }
  .sun-editor-editable audio {
    width: 300px;
    height: 54px;
  }
  .sun-editor-editable audio.active {
    outline: 2px solid #80bdff;
  }
  .sun-editor-editable.se-show-block p, .sun-editor-editable.se-show-block div, 
  .sun-editor-editable.se-show-block h1, .sun-editor-editable.se-show-block h2, .sun-editor-editable.se-show-block h3, 
  .sun-editor-editable.se-show-block h4, .sun-editor-editable.se-show-block h5, .sun-editor-editable.se-show-block h6, .sun-editor-editable.se-show-block li, 
  .sun-editor-editable.se-show-block ol, .sun-editor-editable.se-show-block ul, 
  .sun-editor-editable.se-show-block pre {
    border:1px dashed #3f9dff !important;
    padding:14px 8px 8px 8px !important;
  }
  .sun-editor-editable.se-show-block ol, .sun-editor-editable.se-show-block ul {
    border:1px dashed #d539ff !important;
  }
  .sun-editor-editable.se-show-block pre {
    border:1px dashed #27c022 !important;
  }
  .se-show-block p {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPAQMAAAAF7dc0AAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAaSURBVAjXY/j/gwGCPvxg+F4BQiAGDP1HQQByxxw0gqOzIwAAAABJRU5ErkJggg==') no-repeat;}
  .se-show-block div {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAPAQMAAAAxlBYoAAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAmSURBVAjXY/j//wcDDH+8XsHwDYi/hwNx1A8w/nYLKH4XoQYJAwCXnSgcl2MOPgAAAABJRU5ErkJggg==') no-repeat;}
  .se-show-block h1 {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAPAQMAAAA4f7ZSAAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAfSURBVAjXY/j/v4EBhr+9B+LzEPrDeygfhI8j1CBhAEhmJGY4Rf6uAAAAAElFTkSuQmCC') no-repeat;}
  .se-show-block h2 {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAPAQMAAAA4f7ZSAAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAmSURBVAjXY/j/v4EBhr+dB+LtQPy9geEDEH97D8T3gbgdoQYJAwA51iPuD2haEAAAAABJRU5ErkJggg==') no-repeat;}
  .se-show-block h3 {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAPAQMAAAA4f7ZSAAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAiSURBVAjXY/j/v4EBhr+dB+LtQPy9geHDeQgN5p9HqEHCADeWI+69VG2MAAAAAElFTkSuQmCC') no-repeat;}
  .se-show-block h4 {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAPAQMAAADTSA1RAAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAiSURBVAjXY/j//wADDH97DsTXIfjDdiDdDMTfIRhZHRQDAKJOJ6L+K3y7AAAAAElFTkSuQmCC') no-repeat;}
  .se-show-block h5 {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAPAQMAAAA4f7ZSAAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAlSURBVAjXY/j/v4EBhr+1A/F+IO5vYPiwHUh/B2IQfR6hBgkDABlWIy5uM+9GAAAAAElFTkSuQmCC') no-repeat;}
  .se-show-block h6 {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAPAQMAAAA4f7ZSAAAABlBMVEWAgID////n1o2sAAAAAnRSTlP/AOW3MEoAAAAiSURBVAjXY/j/v4EBhr+dB+LtQLy/geFDP5S9HSKOrA6KAR9GIza1ptJnAAAAAElFTkSuQmCC') no-repeat;}
  .se-show-block li {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAA7SURBVDhPYxgFcNDQ0PAfykQBIHEYhgoRB/BpwCfHBKWpBkaggYxQGgOgBzyQD1aLLA4TGwWDGjAwAACR3RcEU9Ui+wAAAABJRU5ErkJggg==') no-repeat;}
  .se-show-block ol {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABHSURBVDhPYxgFcNDQ0PAfhKFcFIBLHCdA1oBNM0kGEmMAPgOZoDTVANUNxAqQvURMECADRiiNAWCagDSGGhyW4DRrMAEGBgAu0SX6WpGgjAAAAABJRU5ErkJggg==') no-repeat;}
  .se-show-block ul {background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAA1SURBVDhPYxgFDA0NDf+hTBSALI5LDQgwQWmqgVEDKQcsUBoF4ItFGEBXA+QzQpmDGjAwAAA8DQ4Lni6gdAAAAABJRU5ErkJggg==') no-repeat;}
  .sun-editor-editable .__se__p-bordered, .sun-editor .__se__p-bordered {
    border-top: solid 1px #b1b1b1;
    border-bottom: solid 1px #b1b1b1;
    padding: 4px 0;
  }
  .sun-editor-editable .__se__p-spaced, .sun-editor .__se__p-spaced {
    letter-spacing: 1px;
  }
  .sun-editor-editable .__se__p-neon, .sun-editor .__se__p-neon {
    font-weight: 200;
    font-style: italic;
    background: #000;
    color: #fff;
    padding: 6px 4px;
    border: 2px solid #fff;
    border-radius: 6px;
    text-transform: uppercase;
    animation: neonFlicker 1.5s infinite alternate;     
  }
  @keyframes neonFlicker {
    0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
        text-shadow:
          -0.2rem -0.2rem 1rem #fff,
          0.2rem 0.2rem 1rem #fff,
          0 0 2px #f40,
          0 0 4px #f40,
          0 0 6px #f40,
          0 0 8px #f40,
          0 0 10px #f40;
        box-shadow:
          0 0 .5px #fff,
          inset 0 0 .5px #fff,
          0 0 2px #08f,
          inset 0 0 2px #08f,
          0 0 4px #08f,
          inset 0 0 4px #08f;      
    }
    20%, 24%, 55% {      
        text-shadow: none;
        box-shadow: none;
    }    
  }
  .sun-editor-editable .__se__t-shadow, .sun-editor .__se__t-shadow {
    text-shadow:
        -0.2rem -0.2rem 1rem #fff,
        0.2rem 0.2rem 1rem #fff,
        0 0 0.2rem #999,
        0 0 0.4rem #888,
        0 0 0.6rem #777,
        0 0 0.8rem #666,
        0 0 1rem #555;
  }
  .sun-editor-editable .__se__t-code, .sun-editor .__se__t-code {
    font-family: monospace;
    color: #666;
    background-color: rgba(27,31,35,.05);
    border-radius: 6px;
    padding: 0.2em 0.4em;
  }`;
    }
    template() {
      const {
        value = "",
        //flags
        history,
        font,
        size,
        format,
        paragraph: paragraph2,
        blockquote: blockquote2,
        style,
        color,
        highlight,
        text,
        remove,
        indent,
        align,
        rule,
        list: list2,
        lineheight,
        table,
        link: link2,
        image,
        video,
        audio,
        fullscreen,
        showblocks,
        code,
        print,
        save,
        dir,
        //handlers
        change,
        update,
        //for textarea
        ...attributes
      } = this.props;
      const styles = new import_StyleSet27.default();
      const css = this.styles();
      this.styles = () => css + styles.toString();
      (0, import_display17.default)(this.props, styles, "block");
      const handlers = {
        init: () => {
          const textarea = this.shadowRoot.querySelector(".sun-editor-editable");
          if (!textarea) return;
          const buttonList = [];
          if (history) buttonList.push(["undo", "redo"]);
          const group2 = [];
          if (font) group2.push("font");
          if (size) group2.push("fontSize");
          if (format) group2.push("formatBlock");
          if (group2.length) buttonList.push(group2);
          const group3 = [];
          if (paragraph2) group3.push("paragraphStyle");
          if (blockquote2) group3.push("blockquote");
          if (group3.length) buttonList.push(group3);
          if (style) buttonList.push(["bold", "underline", "italic", "strike", "subscript", "superscript"]);
          const group5 = [];
          if (color) group5.push("fontColor");
          if (highlight) group5.push("hiliteColor");
          if (text) group5.push("textStyle");
          if (group5.length) buttonList.push(group5);
          if (remove) buttonList.push(["removeFormat"]);
          buttonList.push("/");
          if (indent) buttonList.push(["outdent", "indent"]);
          const group8 = [];
          if (align) group8.push("align");
          if (rule) group8.push("horizontalRule");
          if (list2) group8.push("list");
          if (lineheight) group8.push("lineHeight");
          if (group8.length) buttonList.push(group8);
          const group9 = [];
          if (table) group9.push("table");
          if (link2) group9.push("link");
          if (image) group9.push("image");
          if (video) group9.push("video");
          if (audio) group9.push("audio");
          if (group9.length) buttonList.push(group9);
          const group10 = [];
          if (fullscreen) group10.push("fullScreen");
          if (showblocks) group10.push("showBlocks");
          if (code) group10.push("codeView");
          if (group10.length) buttonList.push(group10);
          if (print) buttonList.push(["preview", "print"]);
          if (save) buttonList.push(["save", "template"]);
          if (dir) buttonList.push(["dir", "dir_ltr", "dir_rtl"]);
          const editor = suneditor_default.create(textarea, {
            plugins: plugins_default,
            buttonList: buttonList.length > 1 ? buttonList : [],
            value
          });
          editor.onChange = handlers.change;
        },
        change: (contents, core) => {
          update && update(contents);
          const textarea = this.querySelector("textarea");
          if (!textarea) return;
          textarea.value = contents;
          textarea.setAttribute("value", contents);
          const event = new Event("change", { bubbles: true, composed: true });
          Object.defineProperty(event, "target", { writable: false, value: textarea });
          change && change(event);
        }
      };
      return () => [
        import_Registry33.default.createText(`
`, false),
        import_Registry33.default.createElement("template", { "type": `light` }, [
          import_Registry33.default.createText(`
  `, false),
          import_Registry33.default.createElement("textarea", { ...attributes, "value": value }, [
            ...this._toNodeList(value)
          ]).element,
          import_Registry33.default.createText(`
`, false)
        ]).element,
        import_Registry33.default.createText(`
`, false),
        import_Registry33.default.createElement("template", { "type": `shadow` }, [
          import_Registry33.default.createText(`
  `, false),
          import_Registry33.default.createElement("div", { "class": `sun-editor-editable`, "mount": handlers.init }, []).element,
          import_Registry33.default.createText(`
`, false)
        ]).element
      ];
    }
  };

  // ink-document-client-resolver:C:\Users\Win 10\dev\ink\packages\ink-web\src\pages\ui\form\index.ink
  var import_ink2 = __toESM(require_ink());
  var TemplateDocument = class _TemplateDocument extends import_Document2.default {
    static sync() {
      const document2 = new _TemplateDocument();
      return document2.sync();
    }
    template() {
      const url = "/ink/panel.html";
      const title = _("Ink UI - Web Components Meets Atomic Styles.");
      const description = _("Ink UI atomically generates CSS styles and provides out of box web components.");
      const toggle = () => {
        document.querySelector("panel-layout").toggle("left");
      };
      const fileupload = (file, next) => {
        setTimeout(() => {
          next("https://images.wsj.net/im-580612/8SR");
        }, 5e3);
      };
      const filelistupload = (files, next) => {
        setTimeout(() => {
          next(files.map((file, i) => "https://images.wsj.net/im-580612/8SR"));
        }, 1e3);
      };
      const metadata = { first: "Jane", last: "Doe" };
      const fieldset = [
        { first1: "John", last1: "Doe", fieldset2: [{ first2: "Jane", last2: "Doe" }] }
      ];
      return [
        import_Document.default.createText(`
`, false),
        import_Document.default.createElement("html", {}, [
          import_Document.default.createText(`
  `, false),
          ...[
            import_Document.default.createElement("head", {}, [
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "charset": `utf-8` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "name": `viewport`, "content": `width=device-width, initial-scale=1` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("title", {}, [
                ...this._toNodeList(title)
              ]),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "name": `description`, "content": description }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "property": `og:title`, "content": title }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "property": `og:description`, "content": description }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "property": `og:image`, "content": `https://stackpress.github.io/ink/ink-logo.png` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "property": `og:url`, "content": `https://stackpress.github.io/ink${url}` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "property": `og:type`, "content": `website` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "name": `twitter:card`, "content": `summary` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "name": `twitter:site`, "content": `@stackpress` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "name": `twitter:title`, "content": title }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "name": `twitter:description`, "content": description }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("meta", { "name": `twitter:image`, "content": `https://stackpress.github.io/ink/ink-logo.png` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("link", { "rel": `favicon`, "href": `/ink/favicon.ico` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("link", { "rel": `shortcut icon`, "type": `image/png`, "href": `/ink/favicon.png` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("link", { "rel": `stylesheet`, "type": `text/css`, "href": `https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("link", { "rel": `stylesheet`, "type": `text/css`, "href": `/ink/styles/global.css` }),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("link", { "rel": `stylesheet`, "type": `text/css`, "href": `/ink/build/client/${(0, import_ink2.env)("BUILD_ID")}.css` }),
              import_Document.default.createElement("script", { "data-template": true, "type": `text/json` }, [
                import_Document.default.createText(`__TEMPLATE_DATA__`, true)
              ]),
              import_Document.default.createText(`
  `, false),
              import_Document.default.createElement("script", { "src": `/ink/build/client/${(0, import_ink2.env)("BUILD_ID")}.js` }),
              import_Document.default.createText(`
  `, false),
              ...!!((0, import_ink2.env)("PUBLIC_ENV") === "development") ? [
                import_Document.default.createText(`
    `, false),
                import_Document.default.createElement("script", { "src": `/dev.js` }),
                import_Document.default.createText(`
  `, false)
              ] : [],
              import_Document.default.createText(`
`, false)
            ])
          ],
          import_Document.default.createText(`
  `, false),
          import_Document.default.createElement("body", { "class": `light bg-t-0 tx-t-1 tx-arial` }, [
            import_Document.default.createText(`
    `, false),
            import_Document.default.createElement("panel-layout", {}, [
              import_Document.default.createText(`
      `, false),
              import_Document.default.createElement("header", {}, [
                ...[
                  import_Document.default.createElement("menu", { "class": `flex flex-center-y px-20 py-15 m-0 bg-t-1` }, [
                    import_Document.default.createText(`
  `, false),
                    ...!!(url !== "/ink/index.html" && url !== "/ink/500.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("i", { "class": `fas fa-fw fa-bars cursor-pointer py-5 pr-10 none md-inline-block tx-t-1`, "click": toggle }, []),
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("div", { "class": `flex-grow` }, []),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "href": `/ink` }, [
                        import_Document.default.createText(`
      `, false),
                        import_Document.default.createElement("img", { "alt": `Ink Logo`, "class": `h-26 mr-10`, "src": `/ink/ink-icon.png` }),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    import_Document.default.createElement("nav", { "class": `flex flex-center-y` }, [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `tx-primary`, "href": `/ink/docs/index.html` }, [
                        import_Document.default.createText(`Docs`, false)
                      ]),
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `tx-t-1 tx-5xl ml-10`, "href": `https://github.com/stackpress/ink`, "target": `_blank` }, [
                        import_Document.default.createText(`
      `, false),
                        import_Document.default.createElement("i", { "class": `fab fa-github` }, []),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `bg-h-cb3837 pill tx-t-1 tx-lg ml-5 p-5 tx-center`, "href": `https://www.npmjs.com/package/@stackpress/ink`, "target": `_blank` }, [
                        import_Document.default.createText(`
      `, false),
                        import_Document.default.createElement("i", { "class": `fab fa-npm tx-white` }, []),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ]),
                    import_Document.default.createText(`
`, false)
                  ])
                ]
              ]),
              import_Document.default.createText(`
      `, false),
              import_Document.default.createElement("aside", { "left": true }, [
                ...[
                  import_Document.default.createElement("header", { "class": `flex flex-center-y bg-t-2 py-15 pr-5 pl-10` }, [
                    import_Document.default.createText(`
  `, false),
                    import_Document.default.createElement("a", { "href": `/ink` }, [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("img", { "class": `h-26 mr-10`, "src": `/ink/ink-icon.png`, "alt": `Ink Logo` }),
                      import_Document.default.createText(`
  `, false)
                    ]),
                    import_Document.default.createText(`
  `, false),
                    import_Document.default.createElement("h3", { "class": `flex-grow m-0 tx-upper` }, [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `tx-primary`, "href": `/ink` }, [
                        import_Document.default.createText(`Ink`, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ]),
                    import_Document.default.createText(`
  `, false),
                    import_Document.default.createElement("i", { "class": `fas fa-fw fa-chevron-left cursor-pointer none md-inline-block`, "click": toggle }, []),
                    import_Document.default.createText(`
`, false)
                  ]),
                  import_Document.default.createText(`
`, false),
                  import_Document.default.createElement("nav", { "class": `bg-t-1 scroll-auto h-calc-full-60` }, [
                    import_Document.default.createText(`
  `, false),
                    import_Document.default.createElement("h6", { "class": `bt-1 bt-solid bt-t-1 tx-black tx-14 mb-0 mt-0 pt-20 pb-10 pl-10 tx-upper` }, [
                      import_Document.default.createText(`
    `, false),
                      ...this._toNodeList(_("Introduction")),
                      import_Document.default.createText(`
  `, false)
                    ]),
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/index.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Documentation")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Documentation")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/getting-started.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/getting-started.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Getting Started")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/getting-started.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Getting Started")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`

  `, false),
                    import_Document.default.createElement("h6", { "class": `bt-1 bt-solid bt-t-1 tx-black tx-14 mb-0 mt-20 pt-20 pb-10 pl-10 tx-upper` }, [
                      import_Document.default.createText(`
    `, false),
                      ...this._toNodeList(_("Features")),
                      import_Document.default.createText(`
  `, false)
                    ]),
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/markup-syntax.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/markup-syntax.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Markup Syntax")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/markup-syntax.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Markup Syntax")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/state-management.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/state-management.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("State Management")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/state-management.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("State Management")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/component-strategy.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/component-strategy.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Component Strategy")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/component-strategy.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Component Strategy")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/compiler-api.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/compiler-api.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Compiler API")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/compiler-api.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Compiler API")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/client-api.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/client-api.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Client API")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/client-api.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Client API")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`

  `, false),
                    import_Document.default.createElement("h6", { "class": `bt-1 bt-solid bt-t-1 tx-black tx-14 mb-0 mt-20 pt-20 pb-10 pl-10 tx-upper` }, [
                      import_Document.default.createText(`
    `, false),
                      ...this._toNodeList(_("Usage")),
                      import_Document.default.createText(`
  `, false)
                    ]),
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/template-engine.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/template-engine.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Template Engine")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/template-engine.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Template Engine")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/single-page.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/single-page.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Single Page App")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/single-page.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Single Page App")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/static-site.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/static-site.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Static Site Generator")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/static-site.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Static Site Generator")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/component-publisher.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/component-publisher.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Component Publisher")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/component-publisher.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Component Publisher")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/docs/developer-tools.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/docs/developer-tools.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Developer Tools")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/docs/developer-tools.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Developer Tools")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`


    `, false),
                    import_Document.default.createElement("h6", { "class": `bt-1 bt-solid bt-t-1 tx-black tx-14 mb-0 mt-20 pt-20 pb-10 pl-10 tx-upper` }, [
                      import_Document.default.createText(`
    `, false),
                      ...this._toNodeList(_("UI")),
                      import_Document.default.createText(`
  `, false)
                    ]),
                    import_Document.default.createText(`
  `, false),
                    ...!!(url === "/ui/index.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/ui/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Components")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/ui/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Components")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
  
  
  `, false),
                    ...!!(url === "/docs/state-management.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/ui/form/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Form")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10`, "href": `/ink/ui/form/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Form")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`

  `, false),
                    ...!!(url === "/docs/client-api.html") ? [
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 tx-bold`, "href": `/ink/ui/format/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Formats")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : true ? [
                      ,
                      import_Document.default.createText(`
    `, false),
                      import_Document.default.createElement("a", { "class": `block tx-info py-10 pl-10 mb-100`, "href": `/ink/ui/format/index.html` }, [
                        import_Document.default.createText(`
      `, false),
                        ...this._toNodeList(_("Formats")),
                        import_Document.default.createText(`
    `, false)
                      ]),
                      import_Document.default.createText(`
  `, false)
                    ] : [],
                    import_Document.default.createText(`
`, false)
                  ])
                ]
              ]),
              import_Document.default.createText(`
      `, false),
              import_Document.default.createElement("main", {}, [
                import_Document.default.createText(`
        `, false),
                import_Document.default.createElement("api-docs", {}, [
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("h1", { "class": `tx-primary tx-upper tx-30 py-20` }, [
                    import_Document.default.createText(`
            `, false),
                    ...this._toNodeList(_("Form")),
                    import_Document.default.createText(`
          `, false)
                  ]),
                  import_Document.default.createText(`
          `, false),
                  import_Document.default.createElement("form", { "method": `get`, "action": `/ink/ui/form/index.html` }, [
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("section", { "class": `flex flex-wrap gap-10` }, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("form-button", { "class": `mr-5`, "md": true, "success": true, "curved": true, "solid": true }, [
                            import_Document.default.createText(`
                    Submit
                  `, false)
                          ]),
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("form-button", { "md": true, "warning": true, "rounded": true, "transparent": true, "href": `#` }, [
                            import_Document.default.createText(`
                    Submit
                  `, false)
                          ]),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/form/button.html` }, [
                          import_Document.default.createText(`
                  Buttons
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("form-control", { "class": `py-5`, "label": `First Name*`, "error": `Some Error` }, [
                            import_Document.default.createText(`
                    `, false),
                            import_Document.default.createElement("field-input", { "name": `first`, "placeholder": `Enter your first name`, "error": true }),
                            import_Document.default.createText(`
                  `, false)
                          ]),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/form/control.html` }, [
                          import_Document.default.createText(`
                  Control
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("form-fieldset", { "legend": `Fieldset %s`, "name": `fieldset1`, "value": fieldset, "multiple": true }, [
                            import_Document.default.createText(`
                    `, false),
                            import_Document.default.createElement("field-input", { "name": `first1`, "placeholder": `Enter your first name` }),
                            import_Document.default.createText(`
                  `, false)
                          ]),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/form/fieldset.html` }, [
                          import_Document.default.createText(`
                  Fieldset
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("h1", { "class": `tx-primary tx-upper tx-30 py-20` }, [
                      import_Document.default.createText(`
              `, false),
                      ...this._toNodeList(_("Fields")),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`
            `, false),
                    import_Document.default.createElement("section", { "class": `flex flex-wrap gap-10` }, [
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-checkbox", { "name": `checkbox`, "label": `Active?`, "value": `yes`, "checked": true, "orange": true, "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/checkbox.html` }, [
                          import_Document.default.createText(`
                  Checkbox
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-color", { "name": `color`, "placeholder": `Enter color` }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/color.html` }, [
                          import_Document.default.createText(`
                  Color
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-country", { "name": `country`, "class": `w-200 relative z-1`, "placeholder": `Choose Country`, "value": `US`, "open": (e) => console.log("open", e), "close": (e) => console.log("close", e), "filter": (e) => console.log("filter", e), "select": (e) => console.log("select", e), "remove": (e) => console.log("remove", e), "add": (e) => console.log("add", e), "clear": (e) => console.log("clear", e), "change": (e) => console.log("change", e), "update": (e) => console.log("update", e) }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/country.html` }, [
                          import_Document.default.createText(`
                  Country
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-currency", { "name": `currency`, "class": `w-200`, "placeholder": `Choose Currency`, "value": `PHP`, "open": (e) => console.log("open", e), "close": (e) => console.log("close", e), "filter": (e) => console.log("filter", e), "select": (e) => console.log("select", e), "remove": (e) => console.log("remove", e), "add": (e) => console.log("add", e), "clear": (e) => console.log("clear", e), "change": (e) => console.log("change", e), "update": (e) => console.log("update", e) }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/currency.html` }, [
                          import_Document.default.createText(`
                  Currency
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-date", { "name": `date`, "placeholder": `Enter date`, "value": `2020-01-01`, "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/date.html` }, [
                          import_Document.default.createText(`
                  Date
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-datetime", { "name": `datetime`, "placeholder": `Enter datetime`, "value": `2020-01-01 13:20:10`, "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/datetime.html` }, [
                          import_Document.default.createText(`
                  Datetime
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-editor", { "lang": `javascript`, "class": `w-200 h-80 scroll-auto`, "numbers": true, "name": `editor`, "value": `ink.render(true);`, "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/editor.html` }, [
                          import_Document.default.createText(`
                  Editor
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-file", { "name": `file`, "class": `block w-250`, "upload": fileupload, "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/file.html` }, [
                          import_Document.default.createText(`
                  File
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-filelist", { "image": true, "name": `filelist`, "class": `block w-250`, "upload": filelistupload, "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/filelist.html` }, [
                          import_Document.default.createText(`
                  Filelist
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-input", { "name": `first`, "placeholder": `Enter your first name`, "value": `test` }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/input.html` }, [
                          import_Document.default.createText(`
                  Input
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-markdown", { "class": `w-200 h-80 block`, "numbers": true, "name": `markdown`, "value": `**I AM BOLD**`, "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/markdown.html` }, [
                          import_Document.default.createText(`
                  Markdown
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-mask", { "mask": `999-999-9999`, "placeholder": `999-999-9999` }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/mask.html` }, [
                          import_Document.default.createText(`
                  Mask
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-metadata", { "class": `w-250`, "name": `metadata`, "placeholder": `Enter text`, "value": metadata, "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/metadata.html` }, [
                          import_Document.default.createText(`
                  Metadata
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center tx-black` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-number", { "name": `number`, "min": `0`, "max": `10000`, "step": `0.01`, "value": `1234.56`, "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/number.html` }, [
                          import_Document.default.createText(`
                  Number
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-password", { "name": `password`, "placeholder": `Enter password`, "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/password.html` }, [
                          import_Document.default.createText(`
                  Password
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-radio", { "name": `radio`, "label": `Yes`, "value": `yes`, "checked": true, "rounded": true, "update": console.log, "class": `mr-10` }),
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-radio", { "name": `radio`, "label": `No`, "value": `no`, "rounded": true, "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/radio.html` }, [
                          import_Document.default.createText(`
                  Radio
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-range", { "name": `range`, "min": `0`, "max": `100`, "step": `10`, "value": `0` }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/range.html` }, [
                          import_Document.default.createText(`
                  Range
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-rating", { "name": `rating`, "value": `0`, "primary": true, "xl2": true, "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/rating.html` }, [
                          import_Document.default.createText(`
                  Rating
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-select", { "class": `w-200 relative z-1`, "name": `select`, "placeholder": `Choose`, "value": `1`, "search": true, "custom": true, "multiple": true, "open": (e) => console.log("open", e), "close": (e) => console.log("close", e), "filter": (e) => console.log("filter", e), "select": (e) => console.log("select", e), "remove": (e) => console.log("remove", e), "add": (e) => console.log("add", e), "clear": (e) => console.log("clear", e), "change": (e) => console.log("change", e), "update": (e) => console.log("update", e) }, [
                            import_Document.default.createText(`
                    `, false),
                            import_Document.default.createElement("option", { "value": `1`, "keyword": `option 1` }, [
                              import_Document.default.createText(`Option 1`, false)
                            ]),
                            import_Document.default.createText(`
                    `, false),
                            import_Document.default.createElement("option", { "value": 4, "keyword": `option 2` }, [
                              import_Document.default.createElement("strong", {}, [
                                import_Document.default.createText(`Option 2`, false)
                              ])
                            ]),
                            import_Document.default.createText(`
                    `, false),
                            import_Document.default.createElement("option", { "value": [1, "2", 3], "keyword": `option 3` }, [
                              import_Document.default.createText(`Option 3`, false)
                            ]),
                            import_Document.default.createText(`
                    `, false),
                            import_Document.default.createElement("option", { "value": [1, "2", 3], "keyword": `option 3` }, [
                              import_Document.default.createText(`Option 4`, false)
                            ]),
                            import_Document.default.createText(`
                  `, false)
                          ]),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/select.html` }, [
                          import_Document.default.createText(`
                  Select
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-slug", { "name": `slug`, "placeholder": `Enter slug`, "value": `I AM A SLUG`, "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/slug.html` }, [
                          import_Document.default.createText(`
                  Slug
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-switch", { "name": `switch`, "label": `Active?`, "value": `yes`, "checked": true, "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/switch.html` }, [
                          import_Document.default.createText(`
                  Switch
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-taglist", { "name": `taglist`, "class": `w-250`, "placeholder": `Enter Value`, "value": ["foo", "bar"] }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/taglist.html` }, [
                          import_Document.default.createText(`
                  Taglist
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-textarea", { "name": `textarea`, "placeholder": `Enter text`, "update": console.log }, [
                            import_Document.default.createText(`Some Text`, false)
                          ]),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/textarea.html` }, [
                          import_Document.default.createText(`
                  Textarea
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-textlist", { "name": `textlist[]`, "placeholder": `Enter text`, "value": ["foo", "bar"], "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/textlist.html` }, [
                          import_Document.default.createText(`
                  Textlist
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-time", { "name": `time`, "placeholder": `Enter time`, "value": (/* @__PURE__ */ new Date()).getTime(), "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/time.html` }, [
                          import_Document.default.createText(`
                  Time
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
              `, false),
                      import_Document.default.createElement("div", { "class": `basis-third-10 lg-basis-half-10 md-basis-full` }, [
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("div", { "class": `bg-t-3 h-120 flex flex-center scroll-hidden` }, [
                          import_Document.default.createText(`
                  `, false),
                          import_Document.default.createElement("field-wysiwyg", { "class": `w-200 h-100`, "name": `wysiwyg`, "value": `I am ironman.`, "size": true, "color": true, "update": console.log }),
                          import_Document.default.createText(`
                `, false)
                        ]),
                        import_Document.default.createText(`
                `, false),
                        import_Document.default.createElement("a", { "class": `block tx-center tx-primary p-10 b-solid b-t-3 b-1`, "href": `/ink/ui/field/wysiwyg.html` }, [
                          import_Document.default.createText(`
                  WYSIWYG
                `, false)
                        ]),
                        import_Document.default.createText(`
              `, false)
                      ]),
                      import_Document.default.createText(`
            `, false)
                    ]),
                    import_Document.default.createText(`
          `, false)
                  ]),
                  import_Document.default.createText(`
        `, false)
                ]),
                import_Document.default.createText(`
      `, false)
              ]),
              import_Document.default.createText(`
    `, false)
            ]),
            import_Document.default.createText(`
  `, false)
          ]),
          import_Document.default.createText(`
`, false)
        ])
      ];
    }
  };
  var components = {
    "ApiDocs_0ab1bce486b32e7cdafc": Docs_0ab1bce486b32e7cdafc,
    "I18nTranslate_794a00a5e900fca28310": Translate_794a00a5e900fca28310,
    "PanelLayout_c4c96a14064fc0c4d224": Panel_c4c96a14064fc0c4d224,
    "FormButton_8b2d9633875784010957": Button_8b2d9633875784010957,
    "FormControl_7df3c1a799ae50f9a174": Control_7df3c1a799ae50f9a174,
    "FormFieldset_ef9b2ae0fcce531cd739": Fieldset_ef9b2ae0fcce531cd739,
    "FieldColor_a278209728128a71ca7a": Color_a278209728128a71ca7a,
    "FieldCheckbox_22993f1e10483a264a1f": Checkbox_22993f1e10483a264a1f,
    "FieldCountry_e24d0db854af71ec9fc5": Country_e24d0db854af71ec9fc5,
    "FieldCurrency_f19a5f2e28ee751b9497": Currency_f19a5f2e28ee751b9497,
    "FieldDate_af6eaa22db40ba187f7b": Date_af6eaa22db40ba187f7b,
    "FieldDatetime_b6d79d7c9e1a2f6724a8": Datetime_b6d79d7c9e1a2f6724a8,
    "FieldEditor_015bbef1a0403600489f": Editor_015bbef1a0403600489f,
    "FieldFile_e1ccc97731cc5c06477e": File_e1ccc97731cc5c06477e,
    "FieldInput_cb7a6224432a087beaf2": Input_cb7a6224432a087beaf2,
    "FieldFilelist_1bad9ce547117f592df7": Filelist_1bad9ce547117f592df7,
    "FieldMarkdown_12b2cd27e75a9b30b72c": Markdown_12b2cd27e75a9b30b72c,
    "ElementIcon_33cb84912ffcb000a388": Icon_33cb84912ffcb000a388,
    "FieldMask_3040fa9be886a5e9b81b": Mask_3040fa9be886a5e9b81b,
    "FieldMetadata_7a77cccac9ec06877cc1": Metadata_7a77cccac9ec06877cc1,
    "FieldNumber_86f400b74c281ff3b8cb": Number_86f400b74c281ff3b8cb,
    "FieldPassword_e2bbd1afa75609a2474c": Password_e2bbd1afa75609a2474c,
    "FieldRadio_7eb23fa5e323e66c0392": Radio_7eb23fa5e323e66c0392,
    "FieldRange_c518adb6b44f1a3d7afe": Range_c518adb6b44f1a3d7afe,
    "FieldRating_2d6a3c2d29eb25c7053c": Rating_2d6a3c2d29eb25c7053c,
    "FieldSelect_180142206112824ab003": Select_180142206112824ab003,
    "FieldSlug_fef3f64de8b66d9e4ca9": Slug_fef3f64de8b66d9e4ca9,
    "FieldSwitch_6a5872ff1487f563ea53": Switch_6a5872ff1487f563ea53,
    "FieldTextarea_8a2ce892dd22c3ebd0b9": Textarea_8a2ce892dd22c3ebd0b9,
    "FieldTaglist_77761941800dcd7a085c": Taglist_77761941800dcd7a085c,
    "FieldTextlist_e6367e273a85cfed73bc": Textlist_e6367e273a85cfed73bc,
    "FieldTime_33e808b67f575a5b36fc": Time_33e808b67f575a5b36fc,
    "FieldWysiwyg_7e3499be9641069413db": Wysiwyg_7e3499be9641069413db
  };
  var elements = {
    "api-docs": Docs_0ab1bce486b32e7cdafc,
    "i18n-translate": Translate_794a00a5e900fca28310,
    "panel-layout": Panel_c4c96a14064fc0c4d224,
    "form-button": Button_8b2d9633875784010957,
    "form-control": Control_7df3c1a799ae50f9a174,
    "form-fieldset": Fieldset_ef9b2ae0fcce531cd739,
    "field-color": Color_a278209728128a71ca7a,
    "field-checkbox": Checkbox_22993f1e10483a264a1f,
    "field-country": Country_e24d0db854af71ec9fc5,
    "field-currency": Currency_f19a5f2e28ee751b9497,
    "field-date": Date_af6eaa22db40ba187f7b,
    "field-datetime": Datetime_b6d79d7c9e1a2f6724a8,
    "field-editor": Editor_015bbef1a0403600489f,
    "field-file": File_e1ccc97731cc5c06477e,
    "field-filelist": Filelist_1bad9ce547117f592df7,
    "field-input": Input_cb7a6224432a087beaf2,
    "field-markdown": Markdown_12b2cd27e75a9b30b72c,
    "field-mask": Mask_3040fa9be886a5e9b81b,
    "field-metadata": Metadata_7a77cccac9ec06877cc1,
    "field-number": Number_86f400b74c281ff3b8cb,
    "field-password": Password_e2bbd1afa75609a2474c,
    "field-radio": Radio_7eb23fa5e323e66c0392,
    "field-range": Range_c518adb6b44f1a3d7afe,
    "field-rating": Rating_2d6a3c2d29eb25c7053c,
    "field-select": Select_180142206112824ab003,
    "field-slug": Slug_fef3f64de8b66d9e4ca9,
    "field-switch": Switch_6a5872ff1487f563ea53,
    "field-textarea": Textarea_8a2ce892dd22c3ebd0b9,
    "field-taglist": Taglist_77761941800dcd7a085c,
    "field-textlist": Textlist_e6367e273a85cfed73bc,
    "field-time": Time_33e808b67f575a5b36fc,
    "field-wysiwyg": Wysiwyg_7e3499be9641069413db
  };
  var BUILD_ID = "2d9ec985aca105c3f84b";
  import_Emitter.default.once("ready", () => {
    TemplateDocument.sync();
    for (const [tagname, definition] of Object.entries(elements)) {
      if (!customElements.getName(definition)) {
        customElements.define(tagname, definition);
      }
    }
    import_Emitter.default.emit("mounted", document.body);
  });
  return __toCommonJS(form_exports);
})();
/*! Bundled license information:

inputmask/dist/inputmask.js:
  (*!
   * dist/inputmask
   * https://github.com/RobinHerbots/Inputmask
   * Copyright (c) 2010 - 2024 Robin Herbots
   * Licensed under the MIT license
   * Version: 5.0.9
   *)
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)
*/
